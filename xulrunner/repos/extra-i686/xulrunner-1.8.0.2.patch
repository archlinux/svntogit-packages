diff -uprN --exclude=CVS mozilla/build/autoconf/mozconfig2client-mk mozilla.new/build/autoconf/mozconfig2client-mk
--- mozilla/build/autoconf/mozconfig2client-mk	2004-04-18 16:17:09.000000000 +0200
+++ mozilla.new/build/autoconf/mozconfig2client-mk	2006-02-24 11:16:26.000000000 +0100
@@ -58,6 +58,10 @@ ac_add_options() {
   echo "# $* is used by configure (not client.mk)" >> $tmp_file
 }
 
+ac_add_app_options() {
+  echo "# $* is used by configure (not client.mk)" >> $tmp_file
+}
+
 mk_add_options() {
   for _opt
   do
diff -uprN --exclude=CVS mozilla/build/autoconf/mozconfig2configurator mozilla.new/build/autoconf/mozconfig2configurator
--- mozilla/build/autoconf/mozconfig2configurator	2004-04-18 16:17:09.000000000 +0200
+++ mozilla.new/build/autoconf/mozconfig2configurator	1970-01-01 01:00:00.000000000 +0100
@@ -1,87 +0,0 @@
-#! /bin/sh
-#
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is mozilla.org code.
-#
-# The Initial Developer of the Original Code is
-# Netscape Communications Corporation.
-# Portions created by the Initial Developer are Copyright (C) 1999
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#   Stephen Lamm (slamm@netscape.com)
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either of the GNU General Public License Version 2 or later (the "GPL"),
-# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
-
-# mozconfig2configurator - Translates .mozconfig into options for
-#    the online configurator,
-#
-#        http://webtools.mozilla.org/build/config.cgi
-#    
-#   This is called by the 'webconfig' target of mozilla/client.mk
-#
-
-ac_add_options() {
-  for _opt
-  do
-    # Escape special url characters
-    _opt=`echo $_opt | sed -e 's/%/%25/g;s/ /%20/g;s/&/%26/g;'`
-    case "$_opt" in
-      --*-*= ) url="$url$_opt&"     ;;
-      --*-* )  url="$url$_opt=yes&" ;;
-    esac
-  done
-}
-
-mk_add_options() {
-  for _opt
-  do
-    # Escape special url characters
-    # Escape special url characters
-    _opt=`echo $_opt | sed -e 's/%/%25/g;s/ /%20/g;s/&/%26/g;'`
-    url="$url$_opt&"
-  done
-}
-
-#
-# main
-#
-
-# find-mozconfig.sh 
-#   In params:   $MOZCONFIG $HOME ($MOZ_MYCONFIG)
-scriptdir=`dirname $0`
-MOZCONFIG=`$scriptdir/mozconfig-find $topsrcdir`
-
-if [ "$MOZCONFIG" ]
-then
-  url="http://webtools.mozilla.org/build/config.cgi?"
-  . $MOZCONFIG
-
-  # Drop the last character of $url
-  echo `expr "$url" : "\(.*\)."`
-fi
-
diff -uprN --exclude=CVS mozilla/build/autoconf/mozconfig2configure mozilla.new/build/autoconf/mozconfig2configure
--- mozilla/build/autoconf/mozconfig2configure	2005-06-29 05:51:42.000000000 +0200
+++ mozilla.new/build/autoconf/mozconfig2configure	2006-02-24 11:16:26.000000000 +0100
@@ -76,6 +76,14 @@ ac_add_options() {
   done
 }
 
+ac_add_app_options() {
+  APP=$1
+  shift;
+  if [ "$APP" == "$MOZ_BUILD_APP" ]; then
+      ac_add_options "$*";
+  fi
+}
+
 mk_add_options() {
   # These options are for client.mk
   # configure can safely ignore them.
diff -uprN --exclude=CVS mozilla/build/macosx/universal/fix-buildconfig mozilla.new/build/macosx/universal/fix-buildconfig
--- mozilla/build/macosx/universal/fix-buildconfig	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/build/macosx/universal/fix-buildconfig	2006-02-22 05:02:32.000000000 +0100
@@ -0,0 +1,142 @@
+#!/usr/bin/perl
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Mozilla Mac OS X Universal Binary Packaging System
+#
+# The Initial Developer of the Original Code is Google Inc.
+# Portions created by the Initial Developer are Copyright (C) 2006
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#  Mark Mentovai <mark@moxienet.com> (Original Author)
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+use strict;
+use warnings;
+
+use Archive::Zip(':ERROR_CODES');
+
+my ($BUILDCONFIG);
+
+sub fixBuildconfig($$);
+
+$BUILDCONFIG = 'content/global/buildconfig.html';
+
+if (scalar(@ARGV) != 2) {
+  print STDERR ("usage: fix-buildconfig <zipfile1> <zipfile2>\n");
+  exit(1);
+}
+
+if (!fixBuildconfig($ARGV[0], $ARGV[1])) {
+  exit(1);
+}
+
+exit(0);
+
+sub fixBuildconfig($$) {
+  my ($zipPath1, $zipPath2);
+  ($zipPath1, $zipPath2) = @_;
+
+  my ($ze, $zip1, $zip2);
+
+  $zip1 = Archive::Zip->new();
+  if (($ze = $zip1->read($zipPath1)) != AZ_OK) {
+    print STDERR ($0.': could not read "'.$zipPath1.'": error '.$ze."\n");
+    return 0;
+  }
+  $zip2 = Archive::Zip->new();
+  if (($ze = $zip2->read($zipPath2)) != AZ_OK) {
+    print STDERR ($0.': could not read "'.$zipPath2.'": error '.$ze."\n");
+    return 0;
+  }
+
+  my ($contents1, $contents2);
+  if (!defined($contents1 = $zip1->contents($BUILDCONFIG))) {
+    print STDERR ($0.': could not get "'.$BUILDCONFIG.'" from "'.$zipPath1.'"'.
+                  "\n");
+    return 0;
+  }
+  if (!defined($contents2 = $zip2->contents($BUILDCONFIG))) {
+    print STDERR ($0.': could not get "'.$BUILDCONFIG.'" from "'.$zipPath2.'"'.
+                  "\n");
+    return 0;
+  }
+
+  my (@lines1, @lines2);
+  @lines1 = split(/\n/, $contents1);
+  @lines2 = split(/\n/, $contents2);
+
+  my ($line, @linesNew);
+  @linesNew = ();
+
+  # Copy everything from the first file up to the end of its <body>.
+  while ($line = shift(@lines1)) {
+    if ($line eq '</body>') {
+      last;
+    }
+    push(@linesNew, $line);
+  }
+
+  # Insert a <hr> between the two files.
+  push (@linesNew, '<hr> </hr>');
+
+  # Copy the second file's content beginning after its leading <h1> and <p>.
+  while ($line = shift(@lines2)) {
+    if ($line eq '<p> </p>') {
+      last;
+    }
+  }
+  while ($line = shift(@lines2)) {
+    push(@linesNew, $line);
+  }
+
+  my ($contentsNew);
+  $contentsNew = join("\n", @linesNew);
+
+  if (!defined($zip1->contents($BUILDCONFIG, $contentsNew))) {
+    print STDERR ($0.': could not set "'.$BUILDCONFIG.'" to "'.$zipPath1.'"'.
+                  "\n");
+    return 0;
+  }
+  if (!defined($zip2->contents($BUILDCONFIG, $contentsNew))) {
+    print STDERR ($0.': could not set "'.$BUILDCONFIG.'" to "'.$zipPath2.'"'.
+                  "\n");
+    return 0;
+  }
+
+
+  if (($ze = $zip1->overwrite()) != AZ_OK) {
+    print STDERR ($0.': could not write "'.$zipPath1.'": error '.$ze."\n");
+    return 0;
+  }
+  if (($ze = $zip2->overwrite()) != AZ_OK) {
+    print STDERR ($0.': could not write "'.$zipPath2.'": error '.$ze."\n");
+    return 0;
+  }
+
+  return 1;
+}
diff -uprN --exclude=CVS mozilla/build/macosx/universal/flight.mk mozilla.new/build/macosx/universal/flight.mk
--- mozilla/build/macosx/universal/flight.mk	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/build/macosx/universal/flight.mk	2006-02-22 18:32:41.000000000 +0100
@@ -0,0 +1,105 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Mozilla Mac OS X Universal Binary Packaging System
+#
+# The Initial Developer of the Original Code is Google Inc.
+# Portions created by the Initial Developer are Copyright (C) 2006
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#  Mark Mentovai <mark@moxienet.com> (Original Author)
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+# BE CAREFUL!  This makefile handles a postflight_all rule for a
+# multi-project build, so DON'T rely on anything that might differ between
+# the two OBJDIRs.
+
+ifndef OBJDIR
+OBJDIR_PPC = $(MOZ_OBJDIR)/ppc
+OBJDIR_X86 = $(MOZ_OBJDIR)/i386
+DIST_PPC = $(OBJDIR_PPC)/dist
+DIST_X86 = $(OBJDIR_X86)/dist
+DIST_UNI = $(DIST_PPC)/universal
+OBJDIR = $(OBJDIR_PPC)
+endif
+
+include $(OBJDIR)/config/autoconf.mk
+
+DIST = $(OBJDIR)/dist
+
+ifeq ($(MOZ_BUILD_APP),macbrowser)
+INSTALLER_DIR = camino/installer
+MOZ_PKG_APPNAME = camino
+APPNAME_BASE = Camino
+BUILDCONFIG_JAR = Contents/MacOS/chrome/embed.jar
+else
+ifeq ($(MOZ_BUILD_APP),suite)
+INSTALLER_DIR = xpinstall/packager
+else
+INSTALLER_DIR = $(MOZ_BUILD_APP)/installer
+endif
+MOZ_PKG_APPNAME = $(MOZ_APP_NAME)
+APPNAME_BASE = $(MOZ_APP_DISPLAYNAME)
+BUILDCONFIG_JAR = Contents/MacOS/chrome/toolkit.jar
+endif
+
+ifdef MOZ_DEBUG
+APPNAME = $(APPNAME_BASE)Debug
+else
+APPNAME = $(APPNAME_BASE)
+endif
+
+postflight_all:
+# Build the universal package out of only the bits that would be released.
+# Call the packager to set this up.  Set UNIVERSAL_BINARY= to avoid producing
+# a universal binary too early, before the unified bits have been staged.
+# Set MAKE_PACKAGE= to avoid building a dmg.  Set SIGN_NSS= to skip shlibsign.
+	$(MAKE) -C $(OBJDIR_PPC)/$(INSTALLER_DIR) \
+          UNIVERSAL_BINARY= MAKE_PACKAGE= SIGN_NSS=
+	$(MAKE) -C $(OBJDIR_X86)/$(INSTALLER_DIR) \
+          UNIVERSAL_BINARY= MAKE_PACKAGE= SIGN_NSS=
+# Remove .chk files that may have been copied from the NSS build.  These will
+# cause unify to warn or fail if present.  New .chk files that are
+# appropriate for the merged libraries will be generated when the universal
+# dmg is built.
+	rm -f $(DIST_PPC)/$(MOZ_PKG_APPNAME)/$(APPNAME).app/Contents/MacOS/*.chk \
+	      $(DIST_X86)/$(MOZ_PKG_APPNAME)/$(APPNAME).app/Contents/MacOS/*.chk
+# The only difference betewen the two trees now should be the
+# about:buildconfig page.  Fix it up.
+	$(TOPSRCDIR)/build/macosx/universal/fix-buildconfig \
+	  $(DIST_PPC)/$(MOZ_PKG_APPNAME)/$(APPNAME).app/$(BUILDCONFIG_JAR) \
+	  $(DIST_X86)/$(MOZ_PKG_APPNAME)/$(APPNAME).app/$(BUILDCONFIG_JAR)
+	mkdir -p $(DIST_UNI)/$(MOZ_PKG_APPNAME)
+	rm -f $(DIST_X86)/universal
+	ln -s $(DIST_UNI) $(DIST_X86)/universal
+	rm -rf $(DIST_UNI)/$(MOZ_PKG_APPNAME)/$(APPNAME).app
+	$(TOPSRCDIR)/build/macosx/universal/unify \
+	  $(DIST_PPC)/$(MOZ_PKG_APPNAME)/$(APPNAME).app \
+	  $(DIST_X86)/$(MOZ_PKG_APPNAME)/$(APPNAME).app \
+	  $(DIST_UNI)/$(MOZ_PKG_APPNAME)/$(APPNAME).app
+# A universal .dmg can now be produced by making in either architecture's
+# INSTALLER_DIR.
diff -uprN --exclude=CVS mozilla/build/macosx/universal/mozconfig mozilla.new/build/macosx/universal/mozconfig
--- mozilla/build/macosx/universal/mozconfig	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/build/macosx/universal/mozconfig	2006-02-22 18:32:41.000000000 +0100
@@ -0,0 +1,102 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Mozilla Mac OS X Universal Binary Packaging System
+#
+# The Initial Developer of the Original Code is Google Inc.
+# Portions created by the Initial Developer are Copyright (C) 2006
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#  Mark Mentovai <mark@moxienet.com> (Original Author)
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+# As used here, arguments in $MOZ_BUILD_PROJECTS are suitable as arguments
+# to gcc's -arch parameter.
+mk_add_options MOZ_BUILD_PROJECTS="ppc i386"
+
+mk_add_options MOZ_UNIFY_BDATE=1
+
+mk_add_options MOZ_POSTFLIGHT_ALL+=build/macosx/universal/flight.mk
+
+DARWIN_VERSION=`uname -r`
+ac_add_app_options ppc  --target=powerpc-apple-darwin$DARWIN_VERSION
+ac_add_app_options i386 --target=i386-apple-darwin$DARWIN_VERSION
+
+# ppc builds run on older systems.  The minimum SDK for x86 is 10.4u.
+ac_add_app_options ppc  --with-macos-sdk=/Developer/SDKs/MacOSX10.2.8.sdk
+ac_add_app_options i386 --with-macos-sdk=/Developer/SDKs/MacOSX10.4u.sdk
+
+# $MOZ_BUILD_APP is only defined when sourced by configure.  That's not a
+# problem, because the variables it affects only need to be set for
+# configure.
+if test -n "$MOZ_BUILD_APP" ; then
+  TARGET_CPU=$MOZ_BUILD_APP
+
+  # When compiling C++, Apple gcc 4.0 produces output that requires a minimum
+  # of 10.3.9.  Use 4.0 for the x86 build, which has a higher minimum than
+  # that.  Use 3.3 for ppc, which must run on older systems.  This will
+  # completely override the compiler selected with the gcc_select command.
+  if test "$TARGET_CPU" = "ppc" ; then
+    GCC_VERSION=3.3
+  else
+    GCC_VERSION=4.0
+  fi
+
+  # It's not strictly necessary to specify -arch during native builds, but it
+  # makes the merged about:buildconfig easier to follow, and it reduces
+  # conditionalized differences between builds.
+  CC="gcc-$GCC_VERSION -arch $TARGET_CPU"
+  CXX="g++-$GCC_VERSION -arch $TARGET_CPU"
+
+  # $HOST_CXX is presently unused.  $HOST_CC will only be used during a cross
+  # compile.  Always use the 4.0 compiler, since it will always be present and
+  # will always work.
+  HOST_CC=gcc-4.0
+  HOST_CXX=g++-4.0
+
+  # These must be set for cross builds, and don't hurt straight builds.
+  RANLIB=ranlib
+  AR=ar
+  AS=$CC
+  LD=ld
+  STRIP="strip -x -S"
+
+  NATIVE_CPU=`uname -p`
+  if test "$NATIVE_CPU" = "powerpc" ; then
+    NATIVE_CPU=ppc
+  fi
+
+  # Let configure know that we mean business.
+  if test "$NATIVE_CPU" != "$TARGET_CPU" ; then
+    CROSS_COMPILE=1
+  fi
+
+  # Each per-CPU build should be entirely oblivious to the fact that a
+  # universal binary will be produced.  The exception is packager.mk, which
+  # needs to know to look for universal bits when building the .dmg.
+  UNIVERSAL_BINARY=1
+fi
diff -uprN --exclude=CVS mozilla/build/macosx/universal/unify mozilla.new/build/macosx/universal/unify
--- mozilla/build/macosx/universal/unify	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/build/macosx/universal/unify	2006-02-22 05:02:06.000000000 +0100
@@ -0,0 +1,1308 @@
+#!/usr/bin/perl
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Mozilla Mac OS X Universal Binary Packaging System
+#
+# The Initial Developer of the Original Code is Google Inc.
+# Portions created by the Initial Developer are Copyright (C) 2006
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#  Mark Mentovai <mark@moxienet.com> (Original Author)
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+use strict;
+use warnings;
+
+=pod
+
+=head1 NAME
+
+B<unify> - Mac OS X universal binary packager
+
+=head1 SYNOPSIS
+
+B<unify>
+I<ppc-path>
+I<x86-path>
+I<universal-path>
+[B<--dry-run>]
+[B<--only-one> I<action>]
+[B<--verbosity> I<level>]
+
+=head1 DESCRIPTION
+
+I<unify> merges any two architecture-specific files or directory trees
+into a single file or tree suitable for use on either architecture as a
+"fat" or "universal binary."
+
+Architecture-specific Mach-O files will be merged into fat Mach-O files
+using L<lipo(1)>.  Non-Mach-O files in the architecture-specific trees
+are compared to ensure that they are equivalent before copying.  Symbolic
+links are permitted in the architecture-specific trees and will cause
+identical links to be created in the merged tree, provided that the source
+links have identical targets.  Directories are processed recursively.
+
+If the architecture-specific source trees contain zip archives (including
+jar files) that are not identical according to a byte-for-byte check, they
+are still assumed to be equivalent if both archives contain exactly the
+same members with identical checksums and sizes.
+
+Behavior when one architecture-specific tree contains files that the other
+does not is controlled by the B<--only-one> option.
+
+If Mach-O files cannot be merged using L<lipo(1)>, zip archives are not
+equivalent, regular files are not identical, or any other error occurs,
+B<unify> will fail with an exit status of 1.  Diagnostic messages are
+typically printed to stderr; this behavior can be controlled with the
+B<--verbosity> option.
+
+=head1 OPTIONS
+
+=over 5
+
+=item I<ppc-path>
+
+=item I<x86-path>
+
+The paths to directory trees containing PowerPC and x86 builds,
+respectively.  I<ppc-path> and I<x86-path> are permitted to contain files
+that are already "fat," and only the appropriate architecture's images will
+be used.
+
+I<ppc-path> and I<x86-path> are also permitted to both be files, in which
+case B<unify> operates solely on those files, and produces an appropriate
+merged file at I<target-path>.
+
+=item I<target-path>
+
+The path to the merged file or directory tree.  This path will be created,
+and it must not exist prior to running B<unify>.
+
+=item B<--dry-run>
+
+When specified, the commands that would be executed are printed, without
+actually executing them.  Note that B<--dry-run> and the equivalent
+B<--verbosity> level during "wet" runs may print equivalent commands when
+no commands are in fact executed: certain operations are handled internally
+within B<unify>, and an approximation of a command that performs a similar
+task is printed.
+
+=item B<--only-one> I<action>
+
+Controls handling of files that are only present in one of the two source
+trees.  I<action> may be:
+  skip - These files are skipped.
+  copy - These files are copied from the tree in which they exist.
+  fail - When this condition occurs, it is treated as an error.
+
+The default I<action> is copy.
+
+=item B<--verbosity> I<level>
+
+Adjusts the level of loudness of B<unify>.  The possible values for
+I<level> are:
+  0 - B<unify> never prints anything.
+      (Other programs that B<unify> calls may still print messages.)
+  1 - Fatal error messages are printed to stderr.
+  2 - Nonfatal warnings are printed to stderr.
+  3 - Commands are printed to stdout as they are executed.
+
+The default I<level> is 2.
+
+=back
+
+=head1 EXAMPLES
+
+=over 5
+
+=item Create a universal .app bundle from two architecture-specific .app
+bundles:
+
+unify --only-one copy ppc/dist/firefox/Firefox.app
+  x86/dist/firefox/Firefox.app universal/Firefox.app
+  --verbosity 3
+
+=item Merge two identical architecture-specific trees:
+
+unify --only-one fail /usr/local /nfs/x86/usr/local
+  /tmp/usrlocal.fat
+
+=back
+
+=head1 REQUIREMENTS
+
+The only esoteric requirement of B<unify> is that the L<lipo(1)> command
+be available.  It is present on Mac OS X systems at least as early as
+10.3.9, and probably earlier.  Mac OS X 10.4 ("Tiger") or later are
+recommended.
+
+=head1 LICENSE
+
+MPL 1.1/GPL 2.0/LGPL 2.1.  Your choice
+
+=head1 AUTHOR
+
+The software was initially written by Mark Mentovai; copyright 2006
+Google Inc.
+
+=head1 SEE ALSO
+
+L<cmp(1)>, L<ditto(1)>, L<lipo(1)>
+
+=cut
+
+use Archive::Zip(':ERROR_CODES');
+use Errno;
+use File::Compare;
+use File::Copy;
+use Getopt::Long;
+
+my (%gConfig, $gDryRun, $gOnlyOne, $gVerbosity);
+
+sub argumentEscape(@);
+sub command(@);
+sub compareZipArchives($$);
+sub complain($$@);
+sub copyIfIdentical($$$);
+sub makeUniversal($$$);
+sub makeUniversalDirectory($$$);
+sub makeUniversalInternal($$$$);
+sub makeUniversalFile($$$);
+sub usage();
+sub readZipCRCs($);
+
+{
+  package FileAttrCache;
+
+  sub new($$);
+
+  sub isFat($);
+  sub isMachO($);
+  sub isZip($);
+  sub lIsDir($);
+  sub lIsRegularFile($);
+  sub lIsSymLink($);
+  sub lstat($);
+  sub lstatType($);
+  sub magic($);
+  sub path($);
+  sub stat($);
+  sub statSize($);
+}
+
+%gConfig = (
+  'cmd_lipo' => 'lipo',
+  'cmd_rm'   => 'rm',
+);
+
+$gDryRun = 0;
+$gOnlyOne = 'copy';
+$gVerbosity = 2;
+
+Getopt::Long::Configure('pass_through');
+GetOptions('dry-run'     => \$gDryRun,
+           'only-one=s'  => \$gOnlyOne,
+           'verbosity=i' => \$gVerbosity,
+           'config=s'    => \%gConfig); # "hidden" option not in usage()
+
+if (scalar(@ARGV) != 3 || $gVerbosity < 0 || $gVerbosity > 3 ||
+    ($gOnlyOne ne 'skip' && $gOnlyOne ne 'copy' && $gOnlyOne ne 'fail')) {
+  usage();
+  exit(1);
+}
+
+if (!makeUniversal($ARGV[0],$ARGV[1],$ARGV[2])) {
+  # makeUniversal or something it called will have printed an error.
+  exit(1);
+}
+
+exit(0);
+
+# argumentEscape(@arguments)
+#
+# Takes a list of @arguments and makes them shell-safe.
+sub argumentEscape(@) {
+  my (@arguments);
+  @arguments = @_;
+
+  my ($argument, @argumentsOut);
+  foreach $argument (@arguments) {
+    $argument =~ s%([^A-Za-z0-9_\-/.=+,])%\\$1%g;
+    push(@argumentsOut, $argument);
+  }
+
+  return @argumentsOut;
+}
+
+# command(@arguments)
+#
+# Runs the specified command by calling system(@arguments).  If $gDryRun
+# is true, the command is printed but not executed, and 0 is returned.
+# if $gVerbosity is greater than 1, the command is printed before being
+# executed.  When the command is executed, the system() return value will
+# be returned.  stdout and stderr are left connected for command output.
+sub command(@) {
+  my (@arguments);
+  @arguments = @_;
+  if ($gVerbosity >= 3 || $gDryRun) {
+    print(join(' ', argumentEscape(@arguments))."\n");
+  }
+  if ($gDryRun) {
+    return 0;
+  }
+  return system(@arguments);
+}
+
+# compareZipArchives($zip1, $zip2)
+#
+# Given two pathnames to zip archives, determines whether or not they are
+# functionally identical.  Returns true if they are, false if they differ in
+# some substantial way, and undef if an error occurs.  If the zip files
+# differ, diagnostic messages are printed indicating how they differ.
+#
+# Zip files will differ if any of the members are different as defined by
+# readZipCRCs, which consider CRCs, sizes, and file types as stored in the
+# file header.  Timestamps are not considered.  Zip files also differ if one
+# file contains members that the other one does not.  $gOnlyOne has no
+# effect on this behavior.
+sub compareZipArchives($$) {
+  my ($zip1, $zip2);
+  ($zip1, $zip2) = @_;
+
+  my ($CRCHash1, $CRCHash2);
+  if (!defined($CRCHash1 = readZipCRCs($zip1))) {
+    # readZipCRCs printed an error.
+    return undef;
+  }
+  if (!defined($CRCHash2 = readZipCRCs($zip2))) {
+    # readZipCRCs printed an error.
+    return undef;
+  }
+
+  my (@diffCRCs, @onlyInZip1);
+  @diffCRCs = ();
+  @onlyInZip1 = ();
+
+  my ($memberName);
+  foreach $memberName (keys(%$CRCHash1)) {
+    if (!exists($$CRCHash2{$memberName})) {
+      # The member is present in $zip1 but not $zip2.
+      push(@onlyInZip1, $memberName);
+    }
+    elsif ($$CRCHash1{$memberName} ne $$CRCHash2{$memberName}) {
+      # The member is present in both archives but its CRC or some other
+      # other critical attribute isn't identical.
+      push(@diffCRCs, $memberName);
+    }
+    delete($$CRCHash2{$memberName});
+  }
+
+  # If any members remain in %CRCHash2, it's because they're not present
+  # in $zip1.
+  my (@onlyInZip2);
+  @onlyInZip2 = keys(%$CRCHash2);
+
+  if (scalar(@onlyInZip1) + scalar(@onlyInZip2) + scalar(@diffCRCs)) {
+    complain(1, 'compareZipArchives: zip archives differ:',
+             $zip1,
+             $zip2);
+    if (scalar(@onlyInZip1)) {
+      complain(1, 'compareZipArchives: members only in former:',
+               @onlyInZip1);
+    }
+    if (scalar(@onlyInZip2)) {
+      complain(1, 'compareZipArchives: members only in latter:',
+               @onlyInZip2);
+    }
+    if (scalar(@diffCRCs)) {
+      complain(1, 'compareZipArchives: members differ:',
+               @diffCRCs);
+    }
+    return 0;
+  }
+
+  return 1;
+}
+
+# complain($severity, $message, @list)
+#
+# Prints $message to stderr if $gVerbosity allows it for severity level
+# $severity.  @list is a list of words that will be shell-escaped and printed
+# after $message, one per line, intended to be used, for example, to list
+# arguments to a call that failed.
+#
+# Expected severity levels are 1 for hard errors and 2 for non-fatal warnings.
+#
+# Always returns false as a convenience, so callers can return complain's
+# return value when it is used to signal errors.
+sub complain($$@) {
+  my ($severity, $message, @list);
+  ($severity, $message, @list) = @_;
+
+  if ($gVerbosity >= $severity) {
+    print STDERR ($0.': '.$message."\n");
+
+    my ($item);
+    while ($item = shift(@list)) {
+      print STDERR ('  '.(argumentEscape($item))[0].
+                    (scalar(@list)?',':'')."\n");
+    }
+  }
+
+  return 0;
+}
+
+# copyIfIdentical($source1, $source2, $target)
+#
+# $source1 and $source2 are FileAttrCache objects that are compared, and if
+# identical, copied to path string $target.  The comparison is initially
+# done as a byte-for-byte comparison, but if the files differ and appear to
+# be zip archives, compareZipArchives is called to determine whether
+# files that are not byte-for-byte identical are equivalent archives.
+#
+# Returns true on success, false for files that are not identical or
+# equivalent archives, and undef if an error occurs.
+#
+# One of $source1 and $source2 is permitted to be undef.  In this event,
+# whichever source is defined is copied directly to $target without performing
+# any comparisons.  This enables the $gOnlyOne = 'copy' mode, which is
+# driven by makeUniversalDirectory and makeUniversalInternal.
+sub copyIfIdentical($$$) {
+  my ($source1, $source2, $target);
+  ($source1, $source2, $target) = @_;
+
+  if (!defined($source1)) {
+    # If there's only one source file, make it the first file.  Order
+    # isn't important here, and this makes it possible to use
+    # defined($source2) as the switch, and to always copy from $source1.
+    $source1 = $source2;
+    $source2 = undef;
+  }
+
+  if (defined($source2)) {
+    # Only do the comparisons if there are two source files.  If there's
+    # only one source file, skip the comparisons and go straight to the
+    # copy operation.
+    if ($gVerbosity >= 3 || $gDryRun) {
+      print('cmp -s '.
+            join(' ',argumentEscape($source1->path(), $source2->path()))."\n");
+    }
+    my ($comparison);
+    if (!defined($comparison = compare($source1->path(), $source2->path())) ||
+        $comparison == -1) {
+      return complain(1, 'copyIfIdentical: compare: '.$!.' while comparing:',
+                      $source1->path(),
+                      $source2->path());
+    }
+    elsif ($comparison != 0) {
+      my ($zip1, $zip2);
+      if (defined($zip1 = $source1->isZip()) &&
+          defined($zip2 = $source2->isZip()) &&
+          $zip1 && $zip2) {
+        my ($zipComparison);
+        if (!defined($zipComparison = compareZipArchives($source1->path(),
+                                                         $source2->path)) ||
+            !$zipComparison) {
+          # An error occurred or the zip files aren't sufficiently identical.
+          # compareZipArchives will have printed an error message.
+          return 0;
+        }
+        # The zip files were compared successfully, and they both contain
+        # all of the same members, and all of their members' CRCs are
+        # identical.  For the purposes of this script, the zip files can be
+        # treated as identical, so reset $comparison.
+        $comparison = 0;
+      }
+    }
+    if ($comparison != 0) {
+      return complain(1, 'copyIfIdentical: files differ:',
+                      $source1->path(),
+                      $source2->path());
+    }
+  }
+
+  if ($gVerbosity >= 3 || $gDryRun) {
+    print('cp '.
+          join(' ',argumentEscape($source1->path(), $target))."\n");
+  }
+  if (!$gDryRun && !copy($source1->path(), $target)) {
+    return complain(1, 'copyIfIdentical: copy: '.$!.' while copying',
+                    $source1->path(),
+                    $target);
+  }
+
+  return 1;
+}
+
+# makeUniversal($pathPPC, $pathX86, $pathTarget)
+#
+# The top-level call.  $pathPPC, $pathX86, and $pathTarget are strings
+# identifying the ppc and x86 files or directories to merge and the location
+# to merge them to.  Returns false on failure and true on success.
+sub makeUniversal($$$) {
+  my ($pathTarget, $pathPPC, $pathX86);
+  ($pathPPC, $pathX86, $pathTarget) = @_;
+
+  my ($filePPC, $fileX86);
+  $filePPC = FileAttrCache->new($pathPPC);
+  $fileX86 = FileAttrCache->new($pathX86);
+
+  return makeUniversalInternal(1, $filePPC, $fileX86, $pathTarget);
+}
+
+# makeUniversalDirectory($dirPPC, $dirX86, $dirTarget)
+#
+# This is part of the heart of recursion.  $dirPPC and $dirX86 are
+# FileAttrCache objects designating the source ppc and x86 directories to
+# merge into a universal directory at $dirTarget, a string.  For each file
+# in $dirPPC and $dirX86, makeUniversalInternal is called.
+# makeUniversalInternal will call back into makeUniversalDirectory for
+# directories, thus completing the recursion.  If a failure is encountered
+# in ths function or in makeUniversalInternal or anything that it calls,
+# false is returned, otherwise, true is returned.
+#
+# If there are files present in one source directory but not both, the
+# value of $gOnlyOne controls the behavior.  If $gOnlyOne is 'copy', the
+# single source file is copied into $pathTarget.  If it is 'skip', it is
+# skipped.  If it is 'fail', such files will trigger makeUniversalDirectory
+# to fail.
+#
+# If either source directory is undef, it is treated as having no files.
+# This facilitates deep recursion when entire directories are only present
+# in one source when $gOnlyOne = 'copy'.
+sub makeUniversalDirectory($$$) {
+  my ($dirPPC, $dirX86, $dirTarget);
+  ($dirPPC, $dirX86, $dirTarget) = @_;
+
+  my ($dh, @filesPPC, @filesX86);
+
+  @filesPPC = ();
+  if (defined($dirPPC)) {
+    if (!opendir($dh, $dirPPC->path())) {
+      return complain(1, 'makeUniversalDirectory: opendir ppc: '.$!.' for:',
+                      $dirPPC->path());
+    }
+    @filesPPC = readdir($dh);
+    closedir($dh);
+  }
+
+  @filesX86 = ();
+  if (defined($dirX86)) {
+    if (!opendir($dh, $dirX86->path())) {
+      return complain(1, 'makeUniversalDirectory: opendir x86: '.$!.' for:',
+                      $dirX86->path());
+     }
+    @filesX86 = readdir($dh);
+    closedir($dh);
+  }
+
+  my (%common, $file, %onlyPPC, %onlyX86);
+
+  %onlyPPC = ();
+  foreach $file (@filesPPC) {
+    if ($file eq '.' || $file eq '..') {
+      next;
+    }
+    $onlyPPC{$file}=1;
+  }
+
+  %common = ();
+  %onlyX86 = ();
+  foreach $file (@filesX86) {
+    if ($file eq '.' || $file eq '..') {
+      next;
+    }
+    if ($onlyPPC{$file}) {
+      delete $onlyPPC{$file};
+      $common{$file}=1;
+    }
+    else {
+      $onlyX86{$file}=1;
+    }
+  }
+
+  # First, handle files common to both.
+  foreach $file (sort(keys(%common))) {
+    if (!makeUniversalInternal(0,
+                               FileAttrCache->new($dirPPC->path().'/'.$file),
+                               FileAttrCache->new($dirX86->path().'/'.$file),
+                               $dirTarget.'/'.$file)) {
+      # makeUniversalInternal will have printed an error.
+      return 0;
+    }
+  }
+
+  # Handle files found only in a single directory here.  There are three
+  # options, dictated by $gOnlyOne: fail if files are only present in
+  # one directory, skip any files only present in one directory, or copy
+  # these files straight over to the target directory.  In any event,
+  # a message will be printed indicating that the file trees don't match
+  # exactly.
+  if (keys(%onlyPPC)) {
+    complain(($gOnlyOne eq 'fail' ? 1 : 2),
+             ($gOnlyOne ne 'fail' ? 'warning: ' : '').
+             'makeUniversalDirectory: only in ppc '.
+             (argumentEscape($dirPPC->path()))[0].':',
+             argumentEscape(keys(%onlyPPC)));
+  }
+
+  if (keys(%onlyX86)) {
+    complain(($gOnlyOne eq 'fail' ? 1 : 2),
+             ($gOnlyOne ne 'fail' ? 'warning: ' : '').
+             'makeUniversalDirectory: only in x86 '.
+             (argumentEscape($dirX86->path()))[0].':',
+             argumentEscape(keys(%onlyX86)));
+  }
+
+  if ($gOnlyOne eq 'fail' && (keys(%onlyPPC) || keys(%onlyX86))) {
+    # Error message(s) printed above.
+    return 0;
+  }
+
+  if ($gOnlyOne eq 'copy') {
+    foreach $file (sort(keys(%onlyPPC))) {
+      if (!makeUniversalInternal(0,
+                                 FileAttrCache->new($dirPPC->path().'/'.$file),
+                                 undef,
+                                 $dirTarget.'/'.$file)) {
+        # makeUniversalInternal will have printed an error.
+        return 0;
+      }
+    }
+
+    foreach $file (sort(keys(%onlyX86))) {
+      if (!makeUniversalInternal(0,
+                                 undef,
+                                 FileAttrCache->new($dirX86->path().'/'.$file),
+                                 $dirTarget.'/'.$file)) {
+        # makeUniversalInternal will have printed an error.
+        return 0;
+      }
+    }
+  }
+
+  return 1;
+}
+
+# makeUniversalFile($sourcePPC, $sourceX86, $targetPath)
+#
+# Creates a universal file at pathname $targetPath based on a ppc image at
+# $sourcePPC and an x86 image at $sourceX86.  $sourcePPC and $sourceX86 are
+# both FileAttrCache objects.  Returns true on success and false on failure.
+# On failure, diagnostics will be printed to stderr.
+#
+# The source files may be either thin Mach-O images of the appropriate
+# architecture, or fat Mach-O files that contain images of the appropriate
+# architecture.
+#
+# This function wraps the lipo utility, see lipo(1).
+sub makeUniversalFile($$$) {
+  my ($sourcePPC, $sourceX86, $targetPath, @tempThinFiles, $thinPPC, $thinX86);
+  ($sourcePPC, $sourceX86, $targetPath) = @_;
+  $thinPPC = $sourcePPC;
+  $thinX86 = $sourceX86;
+
+  @tempThinFiles = ();
+
+  # The source files might already be fat.  They should be thinned out to only
+  # contain a single architecture.
+ 
+  my ($isFatPPC, $isFatX86);
+
+  if(!defined($isFatPPC = $sourcePPC->isFat())) {
+    # isFat printed its own error
+    return 0;
+  }
+  elsif($isFatPPC) {
+    $thinPPC = FileAttrCache->new($targetPath.'.ppc');
+    push(@tempThinFiles, $thinPPC->path());
+    if (command($gConfig{'cmd_lipo'}, '-thin', 'ppc',
+                $sourcePPC->path(), '-output', $thinPPC->path()) != 0) {
+      unlink(@tempThinFiles);
+      return complain(1, 'lipo thin ppc failed for:',
+                      $sourcePPC->path(),
+                      $thinPPC->path());
+    }
+  }
+
+  if(!defined($isFatX86 = $sourceX86->isFat())) {
+    # isFat printed its own error
+    unlink(@tempThinFiles);
+    return 0;
+  }
+  elsif($isFatX86) {
+    $thinX86 = FileAttrCache->new($targetPath.'.x86');
+    push(@tempThinFiles, $thinX86->path());
+    if (command($gConfig{'cmd_lipo'}, '-thin', 'i386',
+                $sourceX86->path(), '-output', $thinX86->path()) != 0) {
+      unlink(@tempThinFiles);
+      return complain(1, 'lipo thin x86 failed for:',
+                      $sourceX86->path(),
+                      $thinX86->path());
+    }
+  }
+
+  # The image for each architecture in the fat file will be aligned on
+  # a specific boundary, default 4096 bytes, see lipo(1) -segalign.
+  # Since there's no tail-padding, the fat file will consume the least
+  # space on disk if the image that comes last exceeds the segment size
+  # by the smallest amount.
+  #
+  # This saves an average of 1kB per fat file over the naive approach of
+  # always putting one architecture first: average savings is 2kB per
+  # file, but the naive approach would have gotten it right half of the
+  # time.
+
+  my ($sizePPC, $sizeX86, $thinPPCForStat, $thinX86ForStat);
+
+  if (!$gDryRun) {
+    $thinPPCForStat = $thinPPC;
+    $thinX86ForStat = $thinX86;
+  }
+  else {
+    # Normally, fat source files will have been converted into temporary
+    # thin files.  During a dry run, that doesn't happen, so fake it up
+    # a little bit by always using the source file, fat or thin, for the
+    # stat.
+    $thinPPCForStat = $sourcePPC;
+    $thinX86ForStat = $sourceX86;
+  }
+
+  if (!defined($sizePPC = $thinPPCForStat->statSize())) {
+    unlink(@tempThinFiles);
+    return complain(1, 'stat ppc: '.$!.' for:',
+                    $thinPPCForStat->path());
+  }
+  if (!defined($sizeX86 = $thinX86ForStat->statSize())) {
+    unlink(@tempThinFiles);
+    return complain(1, 'stat x86: '.$!.' for:',
+                    $thinX86ForStat->path());
+  }
+
+  $sizePPC = $sizePPC % 4096;
+  $sizeX86 = $sizeX86 % 4096;
+
+  my (@thinFiles);
+
+  if ($sizePPC == 0) {
+    # PPC image ends on an alignment boundary, there will be no padding before
+    # starting the x86 image.
+    @thinFiles = ($thinPPC->path(), $thinX86->path());
+  }
+  elsif ($sizeX86 == 0 || $sizeX86 > $sizePPC) {
+    # x86 image ends on an alignment boundary, there will be no padding before
+    # starting the PPC image, or the x86 image exceeds its alignment boundary
+    # by more than the PPC image, so there will be less padding if the x86
+    # comes first.
+    @thinFiles = ($thinX86->path(), $thinPPC->path());
+  }
+  else {
+    # PPC image exceeds its alignment boundary by more than the x86 image, so
+    # there will be less padding if the PPC comes first.
+    @thinFiles = ($thinPPC->path(), $thinX86->path());
+  }
+
+  # Create the fat file.
+  if (command($gConfig{'cmd_lipo'}, '-create', @thinFiles,
+              '-output', $targetPath) != 0) {
+    unlink(@tempThinFiles);
+    return complain(1, 'lipo create fat failed for:',
+                    @thinFiles,
+                    $targetPath);
+  }
+
+  unlink(@tempThinFiles);
+
+  return 1;
+}
+
+# makeUniversalInternal($isToplevel, $filePPC, $fileX86, $fileTargetPath)
+#
+# Given FileAttrCache objects $filePPC and $fileX86, compares filetypes
+# and performs the appropriate action to produce a universal file at
+# path string $fileTargetPath.  $isToplevel should be true if this is
+# the recursive base and false otherwise; this controls cleanup behavior
+# (cleanup is only performed at the base, because cleanup itself is
+# recursive).
+#
+# This handles regular files by determining whether they are Mach-O files
+# and calling makeUniversalFile if so and copyIfIdentical otherwise.  Symbolic
+# links are handled directly in this function by ensuring that the source link
+# targets are identical and creating a new link with the same target
+# at $fileTargetPath.  Directories are handled by calling
+# makeUniversalDirectory.
+#
+# One of $filePPC and $fileX86 is permitted to be undef.  In that case,
+# the defined source file is copied directly to the target if a regular
+# file, and symlinked appropriately if a symbolic link.  This facilitates
+# use of $gOnlyOne = 'copy', although no $gOnlyOne checks are made in this
+# function, they are all handled in makeUniversalDirectory.
+#
+# Returns true on success.  Returns false on failure, including failures
+# in other functions called.
+sub makeUniversalInternal($$$$) {
+  my ($filePPC, $fileTargetPath, $fileX86, $isToplevel);
+  ($isToplevel, $filePPC, $fileX86, $fileTargetPath) = @_;
+
+  my ($typePPC, $typeX86);
+  if (defined($filePPC) && !defined($typePPC = $filePPC->lstatType())) {
+    return complain(1, 'makeUniversal: lstat ppc: '.$!.' for:',
+                    $filePPC->path());
+  }
+  if (defined($fileX86) && !defined($typeX86 = $fileX86->lstatType())) {
+    return complain(1, 'makeUniversal: lstat x86: '.$!.' for:',
+                    $fileX86->path());
+  }
+
+  if (defined($filePPC) && defined($fileX86) && $typePPC != $typeX86) {
+    return complain(1, 'makeUniversal: incompatible types:',
+                    $filePPC->path(),
+                    $fileX86->path());
+  }
+
+  # $aSourceFile will contain a FileAttrCache object that will return
+  # the correct type data.  It's used because it's possible for one of
+  # the two source files to be undefined (indicating a straight copy).
+  my ($aSourceFile);
+  if (defined($filePPC)) { 
+    $aSourceFile = $filePPC;
+  }
+  else {
+    $aSourceFile = $fileX86;
+  }
+
+  if ($aSourceFile->lIsDir()) {
+    if ($gVerbosity >= 3 || $gDryRun) {
+      print('mkdir '.(argumentEscape($fileTargetPath))[0]."\n");
+    }
+    if (!$gDryRun && !mkdir($fileTargetPath)) {
+      return complain(1, 'makeUniversal: mkdir: '.$!.' for:',
+                      $fileTargetPath);
+    }
+
+    my ($rv);
+
+    if (!($rv = makeUniversalDirectory($filePPC, $fileX86, $fileTargetPath))) {
+      # makeUniversalDirectory printed an error.
+      if ($isToplevel) {
+        command($gConfig{'cmd_rm'},'-rf','--',$fileTargetPath);
+      }
+    }
+    else {
+      # Touch the directory when leaving it.  If unify is being run on an
+      # .app bundle, the .app might show up without an icon because the
+      # system might have found the .app before it was completely built.
+      # Touching it dirties it in LaunchServices' mind.
+      if ($gVerbosity >= 3) {
+        print('touch '.(argumentEscape($fileTargetPath))[0]."\n");
+      }
+      utime(undef, undef, $fileTargetPath);
+    }
+
+    return $rv;
+  }
+  elsif ($aSourceFile->lIsSymLink()) {
+    my ($linkPPC, $linkX86);
+    if (defined($filePPC) && !defined($linkPPC=readlink($filePPC->path()))) {
+      return complain(1, 'makeUniversal: readlink ppc: '.$!.' for:',
+                      $filePPC->path());
+    }
+    if (defined($fileX86) && !defined($linkX86=readlink($fileX86->path()))) {
+      return complain(1, 'makeUniversal: readlink x86: '.$!.' for:',
+                      $fileX86->path());
+    }
+    if (defined($filePPC) && defined($fileX86) && $linkPPC ne $linkX86) {
+      return complain(1, 'makeUniversal: symbolic links differ:',
+                      $filePPC->path(),
+                      $fileX86->path());
+    }
+
+    # $aLink here serves the same purpose as $aSourceFile in the enclosing
+    # block: it refers to the target of the symbolic link, whether there
+    # is one valid source or two.
+    my ($aLink);
+    if (defined($linkPPC)) {
+      $aLink = $linkPPC;
+    }
+    else {
+      $aLink = $linkX86;
+    }
+
+    if ($gVerbosity >= 3 || $gDryRun) {
+      print('ln -s '.
+            join(' ',argumentEscape($aLink, $fileTargetPath))."\n");
+    }
+    if (!$gDryRun && !symlink($aLink, $fileTargetPath)) {
+      return complain(1, 'makeUniversal: symlink: '.$!.' for:',
+                      $aLink,
+                      $fileTargetPath);
+    }
+
+    return 1;
+  }
+  elsif($aSourceFile->lIsRegularFile()) {
+    # Unlike mkdir and symlink, neither makeUniversalFile nor copyIfIdentical
+    # care if the target file already exists, and they can't be made to care
+    # without writing lipo and cp equivalents that open files with
+    # O_CREAT|O_EXCL.  Since this script is supposed to be short and sweet,
+    # that's not going to happen.  The next best thing is to check to make
+    # sure the target file doesn't already exist before calling lipo or cp.
+    # It's open to a race, but this script isn't expected to run in hostile
+    # race-prone environments, and since it's expected to be called on
+    # directories and not files, the parent directory's mkdir addresses the
+    # race situation anyway.
+
+    my ($fileTarget);
+    $fileTarget = FileAttrCache->new($fileTargetPath);
+    $! = 0;
+    if ($fileTarget->lstat()) {
+      $! = Errno::EEXIST;
+    }
+    if ($! != Errno::ENOENT) {
+      return complain(1, 'makeUniversal: new file: '.$!.' for:',
+                      $fileTargetPath);
+    }
+
+    my ($machPPC, $machX86);
+    if (!defined($filePPC) || !defined($fileX86)) {
+      # One of the source files isn't present.  The right thing to do is
+      # to just copy what does exist straight over, so skip Mach-O checks.
+      $machPPC = 0;
+      $machX86 = 0;
+    }
+    else {
+      if (!defined($machPPC=$filePPC->isMachO())) {
+        return complain(1, 'makeUniversal: isFileMachO ppc failed for:',
+                        $filePPC->path());
+      }
+      if (!defined($machX86=$fileX86->isMachO())) {
+        return complain(1, 'makeUniversal: isFileMachO x86 failed for:',
+                        $fileX86->path());
+      }
+    }
+
+    if ($machPPC != $machX86) {
+      return complain(1, 'makeUniversal: variant Mach-O attributes:',
+                      $filePPC->path(),
+                  $fileX86->path());
+    }
+
+    my($rv);
+
+    if ($machPPC) {
+      # makeUniversalFile will print an error if it fails.
+      $rv = makeUniversalFile($filePPC, $fileX86, $fileTargetPath);
+    }
+    else {
+      # Regular file.  copyIfIdentical will print an error if it fails.
+      $rv = copyIfIdentical($filePPC, $fileX86, $fileTargetPath);
+    }
+
+    if (!$rv) {
+      unlink($fileTargetPath);
+    }
+
+    return $rv;
+  }
+  else {
+    # Special file, don't know how to handle.
+    return complain(1, 'makeUniversal: cannot handle special file:',
+                    $filePPC->path(),
+                    $fileX86->path());
+  }
+
+  # Not reached.
+  return undef;
+}
+
+# usage()
+#
+# Give the user a hand.
+sub usage() {
+  print STDERR (
+"usage: unify <ppc-path> <x86-path> <universal-path>\n".
+"            [--dry-run]           (print what would be done)\n".
+"            [--only-one <action>] (skip, copy, fail; default=copy)\n".
+"            [--verbosity <level>] (0, 1, 2, 3; default=2)\n");
+  return;
+}
+
+# readZipCRCs($zipFile)
+#
+# $zipFile is the pathname to a zip file whose directory will be read.
+# A reference to a hash is returned, with the member pathnames from the
+# zip file as keys, and reasonably unique identifiers as values.  The
+# format of the values is not specified exactly, but does include the
+# member CRCs and sizes and differentiates between files and directories.
+# It specifically does not distinguish between modification times.  On
+# failure, prints a message and returns undef.
+sub readZipCRCs($) {
+  my ($zipFile);
+  ($zipFile) = @_;
+
+  my ($ze, $zip);
+  $zip = Archive::Zip->new();
+
+  if (($ze = $zip->read($zipFile)) != AZ_OK) {
+    complain(1, 'readZipCRCs: read error '.$ze.' for:',
+             $zipFile);
+    return undef;
+  }
+
+  my ($member, %memberCRCs, @memberList);
+  %memberCRCs = ();
+  @memberList = $zip->members();
+
+  foreach $member (@memberList) {
+    # Take a few of the attributes that identify the file and stuff them into
+    # the members hash.  Directories will show up with size 0 and crc32 0,
+    # so isDirectory() is used to distinguish them from empty files.
+    $memberCRCs{$member->fileName()} = join(',', $member->isDirectory() ? 1 : 0,
+                                                 $member->uncompressedSize(),
+                                                 $member->crc32String());
+  }
+
+  return {%memberCRCs};
+}
+
+{
+  # FileAttrCache allows various attributes about a file to be cached
+  # so that if they are needed again after first use, no system calls
+  # will be made and the program won't need to hit the disk.
+
+  package FileAttrCache;
+
+  use Fcntl(':DEFAULT', ':mode');
+
+  # FileAttrCache->new($path)
+  #
+  # Creates a new FileAttrCache object for the file at path $path and
+  # returns it.  The cache is not primed at creation time, values are
+  # fetched lazily as they are needed.
+  sub new($$) {
+    my ($class, $path, $proto, $this);
+    ($proto, $path) = @_;
+    if (!($class = ref($proto))) {
+      $class = $proto;
+    }
+    $this = {
+      'path'        => $path,
+      'lstat'       => undef,
+      'lstatErrno'  => 0,
+      'lstatInit'   => 0,
+      'magic'       => undef,
+      'magicErrno'  => 0,
+      'magicErrMsg' => undef,
+      'magicInit'   => 0,
+      'stat'        => undef,
+      'statErrno'   => 0,
+      'statInit'    => 0,
+    };
+    bless($this, $class);
+    return($this);
+  }
+
+  # $FileAttrCache->isFat()
+  #
+  # Returns true if the file is a fat Mach-O file, false if it's not, and
+  # undef if an error occurs.  See /usr/include/mach-o/fat.h.
+  sub isFat($) {
+    my ($magic, $this);
+    ($this) = @_;
+
+    # magic() caches, there's no separate cache because isFat() doesn't hit
+    # the disk other than by calling magic().
+
+    if (!defined($magic = $this->magic())) {
+      return undef;
+    }
+
+    if ($magic == 0xcafebabe) {
+      return 1;
+    }
+
+    return 0;
+  }
+
+  # $FileAttrCache->isMachO()
+  #
+  # Returns true if the file is a Mach-O image (including a fat file), false
+  # if it's not, and undef if an error occurs.  See
+  # /usr/include/mach-o/loader.h and /usr/include/mach-o/fat.h.
+  sub isMachO($) {
+    my ($magic, $this);
+    ($this) = @_;
+
+    # magic() caches, there's no separate cache because isMachO() doesn't hit
+    # the disk other than by calling magic().
+
+    if (!defined($magic = $this->magic())) {
+      return undef;
+    }
+
+    # Accept Mach-O fat files or Mach-O thin files of either endianness.
+    if ($magic == 0xfeedface ||
+        $magic == 0xcefaedfe ||
+        $magic == 0xcafebabe) {
+      return 1;
+    }
+
+    return 0;
+  }
+
+  # $FileAttrCache->isZip()
+  #
+  # Returns true if the file is a zip file, false if it's not, and undef if
+  # an error occurs.  See http://www.pkware.com/business_and_developers/developer/popups/appnote.txt .
+  sub isZip($) {
+    my ($magic, $this);
+    ($this) = @_;
+
+    # magic() caches, there's no separate cache because isFat() doesn't hit
+    # the disk other than by calling magic().
+
+    if (!defined($magic = $this->magic())) {
+      return undef;
+    }
+
+    if ($magic == 0x504b0304) {
+      return 1;
+    }
+
+    return 0;
+  }
+
+  # $FileAttrCache->lIsDir()
+  #
+  # Wraps $FileAttrCache->lstat(), returning true if the file is a directory,
+  # false if it isn't, or undef if an error occurs.  Because lstat is used,
+  # this will return false even if the file is a symlink pointing to a
+  # directory.  On error, $! is set to lstat's errno.
+  sub lIsDir($) {
+    my ($type, $this);
+    ($this) = @_;
+
+    if (!defined($type = $this->lstatType())) {
+      return undef;
+    }
+
+    return S_ISDIR($type);
+  }
+
+  # $FileAttrCache->lIsRegularFile()
+  #
+  # Wraps $FileAttrCache->lstat(), returning true if the file is a regular,
+  # file, false if it isn't, or undef if an error occurs.  Because lstat is
+  # used, this will return false even if the file is a symlink pointing to a
+  # regular file.  On error, $! is set to lstat's errno.
+  sub lIsRegularFile($) {
+    my ($type, $this);
+    ($this) = @_;
+
+    if (!defined($type = $this->lstatType())) {
+      return undef;
+    }
+
+    return S_ISREG($type);
+  }
+
+  # $FileAttrCache->lIsSymLink()
+  #
+  # Wraps $FileAttrCache->lstat(), returning true if the file is a symbolic,
+  # link, false if it isn't, or undef if an error occurs.  On error, $! is
+  # set to lstat's errno.
+  sub lIsSymLink($) {
+    my ($type, $this);
+    ($this) = @_;
+   
+    if (!defined($type = $this->lstatType())) {
+      return undef;
+    }
+
+    return S_ISLNK($type);
+  }
+
+  # $FileAttrCache->lstat()
+  #
+  # Wraps the lstat system call, providing a cache to speed up multiple
+  # lstat calls for the same file.  See lstat(2) and lstat in perlfunc(1).
+  sub lstat($) {
+    my (@stat, $this);
+    ($this) = @_;
+
+    # Use the cached lstat result.
+    if ($$this{'lstatInit'}) {
+      if (defined($$this{'lstatErrno'})) {
+        $! = $$this{'lstatErrno'};
+      }
+      return @{$$this{'lstat'}};
+    }
+    $$this{'lstatInit'} = 1;
+
+    if (!(@stat = CORE::lstat($$this{'path'}))) {
+      $$this{'lstatErrno'} = $!;
+    }
+
+    $$this{'lstat'} = [@stat];
+    return @stat;
+  }
+
+  # $FileAttrCache->lstatType()
+  #
+  # Wraps $FileAttrCache->lstat(), returning the type bits from the st_mode
+  # field, or undef if an error occurs.  On error, $! is set to lstat's
+  # errno.
+  sub lstatType($) {
+    my (@stat, $this);
+    ($this) = @_;
+
+    if (!(@stat = $this->lstat())) {
+      return undef;
+    }
+
+    return S_IFMT($stat[2]);
+  }
+
+  # $FileAttrCache->magic()
+  #
+  # Returns the "magic number" for the file by reading its first four bytes
+  # as a big-endian unsigned 32-bit integer and returning the result.  If an
+  # error occurs, returns undef and prints diagnostic messages to stderr.  If
+  # the file is shorter than 32 bits, returns -1.  A cache is provided to
+  # speed multiple magic calls for the same file.
+  sub magic($) {
+    my ($this);
+    ($this) = @_;
+
+    # Use the cached magic result.
+    if ($$this{'magicInit'}) {
+      if (defined($$this{'magicErrno'})) {
+        if (defined($$this{'magicErrMsg'})) {
+          complain(1, 'FileAttrCache::magic: '.$$this{'magicErrMsg'}.' for:',
+                   $$this{'path'});
+        }
+        $! = $$this{'magicErrno'};
+      }
+      return $$this{'magic'};
+    }
+
+    $$this{'magicInit'} = 1;
+
+    my ($fh);
+    if (!sysopen($fh, $$this{'path'}, O_RDONLY)) {
+      $$this{'magicErrno'} = $!;
+      $$this{'magicErrMsg'} = 'open "'.$$this{'path'}.'": '.$!;
+      complain(1, 'FileAttrCache::magic: '.$$this{'magicErrMsg'}.' for:',
+               $$this{'path'});
+      return undef;
+    }
+
+    $! = 0;
+    my ($bytes, $magic);
+    if (!defined($bytes = sysread($fh, $magic, 4))) {
+      $$this{'magicErrno'} = $!;
+      $$this{'magicErrMsg'} = 'read "'.$$this{'path'}.'": '.$!;
+      complain(1, 'FileAttrCache::magic: '.$$this{'magicErrMsg'}.' for:',
+               $$this{'path'});
+      close($fh);
+      return undef;
+    }
+
+    close($fh);
+
+    if ($bytes != 4) {
+      # The file is too short, didn't read a magic number.  This isn't really
+      # an error.  Return an unlikely value.
+      $$this{'magic'} = -1;
+      return -1;
+    }
+
+    $$this{'magic'} = unpack('N', $magic);
+    return $$this{'magic'};
+  }
+
+  # $FileAttrCache->path()
+  #
+  # Returns the file's pathname.
+  sub path($) {
+    my ($this);
+    ($this) = @_;
+    return $$this{'path'};
+  }
+
+  # $FileAttrCache->stat()
+  #
+  # Wraps the stat system call, providing a cache to speed up multiple
+  # stat calls for the same file.  If lstat() has already been called and
+  # the file is not a symbolic link, the cached lstat() result will be used.
+  # See stat(2) and lstat in perlfunc(1).
+  sub stat($) {
+    my (@stat, $this);
+    ($this) = @_;
+
+    # Use the cached stat result.
+    if ($$this{'statInit'}) {
+      if (defined($$this{'statErrno'})) {
+        $! = $$this{'statErrno'};
+      }
+      return @{$$this{'stat'}};
+    }
+
+    $$this{'statInit'} = 1;
+
+    # If lstat has already been called, and the file isn't a symbolic link,
+    # use the cached lstat result.
+    if ($$this{'lstatInit'} && !$$this{'lstatErrno'} &&
+        !S_ISLNK(${$$this{'lstat'}}[2])) {
+      $$this{'stat'} = $$this{'lstat'};
+      return @{$$this{'stat'}};
+    }
+
+    if (!(@stat = CORE::stat($$this{'path'}))) {
+      $$this{'statErrno'} = $!;
+    }
+
+    $$this{'stat'} = [@stat];
+    return @stat;
+  }
+
+  # $FileAttrCache->statSize()
+  #
+  # Wraps $FileAttrCache->stat(), returning the st_size field, or undef
+  # undef if an error occurs.  On error, $! is set to stat's errno.
+  sub statSize($) {
+    my (@stat, $this);
+    ($this) = @_;
+
+    if (!(@stat = $this->lstat())) {
+      return undef;
+    }
+
+    return $stat[7];
+  }
+}
diff -uprN --exclude=CVS mozilla/caps/include/nsScriptSecurityManager.h mozilla.new/caps/include/nsScriptSecurityManager.h
--- mozilla/caps/include/nsScriptSecurityManager.h	2005-07-22 22:49:11.000000000 +0200
+++ mozilla.new/caps/include/nsScriptSecurityManager.h	2006-02-24 11:16:26.000000000 +0100
@@ -65,6 +65,7 @@ class nsIXPConnect;
 class nsIStringBundle;
 class nsSystemPrincipal;
 struct ClassPolicy;
+class DomainPolicy;
 
 #if defined(DEBUG_mstoltz) || defined(DEBUG_caillon)
 #define DEBUG_CAPS_HACKER
@@ -208,6 +209,10 @@ struct ClassPolicy : public PLDHashEntry
 {
     char* key;
     PLDHashTable* mPolicy;
+
+    // Note: the DomainPolicy owns us, so if if dies we will too.  Hence no
+    // need to refcount it here (and in fact, we'd probably leak if we tried).
+    DomainPolicy* mDomainWeAreWildcardFor;
 };
 
 PR_STATIC_CALLBACK(void)
@@ -222,6 +227,13 @@ ClearClassPolicyEntry(PLDHashTable *tabl
     PL_DHashTableDestroy(cp->mPolicy);
 }
 
+// Note: actual impl is going to be after the DomainPolicy class definition,
+// since we need to access members of DomainPolicy in the impl
+PR_STATIC_CALLBACK(void)
+MoveClassPolicyEntry(PLDHashTable *table,
+                     const PLDHashEntryHdr *from,
+                     PLDHashEntryHdr *to);
+
 PR_STATIC_CALLBACK(PRBool)
 InitClassPolicyEntry(PLDHashTable *table,
                      PLDHashEntryHdr *entry,
@@ -241,6 +253,7 @@ InitClassPolicyEntry(PLDHashTable *table
     };
 
     ClassPolicy* cp = (ClassPolicy*)entry;
+    cp->mDomainWeAreWildcardFor = nsnull;
     cp->key = PL_strdup((const char*)key);
     if (!cp->key)
         return PR_FALSE;
@@ -279,7 +292,7 @@ public:
             PL_DHashGetKeyStub,
             PL_DHashStringKey,
             PL_DHashMatchStringKey,
-            PL_DHashMoveEntryStub,
+            MoveClassPolicyEntry,
             ClearClassPolicyEntry,
             PL_DHashFinalizeStub,
             InitClassPolicyEntry
@@ -336,6 +349,23 @@ private:
 
 };
 
+PR_STATIC_CALLBACK(void)
+MoveClassPolicyEntry(PLDHashTable *table,
+                     const PLDHashEntryHdr *from,
+                     PLDHashEntryHdr *to)
+{
+    memcpy(to, from, table->entrySize);
+
+    // Now update the mDefaultPolicy pointer that points to us, if any.
+    ClassPolicy* cp = NS_STATIC_CAST(ClassPolicy*, to);
+    if (cp->mDomainWeAreWildcardFor) {
+        NS_ASSERTION(cp->mDomainWeAreWildcardFor->mWildcardPolicy ==
+                     NS_STATIC_CAST(const ClassPolicy*, from),
+                     "Unexpected wildcard policy on mDomainWeAreWildcardFor");
+        cp->mDomainWeAreWildcardFor->mWildcardPolicy = cp;
+    }
+}
+
 /////////////////////////////
 // nsScriptSecurityManager //
 /////////////////////////////
diff -uprN --exclude=CVS mozilla/caps/src/nsScriptSecurityManager.cpp mozilla.new/caps/src/nsScriptSecurityManager.cpp
--- mozilla/caps/src/nsScriptSecurityManager.cpp	2005-10-25 02:40:48.000000000 +0200
+++ mozilla.new/caps/src/nsScriptSecurityManager.cpp	2006-02-24 11:16:26.000000000 +0100
@@ -1555,6 +1555,13 @@ nsScriptSecurityManager::CanExecuteScrip
     //-- See if the current window allows JS execution
     nsIScriptContext *scriptContext = GetScriptContext(cx);
     if (!scriptContext) return NS_ERROR_FAILURE;
+
+    if (!scriptContext->GetScriptsEnabled()) {
+        // No scripting on this context, folks
+        *result = PR_FALSE;
+        return NS_OK;
+    }
+    
     nsIScriptGlobalObject *globalObject = scriptContext->GetGlobalObject();
     if (!globalObject) return NS_ERROR_FAILURE;
 
@@ -3304,9 +3311,15 @@ nsScriptSecurityManager::InitDomainPolic
 
         // If this is the wildcard class (class '*'), save it in mWildcardPolicy
         // (we leave it stored in the hashtable too to take care of the cleanup)
-        if ((*start == '*') && (end == start + 1))
+        if ((*start == '*') && (end == start + 1)) {
             aDomainPolicy->mWildcardPolicy = cpolicy;
 
+            // Make sure that cpolicy knows about aDomainPolicy so it can reset
+            // the mWildcardPolicy pointer as needed if it gets moved in the
+            // hashtable.
+            cpolicy->mDomainWeAreWildcardFor = aDomainPolicy;
+        }
+
         // Get the property name
         start = end + 1;
         end = PL_strchr(start, '.');
diff -uprN --exclude=CVS mozilla/client.mk mozilla.new/client.mk
--- mozilla/client.mk	2005-12-09 20:47:25.000000000 +0100
+++ mozilla.new/client.mk	2006-02-24 11:15:14.000000000 +0100
@@ -22,6 +22,7 @@
 #   Stephen Lamm
 #   Benjamin Smedberg <bsmedberg@covad.net>
 #   Chase Phillips <chase@mozilla.org>
+#   Mark Mentovai <mark@moxienet.com>
 #
 # Alternatively, the contents of this file may be used under the terms of
 # either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -79,6 +80,8 @@
 # See http://www.mozilla.org/build/ for more information.
 #
 # Options:
+#   MOZ_BUILD_PROJECTS   - Build multiple projects in subdirectories
+#                          of MOZ_OBJDIR
 #   MOZ_OBJDIR           - Destination object directory
 #   MOZ_CO_DATE          - Date tag to use for checkout (default: none)
 #   MOZ_CO_LOCALES_DATE  - Date tag to use for locale checkout
@@ -90,6 +93,12 @@
 #   MOZ_CO_LOCALES       - localizations to pull (MOZ_CO_LOCALES="de-DE,pt-BR")
 #   MOZ_LOCALE_DIRS      - directories which contain localizations
 #   LOCALES_CVSROOT      - CVSROOT to use to pull localizations
+#   MOZ_PREFLIGHT_ALL  } - Makefiles to run before any project in
+#   MOZ_PREFLIGHT      }   MOZ_BUILD_PROJECTS, before each project, after
+#   MOZ_POSTFLIGHT     }   each project, and after all projects; these
+#   MOZ_POSTFLIGHT_ALL }   variables contain space-separated lists
+#   MOZ_UNIFY_BDATE      - Set to use the same bdate for each project in
+#                          MOZ_BUILD_PROJECTS
 #
 
 AVAILABLE_PROJECTS = \
@@ -279,6 +288,7 @@ SH := /bin/sh
 ifndef MAKE
 MAKE := gmake
 endif
+PERL ?= perl
 
 CONFIG_GUESS_SCRIPT := $(wildcard $(TOPSRCDIR)/build/autoconf/config.guess)
 ifdef CONFIG_GUESS_SCRIPT
@@ -364,14 +374,32 @@ else
   CVS_FLAGS := $(MOZ_CVS_FLAGS)
 endif
 
+ifdef MOZ_BUILD_PROJECTS
+
+ifndef MOZ_OBJDIR
+  $(error When MOZ_BUILD_PROJECTS is set, you must set MOZ_OBJDIR)
+endif
+ifdef MOZ_CURRENT_PROJECT
+  OBJDIR = $(MOZ_OBJDIR)/$(MOZ_CURRENT_PROJECT)
+  MOZ_MAKE = $(MAKE) $(MOZ_MAKE_FLAGS) -C $(OBJDIR)
+  BUILD_PROJECT_ARG = MOZ_BUILD_APP=$(MOZ_CURRENT_PROJECT)
+else
+  OBJDIR = $(error Cannot find the OBJDIR when MOZ_CURRENT_PROJECT is not set.)
+  MOZ_MAKE = $(error Cannot build in the OBJDIR when MOZ_CURRENT_PROJECT is not set.)
+endif
+
+else # MOZ_BUILD_PROJECTS
+
 ifdef MOZ_OBJDIR
-  OBJDIR := $(MOZ_OBJDIR)
-  MOZ_MAKE := $(MAKE) $(MOZ_MAKE_FLAGS) -C $(OBJDIR)
+  OBJDIR = $(MOZ_OBJDIR)
+  MOZ_MAKE = $(MAKE) $(MOZ_MAKE_FLAGS) -C $(OBJDIR)
 else
   OBJDIR := $(TOPSRCDIR)
   MOZ_MAKE := $(MAKE) $(MOZ_MAKE_FLAGS)
 endif
 
+endif # MOZ_BUILD_PROJECTS
+
 ####################################
 # CVS defines for NSS
 #
@@ -669,26 +697,6 @@ ifdef RUN_AUTOCONF_LOCALLY
 	cd $(TOPSRCDIR)/directory/c-sdk && $(AUTOCONF)
 endif
 
-####################################
-# Web configure
-
-WEBCONFIG_FILE  := $(HOME)/.mozconfig
-
-MOZCONFIG2CONFIGURATOR := build/autoconf/mozconfig2configurator
-webconfig:
-	@cd $(TOPSRCDIR); \
-	url=`$(MOZCONFIG2CONFIGURATOR) $(TOPSRCDIR)`; \
-	echo Running mozilla with the following url: ;\
-	echo ;\
-	echo $$url ;\
-	mozilla -remote "openURL($$url)" || \
-	netscape -remote "openURL($$url)" || \
-	mozilla $$url || \
-	netscape $$url ;\
-	echo ;\
-	echo   1. Fill out the form on the browser. ;\
-	echo   2. Save the results to $(WEBCONFIG_FILE)
-
 #####################################################
 # First Checkout
 
@@ -701,12 +709,61 @@ else
 #####################################################
 # After First Checkout
 
+#####################################################
+# Build date unification
+
+ifdef MOZ_UNIFY_BDATE
+ifndef MOZ_BUILD_DATE
+ifdef MOZ_BUILD_PROJECTS
+MOZ_BUILD_DATE = $(shell $(PERL) -I$(TOPSRCDIR)/config $(TOPSRCDIR)/config/bdate.pl)
+export MOZ_BUILD_DATE
+endif
+endif
+endif
+
+#####################################################
+# Preflight, before building any project
+
+build profiledbuild alldep preflight_all::
+ifeq (,$(MOZ_CURRENT_PROJECT)$(if $(MOZ_PREFLIGHT_ALL),,1))
+# Don't run preflight_all for individual projects in multi-project builds
+# (when MOZ_CURRENT_PROJECT is set.)
+ifndef MOZ_BUILD_PROJECTS
+# Building a single project, OBJDIR is usable.
+	set -e; \
+	for mkfile in $(MOZ_PREFLIGHT_ALL); do \
+	  $(MAKE) -f $$mkfile preflight_all TOPSRCDIR=$(TOPSRCDIR) OBJDIR=$(OBJDIR) MOZ_OBJDIR=$(MOZ_OBJDIR); \
+	done
+else
+# OBJDIR refers to the project-specific OBJDIR, which is not available at
+# this point when building multiple projects.  Only MOZ_OBJDIR is available.
+	set -e; \
+	for mkfile in $(MOZ_PREFLIGHT_ALL); do \
+	  $(MAKE) -f $$mkfile preflight_all TOPSRCDIR=$(TOPSRCDIR) MOZ_OBJDIR=$(MOZ_OBJDIR) MOZ_BUILD_PROJECTS="$(MOZ_BUILD_PROJECTS)"; \
+	done
+endif
+endif
+
+# If we're building multiple projects, but haven't specified which project,
+# loop through them.
+
+ifeq (,$(MOZ_CURRENT_PROJECT)$(if $(MOZ_BUILD_PROJECTS),,1))
+configure depend build profiledbuild install export libs clean realclean distclean alldep preflight postflight::
+	set -e; \
+	for app in $(MOZ_BUILD_PROJECTS); do \
+	  $(MAKE) -f $(TOPSRCDIR)/client.mk $@ MOZ_CURRENT_PROJECT=$$app; \
+	done
+
+else
+
+# MOZ_CURRENT_PROJECT: either doing a single-project build, or building an
+# individual project in a multi-project build.
 
 ####################################
 # Configure
 
-CONFIG_STATUS := $(wildcard $(OBJDIR)/config.status)
-CONFIG_CACHE  := $(wildcard $(OBJDIR)/config.cache)
+CONFIG_STATUS = $(wildcard $(OBJDIR)/config.status)
+CONFIG_CACHE  = $(wildcard $(OBJDIR)/config.cache)
 
 ifdef RUN_AUTOCONF_LOCALLY
 EXTRA_CONFIG_DEPS := \
@@ -735,20 +792,23 @@ CONFIG_STATUS_DEPS := \
 #   $(TOPSRCDIR) will set @srcdir@ to "."; otherwise, it is set to the full
 #   path of $(TOPSRCDIR).
 ifeq ($(TOPSRCDIR),$(OBJDIR))
-  CONFIGURE := ./configure
+  CONFIGURE = ./configure
 else
-  CONFIGURE := $(TOPSRCDIR)/configure
+  CONFIGURE = $(TOPSRCDIR)/configure
 endif
 
 ifdef MOZ_TOOLS
-  CONFIGURE := $(TOPSRCDIR)/configure
+  CONFIGURE = $(TOPSRCDIR)/configure
 endif
 
-configure:
+configure::
+ifdef MOZ_BUILD_PROJECTS
+	@if test ! -d $(MOZ_OBJDIR); then $(MKDIR) $(MOZ_OBJDIR); else true; fi
+endif
 	@if test ! -d $(OBJDIR); then $(MKDIR) $(OBJDIR); else true; fi
 	@echo cd $(OBJDIR);
 	@echo $(CONFIGURE) $(CONFIGURE_ARGS)
-	@cd $(OBJDIR) && $(CONFIGURE_ENV_ARGS) $(CONFIGURE) $(CONFIGURE_ARGS) \
+	@cd $(OBJDIR) && $(BUILD_PROJECT_ARG) $(CONFIGURE_ENV_ARGS) $(CONFIGURE) $(CONFIGURE_ARGS) \
 	  || ( echo "*** Fix above errors and then restart with\
                \"$(MAKE) -f client.mk build\"" && exit 1 )
 	@touch $(OBJDIR)/Makefile
@@ -756,7 +816,7 @@ configure:
 $(OBJDIR)/Makefile $(OBJDIR)/config.status: $(CONFIG_STATUS_DEPS)
 	@$(MAKE) -f $(TOPSRCDIR)/client.mk configure
 
-ifdef CONFIG_STATUS
+ifneq (,$(CONFIG_STATUS))
 $(OBJDIR)/config/autoconf.mk: $(TOPSRCDIR)/config/autoconf.mk.in
 	cd $(OBJDIR); \
 	  CONFIG_FILES=config/autoconf.mk ./config.status
@@ -770,6 +830,17 @@ depend:: $(OBJDIR)/Makefile $(OBJDIR)/co
 	$(MOZ_MAKE) export && $(MOZ_MAKE) depend
 
 ####################################
+# Preflight
+
+build profiledbuild alldep preflight::
+ifdef MOZ_PREFLIGHT
+	set -e; \
+	for mkfile in $(MOZ_PREFLIGHT); do \
+	  $(MAKE) -f $$mkfile preflight TOPSRCDIR=$(TOPSRCDIR) OBJDIR=$(OBJDIR) MOZ_OBJDIR=$(MOZ_OBJDIR); \
+	done
+endif
+
+####################################
 # Build it
 
 build::  $(OBJDIR)/Makefile $(OBJDIR)/config.status
@@ -797,11 +868,44 @@ profiledbuild:: $(OBJDIR)/Makefile $(OBJ
 install export libs clean realclean distclean alldep:: $(OBJDIR)/Makefile $(OBJDIR)/config.status
 	$(MOZ_MAKE) $@
 
+####################################
+# Postflight
+
+build profiledbuild alldep postflight::
+ifdef MOZ_POSTFLIGHT
+	set -e; \
+	for mkfile in $(MOZ_POSTFLIGHT); do \
+	  $(MAKE) -f $$mkfile postflight TOPSRCDIR=$(TOPSRCDIR) OBJDIR=$(OBJDIR) MOZ_OBJDIR=$(MOZ_OBJDIR); \
+	done
+endif
+
+endif # MOZ_CURRENT_PROJECT
+
+####################################
+# Postflight, after building all projects
+
+build profiledbuild alldep postflight_all::
+ifeq (,$(MOZ_CURRENT_PROJECT)$(if $(MOZ_POSTFLIGHT_ALL),,1))
+# Don't run postflight_all for individual projects in multi-project builds
+# (when MOZ_CURRENT_PROJECT is set.)
+ifndef MOZ_BUILD_PROJECTS
+# Building a single project, OBJDIR is usable.
+	set -e; \
+	for mkfile in $(MOZ_POSTFLIGHT_ALL); do \
+	  $(MAKE) -f $$mkfile postflight_all TOPSRCDIR=$(TOPSRCDIR) OBJDIR=$(OBJDIR) MOZ_OBJDIR=$(MOZ_OBJDIR); \
+	done
+else
+# OBJDIR refers to the project-specific OBJDIR, which is not available at
+# this point when building multiple projects.  Only MOZ_OBJDIR is available.
+	set -e; \
+	for mkfile in $(MOZ_POSTFLIGHT_ALL); do \
+	  $(MAKE) -f $$mkfile postflight_all TOPSRCDIR=$(TOPSRCDIR) MOZ_OBJDIR=$(MOZ_OBJDIR) MOZ_BUILD_PROJECTS="$(MOZ_BUILD_PROJECTS)"; \
+	done
+endif
+endif
+
 cleansrcdir:
 	@cd $(TOPSRCDIR); \
-        if [ -f webshell/embed/gtk/Makefile ]; then \
-          $(MAKE) -C webshell/embed/gtk distclean; \
-        fi; \
 	if [ -f Makefile ]; then \
 	  $(MAKE) distclean ; \
 	else \
@@ -818,4 +922,4 @@ endif
 echo_objdir:
 	@echo $(OBJDIR)
 
-.PHONY: checkout real_checkout depend build export libs alldep install clean realclean distclean cleansrcdir pull_all build_all clobber clobber_all pull_and_build_all everything configure
+.PHONY: checkout real_checkout depend build export libs alldep install clean realclean distclean cleansrcdir pull_all build_all clobber clobber_all pull_and_build_all everything configure preflight_all preflight postflight postflight_all
diff -uprN --exclude=CVS mozilla/config/asdecode.cpp mozilla.new/config/asdecode.cpp
--- mozilla/config/asdecode.cpp	2005-06-10 16:16:18.000000000 +0200
+++ mozilla.new/config/asdecode.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,164 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is the AppleSingle decoder.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 2002
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *  Patrick Beard <beard@netscape.com>  (Original author)
- *  Brian Ryner <bryner@brianryner.com>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include <cstdio>
-#include <cstdlib>
-#include <cstring>
-#include <stdlib.h>
-#include <libkern/OSByteOrder.h>
-
-#define EXIT_IF_FALSE(x)                                                      \
-  do {                                                                        \
-    if (!(x)) {                                                               \
-      printf("Assertion failure: %s\n"                                        \
-             "  at %s line %d\n",                                             \
-             #x, __FILE__, __LINE__);                                         \
-      exit(1);                                                                \
-    }                                                                         \
-  } while (0)
-
-// decodes a file into data and resource forks.
-
-static int read_int(FILE* f)
-{
-  int result;
-  EXIT_IF_FALSE(fread(&result, sizeof(result), 1, f) == 1);
-  result = OSSwapBigToHostInt32(result);
-  return result;
-}
-
-static void copy_range(FILE* input, size_t offset, size_t length,
-		       const char* output_name)
-{
-  FILE* output = fopen(output_name, "wb");
-  EXIT_IF_FALSE(output != NULL);
-  fseek(input, offset, SEEK_SET);
-  while (length != 0) {
-    char buffer[4096];
-    size_t amount = (length > sizeof(buffer) ? sizeof(buffer) : length);
-    EXIT_IF_FALSE(fread(buffer, 1, amount, input) == amount);
-    fwrite(buffer, 1, amount, output);
-    length -= amount;
-  }
-  fclose(output);
-}
-
-int main(int argc, char** argv)
-{
-  if (argc < 3) {
-    printf("usage:  %s input output\n", argv[0]);
-    exit(1);
-  }
-
-  FILE* input = fopen(argv[1], "rb");
-  if (input == NULL) {
-    printf("%s: can't open file `%s'\n", argv[0], argv[1]);
-    exit(2);
-  }
-
-  struct header {
-    int magic_number;
-    int version_number;
-    char filler[16];
-  } header;
-
-  EXIT_IF_FALSE(fread(&header, sizeof(header), 1, input) == 1);
-  header.magic_number = OSSwapBigToHostInt32(header.magic_number);
-  header.version_number = OSSwapBigToHostInt32(header.version_number);
-  EXIT_IF_FALSE(header.magic_number == 0x00051600);
-  EXIT_IF_FALSE(header.version_number <= 0x00020000);
-  // printf("sizeof(header) == %d\n", sizeof(header));
-
-  short entry_count;
-  EXIT_IF_FALSE(fread(&entry_count, sizeof(entry_count), 1, input) == 1);
-  entry_count = OSSwapHostToBigInt16(entry_count);
-
-  struct entry {
-    unsigned int id;
-    unsigned int offset;
-    unsigned int length;
-  };
-
-  entry* entries = new entry[entry_count];
-  EXIT_IF_FALSE(fread(entries, sizeof(entry), entry_count, input) == entry_count);
-
-  entry* data_entry = NULL;
-  entry* rez_entry = NULL;
-
-  for (int i = 0; i < entry_count; i++) {
-    entry *swap = &entries[i];
-    swap->id = OSSwapBigToHostInt32(swap->id);
-    swap->offset = OSSwapBigToHostInt32(swap->offset);
-    swap->length = OSSwapBigToHostInt32(swap->length);
-	
-    entry& entry = entries[i];
-    switch (entry.id) {
-    case 1:
-      // data fork.
-      data_entry = &entry;
-      break;
-    case 2:
-      rez_entry = &entry;
-      break;
-    }
-  }
-
-  const char* data_name = argv[2];
-  if (data_entry && data_entry->length) {
-    copy_range(input, data_entry->offset, data_entry->length, data_name);
-  } else {
-    // always create the data fork, even if the file doesn't have one.
-    FILE* tmp = fopen(data_name, "wb");
-    EXIT_IF_FALSE(tmp);
-    fclose(tmp);
-  }
-
-  if (rez_entry && rez_entry->length) {
-    char rez_name[512];
-    strcpy(rez_name, data_name);
-    strcat(rez_name, "/rsrc");
-    copy_range(input, rez_entry->offset, rez_entry->length, rez_name);
-  }
-
-  delete[] entries;
-
-  fclose(input);
-
-  return 0;
-}
diff -uprN --exclude=CVS mozilla/config/autoconf.mk.in mozilla.new/config/autoconf.mk.in
--- mozilla/config/autoconf.mk.in	2006-01-09 06:48:36.000000000 +0100
+++ mozilla.new/config/autoconf.mk.in	2006-02-24 11:16:26.000000000 +0100
@@ -555,6 +555,7 @@ NEXT_ROOT	= @NEXT_ROOT@
 GCC_VERSION	= @GCC_VERSION@
 XCODEBUILD_VERSION= @XCODEBUILD_VERSION@
 HAS_XCODE_2_1	= @HAS_XCODE_2_1@
+UNIVERSAL_BINARY= @UNIVERSAL_BINARY@
 
 VISIBILITY_FLAGS = @VISIBILITY_FLAGS@
 WRAP_SYSTEM_INCLUDES = @WRAP_SYSTEM_INCLUDES@
diff -uprN --exclude=CVS mozilla/config/config.mk mozilla.new/config/config.mk
--- mozilla/config/config.mk	2006-01-09 06:48:36.000000000 +0100
+++ mozilla.new/config/config.mk	2006-02-24 11:16:26.000000000 +0100
@@ -687,6 +687,9 @@ else # NEXT_ROOT
 PBBUILD = $(PBBUILD_BIN)
 endif # NEXT_ROOT
 PBBUILD_SETTINGS = GCC_VERSION="$(GCC_VERSION)" SYMROOT=build
+ifdef CROSS_COMPILE
+PBBUILD_SETTINGS += ARCHS="$(OS_TEST)"
+endif # CROSS_COMPILE
 ifdef MACOS_SDK_DIR
 PBBUILD_SETTINGS += SDKROOT="$(MACOS_SDK_DIR)"
 endif # MACOS_SDK_DIR
diff -uprN --exclude=CVS mozilla/config/Makefile.in mozilla.new/config/Makefile.in
--- mozilla/config/Makefile.in	2005-07-21 15:33:40.000000000 +0200
+++ mozilla.new/config/Makefile.in	2006-02-24 11:16:26.000000000 +0100
@@ -68,13 +68,6 @@ TARGETS		+= elf-dynstr-gc
 endif
 endif
 
-ifeq ($(OS_ARCH), Darwin)
-# XXX Setting CPP_PROG_LINK is ugly, but it works (it makes nsinstall
-# link with $(CXX)).  asdecode should really be in its own directory.
-CPP_PROG_LINK	= 1
-SIMPLE_PROGRAMS	+= asdecode
-endif
-
 # IMPORTANT: Disable NSBUILDROOT for this directory only, otherwise we have
 # a recursive rule for finding nsinstall and the Perl scripts.
 ifdef NSBUILDROOT
diff -uprN --exclude=CVS mozilla/config/rules.mk mozilla.new/config/rules.mk
--- mozilla/config/rules.mk	2005-10-11 01:16:39.000000000 +0200
+++ mozilla.new/config/rules.mk	2006-02-24 11:16:26.000000000 +0100
@@ -1604,6 +1604,33 @@ endif
 
 ifneq ($(XPI_PKGNAME),)
 libs realchrome::
+ifdef STRIP_XPI
+	@echo "Stripping $(XPI_PKGNAME) package directory..."
+	@echo $(FINAL_TARGET)
+	@cd $(FINAL_TARGET) && find . ! -type d \
+			! -name "*.js" \
+			! -name "*.xpt" \
+			! -name "*.gif" \
+			! -name "*.jpg" \
+			! -name "*.png" \
+			! -name "*.xpm" \
+			! -name "*.txt" \
+			! -name "*.rdf" \
+			! -name "*.sh" \
+			! -name "*.properties" \
+			! -name "*.dtd" \
+			! -name "*.html" \
+			! -name "*.xul" \
+			! -name "*.css" \
+			! -name "*.xml" \
+			! -name "*.jar" \
+			! -name "*.dat" \
+			! -name "*.tbl" \
+			! -name "*.src" \
+			! -name "*.reg" \
+			$(PLATFORM_EXCLUDE_LIST) \
+			-exec $(STRIP) $(STRIP_FLAGS) {} >/dev/null 2>&1 \;
+endif
 	@echo "Packaging $(XPI_PKGNAME).xpi..."
 	cd $(FINAL_TARGET) && $(ZIP) -qr ../$(XPI_PKGNAME).xpi *
 endif
diff -uprN --exclude=CVS mozilla/content/base/public/nsIDocument.h mozilla.new/content/base/public/nsIDocument.h
--- mozilla/content/base/public/nsIDocument.h	2005-08-24 23:53:36.000000000 +0200
+++ mozilla.new/content/base/public/nsIDocument.h	2006-02-24 11:16:39.000000000 +0100
@@ -444,9 +444,9 @@ public:
   }
 
   /**
-   * Get the channel that was passed to StartDocumentLoad for this
+   * Get the channel that was passed to StartDocumentLoad or Reset for this
    * document.  Note that this may be null in some cases (eg if
-   * StartDocumentLoad was never called)
+   * StartDocumentLoad or Reset were never called)
    */
   virtual nsIChannel* GetChannel() const = 0;
 
@@ -568,7 +568,12 @@ public:
     return mNodeInfoManager;
   }
 
+  /**
+   * Reset the document using the given channel and loadgroup.  This works
+   * like ResetToURI, but also sets the document's channel to aChannel.
+   */
   virtual void Reset(nsIChannel* aChannel, nsILoadGroup* aLoadGroup) = 0;
+
   /**
    * Reset this document to aURI and aLoadGroup.  aURI must not be null.
    */
diff -uprN --exclude=CVS mozilla/content/base/src/nsDataDocumentContentPolicy.cpp mozilla.new/content/base/src/nsDataDocumentContentPolicy.cpp
--- mozilla/content/base/src/nsDataDocumentContentPolicy.cpp	2005-04-11 02:29:35.000000000 +0200
+++ mozilla.new/content/base/src/nsDataDocumentContentPolicy.cpp	2006-02-24 11:16:39.000000000 +0100
@@ -53,30 +53,27 @@ nsDataDocumentContentPolicy::ShouldLoad(
                                         PRInt16 *aDecision)
 {
   *aDecision = nsIContentPolicy::ACCEPT;
-  if (aContentType == nsIContentPolicy::TYPE_IMAGE ||
-      aContentType == nsIContentPolicy::TYPE_STYLESHEET ||
-      aContentType == nsIContentPolicy::TYPE_SCRIPT) {
-    // Look for the document.  In most cases, aRequestingContext is a
-    // content node.
-    nsCOMPtr<nsIDocument> doc;
-    nsCOMPtr<nsIContent> content = do_QueryInterface(aRequestingContext);
-    if (content) {
-      doc = content->GetOwnerDoc();
-    } else {
-      doc = do_QueryInterface(aRequestingContext);
-      if (!doc) {
-        nsCOMPtr<nsIDOMWindow> window = do_QueryInterface(aRequestingContext);
-        if (window) {
-          nsCOMPtr<nsIDOMDocument> domDoc;
-          window->GetDocument(getter_AddRefs(domDoc));
-          doc = do_QueryInterface(domDoc);
-        }
+  // Look for the document.  In most cases, aRequestingContext is a
+  // content node.
+  nsCOMPtr<nsIDocument> doc;
+  nsCOMPtr<nsIContent> content = do_QueryInterface(aRequestingContext);
+  if (content) {
+    doc = content->GetOwnerDoc();
+  } else {
+    doc = do_QueryInterface(aRequestingContext);
+    if (!doc) {
+      nsCOMPtr<nsIDOMWindow> window = do_QueryInterface(aRequestingContext);
+      if (window) {
+        nsCOMPtr<nsIDOMDocument> domDoc;
+        window->GetDocument(getter_AddRefs(domDoc));
+        doc = do_QueryInterface(domDoc);
       }
     }
-    if (doc && doc->IsLoadedAsData()) {
-      *aDecision = nsIContentPolicy::REJECT_TYPE;
-    }
   }
+  if (doc && doc->IsLoadedAsData()) {
+    *aDecision = nsIContentPolicy::REJECT_TYPE;
+  }
+
   return NS_OK;
 }
 
diff -uprN --exclude=CVS mozilla/content/base/src/nsDocument.cpp mozilla.new/content/base/src/nsDocument.cpp
--- mozilla/content/base/src/nsDocument.cpp	2005-10-13 23:50:01.000000000 +0200
+++ mozilla.new/content/base/src/nsDocument.cpp	2006-02-24 11:16:39.000000000 +0100
@@ -138,6 +138,16 @@ static NS_DEFINE_CID(kDOMEventGroupCID, 
 #include "nsDateTimeFormatCID.h"
 #include "nsIDateTimeFormat.h"
 
+#ifdef MOZ_LOGGING
+// so we can get logging even in release builds
+#define FORCE_PR_LOG 1
+#endif
+#include "prlog.h"
+
+#ifdef PR_LOGGING
+static PRLogModuleInfo* gDocumentLeakPRLog;
+#endif
+
 static NS_DEFINE_CID(kCharsetAliasCID, NS_CHARSETALIAS_CID);
 static NS_DEFINE_CID(kDateTimeFormatCID, NS_DATETIMEFORMAT_CID);
 
@@ -702,10 +712,24 @@ nsDocument::nsDocument()
   : nsIDocument(),
     mVisible(PR_TRUE)
 {
+#ifdef PR_LOGGING
+  if (!gDocumentLeakPRLog)
+    gDocumentLeakPRLog = PR_NewLogModule("DocumentLeak");
+
+  if (gDocumentLeakPRLog)
+    PR_LOG(gDocumentLeakPRLog, PR_LOG_DEBUG,
+           ("DOCUMENT %p created", this));
+#endif
 }
 
 nsDocument::~nsDocument()
 {
+#ifdef PR_LOGGING
+  if (gDocumentLeakPRLog)
+    PR_LOG(gDocumentLeakPRLog, PR_LOG_DEBUG,
+           ("DOCUMENT %p destroyed", this));
+#endif
+
   mInDestructor = PR_TRUE;
 
   // XXX Inform any remaining observers that we are going away.
@@ -936,12 +960,23 @@ nsDocument::Reset(nsIChannel* aChannel, 
 
     mPrincipal = do_QueryInterface(owner);
   }
+
+  mChannel = aChannel;
 }
 
 void
 nsDocument::ResetToURI(nsIURI *aURI, nsILoadGroup *aLoadGroup)
 {
   NS_PRECONDITION(aURI, "Null URI passed to ResetToURI");
+
+#ifdef PR_LOGGING
+  if (gDocumentLeakPRLog && PR_LOG_TEST(gDocumentLeakPRLog, PR_LOG_DEBUG)) {
+    nsCAutoString spec;
+    aURI->GetSpec(spec);
+    PR_LogPrint("DOCUMENT %p ResetToURI %s", this, spec.get());
+  }
+#endif
+
   mDocumentTitle.SetIsVoid(PR_TRUE);
 
   mPrincipal = nsnull;
@@ -1146,6 +1181,17 @@ nsDocument::StartDocumentLoad(const char
                               nsIStreamListener **aDocListener,
                               PRBool aReset, nsIContentSink* aSink)
 {
+#ifdef PR_LOGGING
+  if (gDocumentLeakPRLog && PR_LOG_TEST(gDocumentLeakPRLog, PR_LOG_DEBUG)) {
+    nsCOMPtr<nsIURI> uri;
+    aChannel->GetURI(getter_AddRefs(uri));
+    nsCAutoString spec;
+    if (uri)
+      uri->GetSpec(spec);
+    PR_LogPrint("DOCUMENT %p StartDocumentLoad %s", this, spec.get());
+  }
+#endif
+
   if (aReset) {
     Reset(aChannel, aLoadGroup);
   }
@@ -3151,7 +3197,8 @@ nsDocument::SetTitle(const nsAString& aT
 NS_IMETHODIMP
 nsDocument::GetBoxObjectFor(nsIDOMElement* aElement, nsIBoxObject** aResult)
 {
-  NS_ENSURE_ARG(aElement);
+  nsCOMPtr<nsIContent> content(do_QueryInterface(aElement));
+  NS_ENSURE_TRUE(content, NS_ERROR_UNEXPECTED);
   
   nsresult rv;
 
@@ -3180,7 +3227,6 @@ nsDocument::GetBoxObjectFor(nsIDOMElemen
   nsCOMPtr<nsIAtom> tag;
   nsCOMPtr<nsIXBLService> xblService =
            do_GetService("@mozilla.org/xbl;1", &rv);
-  nsCOMPtr<nsIContent> content(do_QueryInterface(aElement));
   xblService->ResolveTag(content, &namespaceID, getter_AddRefs(tag));
 
   nsCAutoString contractID("@mozilla.org/layout/xul-boxobject");
diff -uprN --exclude=CVS mozilla/content/base/src/nsFrameLoader.cpp mozilla.new/content/base/src/nsFrameLoader.cpp
--- mozilla/content/base/src/nsFrameLoader.cpp	2005-08-22 17:46:13.000000000 +0200
+++ mozilla.new/content/base/src/nsFrameLoader.cpp	2006-03-03 07:14:05.000000000 +0100
@@ -121,28 +121,24 @@ nsFrameLoader::LoadFrame()
   mDocShell->CreateLoadInfo(getter_AddRefs(loadInfo));
   NS_ENSURE_TRUE(loadInfo, NS_ERROR_FAILURE);
 
-  // Check for security
+  // Check for security.  The fun part is trying to figure out what principals
+  // to use.  The way I figure it, if we're doing a LoadFrame() accidentally
+  // (eg someone created a frame/iframe node, we're being parsed, XUL iframes
+  // are being reframed, etc.) then we definitely want to use the node
+  // principal of mOwnerContent for security checks.  If, on the other hand,
+  // someone's setting the src on our owner content, or created it via script,
+  // or whatever, then they can clearly access it... and we should still use
+  // the principal of mOwnerContent.  I don't think that leads to privilege
+  // escalation, and it's reasonably guaranteed to not lead to XSS issues
+  // (since caller can already access mOwnerContent in this case.  So just use
+  // the principal of mOwnerContent no matter what.  If script wants to run
+  // things with its own permissions, which differ from those of mOwnerContent
+  // (which means the script is privileged in some way) it should set
+  // window.location instead.
   nsIScriptSecurityManager *secMan = nsContentUtils::GetSecurityManager();
 
-  // Get referring URL
-  nsCOMPtr<nsIURI> referrer;
-  nsCOMPtr<nsIPrincipal> principal;
-  rv = secMan->GetSubjectPrincipal(getter_AddRefs(principal));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  // If we were called from script, get the referring URL from the script
-
-  if (principal) {
-    // Pass the script principal to the docshell
-
-    loadInfo->SetOwner(principal);
-  } else {
-    // We're not being called form script, tell the docshell
-    // to inherit an owner from the current document.
-
-    loadInfo->SetInheritOwner(PR_TRUE);
-    principal = doc->GetPrincipal();
-  }
+  // Get our principal
+  nsIPrincipal* principal = doc->GetPrincipal();
 
   if (!principal) {
     return NS_ERROR_FAILURE;
@@ -155,15 +151,36 @@ nsFrameLoader::LoadFrame()
     return rv; // We're not
   }
 
-  rv = principal->GetURI(getter_AddRefs(referrer));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  loadInfo->SetReferrer(referrer);
-
   // Bail out if this is an infinite recursion scenario
   rv = CheckForRecursiveLoad(uri);
   NS_ENSURE_SUCCESS(rv, rv);
   
+  // Is our principal the system principal?
+  nsCOMPtr<nsIPrincipal> sysPrin;
+  rv = secMan->GetSystemPrincipal(getter_AddRefs(sysPrin));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  if (principal == sysPrin) {
+    // We're a chrome node.  Belt and braces -- inherit the principal for this
+    // load instead of just forcing the system principal.  That way if we have
+    // something loaded already the principal used will be that of what we
+    // already have loaded.
+    loadInfo->SetInheritOwner(PR_TRUE);
+
+    // Also, in this case we don't set a referrer, just in case.
+  } else {
+    // We'll use our principal, not that of the document loaded inside us.
+    // This is very important; needed to prevent XSS attacks on documents
+    // loaded in subframes!
+    loadInfo->SetOwner(principal);
+
+    nsCOMPtr<nsIURI> referrer;  
+    rv = principal->GetURI(getter_AddRefs(referrer));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    loadInfo->SetReferrer(referrer);
+  }
+
   // Kick off the load...
   rv = mDocShell->LoadURI(uri, loadInfo, nsIWebNavigation::LOAD_FLAGS_NONE,
                           PR_FALSE);
diff -uprN --exclude=CVS mozilla/content/events/src/nsDOMMouseEvent.cpp mozilla.new/content/events/src/nsDOMMouseEvent.cpp
--- mozilla/content/events/src/nsDOMMouseEvent.cpp	2005-04-29 01:47:55.000000000 +0200
+++ mozilla.new/content/events/src/nsDOMMouseEvent.cpp	2006-02-24 11:16:39.000000000 +0100
@@ -181,7 +181,7 @@ nsDOMMouseEvent::GetButton(PRUint16* aBu
       break;
     default:
       // This event doesn't have a mouse button associated with it
-      *aButton = (PRUint16)-1;
+      *aButton = (PRUint16)0;
       break;
     }
   }
diff -uprN --exclude=CVS mozilla/content/events/src/nsDOMTextEvent.cpp mozilla.new/content/events/src/nsDOMTextEvent.cpp
--- mozilla/content/events/src/nsDOMTextEvent.cpp	2005-04-29 01:47:55.000000000 +0200
+++ mozilla.new/content/events/src/nsDOMTextEvent.cpp	2006-02-24 11:16:39.000000000 +0100
@@ -1,4 +1,5 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=2 sw=2 et tw=78: */
 /* ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
@@ -58,7 +59,7 @@ nsDOMTextEvent::nsDOMTextEvent(nsPresCon
   //
   // extract the IME composition string
   //
-  nsTextEvent *te = NS_STATIC_CAST(nsTextEvent*, aEvent);
+  nsTextEvent *te = NS_STATIC_CAST(nsTextEvent*, mEvent);
   mText = te->theText;
 
   //
@@ -68,20 +69,20 @@ nsDOMTextEvent::nsDOMTextEvent(nsPresCon
   //
   nsIPrivateTextRange** tempTextRangeList = new nsIPrivateTextRange*[te->rangeCount];
   if (tempTextRangeList) {
-      PRUint16 i;
+    PRUint16 i;
 
-      for(i = 0; i < te->rangeCount; i++) {
-        nsPrivateTextRange* tempPrivateTextRange = new
-          nsPrivateTextRange(te->rangeArray[i].mStartOffset,
-                             te->rangeArray[i].mEndOffset,
-                             te->rangeArray[i].mRangeType);
+    for(i = 0; i < te->rangeCount; i++) {
+      nsPrivateTextRange* tempPrivateTextRange = new
+        nsPrivateTextRange(te->rangeArray[i].mStartOffset,
+                           te->rangeArray[i].mEndOffset,
+                           te->rangeArray[i].mRangeType);
 
-        if (tempPrivateTextRange) {
-          NS_ADDREF(tempPrivateTextRange);
+      if (tempPrivateTextRange) {
+        NS_ADDREF(tempPrivateTextRange);
 
-          tempTextRangeList[i] = (nsIPrivateTextRange*)tempPrivateTextRange;
-        }
+        tempTextRangeList[i] = (nsIPrivateTextRange*)tempPrivateTextRange;
       }
+    }
   }
 
   // We need to create mTextRange even rangeCount is 0. 
diff -uprN --exclude=CVS mozilla/content/events/src/nsEventStateManager.cpp mozilla.new/content/events/src/nsEventStateManager.cpp
--- mozilla/content/events/src/nsEventStateManager.cpp	2006-01-11 23:05:25.000000000 +0100
+++ mozilla.new/content/events/src/nsEventStateManager.cpp	2006-02-24 11:16:39.000000000 +0100
@@ -3270,6 +3270,11 @@ nsEventStateManager::ShiftFocusInternal(
         PRBool selectionWithFocus;
         MoveFocusToCaret(PR_FALSE, &selectionWithFocus);
         ignoreTabIndex = !selectionWithFocus;
+        // Refresh |selectionFrame| since MoveFocusToCaret() could have
+        // destroyed it. (bug 308086)
+        GetDocSelectionLocation(getter_AddRefs(selectionContent),
+                                getter_AddRefs(endSelectionContent),
+                                &selectionFrame, &selectionOffset);
       }
     }
   }
diff -uprN --exclude=CVS mozilla/content/html/content/src/nsHTMLInputElement.cpp mozilla.new/content/html/content/src/nsHTMLInputElement.cpp
--- mozilla/content/html/content/src/nsHTMLInputElement.cpp	2005-09-28 11:49:17.000000000 +0200
+++ mozilla.new/content/html/content/src/nsHTMLInputElement.cpp	2006-03-03 07:14:07.000000000 +0100
@@ -1297,6 +1297,13 @@ nsHTMLInputElement::HandleDOMEvent(nsPre
     }
   }
 
+  // Don't allow mutation events which are targeted somewhere inside
+  // <input>, except if they are dispatched to the element itself.
+  if (!(NS_EVENT_FLAG_INIT & aFlags) &&
+      aEvent->eventStructType == NS_MUTATION_EVENT) {
+    return NS_OK;
+  }
+
   //
   // Web pages expect the value of a radio button or checkbox to be set
   // *before* onclick and DOMActivate fire, and they expect that if they set
@@ -1775,8 +1782,14 @@ nsHTMLInputElement::ParseAttribute(nsIAt
       return PR_FALSE;
     }
 
-    mType = aResult.GetEnumValue();
-    if (mType == NS_FORM_INPUT_FILE) {
+    // Make sure to do the check for newType being NS_FORM_INPUT_FILE and the
+    // corresponding SetValueInternal() call _before_ we set mType.  That way
+    // the logic in SetValueInternal() will work right (that logic makes
+    // assumptions about our frame based on mType, but we won't have had time
+    // to recreate frames yet -- that happens later in the SetAttr()
+    // process).
+    PRInt8 newType = aResult.GetEnumValue();
+    if (newType == NS_FORM_INPUT_FILE) {      
       // If the type is being changed to file, set the element value
       // to the empty string. This is for security.
       // Call SetValueInternal so that this doesn't accidentally get caught
@@ -1784,6 +1797,8 @@ nsHTMLInputElement::ParseAttribute(nsIAt
       SetValueInternal(EmptyString(), nsnull);
     }
 
+    mType = newType;
+    
     return PR_TRUE;
   }
   if (aAttribute == nsHTMLAtoms::width) {
diff -uprN --exclude=CVS mozilla/content/html/document/src/nsHTMLDocument.cpp mozilla.new/content/html/document/src/nsHTMLDocument.cpp
--- mozilla/content/html/document/src/nsHTMLDocument.cpp	2006-01-09 06:48:52.000000000 +0100
+++ mozilla.new/content/html/document/src/nsHTMLDocument.cpp	2006-02-24 11:16:39.000000000 +0100
@@ -279,7 +279,8 @@ IdAndNameHashInitEntry(PLDHashTable *tab
 
 nsHTMLDocument::nsHTMLDocument()
   : mCompatMode(eCompatibility_NavQuirks),
-    mTexttype(IBMBIDI_TEXTTYPE_LOGICAL)
+    mTexttype(IBMBIDI_TEXTTYPE_LOGICAL),
+    mDefaultNamespaceID(kNameSpaceID_None)
 {
 
   // NOTE! nsDocument::operator new() zeroes out all members, so don't
@@ -314,6 +315,12 @@ nsHTMLDocument::Init()
   nsresult rv = nsDocument::Init();
   NS_ENSURE_SUCCESS(rv, rv);
 
+  // Now reset the case-sensitivity of the CSSLoader, since we default
+  // to being HTML, not XHTML.  Also, reset the compatibility mode to
+  // match our compat mode.
+  CSSLoader()->SetCaseSensitive(IsXHTML());
+  CSSLoader()->SetCompatibilityMode(mCompatMode);
+
   static PLDHashTableOps hash_table_ops =
   {
     PL_DHashAllocTable,
diff -uprN --exclude=CVS mozilla/content/html/document/src/nsHTMLDocument.h mozilla.new/content/html/document/src/nsHTMLDocument.h
--- mozilla/content/html/document/src/nsHTMLDocument.h	2005-06-20 18:18:35.000000000 +0200
+++ mozilla.new/content/html/document/src/nsHTMLDocument.h	2006-02-24 11:16:39.000000000 +0100
@@ -331,6 +331,8 @@ protected:
 
   // kNameSpaceID_None for good ol' HTML documents, and
   // kNameSpaceID_XHTML for spiffy new XHTML documents.
+  // XXXbz should this be reset if someone manually calls
+  // SetContentType() on this document?
   PRInt32 mDefaultNamespaceID;
 };
 
diff -uprN --exclude=CVS mozilla/content/html/document/src/nsWyciwygProtocolHandler.cpp mozilla.new/content/html/document/src/nsWyciwygProtocolHandler.cpp
--- mozilla/content/html/document/src/nsWyciwygProtocolHandler.cpp	2004-04-17 23:52:17.000000000 +0200
+++ mozilla.new/content/html/document/src/nsWyciwygProtocolHandler.cpp	2006-02-24 11:16:39.000000000 +0100
@@ -109,6 +109,7 @@ nsWyciwygProtocolHandler::NewURI(const n
 NS_IMETHODIMP
 nsWyciwygProtocolHandler::NewChannel(nsIURI* url, nsIChannel* *result)
 {
+  NS_ENSURE_ARG_POINTER(url);
   nsresult rv;
     
   nsWyciwygChannel* channel = new nsWyciwygChannel();
diff -uprN --exclude=CVS mozilla/content/xul/content/src/nsXULElement.cpp mozilla.new/content/xul/content/src/nsXULElement.cpp
--- mozilla/content/xul/content/src/nsXULElement.cpp	2005-09-26 15:30:08.000000000 +0200
+++ mozilla.new/content/xul/content/src/nsXULElement.cpp	2006-03-03 07:14:10.000000000 +0100
@@ -1033,8 +1033,9 @@ nsXULElement::UnbindFromTree(PRBool aDee
 PRBool
 nsXULElement::IsNativeAnonymous() const
 {
-    // XXX Workarond for bug 280541
-    return PR_FALSE;
+    // XXX Workaround for bug 280541, wallpaper for bug 326644
+    return Tag() == nsXULAtoms::popupgroup &&
+           nsGenericElement::IsNativeAnonymous();
 }
 
 PRUint32
diff -uprN --exclude=CVS mozilla/content/xul/document/src/nsXULDocument.cpp mozilla.new/content/xul/document/src/nsXULDocument.cpp
--- mozilla/content/xul/document/src/nsXULDocument.cpp	2006-01-11 23:05:27.000000000 +0100
+++ mozilla.new/content/xul/document/src/nsXULDocument.cpp	2006-03-03 07:14:11.000000000 +0100
@@ -149,6 +149,8 @@ const nsForwardReference::Phase nsForwar
     nsForwardReference::eDone
 };
 
+const PRUint32 kMaxAttrNameLength = 512;
+const PRUint32 kMaxAttributeLength = 4096;
 
 //----------------------------------------------------------------------
 //
@@ -483,6 +485,7 @@ NS_INTERFACE_MAP_BEGIN(nsXULDocument)
     NS_INTERFACE_MAP_ENTRY(nsIXULDocument)
     NS_INTERFACE_MAP_ENTRY(nsIDOMXULDocument)
     NS_INTERFACE_MAP_ENTRY(nsIStreamLoaderObserver)
+    NS_INTERFACE_MAP_ENTRY(nsIDOMXULDocument2)
     NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(XULDocument)
 NS_INTERFACE_MAP_END_INHERITING(nsXMLDocument)
 
@@ -1522,6 +1525,14 @@ nsXULDocument::Persist(nsIContent* aElem
     rv = aAttribute->GetUTF8String(&attrstr);
     if (NS_FAILED(rv)) return rv;
 
+    // Don't bother with unreasonable attributes. We clamp long values,
+    // but truncating attribute names turns it into a different attribute
+    // so there's no point in persisting anything at all
+    if (!attrstr || strlen(attrstr) > kMaxAttrNameLength) {
+        NS_WARNING("Can't persist, Attribute name too long");
+        return NS_ERROR_ILLEGAL_VALUE;
+    }
+
     nsCOMPtr<nsIRDFResource> attr;
     rv = gRDFService->GetResource(nsDependentCString(attrstr),
                                   getter_AddRefs(attr));
@@ -1532,6 +1543,14 @@ nsXULDocument::Persist(nsIContent* aElem
     rv = aElement->GetAttr(kNameSpaceID_None, aAttribute, valuestr);
     if (NS_FAILED(rv)) return rv;
 
+    // prevent over-long attributes that choke the parser (bug 319846)
+    // (can't simply Truncate without testing, it's implemented
+    // using SetLength and will grow a short string)
+    if (valuestr.Length() > kMaxAttributeLength) {
+        NS_WARNING("Truncating persisted attribute value");
+        valuestr.Truncate(kMaxAttributeLength);
+    }
+
     PRBool novalue = (rv != NS_CONTENT_ATTR_HAS_VALUE);
 
     // See if there was an old value...
@@ -1699,14 +1718,8 @@ nsXULDocument::GetHeight(PRInt32* aHeigh
 NS_IMETHODIMP
 nsXULDocument::GetPopupNode(nsIDOMNode** aNode)
 {
-    nsresult rv;
-
-    // get focus controller
-    nsCOMPtr<nsIFocusController> focusController;
-    GetFocusController(getter_AddRefs(focusController));
-    NS_ENSURE_TRUE(focusController, NS_ERROR_FAILURE);
-    // get popup node
-    rv = focusController->GetPopupNode(aNode); // addref happens here
+    // Get popup node.
+    nsresult rv = TrustedGetPopupNode(aNode); // addref happens here
 
     if (NS_SUCCEEDED(rv) && *aNode && !nsContentUtils::CanCallerAccess(*aNode)) {
         NS_RELEASE(*aNode);
@@ -1717,6 +1730,18 @@ nsXULDocument::GetPopupNode(nsIDOMNode**
 }
 
 NS_IMETHODIMP
+nsXULDocument::TrustedGetPopupNode(nsIDOMNode** aNode)
+{
+    // Get the focus controller.
+    nsCOMPtr<nsIFocusController> focusController;
+    GetFocusController(getter_AddRefs(focusController));
+    NS_ENSURE_TRUE(focusController, NS_ERROR_FAILURE);
+
+    // Get the popup node.
+    return focusController->GetPopupNode(aNode); // addref happens here
+}
+
+NS_IMETHODIMP
 nsXULDocument::SetPopupNode(nsIDOMNode* aNode)
 {
     nsresult rv;
@@ -1743,6 +1768,13 @@ nsXULDocument::GetTooltipNode(nsIDOMNode
 }
 
 NS_IMETHODIMP
+nsXULDocument::TrustedGetTooltipNode(nsIDOMNode** aNode)
+{
+    NS_IF_ADDREF(*aNode = mTooltipNode);
+    return NS_OK;
+}
+
+NS_IMETHODIMP
 nsXULDocument::SetTooltipNode(nsIDOMNode* aNode)
 {
     mTooltipNode = aNode;
@@ -3183,14 +3215,15 @@ nsXULDocument::ResumeWalk()
     // XXXldb This is where we should really be setting the chromehidden
     // attribute.
 
-    PRBool didInitialReflow = PR_TRUE;
-    nsIPresShell *shell = GetShellAt(0);
-    if (shell)
-        shell->GetDidInitialReflow(&didInitialReflow);
-
-    if (!didInitialReflow) {
-        // Everything after this point we only want to do once we're
-        // certain that we've been embedded in a presentation shell.
+    if (!mDocumentLoaded) {
+        // Make sure we don't reenter here from StartLayout().  Note that
+        // setting mDocumentLoaded to true here means that if StartLayout()
+        // causes ResumeWalk() to be reentered, we'll take the other branch of
+        // the |if (!mDocumentLoaded)| check above and since
+        // mInitialLayoutComplete will be false will follow the else branch
+        // there too.  See the big comment there for how such reentry can
+        // happen.
+        mDocumentLoaded = PR_TRUE;
 
         nsAutoString title;
         mRootContent->GetAttr(kNameSpaceID_None, nsHTMLAtoms::title, title);
@@ -3253,6 +3286,8 @@ nsXULDocument::ResumeWalk()
                 // whether or not the overlay prototype is in the XUL cache. The
                 // most likely effect of this bug is odd UI initialization due to
                 // methods and properties that do not work.
+                // XXXbz really, we shouldn't be firing binding constructors
+                // until after StartLayout returns!
 
                 NS_ENSURE_TRUE(mPendingOverlayLoadNotifications.IsInitialized() || mPendingOverlayLoadNotifications.Init(), 
                                NS_ERROR_OUT_OF_MEMORY);
diff -uprN --exclude=CVS mozilla/content/xul/document/src/nsXULDocument.h mozilla.new/content/xul/document/src/nsXULDocument.h
--- mozilla/content/xul/document/src/nsXULDocument.h	2005-08-29 21:56:09.000000000 +0200
+++ mozilla.new/content/xul/document/src/nsXULDocument.h	2006-02-24 11:16:40.000000000 +0100
@@ -1,4 +1,5 @@
 /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim: set ts=4 sw=4 et tw=78: */
 /* ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
@@ -82,7 +83,7 @@ struct PRLogModuleInfo;
  */
 class nsXULDocument : public nsXMLDocument,
                       public nsIXULDocument,
-                      public nsIDOMXULDocument,
+                      public nsIDOMXULDocument2,
                       public nsIStreamLoaderObserver
 {
 public:
@@ -161,6 +162,7 @@ public:
 
     // nsIDOMXULDocument interface
     NS_DECL_NSIDOMXULDOCUMENT
+    NS_DECL_NSIDOMXULDOCUMENT2
 
     // nsIDOMNSDocument
     NS_IMETHOD GetContentType(nsAString& aContentType);
@@ -269,6 +271,7 @@ protected:
     PRPackedBool               mIsFastLoad;
     PRPackedBool               mApplyingPersistedAttrs;
     PRPackedBool               mIsWritingFastLoad;
+    PRPackedBool               mDocumentLoaded;
     nsCOMPtr<nsIDOMXULCommandDispatcher>     mCommandDispatcher; // [OWNER] of the focus tracker
 
     // Maintains the template builders that have been attached to
diff -uprN --exclude=CVS mozilla/directory/c-sdk/config/autoconf.mk.in mozilla.new/directory/c-sdk/config/autoconf.mk.in
--- mozilla/directory/c-sdk/config/autoconf.mk.in	2005-06-02 19:35:00.000000000 +0200
+++ mozilla.new/directory/c-sdk/config/autoconf.mk.in	2006-02-24 11:15:31.000000000 +0100
@@ -115,3 +115,8 @@ endif
 #
 MOZILLA_CLIENT	= 1
 VPATH		= $(srcdir)
+
+NEXT_ROOT	= @NEXT_ROOT@
+ifdef NEXT_ROOT
+export NEXT_ROOT
+endif
diff -uprN --exclude=CVS mozilla/directory/c-sdk/configure mozilla.new/directory/c-sdk/configure
--- mozilla/directory/c-sdk/configure	2005-06-09 10:17:46.000000000 +0200
+++ mozilla.new/directory/c-sdk/configure	2006-02-24 11:15:30.000000000 +0100
@@ -46,6 +46,8 @@ ac_help="$ac_help
   --with-nspr-exec-prefix=PFX
                           Exec prefix where NSPR is installed"
 ac_help="$ac_help
+  --with-macos-sdk=dir    Location of platform SDK to use (Mac OS X only)"
+ac_help="$ac_help
   --enable-strip          Enable stripping of shared libs and programs"
 ac_help="$ac_help
   --with-pthreads         Use system pthreads library as thread subsystem"
@@ -621,7 +623,7 @@ else { echo "configure: error: can not r
 fi
 
 echo $ac_n "checking host system type""... $ac_c" 1>&6
-echo "configure:625: checking host system type" >&5
+echo "configure:627: checking host system type" >&5
 
 host_alias=$host
 case "$host_alias" in
@@ -642,7 +644,7 @@ host_os=`echo $host | sed 's/^\([^-]*\)-
 echo "$ac_t""$host" 1>&6
 
 echo $ac_n "checking target system type""... $ac_c" 1>&6
-echo "configure:646: checking target system type" >&5
+echo "configure:648: checking target system type" >&5
 
 target_alias=$target
 case "$target_alias" in
@@ -660,7 +662,7 @@ target_os=`echo $target | sed 's/^\([^-]
 echo "$ac_t""$target" 1>&6
 
 echo $ac_n "checking build system type""... $ac_c" 1>&6
-echo "configure:664: checking build system type" >&5
+echo "configure:666: checking build system type" >&5
 
 build_alias=$build
 case "$build_alias" in
@@ -720,7 +722,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:724: checking for $ac_word" >&5
+echo "configure:726: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -963,7 +965,7 @@ fi
 	# Extract the first word of "nspr-config", so it can be a program name with args.
 set dummy nspr-config; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:967: checking for $ac_word" >&5
+echo "configure:969: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_NSPR_CONFIG'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -998,7 +1000,7 @@ fi
 
 	min_nspr_version=4.0.0
 	echo $ac_n "checking for NSPR - version >= $min_nspr_version (skipping)""... $ac_c" 1>&6
-echo "configure:1002: checking for NSPR - version >= $min_nspr_version (skipping)" >&5
+echo "configure:1004: checking for NSPR - version >= $min_nspr_version (skipping)" >&5
 
 	no_nspr=""
 	if test "$NSPR_CONFIG" = "no"; then
@@ -1129,7 +1131,7 @@ if test -z "$SKIP_PATH_CHECKS"; then
     # Extract the first word of "$WHOAMI whoami", so it can be a program name with args.
 set dummy $WHOAMI whoami; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1133: checking for $ac_word" >&5
+echo "configure:1135: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_WHOAMI'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1204,13 +1206,13 @@ if test "$target" != "$host"; then
     _SAVE_LDFLAGS="$LDFLAGS"
 
     echo $ac_n "checking for $host compiler""... $ac_c" 1>&6
-echo "configure:1208: checking for $host compiler" >&5
+echo "configure:1210: checking for $host compiler" >&5
     for ac_prog in gcc cc /usr/ucb/cc
 do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1214: checking for $ac_word" >&5
+echo "configure:1216: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_HOST_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1251,41 +1253,25 @@ test -n "$HOST_CC" || HOST_CC=""""
 	    HOST_LDFLAGS="$LDFLAGS"
     fi
 
-    CC="$HOST_CC"
-    CFLAGS="$HOST_CFLAGS"
-    LDFLAGS="$HOST_LDFLAGS"
-
-    echo $ac_n "checking whether the $host compiler ($HOST_CC $HOST_CFLAGS $HOST_LDFLAGS) works""... $ac_c" 1>&6
-echo "configure:1260: checking whether the $host compiler ($HOST_CC $HOST_CFLAGS $HOST_LDFLAGS) works" >&5
-    cat > conftest.$ac_ext <<EOF
-#line 1262 "configure"
-#include "confdefs.h"
-
-int main() {
-return(0);
-; return 0; }
-EOF
-if { (eval echo configure:1269: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
-  rm -rf conftest*
-  ac_cv_prog_host_cc_works=1 echo "$ac_t""yes" 1>&6
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  { echo "configure: error: installation or configuration problem: $host compiler $HOST_CC cannot create executables." 1>&2; exit 1; } 
-fi
-rm -f conftest*
-    
     CC=$_SAVE_CC
     CFLAGS=$_SAVE_CFLAGS
     LDFLAGS=$_SAVE_LDFLAGS
 
+    case "$build:$target" in 
+      powerpc-apple-darwin8*:i?86-apple-darwin*)
+                                                _SAVE_CFLAGS=$CFLAGS 
+        _SAVE_CXXFLAGS=$CXXLAGS
+        CFLAGS="-isysroot /Developer/SDKs/MacOSX10.4u.sdk $CFLAGS"
+        CXXFLAGS="-isysroot /Developer/SDKs/MacOSX10.4u.sdk $CXXFLAGS"
+        ;;        
+    esac            
+
     for ac_prog in $CC "${target_alias}-gcc" "${target}-gcc"
 do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1289: checking for $ac_word" >&5
+echo "configure:1275: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1319,7 +1305,7 @@ test -n "$CC" || CC="echo"
     # Extract the first word of "gcc", so it can be a program name with args.
 set dummy gcc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1323: checking for $ac_word" >&5
+echo "configure:1309: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1349,7 +1335,7 @@ if test -z "$CC"; then
   # Extract the first word of "cc", so it can be a program name with args.
 set dummy cc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1353: checking for $ac_word" >&5
+echo "configure:1339: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1400,7 +1386,7 @@ fi
       # Extract the first word of "cl", so it can be a program name with args.
 set dummy cl; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1404: checking for $ac_word" >&5
+echo "configure:1390: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1432,7 +1418,7 @@ fi
 fi
 
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
-echo "configure:1436: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
+echo "configure:1422: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
 
 ac_ext=c
 # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
@@ -1443,12 +1429,12 @@ cross_compiling=$ac_cv_prog_cc_cross
 
 cat > conftest.$ac_ext << EOF
 
-#line 1447 "configure"
+#line 1433 "configure"
 #include "confdefs.h"
 
 main(){return(0);}
 EOF
-if { (eval echo configure:1452: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1438: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   ac_cv_prog_cc_works=yes
   # If we can't run a trivial program, we are probably using a cross compiler.
   if (./conftest; exit) 2>/dev/null; then
@@ -1474,12 +1460,12 @@ if test $ac_cv_prog_cc_works = no; then
   { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
 fi
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
-echo "configure:1478: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "configure:1464: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
 echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
 cross_compiling=$ac_cv_prog_cc_cross
 
 echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
-echo "configure:1483: checking whether we are using GNU C" >&5
+echo "configure:1469: checking whether we are using GNU C" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1488,7 +1474,7 @@ else
   yes;
 #endif
 EOF
-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1492: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1478: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
   ac_cv_prog_gcc=yes
 else
   ac_cv_prog_gcc=no
@@ -1507,7 +1493,7 @@ ac_test_CFLAGS="${CFLAGS+set}"
 ac_save_CFLAGS="$CFLAGS"
 CFLAGS=
 echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
-echo "configure:1511: checking whether ${CC-cc} accepts -g" >&5
+echo "configure:1497: checking whether ${CC-cc} accepts -g" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1543,7 +1529,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1547: checking for $ac_word" >&5
+echo "configure:1533: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CXX'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1579,7 +1565,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1583: checking for $ac_word" >&5
+echo "configure:1569: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CXX'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1611,7 +1597,7 @@ test -n "$CXX" || CXX="gcc"
 
 
 echo $ac_n "checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) works""... $ac_c" 1>&6
-echo "configure:1615: checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) works" >&5
+echo "configure:1601: checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) works" >&5
 
 ac_ext=C
 # CXXFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
@@ -1622,12 +1608,12 @@ cross_compiling=$ac_cv_prog_cxx_cross
 
 cat > conftest.$ac_ext << EOF
 
-#line 1626 "configure"
+#line 1612 "configure"
 #include "confdefs.h"
 
 int main(){return(0);}
 EOF
-if { (eval echo configure:1631: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1617: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   ac_cv_prog_cxx_works=yes
   # If we can't run a trivial program, we are probably using a cross compiler.
   if (./conftest; exit) 2>/dev/null; then
@@ -1653,12 +1639,12 @@ if test $ac_cv_prog_cxx_works = no; then
   { echo "configure: error: installation or configuration problem: C++ compiler cannot create executables." 1>&2; exit 1; }
 fi
 echo $ac_n "checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
-echo "configure:1657: checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "configure:1643: checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) is a cross-compiler" >&5
 echo "$ac_t""$ac_cv_prog_cxx_cross" 1>&6
 cross_compiling=$ac_cv_prog_cxx_cross
 
 echo $ac_n "checking whether we are using GNU C++""... $ac_c" 1>&6
-echo "configure:1662: checking whether we are using GNU C++" >&5
+echo "configure:1648: checking whether we are using GNU C++" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gxx'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1667,7 +1653,7 @@ else
   yes;
 #endif
 EOF
-if { ac_try='${CXX-g++} -E conftest.C'; { (eval echo configure:1671: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+if { ac_try='${CXX-g++} -E conftest.C'; { (eval echo configure:1657: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
   ac_cv_prog_gxx=yes
 else
   ac_cv_prog_gxx=no
@@ -1686,7 +1672,7 @@ ac_test_CXXFLAGS="${CXXFLAGS+set}"
 ac_save_CXXFLAGS="$CXXFLAGS"
 CXXFLAGS=
 echo $ac_n "checking whether ${CXX-g++} accepts -g""... $ac_c" 1>&6
-echo "configure:1690: checking whether ${CXX-g++} accepts -g" >&5
+echo "configure:1676: checking whether ${CXX-g++} accepts -g" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_cxx_g'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1717,63 +1703,20 @@ else
   fi
 fi
 
-for ac_declaration in \
-   ''\
-   '#include <stdlib.h>' \
-   'extern "C" void std::exit (int) throw (); using std::exit;' \
-   'extern "C" void std::exit (int); using std::exit;' \
-   'extern "C" void exit (int) throw ();' \
-   'extern "C" void exit (int);' \
-   'void exit (int);'
-do
-  cat > conftest.$ac_ext <<EOF
-#line 1731 "configure"
-#include "confdefs.h"
-#include <stdlib.h>
-$ac_declaration
-int main() {
-exit (42);
-; return 0; }
-EOF
-if { (eval echo configure:1739: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
-  :
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  continue
-fi
-rm -f conftest*
-  cat > conftest.$ac_ext <<EOF
-#line 1749 "configure"
-#include "confdefs.h"
-$ac_declaration
-int main() {
-exit (42);
-; return 0; }
-EOF
-if { (eval echo configure:1756: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
-  rm -rf conftest*
-  break
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-fi
-rm -f conftest*
-done
-if test -n "$ac_declaration"; then
-  echo '#ifdef __cplusplus' >>confdefs.h
-  echo $ac_declaration      >>confdefs.h
-  echo '#endif'             >>confdefs.h
-fi
 
+    case "$build:$target" in
+      powerpc-apple-darwin8*:i?86-apple-darwin*)
+                                CFLAGS=$_SAVE_CFLAGS
+        CXXFLAGS=$_SAVE_CXXFLAGS
+        ;;
+    esac
 
     for ac_prog in $RANLIB "${target_alias}-ranlib" "${target}-ranlib"
 do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1777: checking for $ac_word" >&5
+echo "configure:1720: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1808,7 +1751,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1812: checking for $ac_word" >&5
+echo "configure:1755: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_AR'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1843,7 +1786,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1847: checking for $ac_word" >&5
+echo "configure:1790: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_AS'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1878,7 +1821,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1882: checking for $ac_word" >&5
+echo "configure:1825: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_LD'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1913,7 +1856,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1917: checking for $ac_word" >&5
+echo "configure:1860: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_STRIP'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1948,7 +1891,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1952: checking for $ac_word" >&5
+echo "configure:1895: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_WINDRES'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1985,7 +1928,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1989: checking for $ac_word" >&5
+echo "configure:1932: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CXX'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2017,7 +1960,7 @@ test -n "$CXX" || CXX="gcc"
 
 
 echo $ac_n "checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) works""... $ac_c" 1>&6
-echo "configure:2021: checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) works" >&5
+echo "configure:1964: checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) works" >&5
 
 ac_ext=C
 # CXXFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
@@ -2028,12 +1971,12 @@ cross_compiling=$ac_cv_prog_cxx_cross
 
 cat > conftest.$ac_ext << EOF
 
-#line 2032 "configure"
+#line 1975 "configure"
 #include "confdefs.h"
 
 int main(){return(0);}
 EOF
-if { (eval echo configure:2037: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1980: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   ac_cv_prog_cxx_works=yes
   # If we can't run a trivial program, we are probably using a cross compiler.
   if (./conftest; exit) 2>/dev/null; then
@@ -2059,12 +2002,12 @@ if test $ac_cv_prog_cxx_works = no; then
   { echo "configure: error: installation or configuration problem: C++ compiler cannot create executables." 1>&2; exit 1; }
 fi
 echo $ac_n "checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
-echo "configure:2063: checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "configure:2006: checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) is a cross-compiler" >&5
 echo "$ac_t""$ac_cv_prog_cxx_cross" 1>&6
 cross_compiling=$ac_cv_prog_cxx_cross
 
 echo $ac_n "checking whether we are using GNU C++""... $ac_c" 1>&6
-echo "configure:2068: checking whether we are using GNU C++" >&5
+echo "configure:2011: checking whether we are using GNU C++" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gxx'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2073,7 +2016,7 @@ else
   yes;
 #endif
 EOF
-if { ac_try='${CXX-g++} -E conftest.C'; { (eval echo configure:2077: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+if { ac_try='${CXX-g++} -E conftest.C'; { (eval echo configure:2020: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
   ac_cv_prog_gxx=yes
 else
   ac_cv_prog_gxx=no
@@ -2092,7 +2035,7 @@ ac_test_CXXFLAGS="${CXXFLAGS+set}"
 ac_save_CXXFLAGS="$CXXFLAGS"
 CXXFLAGS=
 echo $ac_n "checking whether ${CXX-g++} accepts -g""... $ac_c" 1>&6
-echo "configure:2096: checking whether ${CXX-g++} accepts -g" >&5
+echo "configure:2039: checking whether ${CXX-g++} accepts -g" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_cxx_g'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2123,64 +2066,13 @@ else
   fi
 fi
 
-for ac_declaration in \
-   ''\
-   '#include <stdlib.h>' \
-   'extern "C" void std::exit (int) throw (); using std::exit;' \
-   'extern "C" void std::exit (int); using std::exit;' \
-   'extern "C" void exit (int) throw ();' \
-   'extern "C" void exit (int);' \
-   'void exit (int);'
-do
-  cat > conftest.$ac_ext <<EOF
-#line 2137 "configure"
-#include "confdefs.h"
-#include <stdlib.h>
-$ac_declaration
-int main() {
-exit (42);
-; return 0; }
-EOF
-if { (eval echo configure:2145: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
-  :
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  continue
-fi
-rm -f conftest*
-  cat > conftest.$ac_ext <<EOF
-#line 2155 "configure"
-#include "confdefs.h"
-$ac_declaration
-int main() {
-exit (42);
-; return 0; }
-EOF
-if { (eval echo configure:2162: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
-  rm -rf conftest*
-  break
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-fi
-rm -f conftest*
-done
-if test -n "$ac_declaration"; then
-  echo '#ifdef __cplusplus' >>confdefs.h
-  echo $ac_declaration      >>confdefs.h
-  echo '#endif'             >>confdefs.h
-fi
-
-
     if test "$CXX" = "cl" -a -z "$CC"; then
         CC=$CXX
     else        
         # Extract the first word of "gcc", so it can be a program name with args.
 set dummy gcc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2184: checking for $ac_word" >&5
+echo "configure:2076: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2210,7 +2102,7 @@ if test -z "$CC"; then
   # Extract the first word of "cc", so it can be a program name with args.
 set dummy cc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2214: checking for $ac_word" >&5
+echo "configure:2106: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2261,7 +2153,7 @@ fi
       # Extract the first word of "cl", so it can be a program name with args.
 set dummy cl; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2265: checking for $ac_word" >&5
+echo "configure:2157: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2293,7 +2185,7 @@ fi
 fi
 
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
-echo "configure:2297: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
+echo "configure:2189: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
 
 ac_ext=c
 # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
@@ -2304,12 +2196,12 @@ cross_compiling=$ac_cv_prog_cc_cross
 
 cat > conftest.$ac_ext << EOF
 
-#line 2308 "configure"
+#line 2200 "configure"
 #include "confdefs.h"
 
 main(){return(0);}
 EOF
-if { (eval echo configure:2313: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2205: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   ac_cv_prog_cc_works=yes
   # If we can't run a trivial program, we are probably using a cross compiler.
   if (./conftest; exit) 2>/dev/null; then
@@ -2335,12 +2227,12 @@ if test $ac_cv_prog_cc_works = no; then
   { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
 fi
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
-echo "configure:2339: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "configure:2231: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
 echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
 cross_compiling=$ac_cv_prog_cc_cross
 
 echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
-echo "configure:2344: checking whether we are using GNU C" >&5
+echo "configure:2236: checking whether we are using GNU C" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2349,7 +2241,7 @@ else
   yes;
 #endif
 EOF
-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:2353: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:2245: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
   ac_cv_prog_gcc=yes
 else
   ac_cv_prog_gcc=no
@@ -2368,7 +2260,7 @@ ac_test_CFLAGS="${CFLAGS+set}"
 ac_save_CFLAGS="$CFLAGS"
 CFLAGS=
 echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
-echo "configure:2372: checking whether ${CC-cc} accepts -g" >&5
+echo "configure:2264: checking whether ${CC-cc} accepts -g" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2401,7 +2293,7 @@ fi
 
     fi
     echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
-echo "configure:2405: checking how to run the C preprocessor" >&5
+echo "configure:2297: checking how to run the C preprocessor" >&5
 # On Suns, sometimes $CPP names a directory.
 if test -n "$CPP" && test -d "$CPP"; then
   CPP=
@@ -2416,13 +2308,13 @@ else
   # On the NeXT, cc -E runs the code through the compiler's parser,
   # not just through cpp.
   cat > conftest.$ac_ext <<EOF
-#line 2420 "configure"
+#line 2312 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2426: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2318: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   :
@@ -2433,13 +2325,13 @@ else
   rm -rf conftest*
   CPP="${CC-cc} -E -traditional-cpp"
   cat > conftest.$ac_ext <<EOF
-#line 2437 "configure"
+#line 2329 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2443: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2335: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   :
@@ -2450,13 +2342,13 @@ else
   rm -rf conftest*
   CPP="${CC-cc} -nologo -E"
   cat > conftest.$ac_ext <<EOF
-#line 2454 "configure"
+#line 2346 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2460: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2352: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   :
@@ -2483,7 +2375,7 @@ echo "$ac_t""$CPP" 1>&6
     # Extract the first word of "ranlib", so it can be a program name with args.
 set dummy ranlib; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2487: checking for $ac_word" >&5
+echo "configure:2379: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2515,7 +2407,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2519: checking for $ac_word" >&5
+echo "configure:2411: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_AS'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2556,7 +2448,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2560: checking for $ac_word" >&5
+echo "configure:2452: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_AR'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2597,7 +2489,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2601: checking for $ac_word" >&5
+echo "configure:2493: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_LD'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2638,7 +2530,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2642: checking for $ac_word" >&5
+echo "configure:2534: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_STRIP'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2679,7 +2571,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2683: checking for $ac_word" >&5
+echo "configure:2575: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_WINDRES'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2734,6 +2626,12 @@ if test "`echo | $AS -v 2>&1 | grep -c G
 fi
 rm -f a.out
 
+case "$build:$target" in
+    i?86-apple-darwin*:powerpc-apple-darwin*)
+                                cross_compiling=yes
+        ;;
+esac
+
 if test "$cross_compiling"  = "yes"; then
     CROSS_COMPILE=1
 else
@@ -2741,7 +2639,7 @@ else
 fi
 
 echo $ac_n "checking for gcc -pipe support""... $ac_c" 1>&6
-echo "configure:2745: checking for gcc -pipe support" >&5
+echo "configure:2643: checking for gcc -pipe support" >&5
 if test -n "$GNU_CC" && test -n "$GNU_CXX" && test -n "$GNU_AS"; then
     echo '#include <stdio.h>' > dummy-hello.c
     echo 'int main() { printf("Hello World\n"); exit(0); }' >> dummy-hello.c
@@ -2756,14 +2654,14 @@ if test -n "$GNU_CC" && test -n "$GNU_CX
         _SAVE_CFLAGS=$CFLAGS
         CFLAGS="$CFLAGS -pipe"
         cat > conftest.$ac_ext <<EOF
-#line 2760 "configure"
+#line 2658 "configure"
 #include "confdefs.h"
  #include <stdio.h> 
 int main() {
 printf("Hello World\n");
 ; return 0; }
 EOF
-if { (eval echo configure:2767: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2665: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   _res_gcc_pipe="yes"
 else
@@ -2796,7 +2694,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2800: checking for $ac_word" >&5
+echo "configure:2698: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_PERL'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2857,6 +2755,7 @@ if test -n "$CROSS_COMPILE"; then
         linux*)       OS_ARCH=Linux ;;
         solaris*)     OS_ARCH=SunOS OS_RELEASE=5 ;;
         mingw*)     OS_ARCH=WINNT ;;
+        darwin*)    OS_ARCH=Darwin ;;
     esac
 else
     OS_ARCH=`uname -s | sed -e 's|/|_|g'`
@@ -2998,6 +2897,13 @@ if test "$OS_TARGET" = "WIN16"; then
 fi
 OS_CONFIG="${OS_TARGET}${OS_RELEASE}"
 
+# Check whether --with-macos-sdk or --without-macos-sdk was given.
+if test "${with_macos_sdk+set}" = set; then
+  withval="$with_macos_sdk"
+  MACOS_SDK_DIR=$withval
+fi
+
+
 
 case "$host" in
 *-mingw*)
@@ -3040,17 +2946,17 @@ EOF
     DSO_LDOPTS='-brtl -bM:SRE -bnoentry -bexpall -blibpath:/usr/lib:/lib'
     ac_safe=`echo "sys/atomic_op.h" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for sys/atomic_op.h""... $ac_c" 1>&6
-echo "configure:3044: checking for sys/atomic_op.h" >&5
+echo "configure:2950: checking for sys/atomic_op.h" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3049 "configure"
+#line 2955 "configure"
 #include "confdefs.h"
 #include <sys/atomic_op.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:3054: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2960: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -3208,7 +3114,7 @@ EOF
         _DEBUG_FLAGS='-gdwarf-2 -O0'
         MKSHLIB='$(CCC) $(DSO_LDOPTS) -o $@'
         echo $ac_n "checking for gethostbyaddr in -lbind""... $ac_c" 1>&6
-echo "configure:3212: checking for gethostbyaddr in -lbind" >&5
+echo "configure:3118: checking for gethostbyaddr in -lbind" >&5
 ac_lib_var=`echo bind'_'gethostbyaddr | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -3216,7 +3122,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lbind  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3220 "configure"
+#line 3126 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3227,7 +3133,7 @@ int main() {
 gethostbyaddr()
 ; return 0; }
 EOF
-if { (eval echo configure:3231: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3137: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3408,28 +3314,81 @@ EOF
 EOF
 
     CFLAGS="$CFLAGS -Wmost -fno-common"
-    if echo $OS_TEST | grep -c 86 2>/dev/null; then
-        cat >> confdefs.h <<\EOF
+    case "${target_cpu}" in
+        i*86*)
+            cat >> confdefs.h <<\EOF
 #define i386 1
 EOF
 
-        CPU_ARCH=i386
-    else
-        cat >> confdefs.h <<\EOF
+            CPU_ARCH=i386
+            ;;
+        *)
+            cat >> confdefs.h <<\EOF
 #define ppc 1
 EOF
 
-        CPU_ARCH=ppc
-    fi
+            CPU_ARCH=ppc
+            ;;
+    esac
     DSO_LDOPTS='-dynamiclib -compatibility_version 1 -current_version 1 -all_load -install_name @executable_path/$@'
     # Use the standard preprocessor (cpp)
     CFLAGS="$CFLAGS -no-cpp-precomp"
-    MKSHLIB='$(CC) -arch $(CPU_ARCH) $(DSO_LDOPTS) -o $@'
+    MKSHLIB='$(CC) $(DSO_LDOPTS) -o $@'
     STRIP="$STRIP -x -S"
     DLL_SUFFIX=dylib
     USE_PTHREADS=1
     MDCPUCFG_H=_darwin.cfg
     PR_MD_CSRCS=darwin.c
+
+            
+    if test "$MACOS_SDK_DIR"; then
+                if test ! -d "$MACOS_SDK_DIR"; then
+            { echo "configure: error: SDK not found.  When using --with-macos-sdk, you must
+specify a valid SDK.  SDKs are installed when the optional cross-development
+tools are selected during the Xcode/Developer Tools installation." 1>&2; exit 1; }
+        fi
+
+        
+        CC_VERSION=`$CC -v 2>&1 | grep 'gcc version'`
+        GCC_VERSION_FULL=`echo $CC_VERSION | $PERL -pe 's/^.*gcc version ([^ ]*).*/$1/'`
+        GCC_VERSION=`echo $GCC_VERSION_FULL | $PERL -pe '(split(/\./))[0]>=4&&s/(^\d*\.\d*).*/$1/;'`
+        
+        GCC_VERSION_MAJOR=`echo $GCC_VERSION_FULL | $PERL -pe 's/(^\d*).*/$1/;'`
+        if test "$GCC_VERSION_MAJOR" -lt "4" ; then
+            SDK_C_FRAMEWORK="-F${MACOS_SDK_DIR}/System/Library/Frameworks"
+            if test -d "${MACOS_SDK_DIR}/Library/Frameworks" ; then
+                SDK_C_FRAMEWORK="$SDK_C_FRAMEWORK -F${MACOS_SDK_DIR}/Library/Frameworks"
+            fi
+
+            SDK_C_INCLUDE="-isystem ${MACOS_SDK_DIR}/usr/include/gcc/darwin/${GCC_VERSION} -isystem ${MACOS_SDK_DIR}/usr/include ${SDK_C_FRAMEWORK}"
+
+            CFLAGS="$CFLAGS -nostdinc ${SDK_C_INCLUDE}"
+
+                        CPP="$CPP -nostdinc ${SDK_C_INCLUDE}"
+
+                                                                                                                                    MACOS_SDK_LIBS="-L${MACOS_SDK_DIR}/usr/lib/gcc/darwin -L${MACOS_SDK_DIR}/usr/lib/gcc/darwin/${GCC_VERSION_FULL} -L${MACOS_SDK_DIR}/usr/lib ${SDK_C_FRAMEWORK}"
+            LDFLAGS="${MACOS_SDK_LIBS} $LDFLAGS"
+            DSO_LDOPTS="${MACOS_SDK_LIBS} $DSO_LDOPTS"
+            export NEXT_ROOT=$MACOS_SDK_DIR
+
+            if test -n "$CROSS_COMPILE" ; then
+                                                                HOST_CC="NEXT_ROOT= $HOST_CC"
+                HOST_CXX="NEXT_ROOT= $HOST_CXX"
+            fi
+        else
+                                    CFLAGS="$CFLAGS -isysroot ${MACOS_SDK_DIR}"
+
+                        CPP="$CPP -isysroot ${MACOS_SDK_DIR}"
+
+                                                                                                if test "$GCC_VERSION_FULL" != "4.0.0" ; then
+                                                LDFLAGS="$LDFLAGS -isysroot ${MACOS_SDK_DIR}"
+                DSO_LDOPTS="$DSO_LDOPTS -isysroot ${MACOS_SDK_DIR}"
+            else
+                                                LDFLAGS="$LDFLAGS -Wl,-syslibroot,${MACOS_SDK_DIR}"
+                DSO_LDOPTS="$DSO_LDOPTS -Wl,-syslibroot,${MACOS_SDK_DIR}"
+            fi
+        fi
+    fi
     ;;
 
 *-dgux*)
@@ -3976,8 +3935,8 @@ EOF
         fi
 
         if test -n "$MOZ_DEBUG"; then
-            DLLFLAGS="$DLLFLAGS -DEBUG -DEBUGTYPE:CV"
-            LDFLAGS="$LDFLAGS -DEBUG -DEBUGTYPE:CV"
+            DLLFLAGS="$DLLFLAGS -DEBUG"
+            LDFLAGS="$LDFLAGS -DEBUG"
         fi
         
         if test "$OS_TARGET" = "WINNT"; then
@@ -4445,17 +4404,17 @@ EOF
 
     ac_safe=`echo "machine/builtins.h" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for machine/builtins.h""... $ac_c" 1>&6
-echo "configure:4449: checking for machine/builtins.h" >&5
+echo "configure:4408: checking for machine/builtins.h" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4454 "configure"
+#line 4413 "configure"
 #include "confdefs.h"
 #include <machine/builtins.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:4459: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:4418: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -4853,12 +4812,12 @@ esac
 if test -z "$SKIP_LIBRARY_CHECKS"; then
 
 echo $ac_n "checking for dlopen""... $ac_c" 1>&6
-echo "configure:4857: checking for dlopen" >&5
+echo "configure:4816: checking for dlopen" >&5
 if eval "test \"`echo '$''{'ac_cv_func_dlopen'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4862 "configure"
+#line 4821 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char dlopen(); below.  */
@@ -4881,7 +4840,7 @@ dlopen();
 
 ; return 0; }
 EOF
-if { (eval echo configure:4885: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4844: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_dlopen=yes"
 else
@@ -4900,7 +4859,7 @@ else
   echo "$ac_t""no" 1>&6
 
     echo $ac_n "checking for dlopen in -ldl""... $ac_c" 1>&6
-echo "configure:4904: checking for dlopen in -ldl" >&5
+echo "configure:4863: checking for dlopen in -ldl" >&5
 ac_lib_var=`echo dl'_'dlopen | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -4908,7 +4867,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-ldl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 4912 "configure"
+#line 4871 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -4919,7 +4878,7 @@ int main() {
 dlopen()
 ; return 0; }
 EOF
-if { (eval echo configure:4923: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4882: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -4947,13 +4906,13 @@ fi
 
 if test $ac_cv_prog_gcc = yes; then
     echo $ac_n "checking whether ${CC-cc} needs -traditional""... $ac_c" 1>&6
-echo "configure:4951: checking whether ${CC-cc} needs -traditional" >&5
+echo "configure:4910: checking whether ${CC-cc} needs -traditional" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gcc_traditional'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
     ac_pattern="Autoconf.*'x'"
   cat > conftest.$ac_ext <<EOF
-#line 4957 "configure"
+#line 4916 "configure"
 #include "confdefs.h"
 #include <sgtty.h>
 Autoconf TIOCGETP
@@ -4971,7 +4930,7 @@ rm -f conftest*
 
   if test $ac_cv_prog_gcc_traditional = no; then
     cat > conftest.$ac_ext <<EOF
-#line 4975 "configure"
+#line 4934 "configure"
 #include "confdefs.h"
 #include <termio.h>
 Autoconf TCGETA
@@ -4995,12 +4954,12 @@ fi
 for ac_func in lchown strerror
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:4999: checking for $ac_func" >&5
+echo "configure:4958: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5004 "configure"
+#line 4963 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -5023,7 +4982,7 @@ $ac_func();
 
 ; return 0; }
 EOF
-if { (eval echo configure:5027: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4986: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -5061,7 +5020,7 @@ fi
 
 
 echo $ac_n "checking for pthread_create in -lpthreads""... $ac_c" 1>&6
-echo "configure:5065: checking for pthread_create in -lpthreads" >&5
+echo "configure:5024: checking for pthread_create in -lpthreads" >&5
 echo "
     #include <pthread.h> 
     void *foo(void *v) { int a = 1;  } 
@@ -5083,7 +5042,7 @@ echo "
         echo "$ac_t""no" 1>&6
         
 echo $ac_n "checking for pthread_create in -lpthread""... $ac_c" 1>&6
-echo "configure:5087: checking for pthread_create in -lpthread" >&5
+echo "configure:5046: checking for pthread_create in -lpthread" >&5
 echo "
     #include <pthread.h> 
     void *foo(void *v) { int a = 1;  } 
@@ -5105,7 +5064,7 @@ echo "
         echo "$ac_t""no" 1>&6
         
 echo $ac_n "checking for pthread_create in -lc_r""... $ac_c" 1>&6
-echo "configure:5109: checking for pthread_create in -lc_r" >&5
+echo "configure:5068: checking for pthread_create in -lc_r" >&5
 echo "
     #include <pthread.h> 
     void *foo(void *v) { int a = 1;  } 
@@ -5127,7 +5086,7 @@ echo "
         echo "$ac_t""no" 1>&6
         
 echo $ac_n "checking for pthread_create in -lc""... $ac_c" 1>&6
-echo "configure:5131: checking for pthread_create in -lc" >&5
+echo "configure:5090: checking for pthread_create in -lc" >&5
 echo "
     #include <pthread.h> 
     void *foo(void *v) { int a = 1;  } 
@@ -5277,7 +5236,7 @@ if test -n "$USE_PTHREADS"; then
       rm -f conftest*
    ac_cv_have_dash_pthread=no
    echo $ac_n "checking whether ${CC-cc} accepts -pthread""... $ac_c" 1>&6
-echo "configure:5281: checking whether ${CC-cc} accepts -pthread" >&5
+echo "configure:5240: checking whether ${CC-cc} accepts -pthread" >&5
    echo 'int main() { return 0; }' | cat > conftest.c
    ${CC-cc} -pthread -o conftest conftest.c > conftest.out 2>&1
    if test $? -eq 0; then
@@ -5293,7 +5252,7 @@ echo "configure:5281: checking whether $
 			    ac_cv_have_dash_pthreads=no
     if test "$ac_cv_have_dash_pthread" = "no"; then
 	    echo $ac_n "checking whether ${CC-cc} accepts -pthreads""... $ac_c" 1>&6
-echo "configure:5297: checking whether ${CC-cc} accepts -pthreads" >&5
+echo "configure:5256: checking whether ${CC-cc} accepts -pthreads" >&5
     	echo 'int main() { return 0; }' | cat > conftest.c
 	    ${CC-cc} -pthreads -o conftest conftest.c > conftest.out 2>&1
     	if test $? -eq 0; then
@@ -5658,6 +5617,7 @@ esac
 
 
 
+
 MAKEFILES="
 Makefile
 config/Makefile
@@ -5744,34 +5704,15 @@ trap 'rm -f $CONFIG_STATUS conftest*; ex
 # Transform confdefs.h into DEFS.
 # Protect against shell expansion while executing Makefile rules.
 # Protect against Makefile macro expansion.
-#
-# If the first sed substitution is executed (which looks for macros that
-# take arguments), then we branch to the quote section.  Otherwise,
-# look for a macro that doesn't take arguments.
-cat >confdef2opt.sed <<\_ACEOF
-t clear
-: clear
-s,^[ 	]*#[ 	]*define[ 	][ 	]*\([^ 	(][^ 	(]*([^)]*)\)[ 	]*\(.*\),-D\1=\2,g
-t quote
-s,^[ 	]*#[ 	]*define[ 	][ 	]*\([^ 	][^ 	]*\)[ 	]*\(.*\),-D\1=\2,g
-t quote
-d
-: quote
-s,[ 	`~#$^&*(){}\\|;'"<>?],\\&,g
-s,\[,\\&,g
-s,\],\\&,g
-s,\$,$$,g
-p
-_ACEOF
-# We use echo to avoid assuming a particular line-breaking character.
-# The extra dot is to prevent the shell from consuming trailing
-# line-breaks from the sub-command output.  A line-break within
-# single-quotes doesn't work because, if this script is created in a
-# platform that uses two characters for line-breaks (e.g., DOS), tr
-# would break.
-ac_LF_and_DOT=`echo; echo .`
-DEFS=`sed -n -f confdef2opt.sed confdefs.h | tr "$ac_LF_and_DOT" ' .'`
-rm -f confdef2opt.sed
+cat > conftest.defs <<\EOF
+s%#define \([A-Za-z_][A-Za-z0-9_]*\) *\(.*\)%-D\1=\2%g
+s%[ 	`~#$^&*(){}\\|;'"<>?]%\\&%g
+s%\[%\\&%g
+s%\]%\\&%g
+s%\$%$$%g
+EOF
+DEFS=`sed -f conftest.defs confdefs.h | tr '\012' ' '`
+rm -f conftest.defs
 
 
 # Without the "./", some shells look in PATH for config.status.
@@ -5935,6 +5876,7 @@ s%@EXEFLAGS@%$EXEFLAGS%g
 s%@OS_DLLFLAGS@%$OS_DLLFLAGS%g
 s%@CYGWIN_WRAPPER@%$CYGWIN_WRAPPER%g
 s%@WIN_TOP_SRC@%$WIN_TOP_SRC%g
+s%@NEXT_ROOT@%$NEXT_ROOT%g
 
 CEOF
 EOF
diff -uprN --exclude=CVS mozilla/directory/c-sdk/configure.in mozilla.new/directory/c-sdk/configure.in
--- mozilla/directory/c-sdk/configure.in	2005-06-14 23:27:33.000000000 +0200
+++ mozilla.new/directory/c-sdk/configure.in	2006-02-24 11:15:31.000000000 +0100
@@ -401,25 +401,41 @@ if test "$target" != "$host"; then
 	    HOST_LDFLAGS="$LDFLAGS"
     fi
 
-    CC="$HOST_CC"
-    CFLAGS="$HOST_CFLAGS"
-    LDFLAGS="$HOST_LDFLAGS"
-
-    AC_MSG_CHECKING([whether the $host compiler ($HOST_CC $HOST_CFLAGS $HOST_LDFLAGS) works])
-    AC_TRY_COMPILE([], [return(0);], 
-	[ac_cv_prog_host_cc_works=1 AC_MSG_RESULT([yes])],
-	AC_MSG_ERROR([installation or configuration problem: $host compiler $HOST_CC cannot create executables.]) )
-    
     CC=$_SAVE_CC
     CFLAGS=$_SAVE_CFLAGS
     LDFLAGS=$_SAVE_LDFLAGS
 
+    case "$build:$target" in 
+      powerpc-apple-darwin8*:i?86-apple-darwin*)
+        dnl The Darwin cross compiler doesn't necessarily point itself at a
+        dnl root that has libraries for the proper architecture, it defaults
+        dnl to the system root.  The libraries in the system root on current
+        dnl versions of PPC OS X 10.4 aren't fat, so these target compiler
+        dnl checks will fail.  Fake a working SDK in that case.
+        _SAVE_CFLAGS=$CFLAGS 
+        _SAVE_CXXFLAGS=$CXXLAGS
+        CFLAGS="-isysroot /Developer/SDKs/MacOSX10.4u.sdk $CFLAGS"
+        CXXFLAGS="-isysroot /Developer/SDKs/MacOSX10.4u.sdk $CXXFLAGS"
+        ;;        
+    esac            
+
     AC_CHECK_PROGS(CC, $CC "${target_alias}-gcc" "${target}-gcc", echo)
     unset ac_cv_prog_CC
     AC_PROG_CC
     AC_CHECK_PROGS(CXX, $CXX "${target_alias}-g++" "${target}-g++", echo)
     unset ac_cv_prog_CXX
     AC_PROG_CXX
+
+    case "$build:$target" in
+      powerpc-apple-darwin8*:i?86-apple-darwin*)
+        dnl Revert the changes made above.  From this point on, the target
+        dnl compiler will never be used without applying the SDK to CFLAGS
+        dnl (see --with-macos-sdk below).
+        CFLAGS=$_SAVE_CFLAGS
+        CXXFLAGS=$_SAVE_CXXFLAGS
+        ;;
+    esac
+
     AC_CHECK_PROGS(RANLIB, $RANLIB "${target_alias}-ranlib" "${target}-ranlib", echo)
     AC_CHECK_PROGS(AR, $AR "${target_alias}-ar" "${target}-ar", echo)
     AC_CHECK_PROGS(AS, $AS "${target_alias}-as" "${target}-as", echo)
@@ -460,6 +476,15 @@ if test "`echo | $AS -v 2>&1 | grep -c G
 fi
 rm -f a.out
 
+case "$build:$target" in
+    i?86-apple-darwin*:powerpc-apple-darwin*)
+        dnl cross_compiling will have erroneously been set to "no" in this
+        dnl case, because the x86 build host is able to run ppc code in a
+        dnl translated environment, making a cross compiler appear native.
+        cross_compiling=yes
+        ;;
+esac
+
 if test "$cross_compiling"  = "yes"; then
     CROSS_COMPILE=1
 else
@@ -537,6 +562,7 @@ if test -n "$CROSS_COMPILE"; then
         linux*)       OS_ARCH=Linux ;;
         solaris*)     OS_ARCH=SunOS OS_RELEASE=5 ;;
         mingw*)     OS_ARCH=WINNT ;;
+        darwin*)    OS_ARCH=Darwin ;;
     esac
 else
     OS_ARCH=`uname -s | sed -e 's|/|_|g'`
@@ -679,6 +705,13 @@ fi
 OS_CONFIG="${OS_TARGET}${OS_RELEASE}"
 
 dnl ========================================================
+dnl = Mac OS X SDK support
+dnl ========================================================
+AC_ARG_WITH(macos-sdk,
+    [  --with-macos-sdk=dir    Location of platform SDK to use (Mac OS X only)],
+    MACOS_SDK_DIR=$withval)
+
+dnl ========================================================
 
 dnl ========================================================
 dnl Override of system specific host options
@@ -874,22 +907,107 @@ case "$target" in
     AC_DEFINE(DARWIN)
     AC_DEFINE(HAVE_BSD_FLOCK)
     CFLAGS="$CFLAGS -Wmost -fno-common"
-    if echo $OS_TEST | grep -c 86 2>/dev/null; then
-        AC_DEFINE(i386)
-        CPU_ARCH=i386
-    else
-        AC_DEFINE(ppc)
-        CPU_ARCH=ppc
-    fi
+    case "${target_cpu}" in
+        i*86*)
+            AC_DEFINE(i386)
+            CPU_ARCH=i386
+            ;;
+        *)
+            AC_DEFINE(ppc)
+            CPU_ARCH=ppc
+            ;;
+    esac
     DSO_LDOPTS='-dynamiclib -compatibility_version 1 -current_version 1 -all_load -install_name @executable_path/$@'
     # Use the standard preprocessor (cpp)
     CFLAGS="$CFLAGS -no-cpp-precomp"
-    MKSHLIB='$(CC) -arch $(CPU_ARCH) $(DSO_LDOPTS) -o $@'
+    MKSHLIB='$(CC) $(DSO_LDOPTS) -o $@'
     STRIP="$STRIP -x -S"
     DLL_SUFFIX=dylib
     USE_PTHREADS=1
     MDCPUCFG_H=_darwin.cfg
     PR_MD_CSRCS=darwin.c
+
+    dnl MACOS_SDK_DIR will be set to the SDK location whenever one is
+    dnl in use.  NEXT_ROOT will be set and exported if it's needed for
+    dnl ld.
+
+    if test "$MACOS_SDK_DIR"; then
+        dnl Sync this section with the one in Mozilla's top level.
+        if test ! -d "$MACOS_SDK_DIR"; then
+            AC_MSG_ERROR([SDK not found.  When using --with-macos-sdk, you must
+specify a valid SDK.  SDKs are installed when the optional cross-development
+tools are selected during the Xcode/Developer Tools installation.])
+        fi
+
+        changequote(,)
+        CC_VERSION=`$CC -v 2>&1 | grep 'gcc version'`
+        GCC_VERSION_FULL=`echo $CC_VERSION | $PERL -pe 's/^.*gcc version ([^ ]*).*/$1/'`
+        GCC_VERSION=`echo $GCC_VERSION_FULL | $PERL -pe '(split(/\./))[0]>=4&&s/(^\d*\.\d*).*/$1/;'`
+        changequote([,])
+        GCC_VERSION_MAJOR=`echo $GCC_VERSION_FULL | $PERL -pe 's/(^\d*).*/$1/;'`
+        if test "$GCC_VERSION_MAJOR" -lt "4" ; then
+            SDK_C_FRAMEWORK="-F${MACOS_SDK_DIR}/System/Library/Frameworks"
+            if test -d "${MACOS_SDK_DIR}/Library/Frameworks" ; then
+                SDK_C_FRAMEWORK="$SDK_C_FRAMEWORK -F${MACOS_SDK_DIR}/Library/Frameworks"
+            fi
+
+            SDK_C_INCLUDE="-isystem ${MACOS_SDK_DIR}/usr/include/gcc/darwin/${GCC_VERSION} -isystem ${MACOS_SDK_DIR}/usr/include ${SDK_C_FRAMEWORK}"
+
+            CFLAGS="$CFLAGS -nostdinc ${SDK_C_INCLUDE}"
+
+            dnl CPP needs to be set for AC_CHECK_HEADER.
+            CPP="$CPP -nostdinc ${SDK_C_INCLUDE}"
+
+            dnl ld support for -syslibroot is compiler-agnostic, but only
+            dnl available on Tiger.  Although it's possible to switch on
+            dnl the build host's OS release to use ld -syslibroot when
+            dnl available, ld -syslibroot cause warnings as long as
+            dnl NEXT_ROOT is set.  NEXT_ROOT should be set because both
+            dnl both the compiler and linker use it.
+            dnl
+            dnl LDFLAGS is for the utilities built in config (now and
+            dnl nsinstall).  DSO_LDOPTS is used when linking shared
+            dnl libraries.
+            MACOS_SDK_LIBS="-L${MACOS_SDK_DIR}/usr/lib/gcc/darwin -L${MACOS_SDK_DIR}/usr/lib/gcc/darwin/${GCC_VERSION_FULL} -L${MACOS_SDK_DIR}/usr/lib ${SDK_C_FRAMEWORK}"
+            LDFLAGS="${MACOS_SDK_LIBS} $LDFLAGS"
+            DSO_LDOPTS="${MACOS_SDK_LIBS} $DSO_LDOPTS"
+            export NEXT_ROOT=$MACOS_SDK_DIR
+
+            if test -n "$CROSS_COMPILE" ; then
+                dnl NEXT_ROOT will be in the environment, but it
+                dnl shouldn't be set for the build host.  HOST_CXX is
+                dnl presently unused.
+                HOST_CC="NEXT_ROOT= $HOST_CC"
+                HOST_CXX="NEXT_ROOT= $HOST_CXX"
+            fi
+        else
+            dnl gcc >= 4.0 uses different paths than above, but knows
+            dnl how to find them itself.
+            CFLAGS="$CFLAGS -isysroot ${MACOS_SDK_DIR}"
+
+            dnl CPP needs to be set for AC_CHECK_HEADER.
+            CPP="$CPP -isysroot ${MACOS_SDK_DIR}"
+
+            dnl If gcc >= 4.0.0, we're guaranteed to be on Tiger, which
+            dnl has an ld that supports -syslibroot.  Don't set
+            dnl NEXT_ROOT because it will be ignored and cause
+            dnl warnings when -syslibroot is specified.
+            dnl
+            dnl Both LDFLAGS and DSO_LDOPTS are set here, see the
+            dnl gcc < 4.0 case for the explanation.
+            if test "$GCC_VERSION_FULL" != "4.0.0" ; then
+                dnl gcc > 4.0.0 will pass -syslibroot to ld automatically
+                dnl based on the -isysroot it receives.
+                LDFLAGS="$LDFLAGS -isysroot ${MACOS_SDK_DIR}"
+                DSO_LDOPTS="$DSO_LDOPTS -isysroot ${MACOS_SDK_DIR}"
+            else
+                dnl gcc 4.0.0 doesn't pass -syslibroot to ld, it needs
+                dnl to be explicit.
+                LDFLAGS="$LDFLAGS -Wl,-syslibroot,${MACOS_SDK_DIR}"
+                DSO_LDOPTS="$DSO_LDOPTS -Wl,-syslibroot,${MACOS_SDK_DIR}"
+            fi
+        fi
+    fi
     ;;
 
 *-dgux*)
@@ -2335,6 +2453,7 @@ AC_SUBST(EXEFLAGS)
 AC_SUBST(OS_DLLFLAGS)
 AC_SUBST(CYGWIN_WRAPPER)
 AC_SUBST(WIN_TOP_SRC)
+AC_SUBST(NEXT_ROOT)
 
 dnl ========================================================
 dnl Generate output files.
diff -uprN --exclude=CVS mozilla/directory/xpcom/base/src/nsLDAPProtocolHandler.cpp mozilla.new/directory/xpcom/base/src/nsLDAPProtocolHandler.cpp
--- mozilla/directory/xpcom/base/src/nsLDAPProtocolHandler.cpp	2004-04-25 23:07:12.000000000 +0200
+++ mozilla.new/directory/xpcom/base/src/nsLDAPProtocolHandler.cpp	2006-02-24 11:16:21.000000000 +0100
@@ -118,6 +118,7 @@ NS_IMETHODIMP
 nsLDAPProtocolHandler::NewChannel(nsIURI* uri, 
                                   nsIChannel* *result)
 {
+    NS_ENSURE_ARG_POINTER(uri);
     nsresult rv;
     nsLDAPChannel *channel;
 
diff -uprN --exclude=CVS mozilla/docshell/base/nsDocShell.cpp mozilla.new/docshell/base/nsDocShell.cpp
--- mozilla/docshell/base/nsDocShell.cpp	2006-01-11 23:04:33.000000000 +0100
+++ mozilla.new/docshell/base/nsDocShell.cpp	2006-02-24 11:16:27.000000000 +0100
@@ -40,6 +40,11 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
+#ifdef MOZ_LOGGING
+// so we can get logging even in release builds (but only for some things)
+#define FORCE_PR_LOG 1
+#endif
+
 #include "nsIBrowserDOMWindow.h"
 #include "nsIComponentManager.h"
 #include "nsIContent.h"
@@ -202,8 +207,11 @@ static PRBool gValidateOrigin = (PRBool)
 #define NS_ERROR_DOCUMENT_IS_PRINTMODE  NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_GENERAL,2001)
 
 #ifdef PR_LOGGING
+#ifdef DEBUG
 static PRLogModuleInfo* gDocShellLog;
 #endif
+static PRLogModuleInfo* gDocShellLeakLog;
+#endif
 
 //*****************************************************************************
 //***    nsDocShellFocusController
@@ -274,9 +282,15 @@ nsDocShell::nsDocShell():
     }
 
 #ifdef PR_LOGGING
+#ifdef DEBUG
     if (! gDocShellLog)
         gDocShellLog = PR_NewLogModule("nsDocShell");
 #endif
+    if (nsnull == gDocShellLeakLog)
+        gDocShellLeakLog = PR_NewLogModule("nsDocShellLeak");
+    if (gDocShellLeakLog)
+        PR_LOG(gDocShellLeakLog, PR_LOG_DEBUG, ("DOCSHELL %p created\n", this));
+#endif
 }
 
 nsDocShell::~nsDocShell()
@@ -290,6 +304,11 @@ nsDocShell::~nsDocShell()
     if (--gDocShellCount == 0) {
         NS_IF_RELEASE(sURIFixup);
     }
+
+#ifdef PR_LOGGING
+    if (gDocShellLeakLog)
+        PR_LOG(gDocShellLeakLog, PR_LOG_DEBUG, ("DOCSHELL %p destroyed\n", this));
+#endif
 }
 
 nsresult
@@ -628,7 +647,7 @@ nsDocShell::LoadURI(nsIURI * aURI,
         aLoadInfo->GetSendReferrer(&sendReferrer);
     }
 
-#ifdef PR_LOGGING
+#if defined(PR_LOGGING) && defined(DEBUG)
     if (PR_LOG_TEST(gDocShellLog, PR_LOG_DEBUG)) {
         nsCAutoString uristr;
         aURI->GetAsciiSpec(uristr);
@@ -733,8 +752,10 @@ nsDocShell::LoadURI(nsIURI * aURI,
     } // !shEntry
 
     if (shEntry) {
+#ifdef DEBUG
         PR_LOG(gDocShellLog, PR_LOG_DEBUG,
               ("nsDocShell[%p]: loading from session history", this));
+#endif
 
         rv = LoadHistoryEntry(shEntry, loadType);
     }
@@ -1162,10 +1183,27 @@ nsresult nsDocShell::FindTarget(const PR
                 name.LowerCaseEqualsLiteral("_new")) {
                 name.Truncate();
             }
+
+            // Push a null JSContext on the JSContext stack.  We don't want
+            // this search by name to use random stuff from the stack as the
+            // "caller" -- we're the caller.
+            nsCOMPtr<nsIJSContextStack> stack =
+                do_GetService("@mozilla.org/js/xpc/ContextStack;1");
+            if (stack) {
+                rv = stack->Push(nsnull);
+                NS_ENSURE_SUCCESS(rv, rv);
+            }
+            
             rv = parentWindow->Open(EmptyString(),          // URL to load
                                     name,                   // Window name
                                     EmptyString(),          // Window features
                                     getter_AddRefs(newWindow));
+
+            if (stack) {
+                JSContext* cx;
+                stack->Pop(&cx);
+                NS_ASSERTION(!cx, "Unexpected JSContext popped!");
+            }
         }
         if (NS_FAILED(rv)) return rv;
 
@@ -1348,6 +1386,15 @@ PRBool
 nsDocShell::SetCurrentURI(nsIURI *aURI, nsIRequest *aRequest,
                           PRBool aFireOnLocationChange)
 {
+#ifdef PR_LOGGING
+    if (gDocShellLeakLog && PR_LOG_TEST(gDocShellLeakLog, PR_LOG_DEBUG)) {
+        nsCAutoString spec;
+        if (aURI)
+            aURI->GetSpec(spec);
+        PR_LogPrint("DOCSHELL %p SetCurrentURI %s\n", this, spec.get());
+    }
+#endif
+
     // We don't want to send a location change when we're displaying an error
     // page, and we don't want to change our idea of "current URI" either
     if (mLoadType == LOAD_ERROR_PAGE) {
@@ -3058,7 +3105,7 @@ nsDocShell::LoadErrorPage(nsIURI *aURI, 
                           const PRUnichar *aDescription,
                           nsIChannel* aFailedChannel)
 {
-#ifdef PR_LOGGING
+#if defined(PR_LOGGING) && defined(DEBUG)
     if (PR_LOG_TEST(gDocShellLog, PR_LOG_DEBUG)) {
         nsCAutoString spec;
         aURI->GetSpec(spec);
@@ -6156,6 +6203,15 @@ nsDocShell::InternalLoad(nsIURI * aURI,
                          nsIRequest** aRequest)
 {
     nsresult rv = NS_OK;
+
+#ifdef PR_LOGGING
+    if (gDocShellLeakLog && PR_LOG_TEST(gDocShellLeakLog, PR_LOG_DEBUG)) {
+        nsCAutoString spec;
+        if (aURI)
+            aURI->GetSpec(spec);
+        PR_LogPrint("DOCSHELL %p InternalLoad %s\n", this, spec.get());
+    }
+#endif
     
     // Initialize aDocShell/aRequest
     if (aDocShell) {
@@ -7192,7 +7248,7 @@ nsDocShell::OnNewURI(nsIURI * aURI, nsIC
                      PRBool aAddToGlobalHistory)
 {
     NS_ASSERTION(aURI, "uri is null");
-#ifdef PR_LOGGING
+#if defined(PR_LOGGING) && defined(DEBUG)
     if (PR_LOG_TEST(gDocShellLog, PR_LOG_DEBUG)) {
         nsCAutoString spec;
         aURI->GetSpec(spec);
@@ -7253,9 +7309,11 @@ nsDocShell::OnNewURI(nsIURI * aURI, nsIC
     if (mCurrentURI)
         aURI->Equals(mCurrentURI, &equalUri);
 
+#ifdef DEBUG
     PR_LOG(gDocShellLog, PR_LOG_DEBUG,
            ("  shAvailable=%i updateHistory=%i equalURI=%i\n",
             shAvailable, updateHistory, equalUri));
+#endif
 
     /* If the url to be loaded is the same as the one already there,
      * and the original loadType is LOAD_NORMAL, LOAD_LINK, or
@@ -7414,7 +7472,7 @@ nsresult
 nsDocShell::AddToSessionHistory(nsIURI * aURI,
                                 nsIChannel * aChannel, nsISHEntry ** aNewEntry)
 {
-#ifdef PR_LOGGING
+#if defined(PR_LOGGING) && defined(DEBUG)
     if (PR_LOG_TEST(gDocShellLog, PR_LOG_DEBUG)) {
         nsCAutoString spec;
         aURI->GetSpec(spec);
diff -uprN --exclude=CVS mozilla/dom/public/idl/xul/nsIDOMXULDocument.idl mozilla.new/dom/public/idl/xul/nsIDOMXULDocument.idl
--- mozilla/dom/public/idl/xul/nsIDOMXULDocument.idl	2005-08-31 22:47:05.000000000 +0200
+++ mozilla.new/dom/public/idl/xul/nsIDOMXULDocument.idl	2006-02-24 11:16:40.000000000 +0100
@@ -85,3 +85,16 @@ interface nsIDOMXULDocument : nsISupport
    */
   void                      loadOverlay(in DOMString url, in nsIObserver aObserver);
 };
+
+/**
+ * This interface is a hack for bug 319434 since we have to preserve the
+ * nsIDOMXULDocument interface on the branch. It provides non-scriptable
+ * functions that don't do security checks to access the popup and tooltip
+ * nodes.
+ */
+[uuid(87545e48-b966-4579-829a-ca01b0fca9b3)]
+interface nsIDOMXULDocument2 : nsIDOMXULDocument
+{
+  nsIDOMNode trustedGetPopupNode();
+  nsIDOMNode trustedGetTooltipNode();
+};
diff -uprN --exclude=CVS mozilla/dom/src/base/nsDOMClassInfo.cpp mozilla.new/dom/src/base/nsDOMClassInfo.cpp
--- mozilla/dom/src/base/nsDOMClassInfo.cpp	2006-01-11 23:05:28.000000000 +0100
+++ mozilla.new/dom/src/base/nsDOMClassInfo.cpp	2006-02-24 11:16:41.000000000 +0100
@@ -5521,12 +5521,36 @@ nsWindowSH::NewResolve(nsIXPConnectWrapp
       my_cx = (JSContext *)my_context->GetNativeContext();
     }
 
+    // Resolving a standard class won't do any evil, and it's possible
+    // for caps to get the answer wrong, so disable the security check
+    // for this case.
+
     JSBool did_resolve = JS_FALSE;
+    PRBool doSecurityCheckInAddProperty = sDoSecurityCheckInAddProperty;
+    sDoSecurityCheckInAddProperty = PR_FALSE;
 
-    if (!::JS_ResolveStandardClass(my_cx, obj, id, &did_resolve)) {
-      *_retval = JS_FALSE;
+    JSBool ok = ::JS_ResolveStandardClass(my_cx, obj, id, &did_resolve);
 
-      return NS_ERROR_UNEXPECTED;
+    sDoSecurityCheckInAddProperty = doSecurityCheckInAddProperty;
+
+    if (!ok) {
+      // Trust the JS engine (or the script security manager) to set
+      // the exception in the JS engine.
+
+      jsval exn;
+      if (!JS_GetPendingException(my_cx, &exn)) {
+        return NS_ERROR_UNEXPECTED;
+      }
+
+      // Return NS_OK to avoid stomping over the exception that was passed
+      // down from the ResolveStandardClass call.
+      // Note that the order of the JS_ClearPendingException and
+      // JS_SetPendingException is important in the case that my_cx == cx.
+
+      JS_ClearPendingException(my_cx);
+      JS_SetPendingException(cx, exn);
+      *_retval = JS_FALSE;
+      return NS_OK;
     }
 
     if (did_resolve) {
@@ -5839,10 +5863,6 @@ nsWindowSH::NewEnumerate(nsIXPConnectWra
         return NS_OK;
       }
 
-#ifdef DEBUG_mrbkap
-      printf(">>> Enumerating a window!\n");
-#endif
-
       // The security check passed, let's see if we need to get the inner
       // window's JS object or if we can just start enumerating.
       nsGlobalWindow *win = nsGlobalWindow::FromWrapper(wrapper);
@@ -5876,13 +5896,6 @@ nsWindowSH::NewEnumerate(nsIXPConnectWra
       }
 
       if (*idp != JSVAL_VOID) {
-#ifdef DEBUG_mrbkap
-        {
-          jsval v;
-          NS_ASSERTION(JS_IdToValue(cx, *idp, &v), "Give me my value");
-          printf("=== %s\n", JS_GetStringBytes(JS_ValueToString(cx, v)));
-        }
-#endif
         break;
       }
 
diff -uprN --exclude=CVS mozilla/dom/src/base/nsGlobalWindow.cpp mozilla.new/dom/src/base/nsGlobalWindow.cpp
--- mozilla/dom/src/base/nsGlobalWindow.cpp	2006-01-09 06:48:53.000000000 +0100
+++ mozilla.new/dom/src/base/nsGlobalWindow.cpp	2006-02-24 11:16:41.000000000 +0100
@@ -161,6 +161,16 @@
 // belonging to the back-end like nsIContentPolicy
 #include "nsIPopupWindowManager.h"
 
+#ifdef MOZ_LOGGING
+// so we can get logging even in release builds
+#define FORCE_PR_LOG 1
+#endif
+#include "prlog.h"
+
+#ifdef PR_LOGGING
+static PRLogModuleInfo* gDOMLeakPRLog;
+#endif
+
 nsIScriptSecurityManager *nsGlobalWindow::sSecMan      = nsnull;
 nsIFactory *nsGlobalWindow::sComputedDOMStyleFactory   = nsnull;
 
@@ -178,8 +188,14 @@ PRInt32 gTimeoutCnt                     
 #define DEBUG_PAGE_CACHE
 #endif
 
+// The shortest interval/timeout we permit
 #define DOM_MIN_TIMEOUT_VALUE 10 // 10ms
 
+// The longest interval (as PRIntervalTime) we permit, or that our
+// timer code can handle, really. See DELAY_INTERVAL_LIMIT in
+// nsTimerImpl.h for details.
+#define DOM_MAX_TIMEOUT_VALUE    PR_BIT(8 * sizeof(PRIntervalTime) - 1)
+
 #define FORWARD_TO_OUTER(method, args, err_rval)                              \
   PR_BEGIN_MACRO                                                              \
   if (IsInnerWindow()) {                                                      \
@@ -322,6 +338,15 @@ nsGlobalWindow::nsGlobalWindow(nsGlobalW
   printf("++DOMWINDOW == %d\n", gRefCnt);
 #endif
 
+#ifdef PR_LOGGING
+  if (!gDOMLeakPRLog)
+    gDOMLeakPRLog = PR_NewLogModule("DOMLeak");
+
+  if (gDOMLeakPRLog)
+    PR_LOG(gDOMLeakPRLog, PR_LOG_DEBUG,
+           ("DOMWINDOW %p created outer=%p", this, aOuterWindow));
+#endif
+
   if (!sSecMan) {
     CallGetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &sSecMan);
   }
@@ -336,6 +361,12 @@ nsGlobalWindow::~nsGlobalWindow()
   printf("--DOMWINDOW == %d\n", gRefCnt);
 #endif
 
+#ifdef PR_LOGGING
+  if (gDOMLeakPRLog)
+    PR_LOG(gDOMLeakPRLog, PR_LOG_DEBUG,
+           ("DOMWINDOW %p destroyed", this));
+#endif
+
   if (IsOuterWindow()) {
     // An outer window is destroyed with inner windows still possibly
     // alive, iterate through the inner windows and null out their
@@ -817,6 +848,19 @@ nsGlobalWindow::SetNewDocument(nsIDOMDoc
 {
   NS_WARN_IF_FALSE(mDocumentPrincipal == nsnull,
                    "mDocumentPrincipal prematurely set!");
+#ifdef PR_LOGGING
+  if (IsInnerWindow() && aDocument && gDOMLeakPRLog &&
+      PR_LOG_TEST(gDOMLeakPRLog, PR_LOG_DEBUG)) {
+    nsCOMPtr<nsIDocument> newDoc(do_QueryInterface(aDocument));
+    nsIURI *uri = nsnull;
+    if (newDoc)
+      uri = newDoc->GetDocumentURI();
+    nsCAutoString spec;
+    if (uri)
+      uri->GetSpec(spec);
+    PR_LogPrint("DOMWINDOW %p SetNewDocument %s", this, spec.get());
+  }
+#endif
 
   if (!aIsInternalCall && IsInnerWindow()) {
     if (!mOuterWindow) {
@@ -6004,6 +6048,12 @@ nsGlobalWindow::SetTimeoutOrInterval(PRB
     interval = DOM_MIN_TIMEOUT_VALUE;
   }
 
+  // Make sure we don't proceed with a interval larger than our timer
+  // code can handle.
+  if (interval > PR_IntervalToMilliseconds(DOM_MAX_TIMEOUT_VALUE)) {
+    interval = PR_IntervalToMilliseconds(DOM_MAX_TIMEOUT_VALUE);
+  }
+
   timeout = new nsTimeout();
   if (!timeout)
     return NS_ERROR_OUT_OF_MEMORY;
@@ -6080,14 +6130,14 @@ nsGlobalWindow::SetTimeoutOrInterval(PRB
     return NS_ERROR_FAILURE;
   }
 
-  PRIntervalTime delta = PR_MillisecondsToInterval((PRUint32)interval);
+  PRTime delta = (PRTime)interval * PR_USEC_PER_MSEC;
 
   if (!IsFrozen()) {
     // If we're not currently frozen, then we set timeout->mWhen to be the
     // actual firing time of the timer (i.e., now + delta). We also actually
     // create a timer and fire it off.
 
-    timeout->mWhen = PR_IntervalNow() + delta;
+    timeout->mWhen = PR_Now() + delta;
 
     timeout->mTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
     if (NS_FAILED(rv)) {
@@ -6192,8 +6242,8 @@ nsGlobalWindow::RunTimeout(nsTimeout *aT
 
   // A native timer has gone off. See which of our timeouts need
   // servicing
-  PRIntervalTime now = PR_IntervalNow();
-  PRIntervalTime deadline;
+  PRTime now = PR_Now();
+  PRTime deadline;
 
   if (aTimeout && aTimeout->mWhen > now) {
     // The OS timer fired early (yikes!), and possibly out of order
@@ -6247,7 +6297,7 @@ nsGlobalWindow::RunTimeout(nsTimeout *aT
   mTimeoutInsertionPoint = &dummy_timeout.mNext;
 
   prev = nsnull;
-  for (timeout = mTimeouts; timeout != &dummy_timeout; timeout = next) {
+  for (timeout = mTimeouts; timeout != &dummy_timeout && !IsFrozen(); timeout = next) {
     next = timeout->mNext;
 
     if (timeout->mFiringDepth != firingDepth) {
@@ -6297,9 +6347,10 @@ nsGlobalWindow::RunTimeout(nsTimeout *aT
     } else {
       // Add a "secret" final argument that indicates timeout lateness
       // in milliseconds
-      PRIntervalTime lateness =
-        PR_IntervalToMilliseconds(now - timeout->mWhen);
-      timeout->mArgv[timeout->mArgc] = INT_TO_JSVAL((jsint) lateness);
+      PRTime lateness = now - timeout->mWhen;
+
+      timeout->mArgv[timeout->mArgc] =
+        INT_TO_JSVAL((jsint)(lateness / PR_USEC_PER_MSEC));
 
       jsval dummy;
       scx->CallEventHandler(mJSObject, timeout->mFunObj, timeout->mArgc + 1,
@@ -6338,55 +6389,60 @@ nsGlobalWindow::RunTimeout(nsTimeout *aT
       return;
     }
 
+    PRBool isInterval = PR_FALSE;
+
     // If we have a regular interval timer, we re-schedule the
     // timeout, accounting for clock drift.
     if (timeout->mInterval) {
       // Compute time to next timeout for interval timer.
-      timeout->mWhen += PR_MillisecondsToInterval(timeout->mInterval);
-      PRInt32 delay = timeout->mWhen - PR_IntervalNow();
+      // XXX Units?
+      PRTime nextInterval = timeout->mWhen +
+        ((PRTime)timeout->mInterval * PR_USEC_PER_MSEC);
+      PRTime delay = nextInterval - PR_Now();
 
       // If the next interval timeout is already supposed to have
-      // happened then run the timeout immediately.
-      if (delay < 0) {
-        delay = 0;
-      }
-
-      delay = PR_IntervalToMilliseconds(delay);
-
-      if (delay < DOM_MIN_TIMEOUT_VALUE) {
-        // Don't let intervals starve the message pump, no matter
-        // what. Just like we do for non-interval timeouts.
-
-        delay = DOM_MIN_TIMEOUT_VALUE;
-      }
-
-      // Reschedule the OS timer. Don't bother returning any error
-      // codes if this fails since nobody who cares about them is
-      // listening anyways.
-      nsresult rv =
-        timeout->mTimer->InitWithFuncCallback(TimerCallback, timeout, delay,
-                                              nsITimer::TYPE_ONE_SHOT);
-
-      if (NS_FAILED(rv)) {
-        NS_ERROR("Error initializing timer for DOM timeout!");
+      // happened then run the timeout as soon as we can (meaning
+      // after DOM_MIN_TIMEOUT_VALUE time has passed).
+      if (delay < ((PRTime)DOM_MIN_TIMEOUT_VALUE * PR_USEC_PER_MSEC)) {
+        delay = (PRTime)DOM_MIN_TIMEOUT_VALUE * PR_USEC_PER_MSEC;
+      }
+
+      if (timeout->mTimer) {
+        timeout->mWhen = nextInterval;
+
+        // Reschedule the OS timer. Don't bother returning any error
+        // codes if this fails since the callers of this method
+        // doesn't care about them nobody who cares about them
+        // anyways.
+        nsresult rv = timeout->mTimer->
+          InitWithFuncCallback(TimerCallback, timeout,
+                               (PRInt32)(delay / PR_USEC_PER_MSEC),
+                               nsITimer::TYPE_ONE_SHOT);
+
+        if (NS_FAILED(rv)) {
+          NS_ERROR("Error initializing timer for DOM timeout!");
+
+          // We failed to initialize the new OS timer, this timer does
+          // us no good here so we just cancel it (just in case) and
+          // null out the pointer to the OS timer, this will release the
+          // OS timer. As we continue executing the code below we'll end
+          // up deleting the timeout since it's not an interval timeout
+          // any more (since timeout->mTimer == nsnull).
+          timeout->mTimer->Cancel();
+          timeout->mTimer = nsnull;
 
-        // We failed to initialize the new OS timer, this timer does
-        // us no good here so we just cancel it (just in case) and
-        // null out the pointer to the OS timer, this will release the
-        // OS timer. As we continue executing the code below we'll end
-        // up deleting the timeout since it's not an interval timeout
-        // any more (since timeout->mTimer == nsnull).
-        timeout->mTimer->Cancel();
-        timeout->mTimer = nsnull;
+          // Now that the OS timer no longer has a reference to the
+          // timeout we need to drop that reference.
+          timeout->Release(scx);
+        }
+      } else {
+        NS_ASSERTION(IsFrozen(), "How'd our timer end up null if we're not frozen?");
 
-        // Now that the OS timer no longer has a reference to the
-        // timeout we need to drop that reference.
-        timeout->Release(scx);
+        timeout->mWhen = delay;
+        isInterval = PR_TRUE;
       }
     }
 
-    PRBool isInterval = PR_FALSE;
-
     if (timeout->mTimer) {
       if (timeout->mInterval) {
         isInterval = PR_TRUE;
@@ -6975,7 +7031,7 @@ nsGlobalWindow::SuspendTimeouts()
 {
   FORWARD_TO_INNER_VOID(SuspendTimeouts, ());
 
-  PRIntervalTime now = PR_IntervalNow();
+  PRTime now = PR_Now();
   for (nsTimeout *t = mTimeouts; t; t = t->mNext) {
     // Change mWhen to be the time remaining for this timer.    
     if (t->mWhen > now)
@@ -7025,14 +7081,19 @@ nsGlobalWindow::ResumeTimeouts()
 {
   FORWARD_TO_INNER(ResumeTimeouts, (), NS_ERROR_NOT_INITIALIZED);
 
-  // Restore all of the timeouts, using the stored time remaining.
+  // Restore all of the timeouts, using the stored time remaining
+  // (stored in timeout->mWhen).
 
-  PRIntervalTime now = PR_IntervalNow();
+  PRTime now = PR_Now();
   nsresult rv;
 
   for (nsTimeout *t = mTimeouts; t; t = t->mNext) {
-    PRUint32 delay = PR_MAX(PR_IntervalToMilliseconds(t->mWhen),
-                            DOM_MIN_TIMEOUT_VALUE);
+    PRUint32 delay =
+      PR_MAX(((PRUint32)(t->mWhen / PR_USEC_PER_MSEC)),
+              DOM_MIN_TIMEOUT_VALUE);
+
+    // Set mWhen back to the time when the timer is supposed to
+    // fire.
     t->mWhen += now;
 
     t->mTimer = do_CreateInstance("@mozilla.org/timer;1");
diff -uprN --exclude=CVS mozilla/dom/src/base/nsGlobalWindow.h mozilla.new/dom/src/base/nsGlobalWindow.h
--- mozilla/dom/src/base/nsGlobalWindow.h	2005-10-16 18:31:38.000000000 +0200
+++ mozilla.new/dom/src/base/nsGlobalWindow.h	2006-02-24 11:16:41.000000000 +0100
@@ -560,11 +560,12 @@ struct nsTimeout
   // Returned as value of setTimeout()
   PRUint32 mPublicId;
 
-  // Non-zero if repetitive timeout
+  // Non-zero interval in milliseconds if repetitive timeout
   PRInt32 mInterval;
 
-  // Nominal time to run this timeout
-  PRIntervalTime mWhen;
+  // Nominal time (in microseconds since the epoch) to run this
+  // timeout
+  PRTime mWhen;
 
   // Principal with which to execute
   nsCOMPtr<nsIPrincipal> mPrincipal;
diff -uprN --exclude=CVS mozilla/editor/libeditor/html/nsHTMLEditor.cpp mozilla.new/editor/libeditor/html/nsHTMLEditor.cpp
--- mozilla/editor/libeditor/html/nsHTMLEditor.cpp	2005-07-13 18:45:58.000000000 +0200
+++ mozilla.new/editor/libeditor/html/nsHTMLEditor.cpp	2006-02-24 11:16:49.000000000 +0100
@@ -4047,139 +4047,6 @@ nsHTMLEditor::DebugUnitTests(PRInt32 *ou
 
 #ifdef XP_MAC
 #pragma mark -
-#pragma mark  nsIEditorIMESupport overrides 
-#pragma mark -
-#endif
-
-NS_IMETHODIMP
-nsHTMLEditor::SetCompositionString(const nsAString& aCompositionString, nsIPrivateTextRangeList* aTextRangeList,nsTextEventReply* aReply)
-{
-  NS_ASSERTION(aTextRangeList, "null ptr");
-  if (nsnull == aTextRangeList)
-    return NS_ERROR_NULL_POINTER;
-
-  nsCOMPtr<nsICaret>  caretP;
-  
-  // workaround for windows ime bug 23558: we get every ime event twice. 
-  // for escape keypress, this causes an empty string to be passed
-  // twice, which freaks out the editor.  This is to detect and aviod that
-  // situation:
-  if (aCompositionString.IsEmpty() && !mIMETextNode) 
-  {
-    return NS_OK;
-  }
-  
-  nsCOMPtr<nsISelection> selection;
-  nsresult result = GetSelection(getter_AddRefs(selection));
-  if (NS_FAILED(result)) return result;
-
-  mIMETextRangeList = aTextRangeList;
-
-  if (!mPresShellWeak)  
-    return NS_ERROR_NOT_INITIALIZED;
-
-  nsCOMPtr<nsIPresShell> ps = do_QueryReferent(mPresShellWeak);
-  if (!ps) 
-    return NS_ERROR_NOT_INITIALIZED;
-
-  // XXX_kin: BEGIN HACK! HACK! HACK!
-  // XXX_kin:
-  // XXX_kin: This is lame! The IME stuff needs caret coordinates
-  // XXX_kin: synchronously, but the editor could be using async
-  // XXX_kin: updates (reflows and paints) for performance reasons.
-  // XXX_kin: In order to give IME what it needs, we have to temporarily
-  // XXX_kin: switch to sync updating during this call so that the
-  // XXX_kin: nsAutoPlaceHolderBatch can force sync reflows, paints,
-  // XXX_kin: and selection scrolling, so that we get back accurate
-  // XXX_kin: caret coordinates.
-
-  PRUint32 flags = 0;
-  PRBool restoreFlags = PR_FALSE;
-
-  if (NS_SUCCEEDED(GetFlags(&flags)) &&
-     (flags & nsIPlaintextEditor::eEditorUseAsyncUpdatesMask))
-  {
-    if (NS_SUCCEEDED(SetFlags(flags & (~nsIPlaintextEditor::eEditorUseAsyncUpdatesMask))))
-       restoreFlags = PR_TRUE;
-  }
-
-  // XXX_kin: END HACK! HACK! HACK!
-
-  // we need the nsAutoPlaceHolderBatch destructor called before hitting
-  // GetCaretCoordinates so the states in Frame system sync with content
-  // therefore, we put the nsAutoPlaceHolderBatch into an inner block
-  {
-    nsAutoPlaceHolderBatch batch(this, gIMETxnName);
-
-    result = InsertText(aCompositionString);
-
-    mIMEBufferLength = aCompositionString.Length();
-
-    ps->GetCaret(getter_AddRefs(caretP));
-    if (caretP)
-      caretP->SetCaretDOMSelection(selection);
-
-    // second part of 23558 fix:
-    if (aCompositionString.IsEmpty()) 
-    {
-      mIMETextNode = nsnull;
-    }
-  }
-
-  // XXX_kin: BEGIN HACK! HACK! HACK!
-  // XXX_kin:
-  // XXX_kin: Restore the previous set of flags!
-
-  if (restoreFlags)
-    SetFlags(flags);
-
-  // XXX_kin: END HACK! HACK! HACK!
-
-  result = caretP->GetCaretCoordinates(nsICaret::eIMECoordinates, selection,
-              &(aReply->mCursorPosition), &(aReply->mCursorIsCollapsed), nsnull);
-  NS_ASSERTION(NS_SUCCEEDED(result), "cannot get caret position");
-
-  
-  return result;
-}
-
-NS_IMETHODIMP 
-nsHTMLEditor::GetReconversionString(nsReconversionEventReply* aReply)
-{
-  nsresult res;
-
-  nsCOMPtr<nsISelection> selection;
-  res = GetSelection(getter_AddRefs(selection));
-  if (NS_FAILED(res) || !selection)
-    return (res == NS_OK) ? NS_ERROR_FAILURE : res;
-
-  // get the first range in the selection.  Since it is
-  // unclear what to do if reconversion happens with a 
-  // multirange selection, we will ignore any additional ranges.
-  
-  nsCOMPtr<nsIDOMRange> range;
-  res = selection->GetRangeAt(0, getter_AddRefs(range));
-  if (NS_FAILED(res) || !range)
-    return (res == NS_OK) ? NS_ERROR_FAILURE : res;
-  
-  nsAutoString textValue;
-  res = range->ToString(textValue);
-  if (NS_FAILED(res))
-    return res;
-  
-  aReply->mReconversionString = (PRUnichar*) nsMemory::Clone(textValue.get(),
-                                                                (textValue.Length() + 1) * sizeof(PRUnichar));
-  if (!aReply->mReconversionString)
-    return NS_ERROR_OUT_OF_MEMORY;
-
-  // delete the selection
-  res = DeleteSelection(eNone);
-  
-  return res;
-}
-
-#ifdef XP_MAC
-#pragma mark -
 #pragma mark  StyleSheet utils 
 #pragma mark -
 #endif
diff -uprN --exclude=CVS mozilla/editor/libeditor/html/nsHTMLEditor.h mozilla.new/editor/libeditor/html/nsHTMLEditor.h
--- mozilla/editor/libeditor/html/nsHTMLEditor.h	2005-06-16 15:10:55.000000000 +0200
+++ mozilla.new/editor/libeditor/html/nsHTMLEditor.h	2006-02-24 11:16:49.000000000 +0100
@@ -180,11 +180,6 @@ public:
 
   NS_IMETHOD GetNextElementByTagName(nsIDOMElement *aCurrentElement, const nsAString *aTagName, nsIDOMElement **aReturn);
 
-  /* ------------ nsIEditorIMESupport overrides -------------- */
-  
-  NS_IMETHOD SetCompositionString(const nsAString& aCompositionString, nsIPrivateTextRangeList* aTextRangeList,nsTextEventReply* aReply);
-  NS_IMETHOD GetReconversionString(nsReconversionEventReply* aReply);
-
   /* ------------ nsIEditorStyleSheets methods -------------- */
 
   NS_IMETHOD AddStyleSheet(const nsAString & aURL);
diff -uprN --exclude=CVS mozilla/editor/libeditor/html/nsHTMLEditRules.cpp mozilla.new/editor/libeditor/html/nsHTMLEditRules.cpp
--- mozilla/editor/libeditor/html/nsHTMLEditRules.cpp	2005-06-16 15:10:55.000000000 +0200
+++ mozilla.new/editor/libeditor/html/nsHTMLEditRules.cpp	2006-02-24 11:16:49.000000000 +0100
@@ -1879,6 +1879,9 @@ nsHTMLEditRules::WillDeleteSelection(nsI
     if (NS_FAILED(res)) return res;
     if (*aCancel) return NS_OK;
 
+    // We should delete nothing.
+    if (aAction == nsIEditor::eNone)
+      return NS_OK;
 
     // what's in the direction we are deleting?
     nsWSRunObject wsObj(mHTMLEditor, startNode, startOffset);
diff -uprN --exclude=CVS mozilla/editor/libeditor/text/nsPlaintextEditor.cpp mozilla.new/editor/libeditor/text/nsPlaintextEditor.cpp
--- mozilla/editor/libeditor/text/nsPlaintextEditor.cpp	2006-01-23 08:55:18.000000000 +0100
+++ mozilla.new/editor/libeditor/text/nsPlaintextEditor.cpp	2006-02-24 11:16:49.000000000 +0100
@@ -1670,6 +1670,9 @@ nsPlaintextEditor::GetReconversionString
   if (!aReply->mReconversionString)
     return NS_ERROR_OUT_OF_MEMORY;
 
+  if (textValue.IsEmpty())
+    return NS_OK;
+
   // delete the selection
   return DeleteSelection(eNone);
 }
diff -uprN --exclude=CVS mozilla/editor/txtsvc/src/nsTextServicesDocument.cpp mozilla.new/editor/txtsvc/src/nsTextServicesDocument.cpp
--- mozilla/editor/txtsvc/src/nsTextServicesDocument.cpp	2005-02-01 22:12:52.000000000 +0100
+++ mozilla.new/editor/txtsvc/src/nsTextServicesDocument.cpp	2006-03-03 07:15:30.000000000 +0100
@@ -2501,6 +2501,8 @@ nsTextServicesDocument::InsertNode(nsIDO
 nsresult
 nsTextServicesDocument::DeleteNode(nsIDOMNode *aChild)
 {
+  NS_ENSURE_TRUE(mIterator, NS_ERROR_FAILURE);
+
   //**** KDEBUG ****
   // printf("** DeleteNode: 0x%.8x\n", aChild);
   // fflush(stdout);
diff -uprN --exclude=CVS mozilla/editor/ui/composer/content/ComposerCommands.js mozilla.new/editor/ui/composer/content/ComposerCommands.js
--- mozilla/editor/ui/composer/content/ComposerCommands.js	2005-08-17 22:29:02.000000000 +0200
+++ mozilla.new/editor/ui/composer/content/ComposerCommands.js	2006-02-14 10:01:37.000000000 +0100
@@ -2420,7 +2420,7 @@ var nsSpellingCommand =
   {
     window.cancelSendMessage = false;
     try {
-      var skipBlockQuotes = (window.document.firstChild.getAttribute("windowtype") == "msgcompose");
+      var skipBlockQuotes = (window.document.documentElement.getAttribute("windowtype") == "msgcompose");
       window.openDialog("chrome://editor/content/EdSpellCheck.xul", "_blank",
               "chrome,close,titlebar,modal", false, skipBlockQuotes, true);
     }
diff -uprN --exclude=CVS mozilla/editor/ui/composer/content/editorApplicationOverlay.js mozilla.new/editor/ui/composer/content/editorApplicationOverlay.js
--- mozilla/editor/ui/composer/content/editorApplicationOverlay.js	2004-06-25 01:43:59.000000000 +0200
+++ mozilla.new/editor/ui/composer/content/editorApplicationOverlay.js	2006-02-14 10:01:37.000000000 +0100
@@ -103,7 +103,7 @@ function editPage(url, launchWindow, del
   // if the current window is a browser window, then extract the current charset menu setting from the current 
   // document and use it to initialize the new composer window...
 
-  var wintype = document.firstChild.getAttribute('windowtype');
+  var wintype = document.documentElement.getAttribute('windowtype');
   var charsetArg;
 
   if (launchWindow && (wintype == "navigator:browser") && launchWindow.content.document)
diff -uprN --exclude=CVS mozilla/embedding/base/nsEmbedCID.h mozilla.new/embedding/base/nsEmbedCID.h
--- mozilla/embedding/base/nsEmbedCID.h	2005-03-17 06:06:27.000000000 +0100
+++ mozilla.new/embedding/base/nsEmbedCID.h	2006-02-24 11:16:27.000000000 +0100
@@ -75,4 +75,16 @@
 #define NS_PROMPTSERVICE_CONTRACTID \
  "@mozilla.org/embedcomp/prompt-service;1"
 
+/**
+ * Non Blocking Alert Service ContractID
+ *   This service is for posing non blocking alerts to the user.
+ *
+ * This contract implements the following interfaces:
+ * nsINonBlockingAlertService
+ *
+ * Embedders may override this ContractID with their own implementation.
+ */
+#define NS_NONBLOCKINGALERTSERVICE_CONTRACTID \
+ "@mozilla.org/embedcomp/nbalert-service;1"
+
 #endif // NSEMBEDCID_H
diff -uprN --exclude=CVS mozilla/embedding/components/build/nsEmbeddingModule.cpp mozilla.new/embedding/components/build/nsEmbeddingModule.cpp
--- mozilla/embedding/components/build/nsEmbeddingModule.cpp	2005-04-29 15:33:46.000000000 +0200
+++ mozilla.new/embedding/components/build/nsEmbeddingModule.cpp	2006-02-24 11:16:27.000000000 +0100
@@ -134,6 +134,7 @@ static const nsModuleComponentInfo gComp
 #ifdef MOZ_XUL
   { "Dialog ParamBlock", NS_DIALOGPARAMBLOCK_CID, NS_DIALOGPARAMBLOCK_CONTRACTID, nsDialogParamBlockConstructor },
   { "Prompt Service", NS_PROMPTSERVICE_CID, NS_PROMPTSERVICE_CONTRACTID, nsPromptServiceConstructor },
+   { "Nonblocking Alert Service", NS_PROMPTSERVICE_CID, NS_NONBLOCKINGALERTSERVICE_CONTRACTID, nsPromptServiceConstructor },
   { "JS Console Service", NS_JSCONSOLESERVICE_CID, NS_JSCONSOLESERVICE_CONTRACTID, nsJSConsoleServiceConstructor },
 #ifndef WINCE
   { "Printing Prompt Service", NS_PRINTINGPROMPTSERVICE_CID, NS_PRINTINGPROMPTSERVICE_CONTRACTID, nsPrintingPromptServiceConstructor },
diff -uprN --exclude=CVS mozilla/embedding/components/windowwatcher/public/Makefile.in mozilla.new/embedding/components/windowwatcher/public/Makefile.in
--- mozilla/embedding/components/windowwatcher/public/Makefile.in	2004-11-16 21:36:26.000000000 +0100
+++ mozilla.new/embedding/components/windowwatcher/public/Makefile.in	2006-02-24 11:16:27.000000000 +0100
@@ -55,6 +55,7 @@ XPIDLSRCS	= nsIDialogParamBlock.idl \
                   nsPIPromptService.idl \
                   nsPIWindowWatcher.idl \
                   nsIAuthPromptWrapper.idl \
+                  nsINonBlockingAlertService.idl \
                   $(NULL)
 
 include $(topsrcdir)/config/rules.mk
diff -uprN --exclude=CVS mozilla/embedding/components/windowwatcher/public/nsINonBlockingAlertService.idl mozilla.new/embedding/components/windowwatcher/public/nsINonBlockingAlertService.idl
--- mozilla/embedding/components/windowwatcher/public/nsINonBlockingAlertService.idl	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/embedding/components/windowwatcher/public/nsINonBlockingAlertService.idl	2006-02-23 00:31:52.000000000 +0100
@@ -0,0 +1,55 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * YAMASHITA Makoto <makotoy@ms.u-tokyo.ac.jp>.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISupports.idl"
+interface nsIDOMWindow;
+
+/**
+ * This is the interface to the embeddable non-blocking alert
+ * service.  A non-blocking alert is a less serious informative alert
+ * that does not need to block the program's execution to get the
+ * user's response.
+ *
+ * The way to present the alert is left to the implementations.  It
+ * may be a dialog separate from the parent window, or a window-modal
+ * sheet (as the ones in Mac OS X) attached to the parent.
+ */
+[scriptable, uuid(E800EF97-AE37-46B7-A46C-31FBE79657EA)]
+interface nsINonBlockingAlertService : nsISupports {
+  /**
+   * This shows a non-blocking alert with the specified title and
+   * message text. This function requires a valid parent window with
+   * which the alert is associated.
+   *
+   * @param aParent
+   *        The parent window. This must not be null.
+   * @param aDialogTitle
+   *        Text to appear in the title of the alert.
+   * @param aText
+   *        Text to appear in the body of the alert.
+   */
+  void showNonBlockingAlert(in nsIDOMWindow aParent,
+			    in wstring aDialogTitle, in wstring aText);
+};
diff -uprN --exclude=CVS mozilla/embedding/components/windowwatcher/src/nsPromptService.cpp mozilla.new/embedding/components/windowwatcher/src/nsPromptService.cpp
--- mozilla/embedding/components/windowwatcher/src/nsPromptService.cpp	2004-11-01 19:50:11.000000000 +0100
+++ mozilla.new/embedding/components/windowwatcher/src/nsPromptService.cpp	2006-02-24 11:16:27.000000000 +0100
@@ -85,7 +85,8 @@ private:
  ************************ nsPromptService ***********************
  ****************************************************************/
 
-NS_IMPL_ISUPPORTS2(nsPromptService, nsIPromptService, nsPIPromptService)
+NS_IMPL_ISUPPORTS3(nsPromptService, nsIPromptService,
+                   nsPIPromptService, nsINonBlockingAlertService)
 
 nsPromptService::nsPromptService() {
 }
@@ -605,6 +606,32 @@ nsPromptService::Select(nsIDOMWindow *pa
   return rv;
 }
 
+/* void showNonBlockingAlert (in nsIDOMWindow aParent, in wstring aDialogTitle, in wstring aText); */
+NS_IMETHODIMP
+nsPromptService::ShowNonBlockingAlert(nsIDOMWindow *aParent,
+                                      const PRUnichar *aDialogTitle,
+                                      const PRUnichar *aText)
+{
+  NS_ENSURE_ARG(aParent);
+  if (!mWatcher)
+    return NS_ERROR_FAILURE;
+
+  nsCOMPtr<nsIDialogParamBlock> paramBlock(do_CreateInstance(NS_DIALOGPARAMBLOCK_CONTRACTID));
+  if (!paramBlock)
+    return NS_ERROR_FAILURE;
+
+  paramBlock->SetInt(nsPIPromptService::eNumberButtons, 1);
+  paramBlock->SetString(nsPIPromptService::eIconClass, NS_LITERAL_STRING("alert-icon").get());
+  paramBlock->SetString(nsPIPromptService::eDialogTitle, aDialogTitle);
+  paramBlock->SetString(nsPIPromptService::eMsg, aText);
+
+  nsCOMPtr<nsIDOMWindow> dialog;
+  mWatcher->OpenWindow(aParent, "chrome://global/content/commonDialog.xul",
+                       "_blank", "dependent,centerscreen,chrome,titlebar",
+                       paramBlock, getter_AddRefs(dialog));
+  return NS_OK;
+}
+
 nsresult
 nsPromptService::DoDialog(nsIDOMWindow *aParent,
                    nsIDialogParamBlock *aParamBlock, const char *aChromeURL)
diff -uprN --exclude=CVS mozilla/embedding/components/windowwatcher/src/nsPromptService.h mozilla.new/embedding/components/windowwatcher/src/nsPromptService.h
--- mozilla/embedding/components/windowwatcher/src/nsPromptService.h	2005-03-07 18:55:25.000000000 +0100
+++ mozilla.new/embedding/components/windowwatcher/src/nsPromptService.h	2006-02-24 11:16:27.000000000 +0100
@@ -41,17 +41,22 @@
 // {A2112D6A-0E28-421f-B46A-25C0B308CBD0}
 #define NS_PROMPTSERVICE_CID \
  {0xa2112d6a, 0x0e28, 0x421f, {0xb4, 0x6a, 0x25, 0xc0, 0xb3, 0x8, 0xcb, 0xd0}}
+// {150E7415-72D7-11DA-A924-00039386357A}
+#define NS_NONBLOCKINGALERTSERVICE_CID \
+ {0x150e7415, 0x72d7, 0x11da, {0xa9, 0x24, 0x00, 0x03, 0x93, 0x86, 0x35, 0x7a}}
 
 #include "nsCOMPtr.h"
 #include "nsIPromptService.h"
 #include "nsPIPromptService.h"
+#include "nsINonBlockingAlertService.h"
 #include "nsIWindowWatcher.h"
 
 class nsIDOMWindow;
 class nsIDialogParamBlock;
 
 class nsPromptService: public nsIPromptService,
-                       public nsPIPromptService {
+                       public nsPIPromptService,
+                       public nsINonBlockingAlertService {
 
 public:
 
@@ -62,6 +67,7 @@ public:
 
   NS_DECL_NSIPROMPTSERVICE
   NS_DECL_NSPIPROMPTSERVICE
+  NS_DECL_NSINONBLOCKINGALERTSERVICE
   NS_DECL_ISUPPORTS
 
 private:
diff -uprN --exclude=CVS mozilla/embedding/components/windowwatcher/src/nsWindowWatcher.cpp mozilla.new/embedding/components/windowwatcher/src/nsWindowWatcher.cpp
--- mozilla/embedding/components/windowwatcher/src/nsWindowWatcher.cpp	2005-10-18 03:47:31.000000000 +0200
+++ mozilla.new/embedding/components/windowwatcher/src/nsWindowWatcher.cpp	2006-03-03 07:12:52.000000000 +0100
@@ -1,4 +1,5 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=2 sw=2 et tw=78: */
 /* ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
@@ -465,9 +466,14 @@ nsWindowWatcher::OpenWindow(nsIDOMWindow
   jsval    *argv = nsnull;
   JSContext *cx;
   void *mark;
-  nsresult  rv;
 
-  rv = ConvertSupportsTojsvals(aParent, aArguments, &argc, &argv, &cx, &mark);
+  // This kungFuDeathGrip is filled when we are using aParent's context. It
+  // prevents the context from being destroyed before we're truly done with
+  // it.
+  nsCOMPtr<nsIScriptContext> kungFuDeathGrip;
+
+  nsresult rv = ConvertSupportsTojsvals(aParent, aArguments, &argc, &argv, &cx,
+                                        &mark, getter_AddRefs(kungFuDeathGrip));
   if (NS_SUCCEEDED(rv)) {
     PRBool dialog = argc == 0 ? PR_FALSE : PR_TRUE;
     rv = OpenWindowJS(aParent, aUrl, aName, aFeatures, dialog, argc, argv,
@@ -1017,7 +1023,7 @@ nsWindowWatcher::FindWindowEntry(nsIDOMW
   found = PR_FALSE;
   while (info != listEnd && NS_SUCCEEDED(rv)) {
     nsCOMPtr<nsIDOMWindow> infoWindow(do_QueryReferent(info->mWindow));
-    if (!infoWindow) // clean up dangling reference, while we're here
+    if (!infoWindow) { // clean up dangling reference, while we're here
       rv = RemoveWindow(info);
     }
     else if (infoWindow.get() == aWindow)
@@ -1755,7 +1761,8 @@ nsWindowWatcher::ConvertSupportsTojsvals
                                          nsISupports *aArgs,
                                          PRUint32 *aArgc, jsval **aArgv,
                                          JSContext **aUsedContext,
-                                         void **aMarkp)
+                                         void **aMarkp,
+                                         nsIScriptContext **aScriptContext)
 {
   nsresult rv = NS_OK;
 
@@ -1782,6 +1789,15 @@ nsWindowWatcher::ConvertSupportsTojsvals
   JSContextAutoPopper  contextGuard;
 
   cx = GetJSContextFromWindow(aWindow);
+  if (cx) {
+    // Our caller needs to hold a strong ref to keep this context alive.
+    *aScriptContext = GetScriptContextFromJSContext(cx);
+    NS_ASSERTION(*aScriptContext,
+                 "The window's context doesn't have a script context?");
+    NS_ADDREF(*aScriptContext);
+  } else {
+    *aScriptContext = nsnull;
+  }
   if (!cx)
     cx = GetJSContextFromCallStack();
   if (!cx) {
@@ -2103,7 +2119,7 @@ nsWindowWatcher::GetJSContextFromWindow(
     }
     /* (off-topic note:) the nsIScriptContext can be retrieved by
     nsCOMPtr<nsIScriptContext> scx;
-    nsJSUtils::nsGetDynamicScriptContext(cx, getter_AddRefs(scx));
+    nsJSUtils::GetDynamicScriptContext(cx, getter_AddRefs(scx));
     */
   }
 
diff -uprN --exclude=CVS mozilla/embedding/components/windowwatcher/src/nsWindowWatcher.h mozilla.new/embedding/components/windowwatcher/src/nsWindowWatcher.h
--- mozilla/embedding/components/windowwatcher/src/nsWindowWatcher.h	2005-08-15 04:50:31.000000000 +0200
+++ mozilla.new/embedding/components/windowwatcher/src/nsWindowWatcher.h	2006-03-03 07:12:52.000000000 +0100
@@ -55,6 +55,7 @@ class  nsIDocShellTreeOwner;
 class  nsIWebBrowserChrome;
 class  nsString;
 class  nsWatcherWindowEnumerator;
+class  nsIScriptContext;
 struct JSContext;
 struct JSObject;
 struct nsWatcherWindowEntry;
@@ -110,7 +111,8 @@ private:
                                             nsISupports *aArgs,
                                             PRUint32 *aArgc, jsval **aArgv,
                                             JSContext **aUsedContext,
-                                            void **aMarkp);
+                                            void **aMarkp,
+                                            nsIScriptContext **aScriptContext);
   static nsresult   AddSupportsTojsvals(nsISupports *aArg,
                                         JSContext *cx, jsval *aArgv);
   static nsresult   AddInterfaceTojsvals(nsISupports *aArg,
diff -uprN --exclude=CVS mozilla/embedding/config/basebrowser-mac-macho mozilla.new/embedding/config/basebrowser-mac-macho
--- mozilla/embedding/config/basebrowser-mac-macho	2005-12-01 23:25:09.000000000 +0100
+++ mozilla.new/embedding/config/basebrowser-mac-macho	2006-02-24 11:16:27.000000000 +0100
@@ -250,19 +250,19 @@ res/fonts/fontEncoding.properties
 ;
 ; Optional for MathML
 ;
-;res/mathml.css
-;res/dtd/mathml.dtd
-;res/entityTables/mathml20.properties
-;res/fonts/mathfont.properties
-;res/fonts/mathfontCMEX10.properties
-;res/fonts/mathfontCMSY10.properties
-;res/fonts/mathfontMath1.properties
-;res/fonts/mathfontMath2.properties
-;res/fonts/mathfontMath4.properties
-;res/fonts/mathfontMTExtra.properties
-;res/fonts/mathfontPUA.properties
-;res/fonts/mathfontSymbol.properties
-;Components/ucvmath.dylib
+res/mathml.css
+res/dtd/mathml.dtd
+res/entityTables/mathml20.properties
+res/fonts/mathfont.properties
+res/fonts/mathfontCMEX10.properties
+res/fonts/mathfontCMSY10.properties
+res/fonts/mathfontMath1.properties
+res/fonts/mathfontMath2.properties
+res/fonts/mathfontMath4.properties
+res/fonts/mathfontMTExtra.properties
+res/fonts/mathfontPUA.properties
+res/fonts/mathfontSymbol.properties
+components/libucvmath.dylib
 
 ; p3p
 components/libp3p.dylib
diff -uprN --exclude=CVS mozilla/embedding/config/embed-jar.mn mozilla.new/embedding/config/embed-jar.mn
--- mozilla/embedding/config/embed-jar.mn	2005-06-09 06:05:10.000000000 +0200
+++ mozilla.new/embedding/config/embed-jar.mn	2006-02-24 11:16:27.000000000 +0100
@@ -69,3 +69,5 @@ locale/XXXX/cookie/contents.rdf,        
 # Marquee stuff
 content/xbl-marquee,                                comm/content/xbl-marquee
 
+# SVG
+content/global/svg,                                 toolkit/content/global/svg
diff -uprN --exclude=CVS mozilla/embedding/tests/wxEmbed/GeckoProtocolHandler.cpp mozilla.new/embedding/tests/wxEmbed/GeckoProtocolHandler.cpp
--- mozilla/embedding/tests/wxEmbed/GeckoProtocolHandler.cpp	2005-08-13 21:33:51.000000000 +0200
+++ mozilla.new/embedding/tests/wxEmbed/GeckoProtocolHandler.cpp	2006-02-24 11:16:27.000000000 +0100
@@ -245,6 +245,7 @@ NS_IMETHODIMP GeckoProtocolHandlerImpl::
 /* nsIChannel newChannel (in nsIURI aURI); */
 NS_IMETHODIMP GeckoProtocolHandlerImpl::NewChannel(nsIURI *aURI, nsIChannel **_retval)
 {
+    NS_ENSURE_ARG_POINTER(aURI);
     GeckoProtocolChannel *channel = new GeckoProtocolChannel;
     if (!channel)
     {
diff -uprN --exclude=CVS mozilla/extensions/auth/nsAuthSSPI.cpp mozilla.new/extensions/auth/nsAuthSSPI.cpp
--- mozilla/extensions/auth/nsAuthSSPI.cpp	2005-08-24 16:04:42.000000000 +0200
+++ mozilla.new/extensions/auth/nsAuthSSPI.cpp	2006-03-12 20:03:49.000000000 +0100
@@ -34,7 +34,7 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
-
+  
 //
 // Negotiate Authentication Support Module
 //
@@ -356,6 +356,10 @@ nsAuthSSPI::GetNextToken(const void *inT
                                            &ctxAttr,
                                            NULL);
     if (rc == SEC_I_CONTINUE_NEEDED || rc == SEC_E_OK) {
+        if (!ob.cbBuffer) {
+            nsMemory::Free(ob.pvBuffer);
+            ob.pvBuffer = NULL;
+        }
         *outToken = ob.pvBuffer;
         *outTokenLen = ob.cbBuffer;
 
@@ -389,6 +393,9 @@ nsAuthSSPI::Unwrap(const void *inToken,
     ib[0].BufferType = SECBUFFER_STREAM;
     ib[0].cbBuffer = inTokenLen;
     ib[0].pvBuffer = nsMemory::Alloc(ib[0].cbBuffer);
+    if (!ib[0].pvBuffer)
+        return NS_ERROR_OUT_OF_MEMORY;
+    
     memcpy(ib[0].pvBuffer, inToken, inTokenLen);
 
     // app data
@@ -412,7 +419,10 @@ nsAuthSSPI::Unwrap(const void *inToken,
 
     nsMemory::Free(ib[0].pvBuffer);
 
-    return rc;
+    if (!SEC_SUCCESS(rc))
+        return NS_ERROR_FAILURE;
+
+    return NS_OK;
 }
 
 // utility class used to free memory on exit
@@ -456,7 +466,7 @@ nsAuthSSPI::Wrap(const void *inToken,
          &sizes);
 
     if (!SEC_SUCCESS(rc))  
-        return rc;
+        return NS_ERROR_FAILURE;
     
     ibd.cBuffers = 3;
     ibd.pBuffers = bufs.ib;
@@ -494,20 +504,24 @@ nsAuthSSPI::Wrap(const void *inToken,
 
     if (SEC_SUCCESS(rc)) {
         int len  = bufs.ib[0].cbBuffer + bufs.ib[1].cbBuffer + bufs.ib[2].cbBuffer;
+        char *p = (char *) nsMemory::Alloc(len);
 
-        *outToken = nsMemory::Alloc(len);
-
-        if (!*outToken)
+        if (!p)
             return NS_ERROR_OUT_OF_MEMORY;
+				
+        *outToken = (void *) p;
+        *outTokenLen = len;
 
-        memcpy(outToken, bufs.ib[0].pvBuffer, bufs.ib[0].cbBuffer);
+        memcpy(p, bufs.ib[0].pvBuffer, bufs.ib[0].cbBuffer);
+        p += bufs.ib[0].cbBuffer;
 
-        memcpy(outToken + bufs.ib[0].cbBuffer,
-               bufs.ib[1].pvBuffer, bufs.ib[1].cbBuffer);
+        memcpy(p,bufs.ib[1].pvBuffer, bufs.ib[1].cbBuffer);
+        p += bufs.ib[1].cbBuffer;
 
-        memcpy(outToken + bufs.ib[0].cbBuffer + bufs.ib[1].cbBuffer,
-               bufs.ib[2].pvBuffer, bufs.ib[2].cbBuffer);
+        memcpy(p,bufs.ib[2].pvBuffer, bufs.ib[2].cbBuffer);
+        
+        return NS_OK;
     }
 
-    return rc;
+    return NS_ERROR_FAILURE;
 }
diff -uprN --exclude=CVS mozilla/extensions/datetime/nsDateTimeHandler.cpp mozilla.new/extensions/datetime/nsDateTimeHandler.cpp
--- mozilla/extensions/datetime/nsDateTimeHandler.cpp	2004-11-01 19:50:12.000000000 +0100
+++ mozilla.new/extensions/datetime/nsDateTimeHandler.cpp	2006-02-24 11:16:21.000000000 +0100
@@ -125,6 +125,7 @@ NS_IMETHODIMP
 nsDateTimeHandler::NewProxiedChannel(nsIURI* url, nsIProxyInfo* proxyInfo,
                                      nsIChannel* *result)
 {
+    NS_ENSURE_ARG_POINTER(url);
     nsresult rv;
     
     nsDateTimeChannel *chan = new nsDateTimeChannel();
diff -uprN --exclude=CVS mozilla/extensions/finger/nsFingerHandler.cpp mozilla.new/extensions/finger/nsFingerHandler.cpp
--- mozilla/extensions/finger/nsFingerHandler.cpp	2004-11-01 19:50:12.000000000 +0100
+++ mozilla.new/extensions/finger/nsFingerHandler.cpp	2006-02-24 11:16:21.000000000 +0100
@@ -127,6 +127,7 @@ NS_IMETHODIMP
 nsFingerHandler::NewProxiedChannel(nsIURI* url, nsIProxyInfo* proxyInfo,
                                    nsIChannel* *result)
 {
+    NS_ENSURE_ARG_POINTER(url);
     nsresult rv;
     
     nsFingerChannel *chan = new nsFingerChannel();
diff -uprN --exclude=CVS mozilla/extensions/gnomevfs/nsGnomeVFSProtocolHandler.cpp mozilla.new/extensions/gnomevfs/nsGnomeVFSProtocolHandler.cpp
--- mozilla/extensions/gnomevfs/nsGnomeVFSProtocolHandler.cpp	2005-02-25 21:46:26.000000000 +0100
+++ mozilla.new/extensions/gnomevfs/nsGnomeVFSProtocolHandler.cpp	2006-02-24 11:16:22.000000000 +0100
@@ -940,6 +940,7 @@ nsGnomeVFSProtocolHandler::NewURI(const 
 NS_IMETHODIMP
 nsGnomeVFSProtocolHandler::NewChannel(nsIURI *aURI, nsIChannel **aResult)
 {
+  NS_ENSURE_ARG_POINTER(aURI);
   nsresult rv;
 
   nsCAutoString spec;
diff -uprN --exclude=CVS mozilla/extensions/help/resources/content/helpMenuOverlay.xul mozilla.new/extensions/help/resources/content/helpMenuOverlay.xul
--- mozilla/extensions/help/resources/content/helpMenuOverlay.xul	2005-07-01 16:12:45.000000000 +0200
+++ mozilla.new/extensions/help/resources/content/helpMenuOverlay.xul	2006-03-03 07:12:12.000000000 +0100
@@ -19,10 +19,24 @@
       position="1" id="help"
       key="key_openHelp"
       command="cmd_openHelp"/>
+#ifdef XP_WIN
+#define DISPLAY_IE_USERS_HELP_MENU_ITEM
+#endif
+#ifdef XP_MACOSX
+#define DISPLAY_IE_USERS_HELP_MENU_ITEM
+#endif
+#ifdef HPUX
+#define DISPLAY_IE_USERS_HELP_MENU_ITEM
+#endif
+#ifdef SOLARIS
+#define DISPLAY_IE_USERS_HELP_MENU_ITEM
+#endif
+#ifdef DISPLAY_IE_USERS_HELP_MENU_ITEM
     <menuitem label="&helpForIEUsers.label;"
       accesskey="&helpForIEUsers.accesskey;"
       position="2"
       oncommand="openHelp('ieusers');" />
+#endif
   </menupopup>
   
   <commandset id="tasksCommands">
diff -uprN --exclude=CVS mozilla/extensions/help/resources/jar.mn mozilla.new/extensions/help/resources/jar.mn
--- mozilla/extensions/help/resources/jar.mn	2005-04-05 01:35:22.000000000 +0200
+++ mozilla.new/extensions/help/resources/jar.mn	2006-03-03 07:12:12.000000000 +0100
@@ -3,7 +3,7 @@ help.jar:
         content/help/contextHelp.js                     (content/contextHelp.js)
         content/help/help.js                            (content/help.js)
 *       content/help/contents.rdf                       (content/contents.rdf)
-        content/help/helpMenuOverlay.xul                (content/helpMenuOverlay.xul)
+*       content/help/helpMenuOverlay.xul                (content/helpMenuOverlay.xul)
         content/help/helpContextOverlay.xul             (content/helpContextOverlay.xul)
 *       content/help/platformClasses.css                (content/platformClasses.css)
 
diff -uprN --exclude=CVS mozilla/extensions/help/resources/locale/en-US/using_priv_help.xhtml mozilla.new/extensions/help/resources/locale/en-US/using_priv_help.xhtml
--- mozilla/extensions/help/resources/locale/en-US/using_priv_help.xhtml	2006-01-23 08:54:36.000000000 +0100
+++ mozilla.new/extensions/help/resources/locale/en-US/using_priv_help.xhtml	2006-02-14 10:01:12.000000000 +0100
@@ -1182,15 +1182,15 @@
 <p>If you click Yes at least some of the time, Form Manager will soon have
   enough data to begin filling out forms automatically.</p>
 
-<p>Form preferences allow you to</p>
+<p>Form preferences allow you to:</p>
 
 <ul>
   <li><strong>Save form data from web pages when completing forms:</strong>
-    This checkbox determines whether are asked if you want to save form data
-    every time you submit a new form. This option is selected by default. If
-    you deselect it, Form Manager never asks if you want to save form data.
+    This checkbox determines whether you are asked if you want to save form
+    data every time you submit a new form. This option is selected by default.
+    If you deselect it, Form Manager never asks if you want to save form data.
     The only way to save form data is for you open the Edit Menu and choose
-    Fill in Form while viewing a form that you&apos;ve just filled in.
+    Save Form Info while viewing a form that you&apos;ve just filled in.
 
     <p>Note that deselecting this option turns off the notification feature,
       but not Form Manager. The form data it may have already collected is
@@ -1422,8 +1422,8 @@
 
 <p>If you choose to encrypt your stored sensitive information, you&apos;ll need
   a master password. With encryption selected, you&apos;ll be asked for your
-  master password at least once during a browser session in which you access
-  any of your stored sensitive information.</p>
+  master password at least once during a &brandShortName; session in which you
+  access any of your stored sensitive information.</p>
 
 <p>If you choose encryption, but don&apos;t already have a master password,
   you&apos;ll be prompted to create one the first time you try to save or
@@ -1433,12 +1433,13 @@
   time:</p>
 
 <ol>
-  <li>Open the Tools menu, choose Password Manager, and then choose Change
-    Master Password from the submenu (even though you are setting it for the
-    first time, not changing it).
-
-    <p>You see the Set Master Password dialog box.</p>
-  </li>
+  <li>Open the <span class="mac">&brandShortName;</span>
+    <span class="noMac">Edit</span> menu and choose Preferences.</li>
+  <li>Under the Privacy &amp; Security category, click Master Passwords. (If no
+    subcategories are visible, double-click Privacy &amp; Security to expand
+    the list.)</li>
+  <li>In the Change Master Password section, click Change Password... to open
+    the Change Master Password dialog box.</li>
   <li>Enter your desired master password, and retype it to confirm the
     spelling.</li>
   <li>Click OK.</li>
@@ -1457,11 +1458,14 @@
 <p>To change your master password:</p>
 
 <ol>
-  <li>Open the Tools menu, choose Privacy &amp; Security, and then choose
-    Password Manager.</li>
-  <li>Select Change Master Password from the submenu. You see the Set Master
-    Password dialog box.</li>
-  <li>Enter your current master password (if you have previously set one).</li>
+  <li>Open the <span class="mac">&brandShortName;</span>
+    <span class="noMac">Edit</span> menu and choose Preferences.</li> 
+  <li>Under the Privacy &amp; Security category, click Master Passwords. (If no
+    subcategories are visible, double-click Privacy &amp; Security to expand
+    the list.)</li>
+  <li>In the Change Master Password section, click Change Password... to open
+    the Change Master Password dialog box.</li>
+  <li>Enter your current master password.</li>
   <li>Enter your new master password, and retype it to confirm the
     spelling.</li>
   <li>Click OK.</li>
@@ -1478,8 +1482,9 @@
 <h2 id="logging_out_of_your_master_password">Logging Out of Your Master
   Password</h2>
 
-<p>Normally, you are asked for your master password once during each browser
-  session during which you access any of your stored sensitive information.</p>
+<p>Normally, you are asked for your master password once during each
+  &brandShortName; session during which you access any of your stored sensitive
+  information.</p>
 
 <p>It&apos;s also possible to require that your master password be requested
   each time it is needed, or after a certain amount of time has passed. For
@@ -1507,7 +1512,7 @@
   data (see <a href="#encrypting_stored_sensitive_information">Encrypting
   Stored Sensitive Information</a>), you won&apos;t be able to access any of
   the stored password and form data that it protects (assuming you have turned
-  on encryption. Your master password is your most important password. Make
+  on encryption). Your master password is your most important password. Make
   sure you remember it or record it in a safe place.</p>
 
 <p>As a last resort, it&apos;s possible to reset your master password if you
@@ -1546,7 +1551,7 @@
   load.</p>
 
 <p>You can also control how frequently animated images repeat their animation,
-  or turn off animation completely</p>
+  or turn off animation completely.</p>
 
 <p>The next section describes how to control these image settings. The default
   settings allow all images to be accepted and allow them to repeat their
diff -uprN --exclude=CVS mozilla/extensions/help/resources/locale/en-US/welcome_help.xhtml mozilla.new/extensions/help/resources/locale/en-US/welcome_help.xhtml
--- mozilla/extensions/help/resources/locale/en-US/welcome_help.xhtml	2005-03-10 19:44:00.000000000 +0100
+++ mozilla.new/extensions/help/resources/locale/en-US/welcome_help.xhtml	2006-02-14 10:01:12.000000000 +0100
@@ -71,32 +71,16 @@
   </tr>
 
   <tr valign="top">
-    <td colspan="2"><h2>Support</h2></td>
-  </tr>
-  <tr>
-    <td><h3>Technical Support</h3></td>
-    <td><h3>Peer Support</h3></td>
+    <td colspan="2"><h2>Peer Support</h2></td>
   </tr>
 
   <tr valign="top">
     <td>
-      <p><strong><a href="http://support.decisionone.com/mozilla/mozilla_help_main.htm">DecisionOne</a></strong></p>
-
-      <p>Affordable service providing e-mail and phone-in support.</p>
-    </td>
-    <td>
       <p><strong><a href="http://forums.mozillazine.org/index.php">MozillaZine
         Forums</a></strong></p>
 
       <p>Web forums for Mozilla users like you.</p>
     </td>
-  </tr>
-
-  <tr valign="top">
-    <td>
-      <p><strong><a href="http://www.mozillapl.org/?newlang=eng">MozillaPL</a></strong></p>
-      <p>Free community service based on consultants availability.</p>
-    </td>
     <td>
       <p><strong><a href="http://www.mozilla.org/support/#community">User
         Newsgroups</a></strong></p>
@@ -106,13 +90,14 @@
   </tr>
 
   <tr valign="top">
-    <td></td>
     <td>
-      <p><strong>Realtime Chat</strong></p>
+      <p><strong><a href="irc://moznet/mozillazine/">Realtime Chat</a></strong></p>
       <p>Chat with &brandShortName; users via IRC.</p>
     </td>
+    <td></td>
   </tr>
 
+  <!--
   <tr valign="top">
     <td colspan="2"><h2>User Feedback</h2></td>
   </tr>
@@ -122,9 +107,10 @@
         Feedback Agent</a></strong></p>
     </td>
   </tr>
+  -->
 </table>
 
-<p>Copyright &copy; 2003-2004 The Mozilla Foundation.</p>
+<p>Copyright &copy; 2003-2006 The Mozilla Foundation.</p>
 
 </body>
 </html>
diff -uprN --exclude=CVS mozilla/extensions/java/xpcom/interfaces/Makefile.in mozilla.new/extensions/java/xpcom/interfaces/Makefile.in
--- mozilla/extensions/java/xpcom/interfaces/Makefile.in	2006-01-06 22:01:30.000000000 +0100
+++ mozilla.new/extensions/java/xpcom/interfaces/Makefile.in	2006-02-24 11:16:22.000000000 +0100
@@ -63,7 +63,7 @@ GEN_JAVA_SRCS = \
 # install jars into SDK
 SDK_LIBRARY = $(JARFILE) $(JARFILE_SRC)
 
-GARBAGE += $(JARFILE) $(JARFILE_SRC) $(GEN_JAVA_SRCS)
+GARBAGE += $(JARFILE) $(JARFILE_SRC) $(GEN_JAVA_SRCS) java.files
 GARBAGE_DIRS += _javagen org
 
 include $(topsrcdir)/config/rules.mk
@@ -89,12 +89,12 @@ _javagen/org/mozilla/xpcom/.iface_done: 
 	$(RUN) $(DIST)/bin/GenerateJavaInterfaces$(BIN_SUFFIX) -d $(OUTPUT_DIR)
 	@touch $@
 
-# Use find and xargs for passing list of Java files to JAVAC.  This avoids the
-# "argument list too long" error on Windows when using *.java
+# Using the temporary "java.files" avoids an "argument list too long"
+# error on Windows when using *.java
 org/mozilla/xpcom/.class_done: _javagen/org/mozilla/xpcom/.iface_done
 	@echo Compiling Java interface classes
-	find _javagen -name "*.java" | xargs $(JAVAC) $(JAVAC_FLAGS) -classpath . \
-      -d . -sourcepath _javagen
+	find _javagen -name "*.java" > java.files
+	$(JAVAC) $(JAVAC_FLAGS) -classpath . -d . -sourcepath _javagen @java.files
 	@touch $@
 
 $(JARFILE): org/mozilla/xpcom/.class_done Makefile
@@ -117,3 +117,7 @@ $(TEMP_SDK_DIR)::
 
 libs:: $(JARFILE) $(JARFILE_SRC) $(TEMP_SDK_DIR)
 	$(INSTALL) $(IFLAGS2) $^
+
+# Build the implementation Java classes, which depend on these interfaces
+libs::
+	$(MAKE) -C ../src jarfile
diff -uprN --exclude=CVS mozilla/extensions/java/xpcom/Makefile.in mozilla.new/extensions/java/xpcom/Makefile.in
--- mozilla/extensions/java/xpcom/Makefile.in	2006-01-09 06:48:32.000000000 +0100
+++ mozilla.new/extensions/java/xpcom/Makefile.in	2006-02-24 11:16:22.000000000 +0100
@@ -46,11 +46,8 @@ DIRS = src
 
 TOOL_DIRS = \
 	tools/genifaces \
-	interfaces \
 	glue \
 	$(NULL)
 
 include $(topsrcdir)/config/rules.mk
 
-tools::
-	$(MAKE) -C src jarfile
diff -uprN --exclude=CVS mozilla/extensions/java/xpcom/src/Makefile.in mozilla.new/extensions/java/xpcom/src/Makefile.in
--- mozilla/extensions/java/xpcom/src/Makefile.in	2006-01-06 22:01:33.000000000 +0100
+++ mozilla.new/extensions/java/xpcom/src/Makefile.in	2006-02-24 11:16:22.000000000 +0100
@@ -92,7 +92,7 @@ EXTRA_DSO_LDOPTS = \
 	$(MOZ_COMPONENT_LIBS) \
 	$(NULL)
 
-GARBAGE += $(JARFILE) $(JARFILE_SRC)
+GARBAGE += $(JARFILE) $(JARFILE_SRC) java.files
 GARBAGE_DIRS += _javagen org
 
 include $(topsrcdir)/config/rules.mk
@@ -115,13 +115,14 @@ _javagen/org/mozilla/xpcom/internal/.ifa
 			_javagen/org/mozilla/xpcom/internal
 	@touch $@
 
-# Use find and xargs for passing list of Java files to JAVAC.  This avoids the
-# "argument list too long" error on Windows when using *.java
+# Using the temporary "java.files" avoids an "argument list too long"
+# error on Windows when using *.java
 org/mozilla/xpcom/internal/.class_done: _javagen/org/mozilla/xpcom/internal/.iface_done
 	@echo Compiling Java implementation classes
-	find _javagen -name "*.java" | xargs $(JAVAC) $(JAVAC_FLAGS) \
-			-classpath ".$(SEP)../interfaces/MozillaInterfaces.jar" \
-      -d . -sourcepath _javagen
+	find _javagen -name "*.java" > java.files
+	$(JAVAC) $(JAVAC_FLAGS) \
+	  -classpath ".$(SEP)../interfaces/MozillaInterfaces.jar" \
+	  -d . -sourcepath _javagen @java.files
 	@touch $@
 
 $(JARFILE): org/mozilla/xpcom/internal/.class_done Makefile
diff -uprN --exclude=CVS mozilla/extensions/reporter/locales/fy-NL/chrome/about.dtd mozilla.new/extensions/reporter/locales/fy-NL/chrome/about.dtd
--- mozilla/extensions/reporter/locales/fy-NL/chrome/about.dtd	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/extensions/reporter/locales/fy-NL/chrome/about.dtd	2006-01-24 15:27:12.000000000 +0100
@@ -0,0 +1,4 @@
+<!ENTITY projectLead.text                         "Projektlieder">
+<!ENTITY copyright.text                           "Auteursrjocht (C) 2004-2005">
+<!ENTITY thanks.text                              "Tige dank">
+
diff -uprN --exclude=CVS mozilla/extensions/reporter/locales/fy-NL/chrome/reporter.dtd mozilla.new/extensions/reporter/locales/fy-NL/chrome/reporter.dtd
--- mozilla/extensions/reporter/locales/fy-NL/chrome/reporter.dtd	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/extensions/reporter/locales/fy-NL/chrome/reporter.dtd	2006-01-24 15:27:12.000000000 +0100
@@ -0,0 +1,3 @@
+<!ENTITY productName.label                           "Rapportearder">
+<!ENTITY productVersion.label                        "v0.2">
+
diff -uprN --exclude=CVS mozilla/extensions/reporter/locales/fy-NL/chrome/reporterOverlay.dtd mozilla.new/extensions/reporter/locales/fy-NL/chrome/reporterOverlay.dtd
--- mozilla/extensions/reporter/locales/fy-NL/chrome/reporterOverlay.dtd	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/extensions/reporter/locales/fy-NL/chrome/reporterOverlay.dtd	2006-01-24 15:27:12.000000000 +0100
@@ -0,0 +1,5 @@
+<!-- Entities for the Sample Extension Options Dialog go here -->
+<!ENTITY reporterMenu.title                         "Stikkene webstee rapporteare">
+<!ENTITY reporterMenu.tooltip                       "Stikkene webstee rapporteare">
+<!ENTITY reporterMenu.accesskey                     "R">
+
diff -uprN --exclude=CVS mozilla/extensions/reporter/locales/fy-NL/chrome/reporterOverlay.properties mozilla.new/extensions/reporter/locales/fy-NL/chrome/reporterOverlay.properties
--- mozilla/extensions/reporter/locales/fy-NL/chrome/reporterOverlay.properties	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/extensions/reporter/locales/fy-NL/chrome/reporterOverlay.properties	2006-01-24 15:27:12.000000000 +0100
@@ -0,0 +1 @@
+# Script accessible strings for the browser integration overlay go here. 
diff -uprN --exclude=CVS mozilla/extensions/reporter/locales/fy-NL/chrome/reportResults.dtd mozilla.new/extensions/reporter/locales/fy-NL/chrome/reportResults.dtd
--- mozilla/extensions/reporter/locales/fy-NL/chrome/reportResults.dtd	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/extensions/reporter/locales/fy-NL/chrome/reportResults.dtd	2006-01-24 15:27:12.000000000 +0100
@@ -0,0 +1,14 @@
+<!ENTITY reportSite                  "Webstee">
+<!ENTITY reportProblemType           "Probleemtype">
+<!ENTITY reportDecsription           "Beskriuwing">
+<!ENTITY reportPlatform              "Platform">
+<!ENTITY reportProduct               "Produkt">
+<!ENTITY reportoscpu                 "OS">
+<!ENTITY reportGecko                 "Gecko">
+<!ENTITY reportBuildConfig           "Bouwkonfiguraasje">
+<!ENTITY reportUseragent             "Useragent">
+<!ENTITY reportLanguage              "Spraak">
+<!ENTITY reportEmail                 "E-mail">
+<!ENTITY error                       "Foutdetails">
+<!ENTITY faultCode                   "Kode">
+<!ENTITY faultMessage                "Berjocht">
diff -uprN --exclude=CVS mozilla/extensions/reporter/locales/fy-NL/chrome/reportWizard.dtd mozilla.new/extensions/reporter/locales/fy-NL/chrome/reportWizard.dtd
--- mozilla/extensions/reporter/locales/fy-NL/chrome/reportWizard.dtd	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/extensions/reporter/locales/fy-NL/chrome/reportWizard.dtd	2006-01-24 15:27:12.000000000 +0100
@@ -0,0 +1,40 @@
+<!-- Entities for the Sample Extension Options Dialog go here -->
+<!ENTITY reportWizard.title                         "Stikkene webstee rapporteare">
+<!ENTITY privacyNotice.label                        "Privacy-oerienkomst">
+<!ENTITY reportWizardPrivacy.description            "Dit helpprogramma stelt jo in steat om it evangelisaasjeteam yn te ljochten oer websteen welke net goed yn Firefox wurkje of Firefox tslte. Dit is jo manier om s te helpen de best mooglike erfaring foar Firefox-gebrkers te verzekerjen. Nim de tiid om de folgende ynformaasje te lzen oer hoe wy omgean mei de ynformaasje die wy sammelje as jo beslisse om mei te dwaan.">
+<!ENTITY reportWizardMustAgree.description          "Om fjrder te gean motte jo mei de boppensteande privacy-oerienkomst ynstemme.">
+<!ENTITY dontShowPrivacyStatement.label             "Ik ha de bopensteande privacy-oerienkomst lzen en aksepteard.">
+<!ENTITY dontShowPrivacyStatement.accesskey         "I">
+<!ENTITY reportForm.label                           "Rapport ynvulle">
+<!ENTITY reportForm.description                     "Vertel s wat mear oer it probleem wer jo tsjin oan roun:">
+<!ENTITY reportForm.url.title                       "Webstee-URL:">
+<!ENTITY reportForm.behind_login.title              "Webstee is mei in wachtwurd befeilige"><!-- No ":" at the end -->
+<!ENTITY reportForm.behind_login.accesskey          "W">
+<!ENTITY reportForm.problem_type.title              "Probleemtype:">
+<!ENTITY reportForm.problem_type.accesskey          "T">
+<!ENTITY reportForm.problem_type.chooseOne.title    "Kies der ien...">
+<!-- DO *NOT* Add/change/modify (except localization) without consulting with r.m.o server admin first! -->
+<!ENTITY reportForm.problem_type.item1.title        "Browser wurd net ondersteund">
+<!ENTITY reportForm.problem_type.item2.title        "Kin net ynlogge">
+<!ENTITY reportForm.problem_type.item3.title        "Plugin wurd net sjen litten">
+<!ENTITY reportForm.problem_type.item4.title        "Oare ynhld mist">
+<!ENTITY reportForm.problem_type.item5.title        "Reageert verkeerd">
+<!ENTITY reportForm.problem_type.item6.title        "Verskiint verkeerd">
+<!ENTITY reportForm.problem_type.item7.title        "Oar probleem">
+<!ENTITY reportForm.describe.title                  "Probleembeskriuwing:">
+<!ENTITY reportForm.describe.accesskey              "P">
+<!ENTITY reportForm.platform.title                  "Platform:">
+<!ENTITY reportForm.product.title                   "Produkt:">
+<!ENTITY reportForm.gecko.title                     "Gecko:">
+<!ENTITY reportForm.useragent.title                 "Useragent:">
+<!ENTITY reportForm.language.title                  "Spraak:">
+<!--  Make sure this has "(Optional)" at the end.  This is important for the user to know -->
+<!ENTITY reportForm.email.title                     "E-mail (opsjoneel):">
+<!ENTITY reportForm.email.accesskey                 "E">
+<!ENTITY reportForm.privacyPolicy.title             "Privacy-oerienkomst">
+<!ENTITY reportForm.privacyPolicy.tooltip           "Privacy-oerienkomst besjen">
+<!ENTITY reportResults.showDetail.title             "Details sjen litte">
+<!ENTITY reportResults.showDetail.accesskey         "S">
+<!ENTITY sendReport.label                           "Rapport oan it ferstjoeren">
+<!ENTITY sendReport.description                     "It rapport nei de server oan it ferstjoeren...">
+<!ENTITY finish.label                               "Rapport ferstjoert">
diff -uprN --exclude=CVS mozilla/extensions/reporter/locales/fy-NL/chrome/reportWizard.properties mozilla.new/extensions/reporter/locales/fy-NL/chrome/reportWizard.properties
--- mozilla/extensions/reporter/locales/fy-NL/chrome/reportWizard.properties	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/extensions/reporter/locales/fy-NL/chrome/reportWizard.properties	2006-01-24 15:27:12.000000000 +0100
@@ -0,0 +1,10 @@
+submitReport=Rapport ferstjoere
+
+sendingReport=Rapport oan it ferstjoeren...
+reportSent=Rapport ferstjoert
+
+finishError=Fout by it ferstjoeren fan it rapport
+
+successfullyCreatedReport=Rapport suksesfol oerbrocht
+failedCreatingReport=Der wie in fout by it meitsjen fan it rapport en der is dus gjin ynformaasje ferstjoert nei mozilla.org
+
diff -uprN --exclude=CVS mozilla/extensions/reporter/locales/lt/chrome/about.dtd mozilla.new/extensions/reporter/locales/lt/chrome/about.dtd
--- mozilla/extensions/reporter/locales/lt/chrome/about.dtd	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/extensions/reporter/locales/lt/chrome/about.dtd	2006-01-24 15:27:13.000000000 +0100
@@ -0,0 +1,4 @@
+<!ENTITY projectLead.text                         "Projekto vadovas">
+<!ENTITY copyright.text                           "Copyright (C) 2004-2005">
+<!ENTITY thanks.text                              "Padkos">
+
diff -uprN --exclude=CVS mozilla/extensions/reporter/locales/lt/chrome/reporter.dtd mozilla.new/extensions/reporter/locales/lt/chrome/reporter.dtd
--- mozilla/extensions/reporter/locales/lt/chrome/reporter.dtd	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/extensions/reporter/locales/lt/chrome/reporter.dtd	2006-01-24 15:27:13.000000000 +0100
@@ -0,0 +1,3 @@
+<!ENTITY productName.label                           "Reporter">
+<!ENTITY productVersion.label                        "v0.2">
+
diff -uprN --exclude=CVS mozilla/extensions/reporter/locales/lt/chrome/reporterOverlay.dtd mozilla.new/extensions/reporter/locales/lt/chrome/reporterOverlay.dtd
--- mozilla/extensions/reporter/locales/lt/chrome/reporterOverlay.dtd	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/extensions/reporter/locales/lt/chrome/reporterOverlay.dtd	2006-01-24 15:27:13.000000000 +0100
@@ -0,0 +1,5 @@
+<!-- Entities for the Sample Extension Options Dialog go here -->
+<!ENTITY reporterMenu.title                         "Praneti apie neveikiani svetain">
+<!ENTITY reporterMenu.tooltip                       "Praneti apie neveikiani svetain">
+<!ENTITY reporterMenu.accesskey                     "P">
+
diff -uprN --exclude=CVS mozilla/extensions/reporter/locales/lt/chrome/reporterOverlay.properties mozilla.new/extensions/reporter/locales/lt/chrome/reporterOverlay.properties
--- mozilla/extensions/reporter/locales/lt/chrome/reporterOverlay.properties	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/extensions/reporter/locales/lt/chrome/reporterOverlay.properties	2006-01-24 15:27:13.000000000 +0100
@@ -0,0 +1 @@
+# Script accessible strings for the browser integration overlay go here. 
diff -uprN --exclude=CVS mozilla/extensions/reporter/locales/lt/chrome/reportResults.dtd mozilla.new/extensions/reporter/locales/lt/chrome/reportResults.dtd
--- mozilla/extensions/reporter/locales/lt/chrome/reportResults.dtd	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/extensions/reporter/locales/lt/chrome/reportResults.dtd	2006-01-24 15:27:13.000000000 +0100
@@ -0,0 +1,14 @@
+<!ENTITY reportSite                  "Svetain">
+<!ENTITY reportProblemType           "Nesklandumo tipas">
+<!ENTITY reportDecsription           "Apraas">
+<!ENTITY reportPlatform              "Platforma">
+<!ENTITY reportProduct               "Programa">
+<!ENTITY reportoscpu                 "Operacin sistema">
+<!ENTITY reportGecko                 "Gecko versija">
+<!ENTITY reportBuildConfig           "Darinio sranka">
+<!ENTITY reportUseragent             "Naudotojo programa">
+<!ENTITY reportLanguage              "Kalba">
+<!ENTITY reportEmail                 "El. patas">
+<!ENTITY error                       "Isamiau apie klaid">
+<!ENTITY faultCode                   "Kodas">
+<!ENTITY faultMessage                "Praneimas">
diff -uprN --exclude=CVS mozilla/extensions/reporter/locales/lt/chrome/reportWizard.dtd mozilla.new/extensions/reporter/locales/lt/chrome/reportWizard.dtd
--- mozilla/extensions/reporter/locales/lt/chrome/reportWizard.dtd	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/extensions/reporter/locales/lt/chrome/reportWizard.dtd	2006-01-24 15:27:13.000000000 +0100
@@ -0,0 +1,55 @@
+<!-- Entities for the Sample Extension Options Dialog go here -->
+<!ENTITY reportWizard.title                         "Praneimas apie neveikiani svetain">
+
+<!ENTITY privacyNotice.label                        "Privatumo politika">
+<!ENTITY reportWizardPrivacy.description            "i priemon leidia praneti narykls kokybs prieiros komandai apie svetain, kuri naryklje &brandShortName; veikia nekorektikai arba paveikia &brandShortName; veikim. Tuo galite padti pagerinti &brandShortName; kokyb ir iniatinklio narym su ia narykle. Praom perskaityti emiau pateikt tekst, paaikinant, kaip mes panaudojame i Js gaut informacij.">
+<!ENTITY reportWizardMustAgree.description          "Jei norite tsti, turite sutikti su aukiau pateikta privatumo politika.">
+
+<!ENTITY dontShowPrivacyStatement.label             "Privatumo politik perskaiiau ir sutinku su ja.">
+<!ENTITY dontShowPrivacyStatement.accesskey         "P">
+
+<!ENTITY reportForm.label                           "Praneimo informacijos pildymas">
+
+<!ENTITY reportForm.description                     "Praom trumpai apibdinti nesklandum, su kuriuo susidurte:">
+<!ENTITY reportForm.url.title                       "Svetains URL:">
+
+<!ENTITY reportForm.behind_login.title              "Svetain apsaugota slaptaodiu"><!-- No ":" at the end -->
+<!ENTITY reportForm.behind_login.accesskey          "S">
+
+<!ENTITY reportForm.problem_type.title              "Nesklandumo tipas:">
+<!ENTITY reportForm.problem_type.accesskey          "T">
+
+<!ENTITY reportForm.problem_type.chooseOne.title    "Praom parinkti...">
+
+<!-- DO *NOT* Add/change/modify (except localization) without consulting with r.m.o server admin first! -->
+<!ENTITY reportForm.problem_type.item1.title        "Nesuderinama su narykle">
+<!ENTITY reportForm.problem_type.item2.title        "Nepavyksta prisijungti">
+<!ENTITY reportForm.problem_type.item3.title        "Nerodomi papildiniai">
+<!ENTITY reportForm.problem_type.item4.title        "Prarandama turinio dalis">
+<!ENTITY reportForm.problem_type.item5.title        "Neteisingas tinklalapio funkcionavimas">
+<!ENTITY reportForm.problem_type.item6.title        "Neteisingas tinklalapio vaizdavimas">
+<!ENTITY reportForm.problem_type.item7.title        "Kitas nesklandumas">
+
+<!ENTITY reportForm.describe.title                  "Nesklandumo apraas:">
+<!ENTITY reportForm.describe.accesskey              "N">
+
+<!ENTITY reportForm.platform.title                  "Platforma:">
+<!ENTITY reportForm.product.title                   "Programa:">
+<!ENTITY reportForm.gecko.title                     "Gecko versija:">
+<!ENTITY reportForm.useragent.title                 "Naudotojo programa:">
+<!ENTITY reportForm.language.title                  "Kalba:">
+
+<!--  Make sure this has "(Optional)" at the end.  This is important for the user to know -->
+<!ENTITY reportForm.email.title                     "El. patas (nebtina):">
+<!ENTITY reportForm.email.accesskey                 "E">
+
+<!ENTITY reportForm.privacyPolicy.title             "Privatumo politik">
+<!ENTITY reportForm.privacyPolicy.tooltip           "Perirti privatumo politik">
+
+<!ENTITY reportResults.showDetail.title             "Isamiau">
+<!ENTITY reportResults.showDetail.accesskey         "">
+
+<!ENTITY sendReport.label                           "Siuniamas praneimas">
+<!ENTITY sendReport.description                     "Praneimas siuniamas serveriui...">
+
+<!ENTITY finish.label                               "Praneimas isistas">
diff -uprN --exclude=CVS mozilla/extensions/reporter/locales/lt/chrome/reportWizard.properties mozilla.new/extensions/reporter/locales/lt/chrome/reportWizard.properties
--- mozilla/extensions/reporter/locales/lt/chrome/reportWizard.properties	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/extensions/reporter/locales/lt/chrome/reportWizard.properties	2006-01-24 15:27:13.000000000 +0100
@@ -0,0 +1,9 @@
+submitReport=Pateikti prane\u0161im\u0105
+
+sendingReport=Siun\u010diamas prane\u0161imas...
+reportSent=Prane\u0161imas i\u0161si\u0173stas
+
+finishError=Klaida siun\u010diant prane\u0161im\u0105
+
+successfullyCreatedReport=Prane\u0161imas s\u0117kmingai perduotas
+failedCreatingReport=Klaida kuriant prane\u0161im\u0105. Bendrijai \u201emozilla.org\u201c nei\u0161si\u0173sta jokios informacijos
diff -uprN --exclude=CVS mozilla/extensions/reporter/Makefile.in mozilla.new/extensions/reporter/Makefile.in
--- mozilla/extensions/reporter/Makefile.in	2005-11-01 14:55:47.000000000 +0100
+++ mozilla.new/extensions/reporter/Makefile.in	2006-02-14 10:01:12.000000000 +0100
@@ -64,6 +64,7 @@ ALL_LOCALES = \
 	eu \
 	fi \
 	fr \
+	fy-NL \
 	ga-IE \
 	gu-IN \
 	he \
@@ -73,6 +74,7 @@ ALL_LOCALES = \
 	ja \
 	ja-JP-mac \
 	ko \
+	lt \
 	mk \
 	mn \
 	nb-NO \
diff -uprN --exclude=CVS mozilla/extensions/schema-validation/src/Makefile.in mozilla.new/extensions/schema-validation/src/Makefile.in
--- mozilla/extensions/schema-validation/src/Makefile.in	2005-06-24 17:38:12.000000000 +0200
+++ mozilla.new/extensions/schema-validation/src/Makefile.in	2006-02-14 10:01:12.000000000 +0100
@@ -45,10 +45,15 @@ include $(DEPTH)/config/autoconf.mk
 MODULE		= schemavalidation
 LIBRARY_NAME	= schemavalidation
 SHORT_LIBNAME	= schemval
+IS_COMPONENT	= 1
+ifndef MINIMO
 # Do not set EXPORT_LIBRARY as we do not want schema-validation in the static libs list
 #EXPORT_LIBRARY	= 1
 FORCE_SHARED_LIB = 1
-IS_COMPONENT	= 1
+else
+EXPORT_LIBRARY	= 1
+MODULE_NAME	= schemavalidation
+endif
 GRE_MODULE      = 1
 MOZILLA_INTERNAL_API = 1
 
diff -uprN --exclude=CVS mozilla/extensions/schema-validation/src/nsSchemaValidator.cpp mozilla.new/extensions/schema-validation/src/nsSchemaValidator.cpp
--- mozilla/extensions/schema-validation/src/nsSchemaValidator.cpp	2005-10-14 21:09:10.000000000 +0200
+++ mozilla.new/extensions/schema-validation/src/nsSchemaValidator.cpp	2006-03-03 07:12:23.000000000 +0100
@@ -71,6 +71,7 @@
 #include "prprf.h"
 #include "prtime.h"
 #include "plbase64.h"
+#include <ctype.h>
 
 #define NS_SCHEMA_1999_NAMESPACE "http://www.w3.org/1999/XMLSchema"
 #define NS_SCHEMA_2001_NAMESPACE "http://www.w3.org/2001/XMLSchema"
@@ -333,7 +334,8 @@ nsSchemaValidator::ValidateSimpletype(co
 
     case nsISchemaSimpleType::SIMPLE_TYPE_LIST: {
       // handle lists
-      rv = ValidateListSimpletype(aNodeValue, aSchemaSimpleType, &isValid);
+      rv = ValidateListSimpletype(aNodeValue, aSchemaSimpleType, nsnull,
+                                  &isValid);
       break;
     }
 
@@ -348,6 +350,50 @@ nsSchemaValidator::ValidateSimpletype(co
   return rv;
 }
 
+nsresult
+nsSchemaValidator::ValidateDerivedSimpletype(const nsAString & aNodeValue,
+                                             nsSchemaDerivedSimpleType *aDerived,
+                                             PRBool *aResult)
+{
+  // This method is called when validating a simpletype that derives from another
+  // simpletype.
+
+  PRBool isValid = PR_FALSE;
+
+  PRUint16 simpleTypeValue;
+  nsresult rv = aDerived->mBaseType->GetSimpleType(&simpleTypeValue);
+
+  switch (simpleTypeValue) {
+    case nsISchemaSimpleType::SIMPLE_TYPE_BUILTIN: {
+      rv = ValidateDerivedBuiltinType(aNodeValue, aDerived, &isValid);
+      break;
+    }
+
+    case nsISchemaSimpleType::SIMPLE_TYPE_RESTRICTION: {
+      // this happens when for example someone derives from a union which then
+      // derives from another type.
+      rv = nsSchemaValidatorUtils::GetDerivedSimpleType(aDerived->mBaseType,
+                                                        aDerived);
+      ValidateDerivedSimpletype(aNodeValue, aDerived, &isValid);
+      break;
+    }
+
+    case nsISchemaSimpleType::SIMPLE_TYPE_LIST: {
+      rv = ValidateListSimpletype(aNodeValue, aDerived->mBaseType, aDerived,
+                                  &isValid);
+      break;
+    }
+
+    case nsISchemaSimpleType::SIMPLE_TYPE_UNION: {
+      rv = ValidateDerivedUnionSimpletype(aNodeValue, aDerived, &isValid);
+      break;
+    }
+  }
+
+  *aResult = isValid;
+  return rv;
+}
+
 /**
  *  Simpletype restrictions allow restricting a built-in type with several
  *  facets, such as totalDigits or maxLength.
@@ -357,6 +403,8 @@ nsSchemaValidator::ValidateRestrictionSi
                                                  nsISchemaSimpleType *aType,
                                                  PRBool *aResult)
 {
+  PRBool isValid = PR_FALSE;
+
   nsCOMPtr<nsISchemaRestrictionType> restrictionType = do_QueryInterface(aType);
   NS_ENSURE_STATE(restrictionType);
 
@@ -366,151 +414,88 @@ nsSchemaValidator::ValidateRestrictionSi
   nsresult rv = restrictionType->GetBaseType(getter_AddRefs(simpleBaseType));
   NS_ENSURE_SUCCESS(rv, rv);
 
-  // get the amount of restriction facet defined.
-  PRUint32 facetCount;
-  rv = restrictionType->GetFacetCount(&facetCount);
-  NS_ENSURE_SUCCESS(rv, rv);
-  LOG(("    %d facet(s) defined.", facetCount));
-
-  // we create variables for all possible restriction facets and populate them
-  // if we run into them.  This is faster than having the same code repeated
-  // for each built-in type and only handling the relevant facets.
-  PRBool isLengthDefined = PR_FALSE;
-  PRUint32 length = 0;
-  PRBool isMinLengthDefined = PR_FALSE;
-  PRUint32 minLength = 0;
-  PRBool isMaxLengthDefined = PR_FALSE;
-  PRUint32 maxLength = 0;
-  nsAutoString pattern;
-  unsigned short whitespace = 0;
-  nsAutoString maxInclusive;
-  nsAutoString minInclusive;
-  nsAutoString maxExclusive;
-  nsAutoString minExclusive;
-  PRUint32 totalDigits = 0;
-  // since fractionDigits is 0..n, need a bool to remember if it was set or not.
-  PRBool fractionDigitsSet = PR_FALSE;
-  PRUint32 fractionDigits = 0;
-  nsAutoString enumeration;
-  nsStringArray enumerationList;
-
-  nsCOMPtr<nsISchemaFacet> facet;
-  PRUint32 facetCounter;
-  PRUint16 facetType;
-
-  // handle all defined facets
-  for (facetCounter = 0; facetCounter < facetCount; ++facetCounter) {
-    rv = restrictionType->GetFacet(facetCounter, getter_AddRefs(facet));
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    facet->GetFacetType(&facetType);
-
-    switch (facetType) {
-      case nsISchemaFacet::FACET_TYPE_LENGTH: {
-        isLengthDefined = PR_TRUE;
-        facet->GetLengthValue(&length);
-        LOG(("  - Length Facet found (value is %d)", length));
-        break;
-      }
-
-      case nsISchemaFacet::FACET_TYPE_MINLENGTH: {
-        isMinLengthDefined = PR_TRUE;
-        facet->GetLengthValue(&minLength);
-        LOG(("  - Min Length Facet found (value is %d)", minLength));
-        break;
-      }
-
-      case nsISchemaFacet::FACET_TYPE_MAXLENGTH: {
-        isMaxLengthDefined = PR_TRUE;
-        facet->GetLengthValue(&maxLength);
-        LOG(("  - Max Length Facet found (value is %d)", maxLength));
-        break;
-      }
-
-      case nsISchemaFacet::FACET_TYPE_PATTERN: {
-        facet->GetValue(pattern);
-        LOG(("  - Pattern Facet found (value is %s)",
-             NS_ConvertUTF16toUTF8(pattern).get()));
-        break;
-      }
-
-      case nsISchemaFacet::FACET_TYPE_ENUMERATION: {
-        facet->GetValue(enumeration);
-        enumerationList.AppendString(enumeration);
-        LOG(("  - Enumeration found (%s)",
-             NS_ConvertUTF16toUTF8(enumeration).get()));
-        break;
-      }
-
-      case nsISchemaFacet::FACET_TYPE_WHITESPACE: {
-        // XXX whitespace not supported yet
-        facet->GetWhitespaceValue(&whitespace);
-        break;
-      }
-
-      case nsISchemaFacet::FACET_TYPE_MAXINCLUSIVE: {
-        facet->GetValue(maxInclusive);
-        LOG(("  - Max Inclusive Facet found (value is %s)",
-          NS_ConvertUTF16toUTF8(maxInclusive).get()));
-        break;
-      }
-
-      case nsISchemaFacet::FACET_TYPE_MININCLUSIVE: {
-        facet->GetValue(minInclusive);
-        LOG(("  - Min Inclusive Facet found (value is %s)",
-          NS_ConvertUTF16toUTF8(minInclusive).get()));
-        break;
-      }
-
-      case nsISchemaFacet::FACET_TYPE_MAXEXCLUSIVE: {
-        facet->GetValue(maxExclusive);
-        LOG(("  - Max Exclusive Facet found (value is %s)",
-          NS_ConvertUTF16toUTF8(maxExclusive).get()));
-        break;
-      }
-
-      case nsISchemaFacet::FACET_TYPE_MINEXCLUSIVE: {
-        facet->GetValue(minExclusive);
-        LOG(("  - Min Exclusive Facet found (value is %s)",
-          NS_ConvertUTF16toUTF8(minExclusive).get()));
-        break;
-      }
-
-      case nsISchemaFacet::FACET_TYPE_TOTALDIGITS: {
-        facet->GetDigitsValue(&totalDigits);
-        LOG(("  - Totaldigits Facet found (value is %d)", totalDigits));
-        break;
-      }
-
-      case nsISchemaFacet::FACET_TYPE_FRACTIONDIGITS: {
-        fractionDigitsSet = PR_TRUE;
-        facet->GetDigitsValue(&fractionDigits);
-        LOG(("  - Fractiondigits Facet found (value is %d)", fractionDigits));
-        break;
-      }
-    }
-  }
+  nsSchemaDerivedSimpleType derivedType;
+  rv = nsSchemaValidatorUtils::GetDerivedSimpleType(aType, &derivedType);
+  rv = ValidateDerivedSimpletype(aNodeValue, &derivedType, &isValid);
+  *aResult = isValid;
+  return rv;
+}
 
+nsresult
+nsSchemaValidator::ValidateDerivedBuiltinType(const nsAString & aNodeValue,
+                                              nsSchemaDerivedSimpleType *aDerived,
+                                              PRBool *aResult)
+{
+  PRBool isValid = PR_FALSE;
   // now that we have loaded all the restriction facets,
   // check the base type and validate
-  PRUint16 builtinTypeValue;
   nsCOMPtr<nsISchemaBuiltinType> schemaBuiltinType =
-    do_QueryInterface(simpleBaseType);
+    do_QueryInterface(aDerived->mBaseType);
   NS_ENSURE_STATE(schemaBuiltinType);
 
-  schemaBuiltinType->GetBuiltinType(&builtinTypeValue);
+  PRUint16 builtinTypeValue;
+  nsresult rv = schemaBuiltinType->GetBuiltinType(&builtinTypeValue);
 
 #ifdef PR_LOGGING
   DumpBaseType(schemaBuiltinType);
 #endif
 
-  PRBool isValid = PR_FALSE;
-  switch(builtinTypeValue) {
+  switch (builtinTypeValue) {
     case nsISchemaBuiltinType::BUILTIN_TYPE_STRING: {
-      rv = ValidateBuiltinTypeString(aNodeValue, length, isLengthDefined,
-                                     minLength, isMinLengthDefined,
-                                     maxLength, isMaxLengthDefined,
-                                     &enumerationList, &isValid);
+      rv = ValidateBuiltinTypeString(aNodeValue,
+                                     aDerived->length.value,
+                                     aDerived->length.isDefined,
+                                     aDerived->minLength.value,
+                                     aDerived->minLength.isDefined,
+                                     aDerived->maxLength.value,
+                                     aDerived->maxLength.isDefined,
+                                     &aDerived->enumerationList,
+                                     &isValid);
+      break;
+    }
+
+    case nsISchemaBuiltinType::BUILTIN_TYPE_NORMALIZED_STRING: {
+      if (nsSchemaValidatorUtils::IsValidSchemaNormalizedString(aNodeValue)) {
+        rv = ValidateBuiltinTypeString(aNodeValue,
+                                       aDerived->length.value,
+                                       aDerived->length.isDefined,
+                                       aDerived->minLength.value,
+                                       aDerived->minLength.isDefined,
+                                       aDerived->maxLength.value,
+                                       aDerived->maxLength.isDefined,
+                                       &aDerived->enumerationList,
+                                       &isValid);
+      }
+      break;
+    }
+
+    case nsISchemaBuiltinType::BUILTIN_TYPE_TOKEN: {
+      if (nsSchemaValidatorUtils::IsValidSchemaToken(aNodeValue)) {
+        rv = ValidateBuiltinTypeString(aNodeValue,
+                                       aDerived->length.value,
+                                       aDerived->length.isDefined,
+                                       aDerived->minLength.value,
+                                       aDerived->minLength.isDefined,
+                                       aDerived->maxLength.value,
+                                       aDerived->maxLength.isDefined,
+                                       &aDerived->enumerationList,
+                                       &isValid);
+      }
+      break;
+    }
+
+    case nsISchemaBuiltinType::BUILTIN_TYPE_LANGUAGE: {
+      if (nsSchemaValidatorUtils::IsValidSchemaLanguage(aNodeValue)) {
+        rv = ValidateBuiltinTypeString(aNodeValue,
+                                       aDerived->length.value,
+                                       aDerived->length.isDefined,
+                                       aDerived->minLength.value,
+                                       aDerived->minLength.isDefined,
+                                       aDerived->maxLength.value,
+                                       aDerived->maxLength.isDefined,
+                                       &aDerived->enumerationList,
+                                       &isValid);
+      }
       break;
     }
 
@@ -520,139 +505,395 @@ nsSchemaValidator::ValidateRestrictionSi
     }
 
     case nsISchemaBuiltinType::BUILTIN_TYPE_GDAY: {
-      rv = ValidateBuiltinTypeGDay(aNodeValue, maxExclusive, minExclusive,
-                                   maxInclusive, minInclusive, &isValid);
+      rv = ValidateBuiltinTypeGDay(aNodeValue,
+                                   aDerived->maxExclusive.value,
+                                   aDerived->minExclusive.value,
+                                   aDerived->maxInclusive.value,
+                                   aDerived->minInclusive.value,
+                                   &isValid);
       break;
     }
 
     case nsISchemaBuiltinType::BUILTIN_TYPE_GMONTH: {
-      rv = ValidateBuiltinTypeGMonth(aNodeValue, maxExclusive, minExclusive,
-                                     maxInclusive, minInclusive, &isValid);
+      rv = ValidateBuiltinTypeGMonth(aNodeValue,
+                                     aDerived->maxExclusive.value,
+                                     aDerived->minExclusive.value,
+                                     aDerived->maxInclusive.value,
+                                     aDerived->minInclusive.value,
+                                     &isValid);
       break;
     }
 
     case nsISchemaBuiltinType::BUILTIN_TYPE_GYEAR: {
-      rv = ValidateBuiltinTypeGYear(aNodeValue, maxExclusive, minExclusive,
-                                    maxInclusive, minInclusive, &isValid);
+      rv = ValidateBuiltinTypeGYear(aNodeValue,
+                                    aDerived->maxExclusive.value,
+                                    aDerived->minExclusive.value,
+                                    aDerived->maxInclusive.value,
+                                    aDerived->minInclusive.value,
+                                    &isValid);
       break;
     }
 
     case nsISchemaBuiltinType::BUILTIN_TYPE_GYEARMONTH: {
-      rv = ValidateBuiltinTypeGYearMonth(aNodeValue, maxExclusive, minExclusive,
-                                         maxInclusive, minInclusive, &isValid);
+      rv = ValidateBuiltinTypeGYearMonth(aNodeValue,
+                                         aDerived->maxExclusive.value,
+                                         aDerived->minExclusive.value,
+                                         aDerived->maxInclusive.value,
+                                         aDerived->minInclusive.value,
+                                         &isValid);
       break;
     }
 
     case nsISchemaBuiltinType::BUILTIN_TYPE_GMONTHDAY: {
-      rv = ValidateBuiltinTypeGMonthDay(aNodeValue, maxExclusive, minExclusive,
-                                        maxInclusive, minInclusive, &isValid);
+      rv = ValidateBuiltinTypeGMonthDay(aNodeValue,
+                                        aDerived->maxExclusive.value,
+                                        aDerived->minExclusive.value,
+                                        aDerived->maxInclusive.value,
+                                        aDerived->minInclusive.value,
+                                        &isValid);
       break;
     }
 
     case nsISchemaBuiltinType::BUILTIN_TYPE_DATE: {
-      rv = ValidateBuiltinTypeDate(aNodeValue, maxExclusive, minExclusive,
-                                   maxInclusive, minInclusive, &isValid);
+      rv = ValidateBuiltinTypeDate(aNodeValue,
+                                   aDerived->maxExclusive.value,
+                                   aDerived->minExclusive.value,
+                                   aDerived->maxInclusive.value,
+                                   aDerived->minInclusive.value,
+                                   &isValid);
       break;
     }
 
     case nsISchemaBuiltinType::BUILTIN_TYPE_TIME: {
-      rv = ValidateBuiltinTypeTime(aNodeValue, maxExclusive, minExclusive,
-                                   maxInclusive, minInclusive, &isValid);
+      rv = ValidateBuiltinTypeTime(aNodeValue,
+                                   aDerived->maxExclusive.value,
+                                   aDerived->minExclusive.value,
+                                   aDerived->maxInclusive.value,
+                                   aDerived->minInclusive.value,
+                                   &isValid);
       break;
     }
 
     case nsISchemaBuiltinType::BUILTIN_TYPE_DATETIME: {
-      rv = ValidateBuiltinTypeDateTime(aNodeValue, maxExclusive, minExclusive,
-                                       maxInclusive, minInclusive, &isValid);
+      rv = ValidateBuiltinTypeDateTime(aNodeValue,
+                                       aDerived->maxExclusive.value,
+                                       aDerived->minExclusive.value,
+                                       aDerived->maxInclusive.value,
+                                       aDerived->minInclusive.value,
+                                       &isValid);
       break;
     }
 
     case nsISchemaBuiltinType::BUILTIN_TYPE_DURATION: {
-      rv = ValidateBuiltinTypeDuration(aNodeValue, maxExclusive, minExclusive,
-                                       maxInclusive, minInclusive, &isValid);
+      rv = ValidateBuiltinTypeDuration(aNodeValue,
+                                       aDerived->maxExclusive.value,
+                                       aDerived->minExclusive.value,
+                                       aDerived->maxInclusive.value,
+                                       aDerived->minInclusive.value,
+                                       &isValid);
       break;
     }
 
     case nsISchemaBuiltinType::BUILTIN_TYPE_INTEGER: {
-      rv = ValidateBuiltinTypeInteger(aNodeValue, totalDigits, maxExclusive,
-                                      minExclusive, maxInclusive, minInclusive,
-                                      &enumerationList, &isValid);
+      rv = ValidateBuiltinTypeInteger(aNodeValue,
+                                      aDerived->totalDigits.value,
+                                      aDerived->maxExclusive.value,
+                                      aDerived->minExclusive.value,
+                                      aDerived->maxInclusive.value,
+                                      aDerived->minInclusive.value,
+                                      &aDerived->enumerationList,
+                                      &isValid);
       break;
     }
 
     /* http://w3.org/TR/xmlschema-2/#nonPositiveInteger */
     case nsISchemaBuiltinType::BUILTIN_TYPE_NONPOSITIVEINTEGER: {
-      if (maxExclusive.IsEmpty()) {
-        maxExclusive.AssignLiteral("1");
+      if (aDerived->maxExclusive.value.IsEmpty()) {
+        aDerived->maxExclusive.value.AssignLiteral("1");
+      } else if (aDerived->maxInclusive.value.IsEmpty()) {
+        aDerived->maxInclusive.value.AssignLiteral("0");
       }
 
-      if (minInclusive.IsEmpty()) {
-        minInclusive.AssignLiteral("0");
-      }
-
-      rv = ValidateBuiltinTypeInteger(aNodeValue, totalDigits, maxExclusive,
-                                      minExclusive, maxInclusive, minInclusive,
-                                      &enumerationList, &isValid);
+      rv = ValidateBuiltinTypeInteger(aNodeValue,
+                                      aDerived->totalDigits.value,
+                                      aDerived->maxExclusive.value,
+                                      aDerived->minExclusive.value,
+                                      aDerived->maxInclusive.value,
+                                      aDerived->minInclusive.value,
+                                      &aDerived->enumerationList,
+                                      &isValid);
       break;
     }
 
     /* http://www.w3.org/TR/xmlschema-2/#negativeInteger */
     case nsISchemaBuiltinType::BUILTIN_TYPE_NEGATIVEINTEGER: {
-      if (maxExclusive.IsEmpty()) {
-        maxExclusive.AssignLiteral("0");
+      if (aDerived->maxExclusive.value.IsEmpty()) {
+        aDerived->maxExclusive.value.AssignLiteral("0");
+      } else if (aDerived->maxInclusive.value.IsEmpty()) {
+        aDerived->maxInclusive.value.AssignLiteral("-1");
+      }
+
+      rv = ValidateBuiltinTypeInteger(aNodeValue,
+                                      aDerived->totalDigits.value,
+                                      aDerived->maxExclusive.value,
+                                      aDerived->minExclusive.value,
+                                      aDerived->maxInclusive.value,
+                                      aDerived->minInclusive.value,
+                                      &aDerived->enumerationList,
+                                      &isValid);
+      break;
+    }
+
+    /* http://w3.org/TR/xmlschema-2/#positiveInteger */
+    case nsISchemaBuiltinType::BUILTIN_TYPE_POSITIVEINTEGER: {
+      if (aDerived->minInclusive.value.IsEmpty()) {
+        aDerived->minInclusive.value.AssignLiteral("1");
+      } else if (aDerived->minExclusive.value.IsEmpty()) {
+        aDerived->minExclusive.value.AssignLiteral("0");
+      }
+
+      rv = ValidateBuiltinTypeInteger(aNodeValue,
+                                      aDerived->totalDigits.value,
+                                      aDerived->maxExclusive.value,
+                                      aDerived->minExclusive.value,
+                                      aDerived->maxInclusive.value,
+                                      aDerived->minInclusive.value,
+                                      &aDerived->enumerationList,
+                                      &isValid);
+      break;
+    }
+
+    /* http://www.w3.org/TR/xmlschema-2/#long */
+    case nsISchemaBuiltinType::BUILTIN_TYPE_LONG: {
+      if (aDerived->maxInclusive.value.IsEmpty()) {
+        aDerived->maxInclusive.value.AssignLiteral("9223372036854775807");
+      }
+
+      if (aDerived->minInclusive.value.IsEmpty()) {
+        aDerived->minInclusive.value.AssignLiteral("-9223372036854775808");
+      }
+
+      rv = ValidateBuiltinTypeInteger(aNodeValue,
+                                      aDerived->totalDigits.value,
+                                      aDerived->maxExclusive.value,
+                                      aDerived->minExclusive.value,
+                                      aDerived->maxInclusive.value,
+                                      aDerived->minInclusive.value,
+                                      &aDerived->enumerationList,
+                                      &isValid);
+      break;
+    }
+
+    /* http://www.w3.org/TR/xmlschema-2/#int */
+    case nsISchemaBuiltinType::BUILTIN_TYPE_INT: {
+      if (aDerived->maxInclusive.value.IsEmpty()) {
+        aDerived->maxInclusive.value.AssignLiteral("2147483647");
+      }
+
+      if (aDerived->minInclusive.value.IsEmpty()) {
+        aDerived->minInclusive.value.AssignLiteral("-2147483648");
       }
 
-      if (minInclusive.IsEmpty()) {
-        minInclusive.AssignLiteral("-1");
+      rv = ValidateBuiltinTypeInteger(aNodeValue,
+                                      aDerived->totalDigits.value,
+                                      aDerived->maxExclusive.value,
+                                      aDerived->minExclusive.value,
+                                      aDerived->maxInclusive.value,
+                                      aDerived->minInclusive.value,
+                                      &aDerived->enumerationList,
+                                      &isValid);
+      break;
+    }
+
+    /* http://www.w3.org/TR/xmlschema-2/#short */
+    case nsISchemaBuiltinType::BUILTIN_TYPE_SHORT: {
+      if (aDerived->maxInclusive.value.IsEmpty()) {
+        aDerived->maxInclusive.value.AssignLiteral("32767");
+      }
+
+      if (aDerived->minInclusive.value.IsEmpty()) {
+        aDerived->minInclusive.value.AssignLiteral("-32768");
+      }
+
+      rv = ValidateBuiltinTypeInteger(aNodeValue,
+                                      aDerived->totalDigits.value,
+                                      aDerived->maxExclusive.value,
+                                      aDerived->minExclusive.value,
+                                      aDerived->maxInclusive.value,
+                                      aDerived->minInclusive.value,
+                                      &aDerived->enumerationList,
+                                      &isValid);
+      break;
+    }
+
+    /* http://www.w3.org/TR/xmlschema-2/#unsignedLong */
+    case nsISchemaBuiltinType::BUILTIN_TYPE_UNSIGNEDLONG: {
+      if (aDerived->maxInclusive.value.IsEmpty()) {
+        aDerived->maxInclusive.value.AssignLiteral("18446744073709551615");
+      }
+
+      if (aDerived->minInclusive.value.IsEmpty()) {
+        aDerived->minInclusive.value.AssignLiteral("0");
       }
 
-      rv = ValidateBuiltinTypeInteger(aNodeValue, totalDigits,maxExclusive,
-                                      minExclusive, maxInclusive, minInclusive,
-                                      &enumerationList, &isValid);
+      rv = ValidateBuiltinTypeInteger(aNodeValue,
+                                      aDerived->totalDigits.value,
+                                      aDerived->maxExclusive.value,
+                                      aDerived->minExclusive.value,
+                                      aDerived->maxInclusive.value,
+                                      aDerived->minInclusive.value,
+                                      &aDerived->enumerationList,
+                                      &isValid);
+      break;
+    }
+
+    /* http://www.w3.org/TR/xmlschema-2/#unsignedInt */
+    case nsISchemaBuiltinType::BUILTIN_TYPE_UNSIGNEDINT: {
+      if (aDerived->maxInclusive.value.IsEmpty()) {
+        aDerived->maxInclusive.value.AssignLiteral("4294967295");
+      }
+
+      if (aDerived->minInclusive.value.IsEmpty()) {
+        aDerived->minInclusive.value.AssignLiteral("0");
+      }
+
+      rv = ValidateBuiltinTypeInteger(aNodeValue,
+                                      aDerived->totalDigits.value,
+                                      aDerived->maxExclusive.value,
+                                      aDerived->minExclusive.value,
+                                      aDerived->maxInclusive.value,
+                                      aDerived->minInclusive.value,
+                                      &aDerived->enumerationList,
+                                      &isValid);
+      break;
+    }
+
+    /* http://www.w3.org/TR/xmlschema-2/#unsignedShort */
+    case nsISchemaBuiltinType::BUILTIN_TYPE_UNSIGNEDSHORT: {
+      if (aDerived->maxInclusive.value.IsEmpty()) {
+        aDerived->maxInclusive.value.AssignLiteral("65535");
+      }
+
+      if (aDerived->minInclusive.value.IsEmpty()) {
+        aDerived->minInclusive.value.AssignLiteral("0");
+      }
+
+      rv = ValidateBuiltinTypeInteger(aNodeValue,
+                                      aDerived->totalDigits.value,
+                                      aDerived->maxExclusive.value,
+                                      aDerived->minExclusive.value,
+                                      aDerived->maxInclusive.value,
+                                      aDerived->minInclusive.value,
+                                      &aDerived->enumerationList,
+                                      &isValid);
+      break;
+    }
+
+    /* http://www.w3.org/TR/xmlschema-2/#unsignedByte */
+    case nsISchemaBuiltinType::BUILTIN_TYPE_UNSIGNEDBYTE: {
+      if (aDerived->maxInclusive.value.IsEmpty()) {
+        aDerived->maxInclusive.value.AssignLiteral("255");
+      }
+
+      if (aDerived->minInclusive.value.IsEmpty()) {
+        aDerived->minInclusive.value.AssignLiteral("0");
+      }
+
+      rv = ValidateBuiltinTypeInteger(aNodeValue,
+                                      aDerived->totalDigits.value,
+                                      aDerived->maxExclusive.value,
+                                      aDerived->minExclusive.value,
+                                      aDerived->maxInclusive.value,
+                                      aDerived->minInclusive.value,
+                                      &aDerived->enumerationList,
+                                      &isValid);
       break;
     }
 
     case nsISchemaBuiltinType::BUILTIN_TYPE_BYTE: {
-      rv = ValidateBuiltinTypeByte(aNodeValue, totalDigits, maxExclusive,
-                                   minExclusive, maxInclusive, minInclusive,
-                                   &enumerationList, &isValid);
+      rv = ValidateBuiltinTypeByte(aNodeValue,
+                                   aDerived->totalDigits.value,
+                                   aDerived->maxExclusive.value,
+                                   aDerived->minExclusive.value,
+                                   aDerived->maxInclusive.value,
+                                   aDerived->minInclusive.value,
+                                   &aDerived->enumerationList,
+                                   &isValid);
       break;
     }
 
     case nsISchemaBuiltinType::BUILTIN_TYPE_FLOAT: {
-      rv = ValidateBuiltinTypeFloat(aNodeValue, totalDigits, maxExclusive,
-                                    minExclusive, maxInclusive, minInclusive,
-                                    &enumerationList, &isValid);
+      rv = ValidateBuiltinTypeFloat(aNodeValue,
+                                    aDerived->totalDigits.value,
+                                    aDerived->maxExclusive.value,
+                                    aDerived->minExclusive.value,
+                                    aDerived->maxInclusive.value,
+                                    aDerived->minInclusive.value,
+                                    &aDerived->enumerationList,
+                                    &isValid);
       break;
     }
 
     case nsISchemaBuiltinType::BUILTIN_TYPE_DECIMAL: {
-      rv = ValidateBuiltinTypeDecimal(aNodeValue, totalDigits, fractionDigits,
-                                      fractionDigitsSet, maxExclusive,
-                                      minExclusive, maxInclusive, minInclusive,
-                                      &enumerationList, &isValid);
+      rv = ValidateBuiltinTypeDecimal(aNodeValue,
+                                      aDerived->totalDigits.value,
+                                      aDerived->fractionDigits.value,
+                                      aDerived->fractionDigits.isDefined,
+                                      aDerived->maxExclusive.value,
+                                      aDerived->minExclusive.value,
+                                      aDerived->maxInclusive.value,
+                                      aDerived->minInclusive.value,
+                                      &aDerived->enumerationList,
+                                      &isValid);
       break;
     }
 
     case nsISchemaBuiltinType::BUILTIN_TYPE_ANYURI: {
-      rv = ValidateBuiltinTypeAnyURI(aNodeValue, length, minLength, maxLength,
-                                     &enumerationList, &isValid);
+      rv = ValidateBuiltinTypeAnyURI(aNodeValue,
+                                     aDerived->length.value,
+                                     aDerived->minLength.value,
+                                     aDerived->maxLength.value,
+                                     &aDerived->enumerationList,
+                                     &isValid);
       break;
     }
 
     case nsISchemaBuiltinType::BUILTIN_TYPE_BASE64BINARY: {
-      rv = ValidateBuiltinTypeBase64Binary(aNodeValue, length, isLengthDefined,
-                                           minLength, isMinLengthDefined,
-                                           maxLength, isMaxLengthDefined,
-                                           &enumerationList, &isValid);
+      rv = ValidateBuiltinTypeBase64Binary(aNodeValue,
+                                           aDerived->length.value,
+                                           aDerived->length.isDefined,
+                                           aDerived->minLength.value,
+                                           aDerived->minLength.isDefined,
+                                           aDerived->maxLength.value,
+                                           aDerived->maxLength.isDefined,
+                                           &aDerived->enumerationList,
+                                           &isValid);
+      break;
+    }
+
+    case nsISchemaBuiltinType::BUILTIN_TYPE_HEXBINARY: {
+      rv = ValidateBuiltinTypeHexBinary(aNodeValue,
+                                        aDerived->length.value,
+                                        aDerived->length.isDefined,
+                                        aDerived->minLength.value,
+                                        aDerived->minLength.isDefined,
+                                        aDerived->maxLength.value,
+                                        aDerived->maxLength.isDefined,
+                                        &aDerived->enumerationList,
+                                        &isValid);
       break;
     }
 
     case nsISchemaBuiltinType::BUILTIN_TYPE_QNAME: {
-      rv = ValidateBuiltinTypeQName(aNodeValue, length, isLengthDefined,
-                                    minLength, isMinLengthDefined,
-                                    maxLength, isMaxLengthDefined,
-                                    &enumerationList, &isValid);
+      rv = ValidateBuiltinTypeQName(aNodeValue,
+                                    aDerived->length.value,
+                                    aDerived->length.isDefined,
+                                    aDerived->minLength.value,
+                                    aDerived->minLength.isDefined,
+                                    aDerived->maxLength.value,
+                                    aDerived->maxLength.isDefined,
+                                    &aDerived->enumerationList,
+                                    &isValid);
       break;
     }
 
@@ -663,10 +904,11 @@ nsSchemaValidator::ValidateRestrictionSi
 
   // finally check if a pattern is defined, as all types can be constrained by
   // regexp patterns.
-  if (isValid && !pattern.IsEmpty()) {
+  if (isValid && aDerived->pattern.isDefined) {
     // check if the pattern matches
     nsCOMPtr<nsISchemaValidatorRegexp> regexp = do_GetService(kREGEXP_CID);
-    rv = regexp->RunRegexp(aNodeValue, pattern, "g", &isValid);
+    rv = regexp->RunRegexp(aNodeValue, aDerived->pattern.value, "g", &isValid);
+    NS_ENSURE_SUCCESS(rv, rv);
 
 #ifdef PR_LOGGING
     LOG(("  Checking Regular Expression"));
@@ -703,12 +945,37 @@ nsSchemaValidator::ValidateBuiltinType(c
 #endif
 
   PRBool isValid = PR_FALSE;
+
   switch(builtinTypeValue) {
     case nsISchemaBuiltinType::BUILTIN_TYPE_STRING: {
       isValid = PR_TRUE;
       break;
     }
 
+    case nsISchemaBuiltinType::BUILTIN_TYPE_NORMALIZED_STRING: {
+      if (nsSchemaValidatorUtils::IsValidSchemaNormalizedString(aNodeValue)) {
+        rv = ValidateBuiltinTypeString(aNodeValue, 0, PR_FALSE, 0, PR_FALSE, 0,
+                                       PR_FALSE, nsnull, &isValid);
+      }
+      break;
+    }
+
+    case nsISchemaBuiltinType::BUILTIN_TYPE_TOKEN: {
+      if (nsSchemaValidatorUtils::IsValidSchemaToken(aNodeValue)) {
+        rv = ValidateBuiltinTypeString(aNodeValue, 0, PR_FALSE, 0, PR_FALSE, 0,
+                                       PR_FALSE, nsnull, &isValid);
+      }
+      break;
+    }
+
+    case nsISchemaBuiltinType::BUILTIN_TYPE_LANGUAGE: {
+      if (nsSchemaValidatorUtils::IsValidSchemaLanguage(aNodeValue)) {
+        rv = ValidateBuiltinTypeString(aNodeValue, 0, PR_FALSE, 0, PR_FALSE, 0,
+                                       PR_FALSE, nsnull, &isValid);
+      }
+      break;
+    }
+
     case nsISchemaBuiltinType::BUILTIN_TYPE_BOOLEAN: {
       rv = ValidateBuiltinTypeBoolean(aNodeValue, &isValid);
       break;
@@ -767,24 +1034,105 @@ nsSchemaValidator::ValidateBuiltinType(c
 
     /* http://w3.org/TR/xmlschema-2/#nonPositiveInteger */
     case nsISchemaBuiltinType::BUILTIN_TYPE_NONPOSITIVEINTEGER: {
-      // nonPositiveInteger inherits from integer, with maxExclusive
-      // being 1
-      ValidateBuiltinTypeInteger(aNodeValue, nsnull, NS_LITERAL_STRING("1"),
-                                 EmptyString(), EmptyString(), EmptyString(),
-                                 nsnull, &isValid);
+      // nonPositiveInteger inherits from integer, with maxInclusive
+      // being 0
+      ValidateBuiltinTypeInteger(aNodeValue, nsnull, EmptyString(),
+                                 EmptyString(), NS_LITERAL_STRING("0"),
+                                 EmptyString(), nsnull, &isValid);
       break;
     }
 
     /* http://www.w3.org/TR/xmlschema-2/#negativeInteger */
     case nsISchemaBuiltinType::BUILTIN_TYPE_NEGATIVEINTEGER: {
-      // negativeInteger inherits from integer, with maxExclusive
-      // being 0 (only negative numbers)
-      ValidateBuiltinTypeInteger(aNodeValue, nsnull, NS_LITERAL_STRING("0"),
-                                 EmptyString(), EmptyString(), EmptyString(),
-                                 nsnull, &isValid);
+      // negativeInteger inherits from integer, with maxInclusive
+      // being -1 (only negative integers)
+      ValidateBuiltinTypeInteger(aNodeValue, nsnull, EmptyString(),
+                                 EmptyString(), NS_LITERAL_STRING("-1"),
+                                 EmptyString(), nsnull, &isValid);
       break;
     }
 
+    /* http://w3.org/TR/xmlschema-2/#positiveInteger */
+    case nsISchemaBuiltinType::BUILTIN_TYPE_POSITIVEINTEGER: {
+      // positiveInteger inherits from integer, with minInclusive
+      // being 1
+      ValidateBuiltinTypeInteger(aNodeValue, nsnull, EmptyString(),
+                                 EmptyString(), EmptyString(),
+                                 NS_LITERAL_STRING("1"), nsnull, &isValid);
+      break;
+    }
+
+    /* http://www.w3.org/TR/xmlschema-2/#long */
+    case nsISchemaBuiltinType::BUILTIN_TYPE_LONG: {
+      // maxInclusive is 9223372036854775807 and minInclusive is
+      // -9223372036854775808
+      ValidateBuiltinTypeInteger(aNodeValue, nsnull,
+                                 EmptyString(), EmptyString(),
+                                 NS_LITERAL_STRING("9223372036854775807"),
+                                 NS_LITERAL_STRING("-9223372036854775808"),
+                                 nsnull, &isValid);
+    }
+
+    /* http://www.w3.org/TR/xmlschema-2/#int */
+    case nsISchemaBuiltinType::BUILTIN_TYPE_INT: {
+      // maxInclusive is 2147483647 and minInclusive is -2147483648
+      ValidateBuiltinTypeInteger(aNodeValue, nsnull,
+                                 EmptyString(), EmptyString(),
+                                 NS_LITERAL_STRING("2147483647"),
+                                 NS_LITERAL_STRING("-2147483648"),
+                                 nsnull, &isValid);
+    }
+
+    /* http://www.w3.org/TR/xmlschema-2/#short */
+    case nsISchemaBuiltinType::BUILTIN_TYPE_SHORT: {
+      // maxInclusive is 32767 and minInclusive is -32768
+      ValidateBuiltinTypeInteger(aNodeValue, nsnull,
+                                 EmptyString(), EmptyString(),
+                                 NS_LITERAL_STRING("32767"),
+                                 NS_LITERAL_STRING("-32768"),
+                                 nsnull, &isValid);
+    }
+
+    /* http://www.w3.org/TR/xmlschema-2/#unsignedLong */
+    case nsISchemaBuiltinType::BUILTIN_TYPE_UNSIGNEDLONG: {
+      // maxInclusive is 18446744073709551615. and minInclusive is 0
+      ValidateBuiltinTypeInteger(aNodeValue, nsnull,
+                                 EmptyString(), EmptyString(),
+                                 NS_LITERAL_STRING("18446744073709551615"),
+                                 NS_LITERAL_STRING("0"),
+                                 nsnull, &isValid);
+    }
+
+    /* http://www.w3.org/TR/xmlschema-2/#unsignedInt */
+    case nsISchemaBuiltinType::BUILTIN_TYPE_UNSIGNEDINT: {
+      // maxInclusive is 4294967295. and minInclusive is 0
+      ValidateBuiltinTypeInteger(aNodeValue, nsnull,
+                                 EmptyString(), EmptyString(),
+                                 NS_LITERAL_STRING("4294967295"),
+                                 NS_LITERAL_STRING("0"),
+                                 nsnull, &isValid);
+    }
+
+    /* http://www.w3.org/TR/xmlschema-2/#unsignedShort */
+    case nsISchemaBuiltinType::BUILTIN_TYPE_UNSIGNEDSHORT: {
+      // maxInclusive is 65535. and minInclusive is 0
+      ValidateBuiltinTypeInteger(aNodeValue, nsnull,
+                                 EmptyString(), EmptyString(),
+                                 NS_LITERAL_STRING("65535"),
+                                 NS_LITERAL_STRING("0"),
+                                 nsnull, &isValid);
+    }
+
+    /* http://www.w3.org/TR/xmlschema-2/#unsignedByte */
+    case nsISchemaBuiltinType::BUILTIN_TYPE_UNSIGNEDBYTE: {
+      // maxInclusive is 255. and minInclusive is 0
+      ValidateBuiltinTypeInteger(aNodeValue, nsnull,
+                                 EmptyString(), EmptyString(),
+                                 NS_LITERAL_STRING("255"),
+                                 NS_LITERAL_STRING("0"),
+                                 nsnull, &isValid);
+    }
+
     case nsISchemaBuiltinType::BUILTIN_TYPE_BYTE: {
       isValid = IsValidSchemaByte(aNodeValue, nsnull);
       break;
@@ -813,6 +1161,11 @@ nsSchemaValidator::ValidateBuiltinType(c
       break;
     }
 
+    case nsISchemaBuiltinType::BUILTIN_TYPE_HEXBINARY: {
+      isValid = IsValidSchemaHexBinary(aNodeValue);
+      break;
+    }
+
     case nsISchemaBuiltinType::BUILTIN_TYPE_QNAME: {
       isValid = IsValidSchemaQName(aNodeValue);
       break;
@@ -831,8 +1184,16 @@ nsSchemaValidator::ValidateBuiltinType(c
 nsresult
 nsSchemaValidator::ValidateListSimpletype(const nsAString & aNodeValue,
                                           nsISchemaSimpleType *aSchemaSimpleType,
+                                          nsSchemaDerivedSimpleType *aFacets,
                                           PRBool *aResult)
 {
+ /* When a datatype is derived from an list datatype, the following facets apply:
+  * length, maxLength, minLength, enumeration, pattern, whitespace
+  *
+  * The length facets apply to the whole list, ie the number of items in the list.
+  * Patterns are applied to the whole list as well.
+  */
+
   PRBool isValid = PR_FALSE;
 
   nsresult rv;
@@ -847,16 +1208,68 @@ nsSchemaValidator::ValidateListSimpletyp
     nsCStringArray stringArray;
     stringArray.ParseString(NS_ConvertUTF16toUTF8(aNodeValue).get(), " \t\r\n");
 
-    PRInt32 count = stringArray.Count();
-    nsAutoString tmp;
+    PRUint32 count = stringArray.Count();
 
-    for (PRInt32 i=0; i < count; ++i) {
-      CopyUTF8toUTF16(stringArray[i]->get(), tmp);
-      LOG(("  Validating List Item (%d): %s", i, NS_ConvertUTF16toUTF8(tmp).get()));
-      rv = ValidateSimpletype(tmp, listSimpleType, &isValid);
+    // if facets have been provided, check them first
+    PRBool facetsValid = PR_TRUE;
+    if (aFacets) {
+      if (aFacets->length.isDefined) {
+        if (aFacets->length.value != count) {
+          facetsValid = PR_FALSE;
+          LOG(("  Not valid: List is not the right length (%d)",
+               aFacets->length.value));
+        }
+      }
+
+      if (facetsValid && aFacets->maxLength.isDefined) {
+        if (aFacets->maxLength.value < count) {
+          facetsValid = PR_FALSE;
+          LOG(("  Not valid: Length (%d) of the list is too large",
+               aFacets->maxLength.value));
+        }
+      }
 
-      if (!isValid)
-        break;
+      if (facetsValid && aFacets->minLength.isDefined) {
+        if (aFacets->minLength.value > count) {
+          facetsValid = PR_FALSE;
+          LOG(("  Not valid: Length (%d) of the list is too small",
+               aFacets->minLength.value));
+        }
+      }
+
+      if (facetsValid && aFacets->pattern.isDefined) {
+        // check if the pattern matches
+        nsCOMPtr<nsISchemaValidatorRegexp> regexp = do_GetService(kREGEXP_CID);
+        rv = regexp->RunRegexp(aNodeValue, aFacets->pattern.value, "g",
+                               &facetsValid);
+#ifdef PR_LOGGING
+        LOG(("  Checking Regular Expression"));
+        if (facetsValid) {
+          LOG(("    -- pattern validates!"));
+        } else {
+          LOG(("    -- pattern does not validate!"));
+        }
+#endif
+      }
+
+      if (facetsValid && aFacets->enumerationList.Count() > 0) {
+        facetsValid =
+          nsSchemaValidatorUtils::HandleEnumeration(aNodeValue,
+                                                    aFacets->enumerationList);
+      }
+    }
+
+    // either no facets passed in or facets validated fine
+    if (facetsValid) {
+      nsAutoString tmp;
+      for (PRUint32 i=0; i < count; ++i) {
+        CopyUTF8toUTF16(stringArray[i]->get(), tmp);
+        LOG(("  Validating List Item (%d): %s", i, NS_ConvertUTF16toUTF8(tmp).get()));
+        rv = ValidateSimpletype(tmp, listSimpleType, &isValid);
+
+        if (!isValid)
+          break;
+      }
     }
   }
 
@@ -873,7 +1286,8 @@ nsSchemaValidator::ValidateUnionSimplety
   PRBool isValid = PR_FALSE;
 
   nsresult rv;
-  nsCOMPtr<nsISchemaUnionType> unionType = do_QueryInterface(aSchemaSimpleType, &rv);
+  nsCOMPtr<nsISchemaUnionType> unionType = do_QueryInterface(aSchemaSimpleType,
+                                                             &rv);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsISchemaSimpleType> unionSimpleType;
@@ -896,6 +1310,50 @@ nsSchemaValidator::ValidateUnionSimplety
   return rv;
 }
 
+nsresult
+nsSchemaValidator::ValidateDerivedUnionSimpletype(const nsAString & aNodeValue,
+                                                  nsSchemaDerivedSimpleType *aDerived,
+                                                  PRBool *aResult)
+{
+  // This method is called when a simple type is derived from a union type
+  // via restrictions.  So we walk all the possible types, and pass in the
+  // loaded restriction facets so that they will override the ones defined
+  // my the union type.  We actually have to create a custom
+  // nsSchemaDerivedSimpleType for each type, since we need to change the basetype
+  // and to avoid any new restrictions being added to aDerived.
+
+  PRBool isValid = PR_FALSE;
+
+  nsresult rv;
+  nsCOMPtr<nsISchemaUnionType> unionType = do_QueryInterface(aDerived->mBaseType,
+                                                             &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsCOMPtr<nsISchemaSimpleType> unionSimpleType;
+  PRUint32 count;
+  unionType->GetUnionTypeCount(&count);
+
+  // compare against the union simpletypes in order until a match is found
+  for (PRUint32 i=0; i < count; ++i) {
+    rv = unionType->GetUnionType(i, getter_AddRefs(unionSimpleType));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsSchemaDerivedSimpleType derivedType;
+    nsSchemaValidatorUtils::CopyDerivedSimpleType(&derivedType, aDerived);
+
+    derivedType.mBaseType = unionSimpleType;
+
+    LOG(("  Validating Union Type #%d", i));
+    rv = ValidateDerivedSimpletype(aNodeValue, &derivedType, &isValid);
+
+    if (isValid)
+      break;
+  }
+
+  *aResult = isValid;
+  return rv;
+}
+
 /* http://www.w3.org/TR/xmlschema-2/#string */
 nsresult
 nsSchemaValidator::ValidateBuiltinTypeString(const nsAString & aNodeValue,
@@ -929,7 +1387,8 @@ nsSchemaValidator::ValidateBuiltinTypeSt
   }
 
   if (isValid && aEnumerationList && (aEnumerationList->Count() > 0)) {
-    isValid = nsSchemaValidatorUtils::HandleEnumeration(aNodeValue, *aEnumerationList);
+    isValid = nsSchemaValidatorUtils::HandleEnumeration(aNodeValue,
+                                                        *aEnumerationList);
   }
 
 #ifdef PR_LOGGING
@@ -2638,10 +3097,9 @@ PRBool
 nsSchemaValidator::IsValidSchemaAnyURI(const nsAString & aString)
 {
   PRBool isValid = PR_FALSE;
-  nsresult rv;
 
   nsCOMPtr<nsIURI> uri;
-  rv = NS_NewURI(getter_AddRefs(uri), aString);
+  nsresult rv = NS_NewURI(getter_AddRefs(uri), aString);
 
   if (rv == NS_OK)
     isValid = PR_TRUE;
@@ -2777,6 +3235,83 @@ nsSchemaValidator::IsValidSchemaQName(co
   return isValid;
 }
 
+// http://www.w3.org/TR/xmlschema-2/#hexBinary
+nsresult
+nsSchemaValidator::ValidateBuiltinTypeHexBinary(const nsAString & aNodeValue,
+                                                PRUint32 aLength,
+                                                PRBool aLengthDefined,
+                                                PRUint32 aMinLength,
+                                                PRBool aMinLengthDefined,
+                                                PRUint32 aMaxLength,
+                                                PRBool aMaxLengthDefined,
+                                                nsStringArray *aEnumerationList,
+                                                PRBool *aResult)
+{
+  PRBool isValid = PR_FALSE;
+
+  isValid = IsValidSchemaHexBinary(aNodeValue);
+
+  if (isValid) {
+    // For hexBinary, length is measured in octets (8 bits) of binary data.  So
+    // one byte of binary data is represented by two hex digits, so we
+    // divide by 2 to get the binary data length.
+
+    PRUint32 binaryDataLength = aNodeValue.Length() / 2;
+
+    if (aLengthDefined && (binaryDataLength != aLength)) {
+      isValid = PR_FALSE;
+      LOG(("  Not valid: Not the right length (%d)", binaryDataLength));
+    }
+
+    if (isValid && aMinLengthDefined && (binaryDataLength < aMinLength)) {
+      isValid = PR_FALSE;
+      LOG(("  Not valid: Length (%d) is too small", binaryDataLength));
+    }
+
+    if (isValid && aMaxLengthDefined && (binaryDataLength > aMaxLength)) {
+      isValid = PR_FALSE;
+      LOG(("  Not valid: Length (%d) is too large", binaryDataLength));
+    }
+
+    if (isValid && aEnumerationList && (aEnumerationList->Count() > 0)) {
+      isValid = nsSchemaValidatorUtils::HandleEnumeration(aNodeValue, *aEnumerationList);
+    }
+  }
+
+  LOG((isValid ? ("  Value is valid!") : ("  Value is not valid!")));
+
+  *aResult = isValid;
+  return NS_OK;
+}
+
+PRBool
+nsSchemaValidator::IsValidSchemaHexBinary(const nsAString & aString)
+{
+  // hex binary length has to be even
+  PRUint32 length = aString.Length();
+
+  if (length % 2 != 0) 
+    return PR_FALSE;
+
+  nsAString::const_iterator start, end;
+  aString.BeginReading(start);
+  aString.EndReading(end);
+
+  PRBool isValid = PR_TRUE;
+
+  // each character has to be in [0-9a-fA-F]
+  while (start != end) {
+    PRUnichar temp = *start++;
+
+    if (!isxdigit(temp)) {
+      isValid = PR_FALSE;
+      break;
+    }
+  }
+
+  return isValid;
+}
+
 #ifdef DEBUG
 void
 nsSchemaValidator::DumpBaseType(nsISchemaBuiltinType *aBuiltInType)
diff -uprN --exclude=CVS mozilla/extensions/schema-validation/src/nsSchemaValidator.h mozilla.new/extensions/schema-validation/src/nsSchemaValidator.h
--- mozilla/extensions/schema-validation/src/nsSchemaValidator.h	2005-06-24 17:38:12.000000000 +0200
+++ mozilla.new/extensions/schema-validation/src/nsSchemaValidator.h	2006-03-03 07:12:23.000000000 +0100
@@ -48,7 +48,7 @@
 /* eced2af3-fde9-4575-b5a4-e1c830b24611 */
 #define NS_SCHEMAVALIDATOR_CID \
 { 0xeced2af3, 0xfde9, 0x4575, \
-  {0xb5, 0xa4, 0xe1, 0xc8, 0x30, 0xb2, 0x46, 0x11}}     
+  {0xb5, 0xa4, 0xe1, 0xc8, 0x30, 0xb2, 0x46, 0x11}}
 
 #define NS_SCHEMAVALIDATOR_CONTRACTID "@mozilla.org/schemavalidator;1"
 
@@ -72,10 +72,16 @@ private:
   nsresult ValidateSimpletype(const nsAString & aNodeValue,
                               nsISchemaSimpleType *aSchemaSimpleType,
                               PRBool *aResult);
+  nsresult ValidateDerivedSimpletype(const nsAString & aNodeValue,
+                                     nsSchemaDerivedSimpleType *aDerived,
+                                     PRBool *aResult);
 
   nsresult ValidateRestrictionSimpletype(const nsAString & aNodeValue,
                                          nsISchemaSimpleType *aSchemaSimpleType,
                                          PRBool *aResult);
+  nsresult ValidateDerivedBuiltinType(const nsAString & aNodeValue,
+                                      nsSchemaDerivedSimpleType *aDerived,
+                                      PRBool *aResult);
 
   nsresult ValidateBuiltinType(const nsAString & aNodeValue,
                                nsISchemaSimpleType *aSchemaSimpleType,
@@ -83,11 +89,15 @@ private:
 
   nsresult ValidateListSimpletype(const nsAString & aNodeValue,
                                   nsISchemaSimpleType *aSchemaSimpleType,
+                                  nsSchemaDerivedSimpleType *aDerived,
                                   PRBool *aResult);
 
   nsresult ValidateUnionSimpletype(const nsAString & aNodeValue,
                                    nsISchemaSimpleType *aSchemaSimpleType,
                                    PRBool *aResult);
+  nsresult ValidateDerivedUnionSimpletype(const nsAString & aNodeValue,
+                                          nsSchemaDerivedSimpleType *aDerived,
+                                          PRBool *aResult);
 
   // methods dealing with validation of built-in types
   nsresult ValidateBuiltinTypeString(const nsAString & aNodeValue,
@@ -238,6 +248,19 @@ private:
                                            PRBool *aResult);
   PRBool IsValidSchemaBase64Binary(const nsAString & aString, char** aDecodedString);
 
+
+  nsresult ValidateBuiltinTypeHexBinary(const nsAString & aNodeValue,
+                                        PRUint32 aLength,
+                                        PRBool aLengthDefined,
+                                        PRUint32 aMinLength,
+                                        PRBool aMinLengthDefined,
+                                        PRUint32 aMaxLength,
+                                        PRBool aMaxLengthDefined,
+                                        nsStringArray *aEnumerationList,
+                                        PRBool *aResult);
+  PRBool IsValidSchemaHexBinary(const nsAString & aString);
+
+
   nsresult ValidateBuiltinTypeQName(const nsAString & aNodeValue,
                                     PRUint32 aLength,
                                     PRBool aLengthDefined,
@@ -249,7 +272,6 @@ private:
                                     PRBool *aResult);
   PRBool IsValidSchemaQName(const nsAString & aString);
 
-
   // helper methods
   void DumpBaseType(nsISchemaBuiltinType *aBuiltInType);
 
diff -uprN --exclude=CVS mozilla/extensions/schema-validation/src/nsSchemaValidatorUtils.cpp mozilla.new/extensions/schema-validation/src/nsSchemaValidatorUtils.cpp
--- mozilla/extensions/schema-validation/src/nsSchemaValidatorUtils.cpp	2005-10-14 21:47:41.000000000 +0200
+++ mozilla.new/extensions/schema-validation/src/nsSchemaValidatorUtils.cpp	2006-03-03 07:12:24.000000000 +0100
@@ -87,8 +87,7 @@ nsSchemaValidatorUtils::IsValidSchemaInt
   if (aResult)
     *aResult = intValue;
 
-  return (!((intValue == LONG_MAX || intValue == LONG_MIN) && errno == ERANGE))
-         && *pEnd == '\0';
+  return (*pEnd == '\0');
 }
 
 PRBool
@@ -307,7 +306,7 @@ nsSchemaValidatorUtils::ParseSchemaDate(
     fullDate.AppendLiteral("-");
     fullDate.Append(year);
 
-    LOG(("\n      Parsed date is %s", NS_ConvertUTF16toUTF8(fullDate).get()));
+    LOG(("      Parsed date is %s", NS_ConvertUTF16toUTF8(fullDate).get()));
 
     PRStatus status = PR_ParseTimeString(NS_ConvertUTF16toUTF8(fullDate).get(),
                                          PR_TRUE, &dateTime);
@@ -334,7 +333,7 @@ nsSchemaValidatorUtils::ParseSchemaDate(
     }
   }
 
-  LOG(("\n      Date is %s \n", ((isValid) ? "Valid" : "Not Valid")));
+  LOG(("      Date is %s", ((isValid) ? "Valid" : "Not Valid")));
 
   return isValid;
 }
@@ -1177,6 +1176,7 @@ nsSchemaValidatorUtils::CompareDurations
   PRTime foo;
   PRExplodedTime explodedTime, newTime1, newTime2;
 
+  // XXX: nspr doesn't handle pre-1900 dates and will return an error!
   char* datetimeArray[] = { "1696-09-01T00:00:00Z", "1697-02-01T00:00:00Z",
                             "1903-03-01T00:00:00Z", "1903-07-01T00:00:00Z" };
   PRBool indeterminate = PR_FALSE;
@@ -1294,6 +1294,56 @@ nsSchemaValidatorUtils::AddDurationToDat
   return resultDatetime;
 }
 
+// http://www.w3.org/TR/xmlschema-2/#normalizedString
+PRBool
+nsSchemaValidatorUtils::IsValidSchemaNormalizedString(const nsAString &aStrValue)
+{
+  PRBool isValid = PR_FALSE;
+  nsAutoString string(aStrValue);
+
+  // may not contain carriage return, line feed nor tab characters
+  if (string.FindCharInSet("\t\r\n") == kNotFound)
+    isValid = PR_TRUE;
+
+  return isValid;
+}
+
+// http://www.w3.org/TR/xmlschema-2/#token
+PRBool
+nsSchemaValidatorUtils::IsValidSchemaToken(const nsAString &aStrValue)
+{
+  PRBool isValid = PR_FALSE;
+  nsAutoString string(aStrValue);
+
+  // may not contain carriage return, line feed, tab characters.  Also can
+  // not contain leading/trailing whitespace and no internal sequences of
+  // two or more spaces.
+  if ((string.FindCharInSet("\t\r\n") == kNotFound) &&
+      (string.Find(NS_LITERAL_STRING("  ")) == kNotFound) &&
+      (string.First() != ' ') &&
+      (string.Last() != ' '))
+    isValid = PR_TRUE;
+
+  return isValid;
+}
+
+// http://www.w3.org/TR/xmlschema-2/#language
+PRBool
+nsSchemaValidatorUtils::IsValidSchemaLanguage(const nsAString &aStrValue)
+{
+  PRBool isValid = PR_FALSE;
+
+  // pattern is defined in spec
+  nsAutoString pattern;
+  pattern.AssignLiteral("[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*");
+
+  nsCOMPtr<nsISchemaValidatorRegexp> regexp = do_GetService(kREGEXP_CID);
+  nsresult rv = regexp->RunRegexp(aStrValue, pattern, "g", &isValid);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  return isValid;
+}
+
 PRBool
 nsSchemaValidatorUtils::HandleEnumeration(const nsAString &aStrValue,
                                           const nsStringArray &aEnumerationList)
@@ -1305,6 +1355,7 @@ nsSchemaValidatorUtils::HandleEnumeratio
   for (PRInt32 i = 0; i < count; ++i) {
     if (aEnumerationList[i]->Equals(aStrValue)) {
       isValid = PR_TRUE;
+      LOG(("  Valid: Value matched enumeration #%d", i));
       break;
     }
   }
@@ -1378,3 +1429,249 @@ nsSchemaValidatorUtils::RemoveTrailingZe
   aString.Cut(length - count, count);
 }
 
+// Walks the inheritance tree until it finds a type that isn't a restriction
+// type.  While it finds restriction types, it collects restriction facets and
+// places them into the nsSchemaDerivedSimpleType.  Once a facet has been found,
+// it makes sure that it won't be overwritten by the same facet defined in one
+// of the inherited types.
+nsresult
+nsSchemaValidatorUtils::GetDerivedSimpleType(nsISchemaSimpleType *aSimpleType,
+                                             nsSchemaDerivedSimpleType *aDerived)
+{
+  PRBool done = PR_FALSE, hasEnumerations = PR_FALSE;
+  nsCOMPtr<nsISchemaSimpleType> simpleType(aSimpleType);
+  PRUint16 simpleTypeValue;
+  PRUint32 facetCount;
+
+  nsAutoString enumeration;
+  nsresult rv = NS_OK;
+
+  while(simpleType && !done) {
+    // get the type of the simpletype
+    rv = simpleType->GetSimpleType(&simpleTypeValue);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    switch (simpleTypeValue) {
+      case nsISchemaSimpleType::SIMPLE_TYPE_RESTRICTION: {
+        // handle the facets
+
+        nsCOMPtr<nsISchemaRestrictionType> restrictionType =
+          do_QueryInterface(simpleType);
+
+        nsCOMPtr<nsISchemaFacet> facet;
+        PRUint32 facetCounter;
+        PRUint16 facetType;
+
+        // get the amount of restriction facet defined.
+        rv = restrictionType->GetFacetCount(&facetCount);
+        NS_ENSURE_SUCCESS(rv, rv);
+        LOG(("    %d facet(s) defined.", facetCount));
+
+        // if we had enumerations, we may not add new ones, since we are
+        // being restricted. So if x restricts y, x defines the possible
+        // enumerations and any enumerations on y are skipped
+        hasEnumerations = (aDerived->enumerationList.Count() > 0);
+
+        for (facetCounter = 0; facetCounter < facetCount; ++facetCounter) {
+          rv = restrictionType->GetFacet(facetCounter, getter_AddRefs(facet));
+          NS_ENSURE_SUCCESS(rv, rv);
+          facet->GetFacetType(&facetType);
+
+          switch (facetType) {
+            case nsISchemaFacet::FACET_TYPE_LENGTH: {
+              nsSchemaIntFacet *length = &aDerived->length;
+              if (!length->isDefined) {
+                length->isDefined = PR_TRUE;
+                facet->GetLengthValue(&length->value);
+                LOG(("  - Length Facet found (value is %d)",
+                     length->value));
+              }
+              break;
+            }
+
+            case nsISchemaFacet::FACET_TYPE_MINLENGTH: {
+              nsSchemaIntFacet *minLength = &aDerived->minLength;
+              if (!minLength->isDefined) {
+                minLength->isDefined = PR_TRUE;
+                facet->GetLengthValue(&minLength->value);
+                LOG(("  - Min Length Facet found (value is %d)",
+                     minLength->value));
+              }
+              break;
+            }
+
+            case nsISchemaFacet::FACET_TYPE_MAXLENGTH: {
+              nsSchemaIntFacet *maxLength = &aDerived->maxLength;
+              if (!maxLength->isDefined) {
+                maxLength->isDefined = PR_TRUE;
+                facet->GetLengthValue(&maxLength->value);
+                LOG(("  - Max Length Facet found (value is %d)",
+                     maxLength->value));
+              }
+              break;
+            }
+
+            case nsISchemaFacet::FACET_TYPE_PATTERN: {
+              nsSchemaStringFacet *pattern = &aDerived->pattern;
+              if (!pattern->isDefined) {
+                pattern->isDefined = PR_TRUE;
+                facet->GetValue(pattern->value);
+                LOG(("  - Pattern Facet found (value is %s)",
+                      NS_ConvertUTF16toUTF8(pattern->value).get()));
+              }
+              break;
+            }
+
+            case nsISchemaFacet::FACET_TYPE_ENUMERATION: {
+              if (!hasEnumerations) {
+                facet->GetValue(enumeration);
+                aDerived->enumerationList.AppendString(enumeration);
+                LOG(("  - Enumeration found (%s)",
+                  NS_ConvertUTF16toUTF8(enumeration).get()));
+              }
+              break;
+            }
+
+            case nsISchemaFacet::FACET_TYPE_WHITESPACE: {
+              if (!aDerived->isWhitespaceDefined)
+                facet->GetWhitespaceValue(&aDerived->whitespace);
+              break;
+            }
+
+            case nsISchemaFacet::FACET_TYPE_MAXINCLUSIVE: {
+              nsSchemaStringFacet *maxInclusive = &aDerived->maxInclusive;
+              if (!maxInclusive->isDefined) {
+                maxInclusive->isDefined = PR_TRUE;
+                facet->GetValue(maxInclusive->value);
+                LOG(("  - Max Inclusive Facet found (value is %s)",
+                  NS_ConvertUTF16toUTF8(maxInclusive->value).get()));
+              }
+              break;
+            }
+
+            case nsISchemaFacet::FACET_TYPE_MININCLUSIVE: {
+              nsSchemaStringFacet *minInclusive = &aDerived->minInclusive;
+              if (!minInclusive->isDefined) {
+                minInclusive->isDefined = PR_TRUE;
+                facet->GetValue(minInclusive->value);
+                LOG(("  - Min Inclusive Facet found (value is %s)",
+                  NS_ConvertUTF16toUTF8(minInclusive->value).get()));
+              }
+              break;
+            }
+
+            case nsISchemaFacet::FACET_TYPE_MAXEXCLUSIVE: {
+              nsSchemaStringFacet *maxExclusive = &aDerived->maxExclusive;
+              if (!maxExclusive->isDefined) {
+                maxExclusive->isDefined = PR_TRUE;
+                facet->GetValue(aDerived->maxExclusive.value);
+                LOG(("  - Max Exclusive Facet found (value is %s)",
+                  NS_ConvertUTF16toUTF8(maxExclusive->value).get()));
+              }
+              break;
+            }
+
+            case nsISchemaFacet::FACET_TYPE_MINEXCLUSIVE: {
+              nsSchemaStringFacet *minExclusive = &aDerived->minExclusive;
+              if (!minExclusive->isDefined) {
+                minExclusive->isDefined = PR_TRUE;
+                facet->GetValue(minExclusive->value);
+                LOG(("  - Min Exclusive Facet found (value is %s)",
+                  NS_ConvertUTF16toUTF8(minExclusive->value).get()));
+              }
+              break;
+            }
+
+            case nsISchemaFacet::FACET_TYPE_TOTALDIGITS: {
+              nsSchemaIntFacet *totalDigits = &aDerived->totalDigits;
+              if (!totalDigits->isDefined) {
+                totalDigits->isDefined = PR_TRUE;
+                facet->GetDigitsValue(&totalDigits->value);
+                LOG(("  - Totaldigits Facet found (value is %d)",
+                     totalDigits->value));
+              }
+              break;
+            }
+
+            case nsISchemaFacet::FACET_TYPE_FRACTIONDIGITS: {
+              nsSchemaIntFacet *fractionDigits = &aDerived->fractionDigits;
+              if (!fractionDigits->isDefined) {
+                fractionDigits->isDefined = PR_TRUE;
+                facet->GetDigitsValue(&fractionDigits->value);
+                LOG(("  - FractionDigits Facet found (value is %d)",
+                     fractionDigits->value));
+              }
+              break;
+            }
+          }
+        }
+
+        // get base type
+        nsresult rv = restrictionType->GetBaseType(getter_AddRefs(simpleType));
+        NS_ENSURE_SUCCESS(rv, rv);
+        break;
+      }
+
+      case nsISchemaSimpleType::SIMPLE_TYPE_BUILTIN: {
+        // we are done
+        aDerived->mBaseType = simpleType;
+        done = PR_TRUE;
+        break;
+      }
+
+      case nsISchemaSimpleType::SIMPLE_TYPE_LIST: {
+        // set as base type
+        aDerived->mBaseType = simpleType;
+        done = PR_TRUE;
+        break;
+      }
+
+      case nsISchemaSimpleType::SIMPLE_TYPE_UNION: {
+        // set as base type
+        aDerived->mBaseType = simpleType;
+        done = PR_TRUE;
+        break;
+      }
+    }
+  }
+
+  return rv;
+}
+
+// copies the data from aDerivedSrc to aDerivedDest
+void
+nsSchemaValidatorUtils::CopyDerivedSimpleType(nsSchemaDerivedSimpleType *aDerivedDest,
+                                              nsSchemaDerivedSimpleType *aDerivedSrc)
+{
+  aDerivedDest->mBaseType = aDerivedSrc->mBaseType;
+
+  aDerivedDest->length.value = aDerivedSrc->length.value;
+  aDerivedDest->length.isDefined = aDerivedSrc->length.isDefined;
+  aDerivedDest->minLength.value = aDerivedSrc->minLength.value;
+  aDerivedDest->minLength.isDefined = aDerivedSrc->minLength.isDefined;
+  aDerivedDest->maxLength.value = aDerivedSrc->maxLength.value;
+  aDerivedDest->maxLength.isDefined = aDerivedSrc->maxLength.isDefined;
+
+  aDerivedDest->pattern.value = aDerivedSrc->pattern.value;
+  aDerivedDest->pattern.isDefined = aDerivedSrc->pattern.isDefined;
+
+  aDerivedDest->isWhitespaceDefined = aDerivedSrc->isWhitespaceDefined;
+  aDerivedDest->whitespace = aDerivedSrc->whitespace;
+
+  aDerivedDest->maxInclusive.value = aDerivedSrc->maxInclusive.value;
+  aDerivedDest->maxInclusive.isDefined = aDerivedSrc->maxInclusive.isDefined;
+  aDerivedDest->minInclusive.value = aDerivedSrc->minInclusive.value;
+  aDerivedDest->minInclusive.isDefined = aDerivedSrc->minInclusive.isDefined;
+  aDerivedDest->maxExclusive.value = aDerivedSrc->maxExclusive.value;
+  aDerivedDest->maxExclusive.isDefined = aDerivedSrc->maxExclusive.isDefined;
+  aDerivedDest->minExclusive.value = aDerivedSrc->minExclusive.value;
+  aDerivedDest->minExclusive.isDefined = aDerivedSrc->minExclusive.isDefined;
+
+  aDerivedDest->totalDigits.value = aDerivedSrc->totalDigits.value;
+  aDerivedDest->totalDigits.isDefined = aDerivedSrc->totalDigits.isDefined;
+  aDerivedDest->fractionDigits.value = aDerivedSrc->fractionDigits.value;
+  aDerivedDest->fractionDigits.isDefined = aDerivedSrc->fractionDigits.isDefined;
+
+  aDerivedDest->enumerationList = aDerivedSrc->enumerationList;
+}
+
diff -uprN --exclude=CVS mozilla/extensions/schema-validation/src/nsSchemaValidatorUtils.h mozilla.new/extensions/schema-validation/src/nsSchemaValidatorUtils.h
--- mozilla/extensions/schema-validation/src/nsSchemaValidatorUtils.h	2005-07-26 21:57:17.000000000 +0200
+++ mozilla.new/extensions/schema-validation/src/nsSchemaValidatorUtils.h	2006-03-03 07:12:24.000000000 +0100
@@ -40,8 +40,13 @@
 #define __nsSchemaValidatorUtils_h__
 
 #include "nsCOMPtr.h"
-#include "nsISchemaDuration.h"
+#include "nsString.h"
+#include "nsISchema.h"
 #include "nsCOMArray.h"
+#include "nsIServiceManager.h"
+#include "nsIComponentManager.h"
+#include "nsISchemaDuration.h"
+#include "nsISchemaValidatorRegexp.h"
 
 struct nsSchemaGDay {
   PRUint32 day;            // day represented (1-31)
@@ -94,12 +99,61 @@ const nsMonthShortHand monthShortHand[] 
   { "12", "Dec" }
 };
 
+#define kREGEXP_CID "@mozilla.org/xmlextras/schemas/schemavalidatorregexp;1"
+
+class nsSchemaStringFacet
+{
+public:
+  PRBool isDefined;
+  nsString value;
+  nsSchemaStringFacet() {
+    isDefined = PR_FALSE;
+  }
+};
+
+class nsSchemaIntFacet
+{
+public:
+  PRBool isDefined;
+  PRUint32 value;
+  nsSchemaIntFacet() {
+    isDefined = PR_FALSE;
+    value = 0;
+  }
+};
+
+struct nsSchemaDerivedSimpleType {
+  nsISchemaSimpleType* mBaseType;
+
+  nsSchemaIntFacet length;
+  nsSchemaIntFacet minLength;
+  nsSchemaIntFacet maxLength;
+
+  nsSchemaStringFacet pattern;
+
+  PRBool isWhitespaceDefined;
+  unsigned short whitespace;
+
+  nsSchemaStringFacet maxInclusive;
+  nsSchemaStringFacet minInclusive;
+  nsSchemaStringFacet maxExclusive;
+  nsSchemaStringFacet minExclusive;
+
+  nsSchemaIntFacet totalDigits;
+  nsSchemaIntFacet fractionDigits;
+
+  nsStringArray enumerationList;
+};
+
 class nsSchemaValidatorUtils
 {
 public:
   static PRBool IsValidSchemaInteger(const nsAString & aNodeValue, long *aResult);
   static PRBool IsValidSchemaInteger(const char* aString, long *aResult);
 
+  static PRBool IsValidSchemaDouble(const nsAString & aNodeValue, double *aResult);
+  static PRBool IsValidSchemaDouble(const char* aString, double *aResult);
+
   static PRBool ParseSchemaDate(const nsAString & aStrValue, char *rv_year,
                                 char *rv_month, char *rv_day);
   static PRBool ParseSchemaTime(const nsAString & aStrValue, char *rv_hour,
@@ -136,19 +190,24 @@ public:
   static PRExplodedTime AddDurationToDatetime(PRExplodedTime aDatetime,
                                               nsISchemaDuration *aDuration);
 
+  static PRBool IsValidSchemaNormalizedString(const nsAString & aStrValue);
+  static PRBool IsValidSchemaToken(const nsAString & aStrValue);
+  static PRBool IsValidSchemaLanguage(const nsAString & aStrValue);
+
   static PRBool HandleEnumeration(const nsAString &aStrValue,
                                   const nsStringArray &aEnumerationList);
 
   static void RemoveLeadingZeros(nsAString & aString);
   static void RemoveTrailingZeros(nsAString & aString);
 
+  static nsresult GetDerivedSimpleType(nsISchemaSimpleType *aSimpleType,
+                                       nsSchemaDerivedSimpleType *aDerived);
+  static void CopyDerivedSimpleType(nsSchemaDerivedSimpleType *aDerivedDest,
+                                    nsSchemaDerivedSimpleType *aDerivedSrc);
 private:
   nsSchemaValidatorUtils();
   ~nsSchemaValidatorUtils();
 
-  static PRBool IsValidSchemaDouble(const nsAString & aNodeValue, double *aResult);
-  static PRBool IsValidSchemaDouble(const char* aString, double *aResult);
-
 protected:
 };
 
diff -uprN --exclude=CVS mozilla/extensions/schema-validation/tests/schema.html mozilla.new/extensions/schema-validation/tests/schema.html
--- mozilla/extensions/schema-validation/tests/schema.html	2005-06-24 17:38:12.000000000 +0200
+++ mozilla.new/extensions/schema-validation/tests/schema.html	2006-03-03 07:12:24.000000000 +0100
@@ -125,7 +125,7 @@
                                    .getService(Components.interfaces.nsISchemaLoader);
       try { 
         schema = schemaLoader.load("file:///home/doron/mozbuilds/trunk/mozilla/extensions/schema-validation/tests/schema.xsd");
-        myValidator.loadSchema(schema);        
+        myValidator.loadSchema(schema);
       } catch(e){alert(e)}
 
       //schema collection
@@ -138,17 +138,6 @@
 
       start = new Date();
 
-/*
-        validate("true false 0 1", "list-test-1", true);
-        validate("true false e 1", "list-test-1", false);
-
-        validate("100 33 4", "list-test-2", true);
-        validate("100 333 4", "list-test-2", false);
-
-        validate("50", "union-test-1", true);
-        validate("N/A", "union-test-1", true);
-        validate("#REF!", "union-test-1", false);*/
-
       if (1) {
         validate("220", "integer-test-1", false);
         validate("2", "integer-test-1", false);
@@ -207,6 +196,7 @@
         validate("220.343434", "decimal-test-1", true);
         validate("220.3434a34", "decimal-test-1", false);
         validate("220.343.34", "decimal-test-1", false);
+        validate("0.2", "decimal-test-1", true);
 
         validate("220.343435", "decimal-test-2", false);
         validate("220.3434342", "decimal-test-2", true);
@@ -230,6 +220,47 @@
         validate("1002.32", "decimal-test-4", false);
         validate("100.322", "decimal-test-4", false);
 
+        validate("220", "long-test-1", true);
+        validate("-220", "long-test-1", true);
+        validate("9223372036854775807", "long-test-1", true);
+        validate("-9223372036854775808", "long-test-1", true);
+        validate("-9223372036854775809", "long-test-1", false);
+        validate("9223372036854775808", "long-test-1", false);
+
+        validate("220", "int-test-1", true);
+        validate("-220", "int-test-1", true);
+        validate("2147483647", "int-test-1", true);
+        validate("-2147483648", "int-test-1", true);
+        validate("2147483648", "int-test-1", false);
+        validate("-2147483649", "int-test-1", false);
+
+        validate("220", "short-test-1", true);
+        validate("-220", "short-test-1", true);
+        validate("32767", "short-test-1", true);
+        validate("-32768", "short-test-1", true);
+        validate("32768", "short-test-1", false);
+        validate("-32769", "short-test-1", false);
+
+        validate("220", "unsignedLong-test-1", true);
+        validate("-220", "unsignedLong-test-1", false);
+        validate("18446744073709551615", "unsignedLong-test-1", true);
+        validate("18446744073709551616", "unsignedLong-test-1", false);
+
+        validate("220", "unsignedInt-test-1", true);
+        validate("-220", "unsignedInt-test-1", false);
+        validate("4294967295", "unsignedInt-test-1", true);
+        validate("4294967296", "unsignedInt-test-1", false);
+
+        validate("220", "unsignedShort-test-1", true);
+        validate("-220", "unsignedShort-test-1", false);
+        validate("65535", "unsignedShort-test-1", true);
+        validate("65536", "unsignedShort-test-1", false);
+
+        validate("220", "unsignedByte-test-1", true);
+        validate("-220", "unsignedByte-test-1", false);
+        validate("255", "unsignedByte-test-1", true);
+        validate("256", "unsignedByte-test-1", false);
+
         validate("bla", "string-test-1", false);
         validate("blaadadad", "string-test-1", false);
         validate("bla22", "string-test-1", true);
@@ -256,7 +287,7 @@
         validate("---30", "gday-test-1", true);
         validate("---30Z", "gday-test-1", true);
         validate("---3", "gday-test-1", false);
-        validate("----3", "gday-test-1", false);      
+        validate("----3", "gday-test-1", false);
 
         validate("---03", "gday-test-2", false);
         validate("---14", "gday-test-2", true);
@@ -272,28 +303,28 @@
         validate("---05", "gday-test-3", true);
         validate("---21", "gday-test-3", true);
 
-        validate("--01--", "gmonth-test-1", true);
-        validate("--05--Z", "gmonth-test-1", true);
-        validate("--05---03:43", "gmonth-test-1", true);
-        validate("--05--a03:43", "gmonth-test-1", false);
-        validate("--12--", "gmonth-test-1", true);
-        validate("--32--", "gmonth-test-1", false);
-        validate("---2--", "gmonth-test-1", false);
-        validate("--543--", "gmonth-test-1", false);
-
-        validate("--01--", "gmonth-test-2", false);
-        validate("--05--", "gmonth-test-2", false);
-        validate("--06--", "gmonth-test-2", true);
-        validate("--10--", "gmonth-test-2", true);
-        validate("--11--", "gmonth-test-2", false);
-        validate("--12--", "gmonth-test-2", false);
-
-        validate("--01--", "gmonth-test-3", false);
-        validate("--05--", "gmonth-test-3", true);
-        validate("--06--", "gmonth-test-3", true);
-        validate("--10--", "gmonth-test-3", true);
-        validate("--11--", "gmonth-test-3", true);
-        validate("--12--", "gmonth-test-3", false);
+        validate("--01", "gmonth-test-1", true);
+        validate("--05Z", "gmonth-test-1", true);
+        validate("--05-03:43", "gmonth-test-1", true);
+        validate("--05a03:43", "gmonth-test-1", false);
+        validate("--12", "gmonth-test-1", true);
+        validate("--32", "gmonth-test-1", false);
+        validate("---2", "gmonth-test-1", false);
+        validate("--543", "gmonth-test-1", false);
+
+        validate("--01", "gmonth-test-2", false);
+        validate("--05", "gmonth-test-2", false);
+        validate("--06", "gmonth-test-2", true);
+        validate("--10", "gmonth-test-2", true);
+        validate("--11", "gmonth-test-2", false);
+        validate("--12", "gmonth-test-2", false);
+
+        validate("--01", "gmonth-test-3", false);
+        validate("--05", "gmonth-test-3", true);
+        validate("--06", "gmonth-test-3", true);
+        validate("--10", "gmonth-test-3", true);
+        validate("--11", "gmonth-test-3", true);
+        validate("--12", "gmonth-test-3", false);
 
         validate("1989", "gyear-test-1", true);
         validate("1234-13:43", "gyear-test-1", true); 
@@ -440,16 +471,21 @@
 
         validate("VGhpcyBpcyBhIHRlc3Q=", "base64-test-1", true);
         validate("  VGhpcyBpcyBhIHRlQ=   ", "base64-test-1", false);
-  
+
         validate("VGhpcyBpcyBhIHRlc3Q=", "base64-test-2", true);
         validate("VGhpcyBpcyBhIHRlc3Qh", "base64-test-2", false);
-  
+
         validate("VGhpcyBpcyBhIHRlc3Q=", "base64-test-3", true);
         validate("VGhpcyBpcyBhIHRlc3Qh", "base64-test-3", false);
         validate("aGk=", "base64-test-3", false);
         validate("aGkh", "base64-test-3", true);
         validate("aGkgdGhlcmUh", "base64-test-3", true);
 
+        validate("0FB7", "hexbinary-test-1", true);
+        validate("0FB72", "hexbinary-test-1", false);
+        validate("023-", "hexbinary-test-1", false);
+        validate("0HB7", "hexbinary-test-1", false);
+
         validate("58758", "better-us-zipcode", true);
         validate("a758", "better-us-zipcode", false);
 
@@ -482,11 +518,83 @@
         validate("P32D", "duration-test-3", true);
         validate("P27D", "duration-test-3", false);
 
-
         validate("test:foo", "qname-test-1", true);
         validate(":fooasdad", "qname-test-1", false);
         validate("n:s", "qname-test-1", true);
         validate("test:123456789", "qname-test-1", false);
+
+        validate("2004-02-28T24:21:03Z", "datetime-test-1", true);
+        validate("2004-02-28T25:21:03Z", "datetime-test-1", false);
+        validate("2004-02-28T22:61:03Z", "datetime-test-1", false);
+        validate("-2004-02-28T12:21:03.434Z", "datetime-test-1", true);
+        validate("-2004-02-28T12:21:03-04:00", "datetime-test-1", true);
+        validate("-2004-02-30T12:21:03Z", "datetime-test-1", false);
+
+        validate("2004-02-11T12:21:03Z", "datetime-test-2", true);
+        validate("2004-02-18T00:00:00Z", "datetime-test-2", true);
+        validate("2004-02-18T12:21:03Z", "datetime-test-2", false);
+        validate("2004-02-30T12:21:03Z", "datetime-test-2", false);
+        validate("2002-06-29T12:21:03Z", "datetime-test-2", true);
+        validate("2001-02-18T12:21:03Z", "datetime-test-2", false);
+        validate("2001-01-18T12:21:03Z", "datetime-test-2", false);
+        validate("2002-02-30T12:21:03Z", "datetime-test-2", false);
+
+        validate("2004-02-18T12:21:03Z", "datetime-test-3", true);
+        validate("2004-02-18T00:00:00Z", "datetime-test-3", true);
+        validate("2004-02-18T12:22:03Z", "datetime-test-3", false);
+        validate("2004-02-21T12:22:03Z", "datetime-test-3", false);
+        validate("2001-02-18T12:21:03Z", "datetime-test-3", true);
+        validate("2002-02-18T12:21:03Z", "datetime-test-3", true);
+        validate("2001-02-18T12:20:03Z", "datetime-test-3", false);
+        validate("2001-01-18T22:20:03Z", "datetime-test-3", false);
+        validate("2004-02-18T12:21:03-02:00", "datetime-test-3", false);
+        validate("2004-02-18T12:21:03+02:00", "datetime-test-3", true);
+
+  validate("true false 0 1", "list-test-1", true);
+        validate("true false e 1", "list-test-1", false);
+
+        validate("100 33 4", "list-test-2", true);
+        validate("100 333 4", "list-test-2", false);
+
+        validate("50", "union-test-1", true);
+        validate("N/A", "union-test-1", true);
+        validate("#REF!", "union-test-1", false);
+
+        validateSimpleTypeString("bla", "normalizedString", true);
+        validateSimpleTypeString("bla	", "normalizedString", false);
+
+        validateSimpleTypeString("bla", "token", true);
+        validateSimpleTypeString("bla	", "token", false);
+        validateSimpleTypeString("bla ", "token", false);
+        validateSimpleTypeString(" bla ", "token", false);
+        validateSimpleTypeString("bla afaf", "token", true);
+        validateSimpleTypeString("bla  afaf", "token", false);
+
+        validateSimpleTypeString("en-US", "language", true);
+        validateSimpleTypeString("fr", "language", true);
+        validateSimpleTypeString("2", "language", false);
+
+        validate("Applicant", "IndividualRole", true);
+        validate("Applicanter", "IndividualRole", true);
+        validate("Applicant1", "IndividualRole", false);
+
+        validate("Applicant Trustee", "IndividualRoleList", true);
+        validate("Applicant Trustee Foo", "IndividualRoleList", false);
+
+        validate("Applicant Trustee", "IndividualRoleListType", true);
+        validate("Applicant Trustee Foo", "IndividualRoleListType", false);
+        validate("Applicant Trustee Trustee Applicant", "IndividualRoleListType", true);
+        validate("Applicant Trustee Trustee Applicant Trustee", "IndividualRoleListType", false);
+
+        validate("Applicant Trustee Trustee Applicant", "IndividualRoleListType2", true);
+        validate("Applicant Trustee Trustee", "IndividualRoleListType2", false);
+        validate("Applicant Trustee", "IndividualRoleListType2", false);
+
+        validate("Applicant Trustee Trustee Applicant", "IndividualRoleListType3", true);
+        validate("Applicant Trustee Trustee", "IndividualRoleListType3", false);
+
+        validate("Applicant Trustee Supplier", "IndividualRoleListType5", false);
+        validate("Applicant Trustee", "IndividualRoleListType5", true);
       }
 
       end = new Date();
diff -uprN --exclude=CVS mozilla/extensions/schema-validation/tests/schema.xsd mozilla.new/extensions/schema-validation/tests/schema.xsd
--- mozilla/extensions/schema-validation/tests/schema.xsd	2005-06-24 17:38:12.000000000 +0200
+++ mozilla.new/extensions/schema-validation/tests/schema.xsd	2006-03-03 07:12:24.000000000 +0100
@@ -21,12 +21,59 @@
     </restriction>
   </simpleType>
 
-  <simpleType name="test-nonPositiveInteger">
+  <simpleType name="nonPositiveInteger-test-1">
     <restriction base='nonPositiveInteger'>
       <totalDigits value="3"/>
     </restriction>
   </simpleType>
 
+  <simpleType name="positiveInteger-test-1">
+    <restriction base='positiveInteger'>
+      <totalDigits value="3"/>
+    </restriction>
+  </simpleType>
+
+  <simpleType name="negativeInteger-test-1">
+    <restriction base='negativeInteger'>
+      <totalDigits value="3"/>
+    </restriction>
+  </simpleType>
+
+  <simpleType name='long-test-1'>
+    <restriction base='long'>
+    </restriction>
+  </simpleType>
+
+  <simpleType name='int-test-1'>
+    <restriction base='int'>
+    </restriction>
+  </simpleType>
+
+  <simpleType name='short-test-1'>
+    <restriction base='short'>
+    </restriction>
+  </simpleType>
+          
+  <simpleType name='unsignedLong-test-1'>
+    <restriction base='unsignedLong'>
+    </restriction>
+  </simpleType>
+
+  <simpleType name='unsignedInt-test-1'>
+    <restriction base='unsignedInt'>
+    </restriction>
+  </simpleType>
+
+  <simpleType name='unsignedShort-test-1'>
+    <restriction base='unsignedShort'>
+    </restriction>
+  </simpleType>
+
+  <simpleType name='unsignedByte-test-1'>
+    <restriction base='unsignedByte'>
+    </restriction>
+  </simpleType>
+
   <simpleType name="byte-test-1">
     <restriction base='byte'>
     </restriction>
@@ -139,15 +186,15 @@
 
   <simpleType name="gmonth-test-2">
     <restriction base='gMonth'>
-      <maxExclusive value="--11--Z"/>
-      <minExclusive value="--05--"/>
+      <maxExclusive value="--11Z"/>
+      <minExclusive value="--05"/>
     </restriction>
   </simpleType>
 
   <simpleType name="gmonth-test-3">
     <restriction base='gMonth'>
-      <maxInclusive value="--11--"/>
-      <minInclusive value="--05--"/>
+      <maxInclusive value="--11"/>
+      <minInclusive value="--05"/>
     </restriction>
   </simpleType>
 
@@ -284,7 +331,6 @@
     </restriction>
   </simpleType>
 
-
   <simpleType name="anyuri-test-1">
     <restriction base='anyURI'>
     </restriction>
@@ -321,6 +367,11 @@
     </restriction>
   </simpleType>
 
+  <simpleType name="hexbinary-test-1">
+    <restriction base='hexBinary'>
+    </restriction>
+  </simpleType>
+
   <simpleType name="qname-test-1">
     <restriction base='QName'>
       <maxLength value="13"/>
@@ -334,7 +385,6 @@
     </restriction>
   </simpleType>
 
-
   <simpleType name="list-test-1">
     <list itemType="boolean"/>
   </simpleType>
@@ -362,7 +412,76 @@
         </restriction>
       </simpleType>
     </union>
-  </simpleType> 
+  </simpleType>
+
+  <simpleType name="TypeCode">
+    <restriction base="test:UrType">
+      <enumeration value="Applicanter"/>
+      <enumeration value="Applicant"/>
+      <enumeration value="Third_Party"/>
+      <enumeration value="Trustee"/>
+      <maxLength value="50"/>
+    </restriction>
+  </simpleType>
+
+  <simpleType name="UrType">
+    <restriction base="string">
+    </restriction>
+  </simpleType>
+
+  <simpleType name="IndividualRole">
+    <restriction base="test:TypeCode">
+      <enumeration value="Applicant"/>
+      <enumeration value="Third_Party"/>
+      <enumeration value="Trustee"/>
+    </restriction>
+  </simpleType>
+
+  <simpleType name='IndividualRoleList'>
+    <list itemType='test:IndividualRole'/>
+  </simpleType>
+
+  <simpleType name='IndividualRoleListType'>
+    <restriction base='test:IndividualRoleList'>
+      <maxLength value='4'/>
+    </restriction>
+  </simpleType>
+
+  <simpleType name='IndividualRoleListType2'>
+    <restriction base='test:IndividualRoleList'>
+      <length value='4'/>
+    </restriction>
+  </simpleType>
+
+  <simpleType name='IndividualRoleListType3'>
+    <restriction base='test:IndividualRoleList'>
+      <minLength value='4'/>
+    </restriction>
+  </simpleType>
+
+  <simpleType name="RoleUnion">
+    <union>
+      <simpleType>
+        <restriction base="test:IndividualRoleListType"/>
+      </simpleType>
+      <simpleType>
+        <restriction base="string">
+          <enumeration value="N/A"/>
+        </restriction>
+      </simpleType>
+      <simpleType>
+        <restriction base="string">
+          <maxLength value="4"/>
+        </restriction>
+      </simpleType>
+    </union>
+  </simpleType>
+
+  <simpleType name='IndividualRoleListType5'>
+    <restriction base='test:IndividualRoleList'>
+      <enumeration value='Applicant Trustee'/>
+    </restriction>
+  </simpleType>
 
   <!-- complex types -->
 
diff -uprN --exclude=CVS mozilla/extensions/transformiix/source/base/txURIUtils.cpp mozilla.new/extensions/transformiix/source/base/txURIUtils.cpp
--- mozilla/extensions/transformiix/source/base/txURIUtils.cpp	2004-06-25 14:26:01.000000000 +0200
+++ mozilla.new/extensions/transformiix/source/base/txURIUtils.cpp	2006-02-24 11:16:22.000000000 +0100
@@ -326,6 +326,7 @@ void
 URIUtils::ResetWithSource(nsIDocument *aNewDoc, nsIDOMNode *aSourceNode)
 {
     if (!aSourceNode) {
+        // XXXbz passing nsnull as the first arg to Reset is illegal
         aNewDoc->Reset(nsnull, nsnull);
         return;
     }
@@ -338,21 +339,31 @@ URIUtils::ResetWithSource(nsIDocument *a
     }
     if (!sourceDoc) {
         NS_ASSERTION(0, "no source document found");
+        // XXXbz passing nsnull as the first arg to Reset is illegal
         aNewDoc->Reset(nsnull, nsnull);
         return;
     }
 
-    nsCOMPtr<nsIChannel> channel;
+    nsIPrincipal* sourcePrincipal = sourceDoc->GetPrincipal();
+    if (!sourcePrincipal) {
+        return;
+    }
+
+    // Copy the channel and loadgroup from the source document.
     nsCOMPtr<nsILoadGroup> loadGroup = sourceDoc->GetDocumentLoadGroup();
-    nsCOMPtr<nsIIOService> serv = do_GetService(NS_IOSERVICE_CONTRACTID);
-    if (serv) {
-        // Create a temporary channel to get nsIDocument->Reset to
-        // do the right thing. We want the output document to get
-        // much of the input document's characteristics.
-        serv->NewChannelFromURI(sourceDoc->GetDocumentURI(),
-                                getter_AddRefs(channel));
+    nsCOMPtr<nsIChannel> channel = sourceDoc->GetChannel();
+    if (!channel) {
+        // Need to synthesize one
+        if (NS_FAILED(NS_NewChannel(getter_AddRefs(channel),
+                                    sourceDoc->GetDocumentURI(),
+                                    nsnull,
+                                    loadGroup))) {
+            return;
+        }
+        channel->SetOwner(sourcePrincipal);
     }
     aNewDoc->Reset(channel, loadGroup);
+    aNewDoc->SetPrincipal(sourcePrincipal);
     aNewDoc->SetBaseURI(sourceDoc->GetBaseURI());
 
     // Copy charset
diff -uprN --exclude=CVS mozilla/extensions/transformiix/source/xpath/nsXPathResult.cpp mozilla.new/extensions/transformiix/source/xpath/nsXPathResult.cpp
--- mozilla/extensions/transformiix/source/xpath/nsXPathResult.cpp	2005-08-25 14:45:04.000000000 +0200
+++ mozilla.new/extensions/transformiix/source/xpath/nsXPathResult.cpp	2006-02-24 11:16:22.000000000 +0100
@@ -249,12 +249,18 @@ nsXPathResult::ContentRemoved(nsIDocumen
 nsresult
 nsXPathResult::SetExprResult(txAExprResult* aExprResult, PRUint16 aResultType)
 {
+    mResultType = aResultType;
+
+    if ((isSnapshot() || isIterator() || isNode()) &&
+        aExprResult->getResultType() != txAExprResult::NODESET) {
+        return NS_ERROR_DOM_TYPE_ERR;
+    }
+
     if (mDocument) {
         mDocument->RemoveObserver(this);
         mDocument = nsnull;
     }
  
-    mResultType = aResultType;
     mResult.set(aExprResult);
 
     if (!isIterator()) {
diff -uprN --exclude=CVS mozilla/extensions/transformiix/source/xslt/txMozillaTextOutput.cpp mozilla.new/extensions/transformiix/source/xslt/txMozillaTextOutput.cpp
--- mozilla/extensions/transformiix/source/xslt/txMozillaTextOutput.cpp	2005-04-15 03:30:11.000000000 +0200
+++ mozilla.new/extensions/transformiix/source/xslt/txMozillaTextOutput.cpp	2006-02-24 11:16:22.000000000 +0100
@@ -50,6 +50,7 @@
 #include "nsIDOMNSDocument.h"
 #include "nsIParser.h"
 #include "nsICharsetAlias.h"
+#include "nsIPrincipal.h"
 
 static NS_DEFINE_CID(kXMLDocumentCID, NS_XMLDOCUMENT_CID);
 
@@ -172,18 +173,27 @@ void txMozillaTextOutput::createResultDo
     }
 
     // Reset and set up document
-    nsCOMPtr<nsIChannel> channel;
     nsCOMPtr<nsIDocument> sourceDoc = do_QueryInterface(aSourceDocument);
+    nsIPrincipal* sourcePrincipal = sourceDoc->GetPrincipal();
+    if (!sourcePrincipal) {
+        return;
+    }
+
     nsCOMPtr<nsILoadGroup> loadGroup = sourceDoc->GetDocumentLoadGroup();
-    nsCOMPtr<nsIIOService> serv = do_GetService(NS_IOSERVICE_CONTRACTID);
-    if (serv) {
-        // Create a temporary channel to get nsIDocument->Reset to
-        // do the right thing. We want the output document to get
-        // much of the input document's characteristics.
-        serv->NewChannelFromURI(sourceDoc->GetDocumentURI(),
-                                getter_AddRefs(channel));
+    nsCOMPtr<nsIChannel> channel = sourceDoc->GetChannel();
+    if (!channel) {
+        // Need to synthesize one
+        if (NS_FAILED(NS_NewChannel(getter_AddRefs(channel),
+                                    sourceDoc->GetDocumentURI(),
+                                    nsnull,
+                                    loadGroup))) {
+            return;
+        }
+        channel->SetOwner(sourcePrincipal);
     }
+    // Copy the channel and loadgroup from the source document.
     doc->Reset(channel, loadGroup);
+    doc->SetPrincipal(sourcePrincipal);
     doc->SetBaseURI(sourceDoc->GetBaseURI());
 
     // Set the charset
diff -uprN --exclude=CVS mozilla/extensions/transformiix/source/xslt/txMozillaXSLTProcessor.cpp mozilla.new/extensions/transformiix/source/xslt/txMozillaXSLTProcessor.cpp
--- mozilla/extensions/transformiix/source/xslt/txMozillaXSLTProcessor.cpp	2005-09-04 20:15:59.000000000 +0200
+++ mozilla.new/extensions/transformiix/source/xslt/txMozillaXSLTProcessor.cpp	2006-02-24 11:16:22.000000000 +0100
@@ -64,6 +64,7 @@
 #include "txXSLTProcessor.h"
 #include "nsIPrincipal.h"
 #include "jsapi.h"
+#include "nsIEventQueueService.h"
 
 static NS_DEFINE_CID(kXMLDocumentCID, NS_XMLDOCUMENT_CID);
 
@@ -322,6 +323,31 @@ txMozillaXSLTProcessor::SetSourceContent
     return NS_OK;
 }
 
+PR_BEGIN_EXTERN_C
+void* PR_CALLBACK
+HandleTransformBlockerEvent(PLEvent *aEvent)
+{
+    txMozillaXSLTProcessor *processor =
+         NS_STATIC_CAST(txMozillaXSLTProcessor*, aEvent->owner);
+    processor->TransformToDoc(nsnull, nsnull);
+
+    return nsnull;
+}
+
+void PR_CALLBACK
+DestroyTransformBlockerEvent(PLEvent *aEvent)
+{
+    txMozillaXSLTProcessor *processor =
+         NS_STATIC_CAST(txMozillaXSLTProcessor*, aEvent->owner);
+    nsCOMPtr<nsIDocument> document =
+        do_QueryInterface(processor->GetSourceContentModel());
+    document->UnblockOnload();
+
+    NS_RELEASE(processor);
+    delete aEvent;
+}
+PR_END_EXTERN_C
+
 nsresult
 txMozillaXSLTProcessor::DoTransform()
 {
@@ -329,7 +355,41 @@ txMozillaXSLTProcessor::DoTransform()
     NS_ENSURE_TRUE(mStylesheet, NS_ERROR_UNEXPECTED);
     NS_ASSERTION(mObserver, "no observer");
 
-    return TransformToDoc(nsnull, nsnull);
+    nsresult rv;
+    nsCOMPtr<nsIDocument> document = do_QueryInterface(mSource, &rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsCOMPtr<nsIEventQueueService> service =
+        do_GetService(NS_EVENTQUEUESERVICE_CONTRACTID, &rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+    nsCOMPtr<nsIEventQueue> eventQ;
+    rv = service->GetSpecialEventQueue(nsIEventQueueService::UI_THREAD_EVENT_QUEUE,
+                                       getter_AddRefs(eventQ));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    PLEvent* event = new PLEvent();
+    if (!event) {
+        return NS_ERROR_OUT_OF_MEMORY;
+    }
+
+    PL_InitEvent(event, this, HandleTransformBlockerEvent,
+                 DestroyTransformBlockerEvent);
+
+    document->BlockOnload();
+
+    // After this point, event destruction will release |this| (in
+    // DestroyTransformBlockerEvent)
+    NS_ADDREF_THIS();
+
+    rv = eventQ->PostEvent(event);
+    if (NS_FAILED(rv)) {
+        // XXX Maybe we should just display the source document in this case?
+        //     Also, set up context information, see bug 204655.
+        reportError(rv, nsnull, nsnull);
+        PL_DestroyEvent(event);
+    }
+
+    return rv;
 }
 
 NS_IMETHODIMP
diff -uprN --exclude=CVS mozilla/extensions/transformiix/source/xslt/txMozillaXSLTProcessor.h mozilla.new/extensions/transformiix/source/xslt/txMozillaXSLTProcessor.h
--- mozilla/extensions/transformiix/source/xslt/txMozillaXSLTProcessor.h	2005-01-28 16:08:58.000000000 +0100
+++ mozilla.new/extensions/transformiix/source/xslt/txMozillaXSLTProcessor.h	2006-02-24 11:16:22.000000000 +0100
@@ -155,12 +155,13 @@ public:
         return mSource;
     }
 
+    nsresult TransformToDoc(nsIDOMDocument *aOutputDoc,
+                            nsIDOMDocument **aResult);
+
 private:
     nsresult DoTransform();
     void notifyError();
     nsresult ensureStylesheet();
-    nsresult TransformToDoc(nsIDOMDocument *aOutputDoc,
-                            nsIDOMDocument **aResult);
 
     nsRefPtr<txStylesheet> mStylesheet;
     nsIDocument* mStylesheetDocument; // weak
diff -uprN --exclude=CVS mozilla/extensions/xforms/jar.mn mozilla.new/extensions/xforms/jar.mn
--- mozilla/extensions/xforms/jar.mn	2005-09-02 19:23:35.000000000 +0200
+++ mozilla.new/extensions/xforms/jar.mn	2006-02-14 10:01:13.000000000 +0100
@@ -9,9 +9,11 @@ xforms.jar:
 * content/xforms/xforms-prefs.js               (resources/content/xforms-prefs.js)
   content/xforms/xforms.xml                    (resources/content/xforms.xml)
   content/xforms/select1.xml                   (resources/content/select1.xml)
+  content/xforms/range.xml                     (resources/content/range.xml)
   content/xforms/select.xml                    (resources/content/select.xml)
   content/xforms/bindingex.css                 (resources/content/bindingex.css)
   content/xforms/bindingex.xul                 (resources/content/bindingex.xul)
+  content/xforms/calendar.png                  (resources/content/calendar.png)
 * locale/en-US/xforms/contents.rdf             (resources/locale/en-US/contents.rdf)
   locale/en-US/xforms/xforms.properties        (resources/locale/en-US/xforms.properties)
   locale/en-US/xforms/xforms.dtd               (resources/locale/en-US/xforms.dtd)
diff -uprN --exclude=CVS mozilla/extensions/xforms/Makefile.in mozilla.new/extensions/xforms/Makefile.in
--- mozilla/extensions/xforms/Makefile.in	2006-01-09 06:48:33.000000000 +0100
+++ mozilla.new/extensions/xforms/Makefile.in	2006-02-24 11:16:23.000000000 +0100
@@ -49,14 +49,22 @@ include $(DEPTH)/config/autoconf.mk
 MODULE		= xforms
 LIBRARY_NAME	= xforms
 IS_COMPONENT	= 1
+ifndef MINIMO
 # Do not set EXPORT_LIBRARY as we do not want xforms in the static libs list
 #EXPORT_LIBRARY	= 1
 FORCE_SHARED_LIB = 1
+else
+MODULE_NAME	= xforms
+EXPORT_LIBRARY	= 1
+endif
 MOZILLA_INTERNAL_API = 1
 
 # Also build schema-validation
 DIRS			= ../schema-validation \
 		  	  $(NULL)
+
+ifndef MINIMO
+ifdef MOZ_XUL_APP
 # XPI settings
 # XPI_NAME is exported to include schema-validation in xforms package
 export XPI_NAME	       = xforms
@@ -64,7 +72,10 @@ XPI_PKGNAME            = xforms
 USE_EXTENSION_MANIFEST = 1
 NO_JAR_AUTO_REG        = 1
 INSTALL_EXTENSION_ID   = {cf2812dc-6a7c-4402-b639-4d277dac4c36}
-PACKAGE_VERSION        = 0.3
+PACKAGE_VERSION        = 0.4
+
+# We want to strip the XPI
+STRIP_XPI = 1
 
 XULAPP_DEFINES = \
 	-DFIREFOX_VERSION=$(FIREFOX_VERSION) \
@@ -75,6 +86,8 @@ XULAPP_DEFINES = \
 
 # Include these in the XPI
 DIST_FILES = install.rdf install.js
+endif
+endif
 
 # XForms depends
 REQUIRES	= \
@@ -103,6 +116,7 @@ REQUIRES	= \
 # XForms IDLs
 XPIDLSRCS	= \
 		nsIXFormsModelElement.idl \
+		nsIXFormsNSModelElement.idl \
 		nsIInstanceElementPrivate.idl \
 		nsIModelElementPrivate.idl \
 		nsIXFormsControl.idl \
@@ -120,12 +134,16 @@ XPIDLSRCS	= \
 		nsIXFormsSubmissionElement.idl \
 		nsIXFormsControlBase.idl \
 		nsIXFormsDelegate.idl \
+		nsIDelegateInternal.idl \
 		nsIXFormsUIWidget.idl \
 		nsIXFormsItemElement.idl \
 		nsIXFormsLabelElement.idl \
 		nsIXFormsItemSetUIElement.idl \
+		nsIXFormsAccessors.idl \
+		nsIXFormsRangeAccessors.idl \
 		nsIXFormsUploadElement.idl \
 		nsIXFormsUploadUIElement.idl \
+		nsIXFormsCopyElement.idl \
 		$(NULL)
 
 # XForms source files
@@ -181,6 +199,10 @@ CPPSRCS		= \
 		nsXFormsControlStub.cpp \
 		nsXFormsUtilityService.cpp \
 		nsXFormsDelegateStub.cpp \
+		nsXFormsRangeElement.cpp \
+		nsXFormsAccessors.cpp \
+		nsXFormsRangeAccessors.cpp \
+		nsXFormsCopyElement.cpp \
 		$(NULL)
 
 # Standard Mozilla make rules
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsIDelegateInternal.idl mozilla.new/extensions/xforms/nsIDelegateInternal.idl
--- mozilla/extensions/xforms/nsIDelegateInternal.idl	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/extensions/xforms/nsIDelegateInternal.idl	2006-02-07 16:30:11.000000000 +0100
@@ -0,0 +1,57 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla XForms support.
+ *
+ * The Initial Developer of the Original Code is
+ * Novell, Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Allan Beaufour <abeaufour@novell.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIXFormsDelegate.idl"
+
+/**
+ * Internal interface implemented by XForms controls that delegates the UI to
+ * an external entity.
+ */
+[uuid(aec21659-67e6-4808-b877-670ff756636a)]
+interface nsIDelegateInternal : nsIXFormsDelegate
+{
+  /**
+   * The value bound to the XForms control.
+   */
+  attribute DOMString value;
+
+  /**
+   * Is the delegate bound to a node?
+   */
+  readonly attribute boolean hasBoundNode;
+};
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsIInstanceElementPrivate.idl mozilla.new/extensions/xforms/nsIInstanceElementPrivate.idl
--- mozilla/extensions/xforms/nsIInstanceElementPrivate.idl	2005-10-22 16:39:09.000000000 +0200
+++ mozilla.new/extensions/xforms/nsIInstanceElementPrivate.idl	2006-02-14 10:01:13.000000000 +0100
@@ -44,7 +44,7 @@ interface nsIDOMElement;
 /**
  * Private interface implemented by the instance element.
  */
-[uuid(446dc7b6-91fc-4de5-b6de-5ac22538ee5e)]
+[uuid(debb24ef-7ba1-4e01-9f62-18106b25c993)]
 interface nsIInstanceElementPrivate : nsISupports
 {
   /**
@@ -54,5 +54,5 @@ interface nsIInstanceElementPrivate : ns
   readonly attribute nsIDOMElement element;
   void backupOriginalDocument();
   void restoreOriginalDocument();
-  void initializeLazyInstance();
+  void initialize();
 };
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsIModelElementPrivate.idl mozilla.new/extensions/xforms/nsIModelElementPrivate.idl
--- mozilla/extensions/xforms/nsIModelElementPrivate.idl	2005-06-29 20:14:43.000000000 +0200
+++ mozilla.new/extensions/xforms/nsIModelElementPrivate.idl	2006-02-24 11:16:23.000000000 +0100
@@ -42,17 +42,12 @@ interface nsIXFormsControl;
 interface nsISchemaType;
 interface nsIInstanceElementPrivate;
 interface nsIDOMNode;
-%{C++
-  #include "nsCOMArray.h"
-%}
-
-[ptr] native nsCOMArrayPtr(nsCOMArray<nsIInstanceElementPrivate>);
 
 /**
  * Private interface implemented by the model element for other
  * elements to use.
  */
-[uuid(b21b65d3-3305-4ce0-a604-3648cff61aca)]
+[uuid(a6522c1a-a343-4b36-a130-75eb279a667a)]
 interface nsIModelElementPrivate : nsIXFormsModelElement
 {
   /**
@@ -105,6 +100,18 @@ interface nsIModelElementPrivate : nsIXF
                     out AString  nodeValue);
 
   /**
+   * Insert a set of nodes underneath an instance node.
+   * @param aContextNode       The instance node
+   * @param aNodeContent       Node that holds the contents to insert under
+   *                           the instance node
+   * @param aNodeChanged       Indicates whether the contents of the instance
+   *                           node really did change due to this action
+   */
+  void setNodeContent(in nsIDOMNode aContextNode,
+                      in nsIDOMNode aNodeContent,
+                      out boolean   aNodeChanged);
+
+  /**
    * Validates the instance node against the schemas loaded by the model.
    */
   PRBool validateNode(in nsIDOMNode aInstanceNode);
@@ -126,12 +133,6 @@ interface nsIModelElementPrivate : nsIXF
   void setStates(in nsIXFormsControl aControl, in nsIDOMNode aBoundNode);
 
   /**
-   * The list of instance elements held by this model.  Includes lazy-authored
-   * instance elements
-   */
-  readonly attribute nsCOMArrayPtr instanceList;
-
-  /**
    * Add an instance element to the model's instance list
    * @param aInstanceElement        The instance element to add to the list
    */
@@ -141,4 +142,14 @@ interface nsIModelElementPrivate : nsIXF
    * This attribute is set when the model's instance was lazy authored
    */
   readonly attribute boolean lazyAuthored;
+ 
+   /**
+    * Retrieves the type for an instance data node
+    *
+    * @param aInstanceData     The instance data node
+    * @param aType             The type of the node
+    * @param aNSURI            The namespace of the type
+    */
+   void GetTypeFromNode(in nsIDOMNode aInstanceData, out AString aType,
+                        out AString aNSUri);
 };
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsIXFormsAccessors.idl mozilla.new/extensions/xforms/nsIXFormsAccessors.idl
--- mozilla/extensions/xforms/nsIXFormsAccessors.idl	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/extensions/xforms/nsIXFormsAccessors.idl	2006-02-24 11:16:23.000000000 +0100
@@ -0,0 +1,105 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla XForms support.
+ *
+ * The Initial Developer of the Original Code is
+ * Novell, Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Allan Beaufour <abeaufour@novell.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISupports.idl"
+#include "nsIDOMNode.idl"
+
+/**
+ * Interface exposing the states of an XForms control.
+ *
+ * For more information on this interface please see
+ * http://developer.mozilla.org/en/docs/XForms:Custom_Controls
+ */
+[scriptable, uuid(74992960-42a9-4479-a1ff-f7f1b37e187a)]
+interface nsIXFormsAccessors : nsISupports
+{
+  /**
+   * Get the value bound to the XForms control.
+   */
+  DOMString getValue();
+
+  /**
+   * Set the value bound to the XForms control.
+   */
+  void setValue(in DOMString value);
+
+  /**
+   * @see http://www.w3.org/TR/xforms/slice6.html#model-prop-readOnly
+   */
+  boolean isReadonly();
+
+  /**
+   * @see http://www.w3.org/TR/xforms/slice6.html#model-prop-relevant
+   */
+  boolean isRelevant();
+
+  /**
+   * @see http://www.w3.org/TR/xforms/slice6.html#model-prop-required
+   */
+  boolean isRequired();
+
+  /**
+   * @see http://www.w3.org/TR/xforms/slice6.html#model-prop-validate
+   */
+  boolean isValid();
+
+  /**
+   * true, if XForms control is bound to a node in a data model.
+   */
+  boolean hasBoundNode();
+
+  /**
+   * Node that the control is bound to in its data model.
+   */
+  nsIDOMNode getBoundNode();
+
+  /**
+   * Used to set the complete contents of the bound node.  This function is
+   * meant to be used like setValue() except that it can be used to set more
+   * than just the first textnode contained under the bound node.  If there
+   * is nothing contained under aNode, then all children of the bound node
+   * will be eliminated.
+   *
+   * @param aNode         setContent will take the contents of aNode and copy
+   *                      them under the control's bound node.
+   * @param aForceUpdate  Indicates whether setContent should rebuild,
+   *                      recalculate, revalidate and refresh the model that
+   *                      this control is bound to prior to returning
+   */
+  void setContent(in nsIDOMNode aNode, in boolean aForceUpdate);
+};
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsIXFormsCopyElement.idl mozilla.new/extensions/xforms/nsIXFormsCopyElement.idl
--- mozilla/extensions/xforms/nsIXFormsCopyElement.idl	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/extensions/xforms/nsIXFormsCopyElement.idl	2006-02-07 16:30:11.000000000 +0100
@@ -0,0 +1,54 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla XForms support.
+ *
+ * The Initial Developer of the Original Code is
+ * IBM Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Aaron Reed <aaronr@us.ibm.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/**
+ * This interface is implemented by XForms \<copy\> elements.
+ */
+
+#include "nsISupports.idl"
+#include "nsIDOMNode.idl"
+
+[uuid(4af9ad8e-5266-44ac-b9f7-ef2cb9fe2637)]
+interface nsIXFormsCopyElement : nsISupports
+{
+  /**
+   * Returns the node that will be deep copied into the instance data if the
+   * item element which contains this copy element is selected.
+   */
+  readonly attribute nsIDOMNode copyNode;
+};
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsIXFormsDelegate.idl mozilla.new/extensions/xforms/nsIXFormsDelegate.idl
--- mozilla/extensions/xforms/nsIXFormsDelegate.idl	2005-06-26 20:30:17.000000000 +0200
+++ mozilla.new/extensions/xforms/nsIXFormsDelegate.idl	2006-02-14 10:01:13.000000000 +0100
@@ -39,45 +39,36 @@
 
 #include "nsISupports.idl"
 
+interface nsIXFormsAccessors;
+
 /**
  * Interface implemented by XForms controls that delegates the UI to an
  * external entity.
+ *
+ * For more information on this interface please see
+ * http://developer.mozilla.org/en/docs/XForms:Custom_Controls
+ *
  */
-[scriptable, uuid(3b2300dc-9311-4eb7-a5c9-ca2ee4064de6)]
+[scriptable, uuid(902898eb-490e-4c36-a00b-9e74adcfbc43)]
 interface nsIXFormsDelegate : nsISupports
 {
   /**
-   * The value bound to the XForms control.
+   * Get the IXFormsAccessors object for this control.
    */
-  attribute DOMString value;
+  nsIXFormsAccessors getXFormsAccessors();
 
   /**
-   * @see http://www.w3.org/TR/xforms/slice6.html#model-prop-readOnly
-   */
-  readonly attribute boolean isReadonly;
-
-  /**
-   * @see http://www.w3.org/TR/xforms/slice6.html#model-prop-relevant
-   */
-  readonly attribute boolean isEnabled;
-
-  /**
-   * @see http://www.w3.org/TR/xforms/slice6.html#model-prop-required
-   */
-  readonly attribute boolean isRequired;
-
-  /**
-   * Tells whether the XForms control is valid.
-   */
-  readonly attribute boolean isValid;
-
-  /**
-   * true, if XForms control is bound to a node in a data model.
+   * This should be called by XBL widgets, when they are created.
    */
-  readonly attribute boolean hasBoundNode;
+  void widgetAttached();
 
   /**
-   * This should be called by XBL widgets, when they are created.
+   * Report an error
+   *
+   * @param errorMsg          The error message id
+   *
+   * @todo XXX this should be extended to allow for "raw strings", not
+   * necessarily kept in bundles.
    */
-  void widgetAttached();
+  void reportError(in DOMString errorMsg);
 };
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsIXFormsItemElement.idl mozilla.new/extensions/xforms/nsIXFormsItemElement.idl
--- mozilla/extensions/xforms/nsIXFormsItemElement.idl	2005-08-03 20:43:43.000000000 +0200
+++ mozilla.new/extensions/xforms/nsIXFormsItemElement.idl	2006-02-14 10:01:13.000000000 +0100
@@ -37,11 +37,13 @@
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsISupports.idl"
+#include "nsIDOMNode.idl"
+#include "nsIXFormsDelegate.idl"
 
 /**
  * Interface implemented by the item element.
  */
-[scriptable, uuid(796a2e26-a40b-4ebf-be2c-42faf5fea6c4)]
+[scriptable, uuid(ec8d3556-8ed2-4143-88d1-6b7b2c8b0b3b)]
 interface nsIXFormsItemElement : nsISupports
 {
   /**
@@ -67,4 +69,18 @@ interface nsIXFormsItemElement : nsISupp
    * \<select1\> element, which can then refresh its UI.
    */
   void labelRefreshed();
+
+  /**
+   * Indicates whether the item element contains a value child or a copy
+   * child.  We'll assume that if the item is NOT a copy item, then it must
+   * be a value item.  Which means that it must contain a XForms value element
+   * child.
+   */
+  attribute boolean isCopyItem;
+
+  /*
+   * returns the node that the contained copy element is bound to
+   */
+  readonly attribute nsIDOMNode copyNode;
+
 };
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsIXFormsNSModelElement.idl mozilla.new/extensions/xforms/nsIXFormsNSModelElement.idl
--- mozilla/extensions/xforms/nsIXFormsNSModelElement.idl	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/extensions/xforms/nsIXFormsNSModelElement.idl	2006-02-07 16:30:11.000000000 +0100
@@ -0,0 +1,50 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla XForms support.
+ *
+ * The Initial Developer of the Original Code is
+ * IBM Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Allan Beaufour <allan@beaufour.dk>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "domstubs.idl"
+
+interface nsIDOMNodeList;
+
+/**
+ * Defines additional post-spec. functions for the \<model\> element.
+ */
+[scriptable, uuid(85fd60c7-1db7-40c0-ae8d-f723fdd1eea8)]
+interface nsIXFormsNSModelElement : nsISupports
+{
+  nsIDOMNodeList getInstanceDocuments();
+};
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsIXFormsRangeAccessors.idl mozilla.new/extensions/xforms/nsIXFormsRangeAccessors.idl
--- mozilla/extensions/xforms/nsIXFormsRangeAccessors.idl	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/extensions/xforms/nsIXFormsRangeAccessors.idl	2006-02-07 16:30:11.000000000 +0100
@@ -0,0 +1,57 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla XForms support.
+ *
+ * The Initial Developer of the Original Code is
+ * Novell, Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Allan Beaufour <abeaufour@novell.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIXFormsAccessors.idl"
+
+/**
+ * Accessors provided by XForms \<range\> controls.
+ *
+ * @see http://www.w3.org/TR/xforms/slice8.html#ui-range
+ */
+[scriptable, uuid(8a6c4540-4c2b-4591-af0e-ef147543eee7)]
+interface nsIXFormsRangeAccessors : nsIXFormsAccessors
+{
+  /** The start of the range interval */
+  DOMString getRangeStart();
+
+  /** The end of the range interval */
+  DOMString getRangeEnd();
+
+  /** The step size */
+  DOMString getRangeStep();
+};
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsIXFormsSelectChild.idl mozilla.new/extensions/xforms/nsIXFormsSelectChild.idl
--- mozilla/extensions/xforms/nsIXFormsSelectChild.idl	2005-09-02 19:23:35.000000000 +0200
+++ mozilla.new/extensions/xforms/nsIXFormsSelectChild.idl	2006-02-14 10:01:13.000000000 +0100
@@ -52,7 +52,7 @@ class nsStringArray;
  * of an XForms select element (choices, item, itemset).
  */
 
-[scriptable, uuid(a29ac2bd-f36a-451e-99e1-0f3bd94ffbef)]
+[scriptable, uuid(9fac2f59-4ec8-456f-ad06-4e28cd7d5b2c)]
 interface nsIXFormsSelectChild : nsISupports
 {
   /*
@@ -61,4 +61,11 @@ interface nsIXFormsSelectChild : nsISupp
    * this method returns that \<item\>.
    */
   nsIDOMNode selectItemByValue(in AString value);
+
+  /*
+   * selectItemByNode is used in \<select1\> and \<select\>. If the
+   * XFormsSelectChild is or contains an \<item\>, which has a node 'equal' the
+   * parameter |aNode|, this method returns the first \<item\> that matches.
+   */
+  nsIDOMNode selectItemByNode(in nsIDOMNode aNode);
 };
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsIXFormsUIWidget.idl mozilla.new/extensions/xforms/nsIXFormsUIWidget.idl
--- mozilla/extensions/xforms/nsIXFormsUIWidget.idl	2005-06-26 20:30:17.000000000 +0200
+++ mozilla.new/extensions/xforms/nsIXFormsUIWidget.idl	2006-02-14 10:01:13.000000000 +0100
@@ -41,6 +41,10 @@
 
 /**
  * Interface implemented by XForms UI widgets.
+ *
+ * For more information on this interface please see
+ * http://developer.mozilla.org/en/docs/XForms:Custom_Controls
+ *
  */
 [scriptable, uuid(b88a1c27-47a2-4c25-be7c-170501a93643)]
 interface nsIXFormsUIWidget : nsIDOMElement
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsAccessors.cpp mozilla.new/extensions/xforms/nsXFormsAccessors.cpp
--- mozilla/extensions/xforms/nsXFormsAccessors.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/extensions/xforms/nsXFormsAccessors.cpp	2006-02-24 11:16:23.000000000 +0100
@@ -0,0 +1,223 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla XForms support.
+ *
+ * The Initial Developer of the Original Code is
+ * Novell, Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Allan Beaufour <abeaufour@novell.com>
+ *  Olli Pettay <Olli.Pettay@helsinki.fi>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsString.h"
+#include "nsIDOMElement.h"
+#include "nsXFormsUtils.h"
+#include "nsXFormsAccessors.h"
+#include "nsDOMString.h"
+#include "nsIEventStateManager.h"
+#include "nsIContent.h"
+#include "nsIXFormsControl.h"
+
+NS_IMPL_ISUPPORTS2(nsXFormsAccessors, nsIXFormsAccessors, nsIClassInfo)
+
+void
+nsXFormsAccessors::Destroy()
+{
+  mElement = nsnull;
+  mDelegate = nsnull;
+}
+
+nsresult
+nsXFormsAccessors::GetState(PRInt32 aState, PRBool *aStateVal)
+{
+  NS_ENSURE_ARG_POINTER(aStateVal);
+  nsCOMPtr<nsIContent> content(do_QueryInterface(mElement));
+  *aStateVal = (content && (content->IntrinsicState() & aState));
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXFormsAccessors::GetValue(nsAString &aValue)
+{
+  if (mDelegate) {
+    mDelegate->GetValue(aValue);
+  } else {
+    SetDOMStringToNull(aValue);
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXFormsAccessors::SetValue(const nsAString & aValue)
+{
+  return mDelegate ? mDelegate->SetValue(aValue) : NS_OK;
+}
+
+NS_IMETHODIMP
+nsXFormsAccessors::HasBoundNode(PRBool *aHasBoundNode)
+{
+  NS_ENSURE_ARG_POINTER(aHasBoundNode);
+  *aHasBoundNode = PR_FALSE;
+  return mDelegate ? mDelegate->GetHasBoundNode(aHasBoundNode) : NS_OK;
+}
+
+NS_IMETHODIMP
+nsXFormsAccessors::IsReadonly(PRBool *aStateVal)
+{
+  return GetState(NS_EVENT_STATE_MOZ_READONLY, aStateVal);
+}
+
+NS_IMETHODIMP
+nsXFormsAccessors::IsRelevant(PRBool *aStateVal)
+{
+  return GetState(NS_EVENT_STATE_ENABLED, aStateVal);
+}
+
+NS_IMETHODIMP
+nsXFormsAccessors::IsRequired(PRBool *aStateVal)
+{
+  return GetState(NS_EVENT_STATE_REQUIRED, aStateVal);
+}
+
+NS_IMETHODIMP
+nsXFormsAccessors::IsValid(PRBool *aStateVal)
+{
+  return GetState(NS_EVENT_STATE_VALID, aStateVal);
+}
+
+NS_IMETHODIMP
+nsXFormsAccessors::SetContent(nsIDOMNode *aNode, PRBool aForceUpdate)
+{
+  NS_ENSURE_STATE(mElement);
+  NS_ENSURE_ARG(aNode);
+
+  nsCOMPtr<nsIDOMNode> boundNode;
+  nsresult rv = GetBoundNode(getter_AddRefs(boundNode));
+  NS_ENSURE_STATE(boundNode);
+
+  nsCOMPtr<nsIModelElementPrivate> modelPriv = nsXFormsUtils::GetModel(mElement);
+  NS_ENSURE_STATE(modelPriv);
+
+  PRBool changed;
+  rv = modelPriv->SetNodeContent(boundNode, aNode, &changed);
+  NS_ENSURE_SUCCESS(rv, rv);
+  if (aForceUpdate) {
+    nsCOMPtr<nsIDOMNode> model = do_QueryInterface(modelPriv);
+ 
+    if (model) {
+      rv = nsXFormsUtils::DispatchEvent(model, eEvent_Rebuild);
+      NS_ENSURE_SUCCESS(rv, rv);
+      rv = nsXFormsUtils::DispatchEvent(model, eEvent_Recalculate);
+      NS_ENSURE_SUCCESS(rv, rv);
+      rv = nsXFormsUtils::DispatchEvent(model, eEvent_Revalidate);
+      NS_ENSURE_SUCCESS(rv, rv);
+      rv = nsXFormsUtils::DispatchEvent(model, eEvent_Refresh);
+      NS_ENSURE_SUCCESS(rv, rv);
+    }
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXFormsAccessors::GetBoundNode(nsIDOMNode **aBoundNode)
+{
+  NS_ENSURE_ARG_POINTER(aBoundNode);
+  if (mDelegate) {
+    nsCOMPtr<nsIXFormsControl> control = do_QueryInterface(mDelegate);
+    return control->GetBoundNode(aBoundNode);
+  }
+  return NS_OK;
+}
+
+// nsIClassInfo implementation
+
+static const nsIID sScriptingIIDs[] = {
+  NS_IXFORMSACCESSORS_IID
+};
+
+NS_IMETHODIMP
+nsXFormsAccessors::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
+{
+  return nsXFormsUtils::CloneScriptingInterfaces(sScriptingIIDs,
+                                                 NS_ARRAY_LENGTH(sScriptingIIDs),
+                                                 aCount, aArray);
+}
+
+NS_IMETHODIMP
+nsXFormsAccessors::GetHelperForLanguage(PRUint32 language,
+                                        nsISupports **_retval)
+{
+  *_retval = nsnull;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXFormsAccessors::GetContractID(char * *aContractID)
+{
+  *aContractID = nsnull;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXFormsAccessors::GetClassDescription(char * *aClassDescription)
+{
+  *aClassDescription = nsnull;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXFormsAccessors::GetClassID(nsCID * *aClassID)
+{
+  *aClassID = nsnull;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXFormsAccessors::GetImplementationLanguage(PRUint32 *aImplementationLanguage)
+{
+  *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXFormsAccessors::GetFlags(PRUint32 *aFlags)
+{
+  *aFlags = nsIClassInfo::DOM_OBJECT;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXFormsAccessors::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
+{
+  return NS_ERROR_NOT_AVAILABLE;
+}
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsAccessors.h mozilla.new/extensions/xforms/nsXFormsAccessors.h
--- mozilla/extensions/xforms/nsXFormsAccessors.h	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/extensions/xforms/nsXFormsAccessors.h	2006-02-07 16:30:11.000000000 +0100
@@ -0,0 +1,85 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla XForms support.
+ *
+ * The Initial Developer of the Original Code is
+ * Novell, Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Allan Beaufour <abeaufour@novell.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NSXFORMSACCESSORS_H__
+#define __NSXFORMSACCESSORS_H__
+
+#include "nsIClassInfo.h"
+#include "nsIXFormsAccessors.h"
+#include "nsIDelegateInternal.h"
+
+class nsIDOMElement;
+
+/**
+ * Implementation of the nsIXFormsAccessors object. It is always owned by a
+ * nsIXFormsDelegate.
+ */
+class nsXFormsAccessors : public nsIXFormsAccessors,
+                          public nsIClassInfo
+{
+public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSICLASSINFO
+  NS_DECL_NSIXFORMSACCESSORS
+
+  /** Constructor */
+  nsXFormsAccessors(nsIDelegateInternal* aDelegate, nsIDOMElement* aElement)
+    : mDelegate(aDelegate), mElement(aElement) 
+  {
+  }
+
+  /** Called by the owning delegate when it itself is destroyed */
+  void Destroy();
+
+protected:
+  /**
+   * Checks the status of the model item properties
+   *
+   * @param aState       The state to check
+   * @para  aStateVal    The returned state
+   */
+  nsresult GetState(PRInt32 aState, PRBool *aStateVal);
+
+  /** The delegate owning us */
+  nsIDelegateInternal*   mDelegate;
+
+  /** The control DOM element */
+  nsIDOMElement*         mElement;
+};
+
+#endif
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsAtoms.cpp mozilla.new/extensions/xforms/nsXFormsAtoms.cpp
--- mozilla/extensions/xforms/nsXFormsAtoms.cpp	2005-10-22 16:39:09.000000000 +0200
+++ mozilla.new/extensions/xforms/nsXFormsAtoms.cpp	2006-02-14 10:01:13.000000000 +0100
@@ -61,7 +61,6 @@ nsIAtom *nsXFormsAtoms::incremental;
 nsIAtom *nsXFormsAtoms::clazz;
 nsIAtom *nsXFormsAtoms::deferredBindListProperty;
 nsIAtom *nsXFormsAtoms::readyForBindProperty;
-nsIAtom *nsXFormsAtoms::accesskey;
 nsIAtom *nsXFormsAtoms::fatalError;
 nsIAtom *nsXFormsAtoms::isInstanceDocument;
 nsIAtom *nsXFormsAtoms::instanceDocumentOwner;
@@ -89,7 +88,6 @@ const nsStaticAtom nsXFormsAtoms::Atoms_
   { "class",                    &nsXFormsAtoms::clazz },
   { "DeferredBindListProperty", &nsXFormsAtoms::deferredBindListProperty },
   { "ReadyForBindProperty",     &nsXFormsAtoms::readyForBindProperty },
-  { "accesskey",                &nsXFormsAtoms::accesskey },
   { "fatalError",               &nsXFormsAtoms::fatalError },
   { "isInstanceDocument",       &nsXFormsAtoms::isInstanceDocument },
   { "instanceDocumentOwner",    &nsXFormsAtoms::instanceDocumentOwner }
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsAtoms.h mozilla.new/extensions/xforms/nsXFormsAtoms.h
--- mozilla/extensions/xforms/nsXFormsAtoms.h	2005-10-22 16:39:09.000000000 +0200
+++ mozilla.new/extensions/xforms/nsXFormsAtoms.h	2006-02-14 10:01:13.000000000 +0100
@@ -69,7 +69,6 @@ class nsXFormsAtoms
   static NS_HIDDEN_(nsIAtom *) clazz;
   static NS_HIDDEN_(nsIAtom *) deferredBindListProperty;
   static NS_HIDDEN_(nsIAtom *) readyForBindProperty;
-  static NS_HIDDEN_(nsIAtom *) accesskey;
   static NS_HIDDEN_(nsIAtom *) fatalError;
   static NS_HIDDEN_(nsIAtom *) isInstanceDocument;
   static NS_HIDDEN_(nsIAtom *) instanceDocumentOwner;
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsChoicesElement.cpp mozilla.new/extensions/xforms/nsXFormsChoicesElement.cpp
--- mozilla/extensions/xforms/nsXFormsChoicesElement.cpp	2005-09-02 19:23:35.000000000 +0200
+++ mozilla.new/extensions/xforms/nsXFormsChoicesElement.cpp	2006-02-14 10:01:13.000000000 +0100
@@ -219,6 +219,36 @@ nsXFormsChoicesElement::SelectItemByValu
   return NS_OK;
 }
 
+NS_IMETHODIMP
+nsXFormsChoicesElement::SelectItemByNode(nsIDOMNode *aNode,
+                                         nsIDOMNode **aSelected)
+{
+  NS_ENSURE_ARG_POINTER(aSelected);
+  NS_ENSURE_STATE(mElement);
+  *aSelected = nsnull;
+  nsCOMPtr<nsIDOMNodeList> children;
+  nsresult rv = mElement->GetChildNodes(getter_AddRefs(children));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  PRUint32 childCount = 0;
+  children->GetLength(&childCount);
+
+  nsCOMPtr<nsIDOMNode> childNode;
+  nsCOMPtr<nsIXFormsSelectChild> childItem;
+
+  for (PRUint32 i = 0; i < childCount; ++i) {
+    children->Item(i, getter_AddRefs(childNode));
+    childItem = do_QueryInterface(childNode);
+    if (childItem) {
+      childItem->SelectItemByNode(aNode, aSelected);
+      if (*aSelected)
+        return NS_OK;
+    }
+  }
+  
+  return NS_OK;
+}
+
 // internal methods
 
 void
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsContextContainer.cpp mozilla.new/extensions/xforms/nsXFormsContextContainer.cpp
--- mozilla/extensions/xforms/nsXFormsContextContainer.cpp	2005-08-03 20:43:43.000000000 +0200
+++ mozilla.new/extensions/xforms/nsXFormsContextContainer.cpp	2006-02-14 10:01:13.000000000 +0100
@@ -82,9 +82,12 @@ protected:
   /** The context size for the element */
   PRInt32 mContextSize;
 
+  /** Does this element have the repeat-index? */
+  PRBool mHasIndex;
+
 public:
   nsXFormsContextContainer()
-    : mContextPosition(1), mContextSize(1) {}
+    : mContextPosition(1), mContextSize(1), mHasIndex(PR_FALSE) {}
 
   NS_DECL_ISUPPORTS_INHERITED
 
@@ -260,12 +263,13 @@ NS_IMETHODIMP
 nsXFormsContextContainer::SetIndexState(PRBool aHasIndex)
 {
   if (mElement) {
-    NS_NAMED_LITERAL_STRING(repIndex, "repeat-index");
+    mHasIndex = aHasIndex;
+    NS_NAMED_LITERAL_STRING(classStr, "class");
     if (aHasIndex) {
-      mElement->SetAttribute(repIndex,
-                             NS_LITERAL_STRING("1"));
+      mElement->SetAttribute(classStr,
+                             NS_LITERAL_STRING("xf-repeat-item xf-repeat-index"));
     } else {
-      mElement->RemoveAttribute(repIndex);
+      mElement->SetAttribute(classStr, NS_LITERAL_STRING("xf-repeat-item"));
     }
   }
   return NS_OK;
@@ -273,8 +277,10 @@ nsXFormsContextContainer::SetIndexState(
 
 NS_IMETHODIMP
 nsXFormsContextContainer::GetIndexState(PRBool *aHasIndex)
-{  
-  return mElement->HasAttribute(NS_LITERAL_STRING("repeat-index"), aHasIndex);
+{
+  NS_ENSURE_ARG(aHasIndex);
+  *aHasIndex = mHasIndex;
+  return NS_OK;
 }
 
 // Factory
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsControlStub.cpp mozilla.new/extensions/xforms/nsXFormsControlStub.cpp
--- mozilla/extensions/xforms/nsXFormsControlStub.cpp	2005-10-23 18:30:13.000000000 +0200
+++ mozilla.new/extensions/xforms/nsXFormsControlStub.cpp	2006-02-14 10:01:13.000000000 +0100
@@ -46,8 +46,6 @@
 #include "nsIDOMKeyEvent.h"
 #include "nsIDOMEventTarget.h"
 #include "nsIDOMXPathResult.h"
-#include "nsIDOMDocumentView.h"
-#include "nsIDOMAbstractView.h"
 #include "nsIXTFXMLVisualWrapper.h"
 #include "nsIDocument.h"
 #include "nsXFormsModelElement.h"
@@ -55,8 +53,6 @@
 #include "nsIFocusController.h"
 #include "nsIScriptGlobalObject.h"
 #include "nsIServiceManager.h"
-#include "nsIPrefBranch.h"
-#include "nsIPrefService.h"
 #include "nsIEventStateManager.h"
 #include "nsIContent.h"
 
@@ -417,68 +413,13 @@ nsXFormsControlStubBase::HandleDefault(n
         focusController->MoveFocus(PR_FALSE, nsnull);
       }
     } else if (type.EqualsASCII(sXFormsEventsEntries[eEvent_BindingException].name)) {
-      *aHandled = HandleBindingException();
+      *aHandled = nsXFormsUtils::HandleBindingException(mElement);
     }
   }
   
   return NS_OK;
 }
 
-PRBool
-nsXFormsControlStubBase::HandleBindingException()
-{
-  if (!mElement) {
-    return PR_FALSE;
-  }
-  nsCOMPtr<nsIDOMDocument> doc;
-  mElement->GetOwnerDocument(getter_AddRefs(doc));
-
-  nsCOMPtr<nsIDocument> iDoc(do_QueryInterface(doc));
-  if (!iDoc) {
-    return PR_FALSE;
-  }
-
-  // check for fatalError property, enforcing that only one fatal error will
-  // be shown to the user
-  if (iDoc->GetProperty(nsXFormsAtoms::fatalError)) {
-    return PR_FALSE;
-  }
-  iDoc->SetProperty(nsXFormsAtoms::fatalError, iDoc);
-
-  // Check for preference, disabling this popup
-  PRBool disablePopup = PR_FALSE;
-  nsresult rv;
-  nsCOMPtr<nsIPrefBranch> pref = do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);
-  if (NS_SUCCEEDED(rv) && pref) {
-    PRBool val;
-    if (NS_SUCCEEDED(pref->GetBoolPref("xforms.disablePopup", &val)))
-      disablePopup = val;
-  }
-  if (disablePopup)
-    return PR_FALSE;
-
-  // Get nsIDOMWindowInternal
-  nsCOMPtr<nsIDOMDocumentView> dview(do_QueryInterface(doc));
-  if (!dview)
-    return PR_FALSE;
-
-  nsCOMPtr<nsIDOMAbstractView> aview;
-  dview->GetDefaultView(getter_AddRefs(aview));
-
-  nsCOMPtr<nsIDOMWindowInternal> internal(do_QueryInterface(aview));
-  if (!internal)
-    return PR_FALSE;
-
-  // Show popup
-  nsCOMPtr<nsIDOMWindow> messageWindow;
-  rv = internal->OpenDialog(NS_LITERAL_STRING("chrome://xforms/content/bindingex.xul"),
-                            NS_LITERAL_STRING("XFormsBindingException"),
-                            NS_LITERAL_STRING("modal,dialog,chrome,dependent"),
-                            nsnull, getter_AddRefs(messageWindow));
-  return NS_SUCCEEDED(rv);
-}
-
-
 #ifdef DEBUG_smaug
 static nsVoidArray* sControlList = nsnull;
 class ControlDebug
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsControlStub.h mozilla.new/extensions/xforms/nsXFormsControlStub.h
--- mozilla/extensions/xforms/nsXFormsControlStub.h	2005-10-23 18:30:13.000000000 +0200
+++ mozilla.new/extensions/xforms/nsXFormsControlStub.h	2006-02-14 10:01:13.000000000 +0100
@@ -222,16 +222,6 @@ protected:
 
   /** Removes the index change event listeners */
   void RemoveIndexListeners();
-
-  /**
-   * Shows an error dialog for the user the first time an
-   * xforms-binding-exception event is received by the control.
-   *
-   * The dialog can be disabled via the |xforms.disablePopup| preference.
-   *
-   * @return                 Whether handling was successful
-   */
-  PRBool HandleBindingException();
 };
 
 
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsCopyElement.cpp mozilla.new/extensions/xforms/nsXFormsCopyElement.cpp
--- mozilla/extensions/xforms/nsXFormsCopyElement.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/extensions/xforms/nsXFormsCopyElement.cpp	2006-02-07 16:30:11.000000000 +0100
@@ -0,0 +1,191 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla XForms support.
+ *
+ * The Initial Developer of the Original Code is
+ * IBM Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Aaron Reed <aaronr@us.ibm.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIXFormsCopyElement.h"
+#include "nsXFormsStubElement.h"
+#include "nsIXTFGenericElementWrapper.h"
+#include "nsXFormsUtils.h"
+#include "nsIDOMElement.h"
+#include "nsString.h"
+#include "nsIXFormsItemElement.h"
+
+/**
+ * Implementation of the XForms \<copy\> element.
+ *
+ * @note The copy element does not display any content, it simply provides
+ * a node to be copied to instance data when the containing XForms item
+ * element is selected.
+ */
+
+class nsXFormsCopyElement : public nsXFormsStubElement,
+                            public nsIXFormsCopyElement
+{
+public:
+  nsXFormsCopyElement() : mElement(nsnull) {}
+
+  NS_DECL_ISUPPORTS_INHERITED
+
+  // nsIXTFGenericElement overrides
+  NS_IMETHOD OnCreated(nsIXTFGenericElementWrapper *aWrapper);
+
+  // nsIXTFElement overrides
+  NS_IMETHOD ParentChanged(nsIDOMElement *aNewParent);
+  NS_IMETHOD DocumentChanged(nsIDOMDocument *aNewParent);
+
+  // nsIXFormsCopyElement
+  NS_DECL_NSIXFORMSCOPYELEMENT
+
+private:
+  nsIDOMElement *mElement;
+};
+
+NS_IMPL_ISUPPORTS_INHERITED1(nsXFormsCopyElement,
+                             nsXFormsStubElement,
+                             nsIXFormsCopyElement)
+
+NS_IMETHODIMP
+nsXFormsCopyElement::OnCreated(nsIXTFGenericElementWrapper *aWrapper)
+{
+  aWrapper->SetNotificationMask(nsIXTFElement::NOTIFY_PARENT_CHANGED |
+                                nsIXTFElement::NOTIFY_DOCUMENT_CHANGED);
+
+  nsCOMPtr<nsIDOMElement> node;
+  aWrapper->GetElementNode(getter_AddRefs(node));
+
+  // It's ok to keep pointer to mElement.  mElement will have an
+  // owning reference to this object, so as long as we null out mElement in
+  // OnDestroyed, it will always be valid.
+
+  mElement = node;
+  NS_ASSERTION(mElement, "Wrapper is not an nsIDOMElement, we'll crash soon");
+
+  return NS_OK;
+}
+
+// nsIXTFElement
+
+NS_IMETHODIMP
+nsXFormsCopyElement::ParentChanged(nsIDOMElement *aNewParent)
+{
+  if (aNewParent) {
+    if (!nsXFormsUtils::IsXFormsElement(aNewParent, 
+                                        NS_LITERAL_STRING("itemset")) &&
+        !nsXFormsUtils::IsXFormsElement(aNewParent, 
+          NS_LITERAL_STRING("contextcontainer"))) {
+
+        // parent of a copy element must always be an itemset.  We really can't
+        // enforce this all that well until we have full schema support but for
+        // now we'll at least warn the author.  We are also checking for
+        // contextcontainer because under Mozilla, the children of an itemset
+        // element are cloned underneath a contextcontainer which is in turn
+        // contained in a nsXFormsItemElement.  Each such item element is then
+        // appended as anonymous content of the itemset.
+        nsXFormsUtils::ReportError(NS_LITERAL_STRING("copyError"), mElement);
+    }
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXFormsCopyElement::DocumentChanged(nsIDOMDocument* aNewDocument)
+{
+  if (!aNewDocument)
+    return NS_OK;
+  
+  // tell grandparent (xf:item) that it contains a xf:copy element and
+  // not a xf:value element.
+  nsCOMPtr<nsIDOMNode> contextContainer;
+  nsresult rv = mElement->GetParentNode(getter_AddRefs(contextContainer));
+  NS_ENSURE_TRUE(contextContainer, rv);
+
+  nsCOMPtr<nsIDOMNode> itemNode;
+  rv = contextContainer->GetParentNode(getter_AddRefs(itemNode));
+  NS_ENSURE_TRUE(itemNode, rv);
+
+  nsCOMPtr<nsIXFormsItemElement> item = do_QueryInterface(itemNode);
+
+  // It is possible that the grandparent ISN'T an xf:item, if this is the
+  // original template copy element whose parent is the xf:itemset and
+  // grandparent is the xf:select.  We'll ignore a copy element in that case
+  // since it really isn't in play.
+  if (item) {
+    item->SetIsCopyItem(PR_TRUE);
+  }
+  return NS_OK;
+}
+
+// nsIXFormsCopyElement
+
+NS_IMETHODIMP
+nsXFormsCopyElement::GetCopyNode(nsIDOMNode **aNode)
+{
+  NS_ENSURE_ARG_POINTER(aNode);
+  *aNode = nsnull;
+
+  nsCOMPtr<nsIModelElementPrivate> model;
+  nsCOMPtr<nsIDOMXPathResult> result;
+  nsresult rv =
+    nsXFormsUtils::EvaluateNodeBinding(mElement,
+                                       nsXFormsUtils::ELEMENT_WITH_MODEL_ATTR,
+                                       NS_LITERAL_STRING("ref"), EmptyString(),
+                                       nsIDOMXPathResult::FIRST_ORDERED_NODE_TYPE,
+                                       getter_AddRefs(model),
+                                       getter_AddRefs(result));
+
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  if (result) {
+    nsCOMPtr<nsIDOMNode> singleNode;
+    result->GetSingleNodeValue(getter_AddRefs(singleNode));
+
+    NS_IF_ADDREF(*aNode = singleNode);
+  }
+
+  return NS_OK;
+}
+
+NS_HIDDEN_(nsresult)
+NS_NewXFormsCopyElement(nsIXTFElement **aResult)
+{
+  *aResult = new nsXFormsCopyElement();
+  if (!*aResult)
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  NS_ADDREF(*aResult);
+  return NS_OK;
+}
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsDelegateStub.cpp mozilla.new/extensions/xforms/nsXFormsDelegateStub.cpp
--- mozilla/extensions/xforms/nsXFormsDelegateStub.cpp	2005-10-22 17:24:19.000000000 +0200
+++ mozilla.new/extensions/xforms/nsXFormsDelegateStub.cpp	2006-02-14 10:01:13.000000000 +0100
@@ -54,11 +54,10 @@
 #include "nsXFormsUtils.h"
 #include "nsIServiceManager.h"
 #include "nsXFormsModelElement.h"
-#include "nsIContent.h"
-#include "nsIEventStateManager.h"
 
-NS_IMPL_ISUPPORTS_INHERITED1(nsXFormsDelegateStub,
+NS_IMPL_ISUPPORTS_INHERITED2(nsXFormsDelegateStub,
                              nsXFormsBindableControlStub,
+                             nsIDelegateInternal,
                              nsIXFormsDelegate)
 
 
@@ -91,6 +90,9 @@ NS_IMETHODIMP
 nsXFormsDelegateStub::OnDestroyed()
 {
   nsXFormsModelElement::CancelPostRefresh(this);
+  if (mAccessor) {
+    mAccessor->Destroy();
+  }
   return nsXFormsBindableControlStub::OnDestroyed();
 }
 
@@ -169,48 +171,19 @@ nsXFormsDelegateStub::SetValue(const nsA
   return NS_OK;
 }
 
-nsresult
-nsXFormsDelegateStub::GetState(PRInt32 aState, PRBool *aStateVal)
-{
-  NS_ENSURE_ARG_POINTER(aStateVal);
-  *aStateVal = PR_FALSE;
-  nsCOMPtr<nsIContent> content(do_QueryInterface(mElement));
-  if (content && (content->IntrinsicState() & aState)) {
-    *aStateVal = PR_TRUE;
-  }  
-  return NS_OK;
-}
-
-// XXXbeaufour search for "enabled", "disabled", HasAttribute() and SetAttribute()
-
-NS_IMETHODIMP
-nsXFormsDelegateStub::GetIsReadonly(PRBool *aStateVal)
-{
-  return GetState(NS_EVENT_STATE_MOZ_READONLY, aStateVal);
-}
-
-NS_IMETHODIMP
-nsXFormsDelegateStub::GetIsEnabled(PRBool *aStateVal)
-{
-  return GetState(NS_EVENT_STATE_ENABLED, aStateVal);
-}
-
 NS_IMETHODIMP
-nsXFormsDelegateStub::GetIsRequired(PRBool *aStateVal)
-{
-  return GetState(NS_EVENT_STATE_REQUIRED, aStateVal);
-}
-
-NS_IMETHODIMP
-nsXFormsDelegateStub::GetIsValid(PRBool *aStateVal)
+nsXFormsDelegateStub::GetHasBoundNode(PRBool *aHasBoundNode)
 {
-  return GetState(NS_EVENT_STATE_VALID, aStateVal);
+  NS_ENSURE_ARG_POINTER(aHasBoundNode);
+  *aHasBoundNode = mBoundNode ? PR_TRUE : PR_FALSE;
+  return NS_OK;
 }
 
 NS_IMETHODIMP
-nsXFormsDelegateStub::GetHasBoundNode(PRBool *aHasBoundNode)
+nsXFormsDelegateStub::ReportError(const nsAString& aErrorMsg)
 {
-  *aHasBoundNode = mBoundNode ? PR_TRUE : PR_FALSE;
+  const nsPromiseFlatString& flat = PromiseFlatString(aErrorMsg);
+  nsXFormsUtils::ReportError(flat, mElement);
   return NS_OK;
 }
 
@@ -223,6 +196,8 @@ nsXFormsDelegateStub::WidgetAttached()
   return NS_OK;
 }
 
+// nsXFormsDelegateStub
+
 nsRepeatState
 nsXFormsDelegateStub::UpdateRepeatState()
 {
@@ -265,3 +240,16 @@ nsXFormsDelegateStub::SetMozTypeAttribut
     mElement->RemoveAttributeNS(mozTypeNs, mozType);
   }
 }
+
+NS_IMETHODIMP
+nsXFormsDelegateStub::GetXFormsAccessors(nsIXFormsAccessors **aAccessor)
+{
+  if (!mAccessor) {
+    mAccessor = new nsXFormsAccessors(this, mElement);
+    if (!mAccessor) {
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+  }
+  NS_ADDREF(*aAccessor = mAccessor);
+  return NS_OK;
+}
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsDelegateStub.h mozilla.new/extensions/xforms/nsXFormsDelegateStub.h
--- mozilla/extensions/xforms/nsXFormsDelegateStub.h	2005-10-22 17:24:19.000000000 +0200
+++ mozilla.new/extensions/xforms/nsXFormsDelegateStub.h	2006-02-14 10:01:13.000000000 +0100
@@ -40,12 +40,14 @@
 #ifndef __NSXFORMSDELEGATESTUB_H__
 #define __NSXFORMSDELEGATESTUB_H__
 
+#include "nsAutoPtr.h"
 #include "nsCOMPtr.h"
 #include "nsString.h"
 #include "nsIDOMElement.h"
-#include "nsIXFormsDelegate.h"
+#include "nsIDelegateInternal.h"
 #include "nsXFormsControlStub.h"
 #include "nsIXFormsUIWidget.h"
+#include "nsXFormsAccessors.h"
 
 class nsIAtom;
 
@@ -65,11 +67,12 @@ enum nsRepeatState {
  * Stub implementation of the nsIXFormsDelegate interface.
  */
 class nsXFormsDelegateStub : public nsXFormsBindableControlStub,
-                             public nsIXFormsDelegate
+                             public nsIDelegateInternal
 {
 public:
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_NSIXFORMSDELEGATE
+  NS_DECL_NSIDELEGATEINTERNAL
 
   NS_IMETHOD OnCreated(nsIXTFBindableElementWrapper *aWrapper);
   NS_IMETHOD OnDestroyed();
@@ -96,9 +99,6 @@ public:
     : mControlType(aType), mRepeatState(eType_Unknown) {}
 
 protected:
-  // Checks the status of the model item properties.
-  nsresult GetState(PRInt32 aState, PRBool *aStateVal);
-  
   // This is called when XBL widget is attached to the XForms control.
   // It checks the ancestors of the element and returns an nsRepeatState
   // depending on the elements place in the document.
@@ -110,6 +110,9 @@ protected:
 
   nsString      mControlType;
   nsRepeatState mRepeatState;
+
+  /** The accessors object for this delegate */
+  nsRefPtr<nsXFormsAccessors> mAccessor;
 };
 
 #endif
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsElementFactory.cpp mozilla.new/extensions/xforms/nsXFormsElementFactory.cpp
--- mozilla/extensions/xforms/nsXFormsElementFactory.cpp	2005-10-22 16:39:09.000000000 +0200
+++ mozilla.new/extensions/xforms/nsXFormsElementFactory.cpp	2006-02-14 10:01:13.000000000 +0100
@@ -72,6 +72,8 @@ NS_HIDDEN_(nsresult) NS_NewXFormsItemEle
 NS_HIDDEN_(nsresult) NS_NewXFormsValueElement(nsIXTFElement **aElement);
 NS_HIDDEN_(nsresult) NS_NewXFormsChoicesElement(nsIXTFElement **aElement);
 NS_HIDDEN_(nsresult) NS_NewXFormsItemSetElement(nsIXTFElement **aElement);
+NS_HIDDEN_(nsresult) NS_NewXFormsRangeElement(nsIXTFElement **aElement);
+NS_HIDDEN_(nsresult) NS_NewXFormsCopyElement(nsIXTFElement **aElement);
 
 //Action Module Elements
 NS_HIDDEN_(nsresult) NS_NewXFormsDispatchElement(nsIXTFElement **aResult);
@@ -188,6 +190,10 @@ nsXFormsElementFactory::CreateElement(co
     return NS_NewXFormsSwitchElement(aElement);
   if (aTagName.EqualsLiteral("upload"))
     return NS_NewXFormsUploadElement(aElement);
+  if (aTagName.EqualsLiteral("range"))
+    return NS_NewXFormsRangeElement(aElement);
+  if (aTagName.EqualsLiteral("copy"))
+    return NS_NewXFormsCopyElement(aElement);
 
   *aElement = nsnull;
   return NS_ERROR_FAILURE;
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsInsertDeleteElement.cpp mozilla.new/extensions/xforms/nsXFormsInsertDeleteElement.cpp
--- mozilla/extensions/xforms/nsXFormsInsertDeleteElement.cpp	2005-10-22 16:39:09.000000000 +0200
+++ mozilla.new/extensions/xforms/nsXFormsInsertDeleteElement.cpp	2006-02-14 10:01:13.000000000 +0100
@@ -12,6 +12,8 @@
  * for the specific language governing rights and limitations under the
  * License.
  *
+ * The Original Code is XForms code.
+ *
  * The Initial Developer of the Original Code is
  * Novell, Inc.
  * Portions created by the Initial Developer are Copyright (C) 2005
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsInstanceElement.cpp mozilla.new/extensions/xforms/nsXFormsInstanceElement.cpp
--- mozilla/extensions/xforms/nsXFormsInstanceElement.cpp	2005-10-22 16:39:09.000000000 +0200
+++ mozilla.new/extensions/xforms/nsXFormsInstanceElement.cpp	2006-02-14 10:01:13.000000000 +0100
@@ -63,7 +63,7 @@ NS_IMPL_ISUPPORTS_INHERITED5(nsXFormsIns
 
 nsXFormsInstanceElement::nsXFormsInstanceElement()
   : mElement(nsnull)
-  , mAddingChildren(PR_FALSE)
+  , mInitialized(PR_FALSE)
   , mLazy(PR_FALSE)
 {
 }
@@ -87,7 +87,7 @@ NS_IMETHODIMP
 nsXFormsInstanceElement::AttributeSet(nsIAtom *aName,
                                       const nsAString &aNewValue)
 {
-  if (mAddingChildren || mLazy)
+  if (!mInitialized || mLazy)
     return NS_OK;
 
   if (aName == nsXFormsAtoms::src) {
@@ -100,7 +100,7 @@ nsXFormsInstanceElement::AttributeSet(ns
 NS_IMETHODIMP
 nsXFormsInstanceElement::AttributeRemoved(nsIAtom *aName)
 {
-  if (mAddingChildren || mLazy)
+  if (!mInitialized || mLazy)
     return NS_OK;
 
   if (aName == nsXFormsAtoms::src) {
@@ -136,50 +136,10 @@ nsXFormsInstanceElement::AttributeRemove
 }
 
 NS_IMETHODIMP
-nsXFormsInstanceElement::BeginAddingChildren()
-{
-  mAddingChildren = PR_TRUE;
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsXFormsInstanceElement::DoneAddingChildren()
-{
-  
-  mElement->HasAttributeNS(NS_LITERAL_STRING(NS_NAMESPACE_MOZ_XFORMS_LAZY),
-                           NS_LITERAL_STRING("lazy"), &mLazy);
-  if (!mLazy) {
-    nsCOMPtr<nsIModelElementPrivate> model = GetModel();
-    NS_ENSURE_TRUE(model, NS_ERROR_FAILURE);
-    model->AddInstanceElement(this);
-
-    // By the time this is called, we should be inserted in the document and
-    // have all of our child elements, so this is our first opportunity to
-    // create the instance document.
-  
-    nsAutoString src;
-    mElement->GetAttribute(NS_LITERAL_STRING("src"), src);
-  
-    if (src.IsEmpty()) {
-      // If we don't have a linked external instance, use our inline data.
-      CloneInlineInstance();
-    } else {
-      LoadExternalInstance(src);
-    }
-  }
-
-  mAddingChildren = PR_FALSE;
-  return NS_OK;
-}
-
-NS_IMETHODIMP
 nsXFormsInstanceElement::OnCreated(nsIXTFGenericElementWrapper *aWrapper)
 {
   aWrapper->SetNotificationMask(nsIXTFElement::NOTIFY_ATTRIBUTE_SET |
-                                nsIXTFElement::NOTIFY_ATTRIBUTE_REMOVED |
-                                nsIXTFElement::NOTIFY_PARENT_CHANGED |
-                                nsIXTFElement::NOTIFY_BEGIN_ADDING_CHILDREN |
-                                nsIXTFElement::NOTIFY_DONE_ADDING_CHILDREN);
+                                nsIXTFElement::NOTIFY_ATTRIBUTE_REMOVED);
 
   nsCOMPtr<nsIDOMElement> node;
   aWrapper->GetElementNode(getter_AddRefs(node));
@@ -194,22 +154,6 @@ nsXFormsInstanceElement::OnCreated(nsIXT
   return NS_OK;
 }
 
-NS_IMETHODIMP
-nsXFormsInstanceElement::ParentChanged(nsIDOMElement *aNewParent)
-{
-  if (!aNewParent || mAddingChildren || mLazy)
-    return NS_OK;
-
-  // Once we are set up in the DOM, can find the model and make sure that this
-  // instance is on the list of instance elements that model keeps
-  nsCOMPtr<nsIModelElementPrivate> model = GetModel();
-  if (model) {
-    model->AddInstanceElement(this);
-  }
-  
-  return NS_OK;
-}
-
 // nsIInterfaceRequestor
 
 NS_IMETHODIMP
@@ -239,7 +183,7 @@ nsXFormsInstanceElement::OnChannelRedire
   nsCOMPtr<nsIDocument> doc(do_QueryInterface(domDoc));
   NS_ENSURE_STATE(doc);
 
-  if (!nsXFormsUtils::CheckSameOrigin(doc->GetDocumentURI(), newURI)) {
+  if (!nsXFormsUtils::CheckSameOrigin(doc, newURI)) {
     nsXFormsUtils::ReportError(NS_LITERAL_STRING("instanceLoadOrigin"), domDoc);
     return NS_ERROR_ABORT;
   }
@@ -445,48 +389,73 @@ nsXFormsInstanceElement::GetElement(nsID
 }
 
 NS_IMETHODIMP
-nsXFormsInstanceElement::InitializeLazyInstance()
+nsXFormsInstanceElement::Initialize()
 {
-  NS_ENSURE_STATE(mElement);
-  if (!mLazy) {
-    mElement->HasAttributeNS(NS_LITERAL_STRING(NS_NAMESPACE_MOZ_XFORMS_LAZY),
-                             NS_LITERAL_STRING("lazy"), &mLazy);
+  if (mInitialized || !mElement) {
+    return NS_OK;
   }
 
-  NS_ENSURE_STATE(mLazy);
-
-  nsCOMPtr<nsIDOMDocument> domDoc;
-  mElement->GetOwnerDocument(getter_AddRefs(domDoc));
-  NS_ENSURE_STATE(domDoc);
+  mInitialized = PR_TRUE;
 
-  nsCOMPtr<nsIDOMDOMImplementation> domImpl;
-  nsresult rv = domDoc->GetImplementation(getter_AddRefs(domImpl));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  nsCOMPtr<nsIDOMDocument> newDoc;
-  rv = domImpl->CreateDocument(EmptyString(), EmptyString(), nsnull,
-                               getter_AddRefs(newDoc));
-  NS_ENSURE_SUCCESS(rv, rv);
+  nsCOMPtr<nsIModelElementPrivate> model = GetModel();
+  NS_ENSURE_TRUE(model, NS_ERROR_FAILURE);
+  model->AddInstanceElement(this);
 
-  rv = SetDocument(newDoc);
-  NS_ENSURE_SUCCESS(rv, rv);
+  mElement->HasAttributeNS(NS_LITERAL_STRING(NS_NAMESPACE_MOZ_XFORMS_LAZY),
+                           NS_LITERAL_STRING("lazy"), &mLazy);
 
-  // Lazy authored instance documents have a root named "instanceData"
-  nsCOMPtr<nsIDOMElement> instanceDataElement;
-  nsCOMPtr<nsIDOMNode> childReturn;
-  rv = mDocument->CreateElementNS(EmptyString(), 
-                                  NS_LITERAL_STRING("instanceData"),
-                                  getter_AddRefs(instanceDataElement));
-  NS_ENSURE_SUCCESS(rv, rv);
-  rv = mDocument->AppendChild(instanceDataElement, getter_AddRefs(childReturn));
-  NS_ENSURE_SUCCESS(rv, rv);
+  // Lazy instance
+  if (mLazy) {
+    nsCOMPtr<nsIDOMDocument> domDoc;
+    mElement->GetOwnerDocument(getter_AddRefs(domDoc));
+    NS_ENSURE_STATE(domDoc);
+  
+    nsCOMPtr<nsIDOMDOMImplementation> domImpl;
+    nsresult rv = domDoc->GetImplementation(getter_AddRefs(domImpl));
+    NS_ENSURE_SUCCESS(rv, rv);
+  
+    nsCOMPtr<nsIDOMDocument> newDoc;
+    rv = domImpl->CreateDocument(EmptyString(), EmptyString(), nsnull,
+                                 getter_AddRefs(newDoc));
+    NS_ENSURE_SUCCESS(rv, rv);
+  
+    rv = SetDocument(newDoc);
+    NS_ENSURE_SUCCESS(rv, rv);
+  
+    // Lazy authored instance documents have a root named "instanceData"
+    nsCOMPtr<nsIDOMElement> instanceDataElement;
+    nsCOMPtr<nsIDOMNode> childReturn;
+    rv = mDocument->CreateElementNS(EmptyString(), 
+                                    NS_LITERAL_STRING("instanceData"),
+                                    getter_AddRefs(instanceDataElement));
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = mDocument->AppendChild(instanceDataElement, getter_AddRefs(childReturn));
+    NS_ENSURE_SUCCESS(rv, rv);
+  
+    // I don't know if not being able to create a backup document is worth
+    // failing this function.  Since it probably won't be used often, we'll
+    // let it slide.  But it probably does mean that things are going south
+    // with the browser.
+    domImpl->CreateDocument(EmptyString(), EmptyString(), nsnull,
+                            getter_AddRefs(mOriginalDocument));
+    NS_WARN_IF_FALSE(mOriginalDocument, "Couldn't create mOriginalDocument!!");
+  } else {
+    // Normal instance
 
-  // I don't know if not being able to create a backup document is worth
-  // failing this function.  Since it probably won't be used often, we'll
-  // let it slide.  But it probably does mean that things are going south
-  // with the browser.
-  domImpl->CreateDocument(EmptyString(), EmptyString(), nsnull,
-                          getter_AddRefs(mOriginalDocument));
+    // By the time this is called, we should be inserted in the document and
+    // have all of our child elements, so this is our first opportunity to
+    // create the instance document.
+  
+    nsAutoString src;
+    mElement->GetAttribute(NS_LITERAL_STRING("src"), src);
+  
+    if (src.IsEmpty()) {
+      // If we don't have a linked external instance, use our inline data.
+      CloneInlineInstance();
+    } else {
+      LoadExternalInstance(src);
+    }
+  }
 
   return NS_OK;
 }
@@ -568,7 +537,7 @@ nsXFormsInstanceElement::LoadExternalIns
         NS_NewURI(getter_AddRefs(uri), aSrc,
                   doc->GetDocumentCharacterSet().get(), doc->GetDocumentURI());
         if (uri) {
-          if (nsXFormsUtils::CheckSameOrigin(doc->GetDocumentURI(), uri)) {
+          if (nsXFormsUtils::CheckSameOrigin(doc, uri)) {
             nsCOMPtr<nsILoadGroup> loadGroup;
             loadGroup = doc->GetDocumentLoadGroup();
             NS_WARN_IF_FALSE(loadGroup, "No load group!");
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsInstanceElement.h mozilla.new/extensions/xforms/nsXFormsInstanceElement.h
--- mozilla/extensions/xforms/nsXFormsInstanceElement.h	2005-10-22 16:39:09.000000000 +0200
+++ mozilla.new/extensions/xforms/nsXFormsInstanceElement.h	2006-02-14 10:01:13.000000000 +0100
@@ -75,10 +75,7 @@ public:
   NS_IMETHOD OnDestroyed();
   NS_IMETHOD AttributeSet(nsIAtom *aName, const nsAString &aNewValue);
   NS_IMETHOD AttributeRemoved(nsIAtom *aName);
-  NS_IMETHOD BeginAddingChildren();
-  NS_IMETHOD DoneAddingChildren();
   NS_IMETHOD OnCreated(nsIXTFGenericElementWrapper *aWrapper);
-  NS_IMETHOD ParentChanged(nsIDOMElement *aNewParent);
 
   nsXFormsInstanceElement() NS_HIDDEN;
 
@@ -92,7 +89,7 @@ private:
   nsCOMPtr<nsIDOMDocument>    mOriginalDocument;
   nsIDOMElement              *mElement;
   nsCOMPtr<nsIStreamListener> mListener;
-  PRBool                      mAddingChildren;
+  PRBool                      mInitialized;
   PRBool                      mLazy;
   nsCOMPtr<nsIChannel>        mChannel;
 };
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsItemElement.cpp mozilla.new/extensions/xforms/nsXFormsItemElement.cpp
--- mozilla/extensions/xforms/nsXFormsItemElement.cpp	2005-10-24 22:55:46.000000000 +0200
+++ mozilla.new/extensions/xforms/nsXFormsItemElement.cpp	2006-02-14 10:01:13.000000000 +0100
@@ -56,6 +56,8 @@
 #include "nsIXFormsLabelElement.h"
 #include "nsIDocument.h"
 #include "nsXFormsModelElement.h"
+#include "nsIXFormsCopyElement.h"
+#include "nsIDOMEventTarget.h"
 
 /**
  * nsXFormsItemElement implements the XForms \<item\> element.
@@ -69,7 +71,8 @@ class nsXFormsItemElement : public nsXFo
                             public nsIXFormsItemElement
 {
 public:
-  nsXFormsItemElement() : mElement(nsnull), mDoneAddingChildren(PR_FALSE)
+  nsXFormsItemElement() : mElement(nsnull), mDoneAddingChildren(PR_FALSE),
+                          mIsCopyItem(PR_FALSE)
   {
   }
 
@@ -95,6 +98,10 @@ private:
   nsIDOMElement* mElement;
   PRBool         mDoneAddingChildren;
 
+  // If true, indicates that this item contains a xf:copy element (via
+  // xf:itemset) rather than a xf:value element
+  PRBool         mIsCopyItem;
+
   // context node (used by itemset in select)
   nsCOMPtr<nsIDOMElement>           mContextNode;
 };
@@ -222,12 +229,50 @@ nsXFormsItemElement::SelectItemByValue(c
 {
   NS_ENSURE_ARG_POINTER(aSelected);
   NS_ENSURE_STATE(mElement);
+
+  *aSelected = nsnull;
+  if (mIsCopyItem) {
+    // copy items are selected by node, not by value
+    return NS_OK;
+  }
+
   nsAutoString value;
-  GetValue(value);
-  if (aValue.Equals(value)) {
+  nsresult rv = GetValue(value);
+
+  if (NS_SUCCEEDED(rv) && aValue.Equals(value)) {
+    NS_ADDREF(*aSelected = mElement);
+  }
+
+  return rv;
+}
+
+NS_IMETHODIMP
+nsXFormsItemElement::SelectItemByNode(nsIDOMNode *aNode, nsIDOMNode **aSelected)
+{
+  NS_ENSURE_ARG_POINTER(aSelected);
+  NS_ENSURE_STATE(mElement);
+  PRBool isCopyItem;
+  *aSelected = nsnull;
+
+  // If this item doesn't contain a copy element but instead has a value
+  // element, then there is no sense testing further.
+  GetIsCopyItem(&isCopyItem);
+  if (!isCopyItem) {
+    return NS_ERROR_FAILURE;
+  }
+
+  nsCOMPtr<nsIDOMNode> copyNode;
+  GetCopyNode(getter_AddRefs(copyNode));
+  NS_ENSURE_STATE(copyNode);
+
+  PRUint16 nodeType;
+  copyNode->GetNodeType(&nodeType);
+
+  // copy elements are only allowed to bind to ELEMENT_NODEs per spec.  But
+  // test first before doing all of this work.
+  if ((nodeType == nsIDOMNode::ELEMENT_NODE) && 
+      (nsXFormsUtils::AreNodesEqual(copyNode, aNode))) {
     NS_ADDREF(*aSelected = mElement);
-  } else {
-    *aSelected = nsnull;
   }
 
   return NS_OK;
@@ -236,7 +281,16 @@ nsXFormsItemElement::SelectItemByValue(c
 NS_IMETHODIMP
 nsXFormsItemElement::GetValue(nsAString &aValue)
 {
- 
+  PRBool isCopyItem;
+  GetIsCopyItem(&isCopyItem);
+  if (isCopyItem) {
+    // if this item was built by an itemset and the itemset's template used
+    // a copy element, then there is no value element to be had.  No sense
+    // continuing.
+    aValue.Truncate(0);
+    return NS_ERROR_FAILURE;
+  }
+
   nsCOMPtr<nsIDOMNode> firstChild, container;
   mElement->GetFirstChild(getter_AddRefs(firstChild));
 
@@ -274,6 +328,52 @@ nsXFormsItemElement::GetValue(nsAString 
   return NS_OK;
 }
 
+NS_IMETHODIMP
+nsXFormsItemElement::GetCopyNode(nsIDOMNode **aNode)
+{
+  NS_ENSURE_ARG_POINTER(aNode);
+
+  PRBool isCopyItem;
+  GetIsCopyItem(&isCopyItem);
+  if (!isCopyItem) {
+    // If this item doesn't contain a copy element but instead has a value
+    // element, then there is no sense continuing.
+    *aNode = nsnull;
+    return NS_ERROR_FAILURE;
+  }
+
+  // Since this item really contains a copy element, then firstChild MUST be
+  // a contextcontainer since copy elements can only exist as a child of an
+  // itemset.
+  nsCOMPtr<nsIDOMNode> container;
+  mElement->GetFirstChild(getter_AddRefs(container));
+
+  // Find the copy element contained by this item and get the copyNode from it.
+  nsCOMPtr<nsIDOMNodeList> children;
+  nsresult rv = container->GetChildNodes(getter_AddRefs(children));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  PRUint32 childCount;
+  children->GetLength(&childCount);
+
+  nsCOMPtr<nsIDOMNode> child;
+  nsAutoString value;
+
+  for (PRUint32 i = 0; i < childCount; ++i) {
+    children->Item(i, getter_AddRefs(child));
+    nsCOMPtr<nsIXFormsCopyElement> copyElement = do_QueryInterface(child);
+    if (copyElement) {
+      return copyElement->GetCopyNode(aNode);
+    }
+  }     
+
+  // No copy element as a child.  Set return node to null and set the copyitem
+  // boolean to false so we don't go through this unnecessary pain again.
+  aNode = nsnull;
+  SetIsCopyItem(PR_FALSE);
+  return NS_OK;
+}
+
 void
 nsXFormsItemElement::Refresh()
 {
@@ -353,15 +453,6 @@ nsXFormsItemElement::GetLabelText(nsAStr
 NS_IMETHODIMP
 nsXFormsItemElement::LabelRefreshed()
 {
-  nsCOMPtr<nsIDOMDocument> domDoc;
-  mElement->GetOwnerDocument(getter_AddRefs(domDoc));
-  nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
-  // This is an optimization. It prevents us doing some of the unnecessary
-  // refreshes.
-  if (doc && doc->GetProperty(nsXFormsAtoms::deferredBindListProperty)) {
-    return NS_OK;
-  }
-
   NS_ENSURE_STATE(mElement);
   nsCOMPtr<nsIDOMNode> parent, current;
   current = mElement;
@@ -380,6 +471,21 @@ nsXFormsItemElement::LabelRefreshed()
   return NS_OK;
 }
 
+NS_IMETHODIMP
+nsXFormsItemElement::GetIsCopyItem(PRBool *aIsCopyItem)
+{
+  NS_ENSURE_ARG(aIsCopyItem);
+  *aIsCopyItem = mIsCopyItem;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXFormsItemElement::SetIsCopyItem(PRBool aIsCopyItem)
+{
+  mIsCopyItem = aIsCopyItem;
+  return NS_OK;
+}
+
 NS_HIDDEN_(nsresult)
 NS_NewXFormsItemElement(nsIXTFElement **aResult)
 {
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsItemSetElement.cpp mozilla.new/extensions/xforms/nsXFormsItemSetElement.cpp
--- mozilla/extensions/xforms/nsXFormsItemSetElement.cpp	2005-10-04 20:28:21.000000000 +0200
+++ mozilla.new/extensions/xforms/nsXFormsItemSetElement.cpp	2006-02-14 10:01:13.000000000 +0100
@@ -191,8 +191,45 @@ nsXFormsItemSetElement::SelectItemByValu
 }
 
 NS_IMETHODIMP
+nsXFormsItemSetElement::SelectItemByNode(nsIDOMNode *aNode,
+                                         nsIDOMNode **aSelected)
+{
+  NS_ENSURE_ARG_POINTER(aSelected);
+  NS_ENSURE_STATE(mElement);
+  *aSelected = nsnull;
+  // nsIXFormsItemSetUIElement is implemented by the XBL binding.
+  nsCOMPtr<nsIXFormsItemSetUIElement> uiItemSet(do_QueryInterface(mElement));
+  NS_ENSURE_STATE(uiItemSet);
+
+  nsCOMPtr<nsIDOMElement> anonContent;
+  uiItemSet->GetAnonymousItemSetContent(getter_AddRefs(anonContent));
+  NS_ENSURE_STATE(anonContent);
+
+  nsCOMPtr<nsIDOMNode> child, tmp;
+  anonContent->GetFirstChild(getter_AddRefs(child));
+  // Trying to select the first possible (generated) \<item\> element.
+  while (child) {
+    nsCOMPtr<nsIXFormsSelectChild> selectChild(do_QueryInterface(child));
+    if (selectChild) {
+      selectChild->SelectItemByNode(aNode, aSelected);
+      if (*aSelected) {
+        return NS_OK;
+      }
+    }
+    tmp.swap(child);
+    tmp->GetNextSibling(getter_AddRefs(child));
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 nsXFormsItemSetElement::Bind()
 {
+  mModel = nsXFormsUtils::GetModel(mElement);
+  if (mModel) {
+    mModel->AddFormControl(this);
+  }
+
   return NS_OK;
 }
 
@@ -287,8 +324,7 @@ nsXFormsItemSetElement::Refresh()
 
     nsCOMPtr<nsIXFormsContextControl> ctx(do_QueryInterface(contextContainer));
     if (ctx) {
-      ctx->SetContext(nsCOMPtr<nsIDOMElement>(do_QueryInterface(node)),
-                      i + 1, nodeCount);
+      ctx->SetContext(node, i + 1, nodeCount);
     }
     // Clone the template content under the item
     for (PRUint32 j = 0; j < templateNodeCount; ++j) {
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsLabelElement.cpp mozilla.new/extensions/xforms/nsXFormsLabelElement.cpp
--- mozilla/extensions/xforms/nsXFormsLabelElement.cpp	2005-09-02 19:23:35.000000000 +0200
+++ mozilla.new/extensions/xforms/nsXFormsLabelElement.cpp	2006-02-14 10:01:13.000000000 +0100
@@ -216,7 +216,7 @@ nsXFormsLabelElement::LoadExternalLabel(
     NS_NewURI(getter_AddRefs(uri), aSrc, doc->GetDocumentCharacterSet().get(),
               doc->GetDocumentURI());
     if (uri) {
-      if (nsXFormsUtils::CheckSameOrigin(doc->GetDocumentURI(), uri)) {
+      if (nsXFormsUtils::CheckSameOrigin(doc, uri)) {
         nsCOMPtr<nsILoadGroup> loadGroup;
         loadGroup = doc->GetDocumentLoadGroup();
         NS_WARN_IF_FALSE(loadGroup, "No load group!");
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsLoadElement.cpp mozilla.new/extensions/xforms/nsXFormsLoadElement.cpp
--- mozilla/extensions/xforms/nsXFormsLoadElement.cpp	2004-11-05 03:15:00.000000000 +0100
+++ mozilla.new/extensions/xforms/nsXFormsLoadElement.cpp	2006-02-14 10:01:13.000000000 +0100
@@ -80,19 +80,13 @@ nsXFormsLoadElement::HandleAction(nsIDOM
     return NS_OK;
 
   nsCOMPtr<nsIDOMDocument> doc;
+  nsCOMPtr<nsIDOMWindowInternal> internal;
   mElement->GetOwnerDocument(getter_AddRefs(doc));
-
-  nsCOMPtr<nsIDOMDocumentView> dview(do_QueryInterface(doc));
-  if (!dview)
-    return NS_OK;
-
-  nsCOMPtr<nsIDOMAbstractView> aview;
-  dview->GetDefaultView(getter_AddRefs(aview));
-
-  nsCOMPtr<nsIDOMWindowInternal> internal(do_QueryInterface(aview));
-  NS_ASSERTION(internal, "No AbstractView or it isn't an nsIDOMWindowInternal");
-  if (!internal)
+  nsXFormsUtils::GetWindowFromDocument(doc, getter_AddRefs(internal));
+  if (!internal) {
+    NS_ASSERTION(internal, "No AbstractView or it isn't an nsIDOMWindowInternal");
     return NS_OK;
+  }
   
   PRBool openNew = PR_FALSE;
   nsAutoString show;
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsMDGEngine.cpp mozilla.new/extensions/xforms/nsXFormsMDGEngine.cpp
--- mozilla/extensions/xforms/nsXFormsMDGEngine.cpp	2005-07-25 16:29:47.000000000 +0200
+++ mozilla.new/extensions/xforms/nsXFormsMDGEngine.cpp	2006-02-24 11:16:23.000000000 +0100
@@ -47,6 +47,7 @@
 #include "nsDeque.h"
 #include "nsIModelElementPrivate.h"
 #include "nsXFormsUtils.h"
+#include "nsDOMError.h"
 
 #ifdef DEBUG
 //#  define DEBUG_XF_MDG
@@ -743,6 +744,147 @@ nsXFormsMDGEngine::SetNodeValueInternal(
   return NS_OK;
 }
 
+nsresult
+nsXFormsMDGEngine::SetNodeContent(nsIDOMNode       *aContextNode,
+                                  nsIDOMNode       *aContentEnvelope,
+                                  PRBool           *aNodeChanged)
+{
+  NS_ENSURE_ARG(aContextNode);
+  NS_ENSURE_ARG(aContentEnvelope);
+
+  // ok, this is tricky.  This function will REPLACE the contents of
+  // aContextNode with the a clone of the contents of aContentEnvelope.  If
+  // aContentEnvelope has no contents, then any contents that aContextNode
+  // has will still be removed.  
+
+  if (aNodeChanged) {
+    *aNodeChanged = PR_FALSE;
+  }
+
+  const nsXFormsNodeState* ns = GetNodeState(aContextNode);
+  NS_ENSURE_TRUE(ns, NS_ERROR_FAILURE);
+
+  // If the node is read-only and not set by a @calculate MIP,
+  // ignore the call
+  if (ns->IsReadonly()) {
+    ///
+    /// @todo Better feedback for readonly nodes? (XXX)
+    return NS_OK;
+  }
+
+  PRUint16 nodeType;
+  nsresult rv = aContextNode->GetNodeType(&nodeType);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  if (nodeType != nsIDOMNode::ELEMENT_NODE) {
+    // got to return something pretty unique that we can check down the road in
+    // order to dispatch any error events
+    return NS_ERROR_DOM_WRONG_TYPE_ERR;
+  }
+
+  // Need to determine if the contents of the context node and content envelope
+  // are already the same.  If so, we can avoid some unnecessary work.
+
+  PRBool hasChildren1, hasChildren2, contentsEqual = PR_FALSE;
+  nsresult rv1 = aContextNode->HasChildNodes(&hasChildren1);
+  nsresult rv2 = aContentEnvelope->HasChildNodes(&hasChildren2);
+  if (NS_SUCCEEDED(rv1) && NS_SUCCEEDED(rv2) && hasChildren1 == hasChildren2) {
+    // First test passed.  Both have the same number of children nodes.
+    if (hasChildren1) {
+      nsCOMPtr<nsIDOMNodeList> children1, children2;
+      PRUint32 childrenLength1, childrenLength2;
+  
+      rv1 = aContextNode->GetChildNodes(getter_AddRefs(children1));
+      rv2 = aContentEnvelope->GetChildNodes(getter_AddRefs(children2));
+
+      if (NS_SUCCEEDED(rv1) && NS_SUCCEEDED(rv2) && children1 && children2) {
+
+        // Both have child nodes.
+        rv1 = children1->GetLength(&childrenLength1);
+        rv2 = children2->GetLength(&childrenLength2);
+        if (NS_SUCCEEDED(rv1) && NS_SUCCEEDED(rv2) && 
+            (childrenLength1 == childrenLength2)) {
+
+          // both have the same number of child nodes.  Now checking to see if
+          // each of the children are equal.
+          for (PRUint32 i = 0; i < childrenLength1; ++i) {
+            nsCOMPtr<nsIDOMNode> child1, child2;
+      
+            rv1 = children1->Item(i, getter_AddRefs(child1));
+            rv2 = children2->Item(i, getter_AddRefs(child2));
+            if (NS_FAILED(rv1) || NS_FAILED(rv2)) {
+              // Unexpected error.  Not as many children in the list as we
+              // were told.
+              return NS_ERROR_UNEXPECTED;
+            }
+      
+            contentsEqual = nsXFormsUtils::AreNodesEqual(child1, child2, PR_TRUE);
+            if (!contentsEqual) {
+              break;
+            }
+          }
+        }
+      }
+    } else {
+      // neither have children
+      contentsEqual = PR_TRUE;
+    }
+  }
+
+  if (contentsEqual) {
+    return NS_OK;
+  }
+
+  // remove any child nodes that aContextNode already contains
+  nsCOMPtr<nsIDOMNode> resultNode;
+  nsCOMPtr<nsIDOMNodeList> childList;
+  rv = aContextNode->GetChildNodes(getter_AddRefs(childList));
+  NS_ENSURE_SUCCESS(rv, rv);
+  if (childList) {
+    PRUint32 length;
+    rv = childList->GetLength(&length);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    for (PRInt32 i = length-1; i >= 0; i--) {
+      nsCOMPtr<nsIDOMNode> childNode;
+      rv = childList->Item(i, getter_AddRefs(childNode));
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      rv = aContextNode->RemoveChild(childNode, getter_AddRefs(resultNode));
+      NS_ENSURE_SUCCESS(rv, rv);
+    }
+  }
+
+  // add contents of the envelope under aContextNode
+  nsCOMPtr<nsIDOMNode> childNode;
+  rv = aContentEnvelope->GetFirstChild(getter_AddRefs(childNode));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsCOMPtr<nsIDOMDocument> document;
+  rv = aContextNode->GetOwnerDocument(getter_AddRefs(document));
+  NS_ENSURE_STATE(document);
+
+  while (childNode) {
+    nsCOMPtr<nsIDOMNode> importedNode;
+    rv = document->ImportNode(childNode, PR_TRUE, getter_AddRefs(importedNode));
+    NS_ENSURE_STATE(importedNode);
+    rv = aContextNode->AppendChild(importedNode, getter_AddRefs(resultNode));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = childNode->GetNextSibling(getter_AddRefs(resultNode));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    resultNode.swap(childNode);
+  }
+
+  // NB: Never reached for Readonly nodes.  
+  if (aNodeChanged) {
+    *aNodeChanged = PR_TRUE;
+  }
+
+  return NS_OK;
+}
+
 const nsXFormsNodeState*
 nsXFormsMDGEngine::GetNodeState(nsIDOMNode *aContextNode)
 {
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsMDGEngine.h mozilla.new/extensions/xforms/nsXFormsMDGEngine.h
--- mozilla/extensions/xforms/nsXFormsMDGEngine.h	2005-06-02 09:00:11.000000000 +0200
+++ mozilla.new/extensions/xforms/nsXFormsMDGEngine.h	2006-02-14 10:01:13.000000000 +0100
@@ -326,6 +326,7 @@ protected:
                                 PRBool           aMarkNode = PR_TRUE,
                                 PRBool           aIsCalculate = PR_FALSE,
                                 PRBool          *aNodeChanged = nsnull);
+
 public:
   /**
    * Constructor
@@ -420,6 +421,18 @@ public:
                         nsAString  &aNodeValue);
 
   /**
+   * Set the contents of a node
+   *
+   * @param aContextNode     The node to set the contents of
+   * @param aContentEnvelope The container of the contents that need to be
+   *                         moved under aContextNode
+   * @param aNodeChanged     Was node changed?
+   */
+  nsresult SetNodeContent(nsIDOMNode      *aContextNode,
+                          nsIDOMNode      *aContentEnvelope,
+                          PRBool          *aNodeChanged = nsnull);
+
+  /**
    * External interface of GetNCNodeState(), returns const pointer to the node
    * state.
    *
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsMessageElement.cpp mozilla.new/extensions/xforms/nsXFormsMessageElement.cpp
--- mozilla/extensions/xforms/nsXFormsMessageElement.cpp	2005-08-10 09:58:29.000000000 +0200
+++ mozilla.new/extensions/xforms/nsXFormsMessageElement.cpp	2006-02-14 10:01:13.000000000 +0100
@@ -77,7 +77,7 @@
 #include "nsIStringBundle.h"
 #include "nsIDOMSerializer.h"
 #include "nsIServiceManager.h"
-#include "nsIXFormsDelegate.h"
+#include "nsIDelegateInternal.h"
 
 #define EPHEMERAL_STYLE \
   "position:absolute;z-index:2147483647; \
@@ -98,6 +98,7 @@
    <?xml-stylesheet href='chrome://global/skin/' type='text/css'?> \
    <window title='[XForms]'\
      xmlns='http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul' \
+     onkeypress='if (event.keyCode == event.DOM_VK_ESCAPE) window.close();' \
      onload='document.documentElement.lastChild.previousSibling \
              .firstChild.nextSibling.focus();'>"
 
@@ -293,7 +294,7 @@ nsXFormsMessageElement::CloneNode(nsIDOM
   // to support <output> here.
   if (ns.EqualsLiteral(NS_NAMESPACE_XFORMS) &&
       localName.EqualsLiteral("output")) {
-    nsCOMPtr<nsIXFormsDelegate> outEl(do_QueryInterface(aSrc));
+    nsCOMPtr<nsIDelegateInternal> outEl(do_QueryInterface(aSrc));
     if (outEl) {
       nsCOMPtr<nsIDOMDocument> doc;
       aSrc->GetOwnerDocument(getter_AddRefs(doc));
@@ -456,20 +457,12 @@ PRBool
 nsXFormsMessageElement::HandleInlineAlert(nsIDOMEvent* aEvent)
 {
   nsCOMPtr<nsIDOMDocument> doc;
+  nsCOMPtr<nsIDOMWindowInternal> internal;
   mElement->GetOwnerDocument(getter_AddRefs(doc));
-  
-  nsCOMPtr<nsIDOMDocumentView> dview(do_QueryInterface(doc));
-  if (!dview)
-    return PR_FALSE;
-
-  nsCOMPtr<nsIDOMAbstractView> aview;
-  dview->GetDefaultView(getter_AddRefs(aview));
-  if (!aview)
-    return PR_FALSE;
-
-  nsCOMPtr<nsIDOMWindowInternal> internal(do_QueryInterface(aview));
-  if (!internal)
+  nsXFormsUtils::GetWindowFromDocument(doc, getter_AddRefs(internal));
+  if (!internal) {
     return PR_FALSE;
+  }
 
   nsCOMPtr<nsIDOMViewCSS> cssView(do_QueryInterface(internal));
   if (!cssView)
@@ -600,16 +593,11 @@ nsresult
 nsXFormsMessageElement::HandleModalAndModelessMessage(nsIDOMDocument* aDoc,
                                                       nsAString& aLevel)
 {
-  nsCOMPtr<nsIDOMDocumentView> dview(do_QueryInterface(aDoc));
-  if (!dview)
-    return NS_OK;
-
-  nsCOMPtr<nsIDOMAbstractView> aview;
-  dview->GetDefaultView(getter_AddRefs(aview));
-
-  nsCOMPtr<nsIDOMWindowInternal> internal(do_QueryInterface(aview));
-  if (!internal)
+  nsCOMPtr<nsIDOMWindowInternal> internal;
+  nsXFormsUtils::GetWindowFromDocument(aDoc, getter_AddRefs(internal));
+  if (!internal) {
     return NS_OK;
+  }
 
   nsAutoString instanceData;
   PRBool hasBinding = nsXFormsUtils::GetSingleNodeBindingValue(mElement,
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsModelElement.cpp mozilla.new/extensions/xforms/nsXFormsModelElement.cpp
--- mozilla/extensions/xforms/nsXFormsModelElement.cpp	2005-10-22 16:39:09.000000000 +0200
+++ mozilla.new/extensions/xforms/nsXFormsModelElement.cpp	2006-02-24 11:16:23.000000000 +0100
@@ -176,7 +176,8 @@ static const nsIID sScriptingIIDs[] = {
   NS_IDOMELEMENT_IID,
   NS_IDOMEVENTTARGET_IID,
   NS_IDOM3NODE_IID,
-  NS_IXFORMSMODELELEMENT_IID
+  NS_IXFORMSMODELELEMENT_IID,
+  NS_IXFORMSNSMODELELEMENT_IID
 };
 
 static nsIAtom* sModelPropsList[eModel__count];
@@ -259,19 +260,24 @@ nsXFormsModelElement::nsXFormsModelEleme
     mPendingInstanceCount(0),
     mDocumentLoaded(PR_FALSE),
     mNeedsRefresh(PR_FALSE),
-    mInstanceList(16),
+    mInstancesInitialized(PR_FALSE),
+    mInstanceDocuments(nsnull),
     mLazyModel(PR_FALSE)
 {
 }
 
-NS_IMPL_ISUPPORTS_INHERITED6(nsXFormsModelElement,
-                             nsXFormsStubElement,
-                             nsIXFormsModelElement,
-                             nsIModelElementPrivate,
-                             nsISchemaLoadListener,
-                             nsIWebServiceErrorHandler,
-                             nsIDOMEventListener,
-                             nsIXFormsContextControl)
+NS_INTERFACE_MAP_BEGIN(nsXFormsModelElement)
+  NS_INTERFACE_MAP_ENTRY(nsIXFormsModelElement)
+  NS_INTERFACE_MAP_ENTRY(nsIXFormsNSModelElement)
+  NS_INTERFACE_MAP_ENTRY(nsIModelElementPrivate)
+  NS_INTERFACE_MAP_ENTRY(nsISchemaLoadListener)
+  NS_INTERFACE_MAP_ENTRY(nsIWebServiceErrorHandler)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMEventListener)
+  NS_INTERFACE_MAP_ENTRY(nsIXFormsContextControl)
+NS_INTERFACE_MAP_END_INHERITING(nsXFormsStubElement)
+
+NS_IMPL_ADDREF_INHERITED(nsXFormsModelElement, nsXFormsStubElement)
+NS_IMPL_RELEASE_INHERITED(nsXFormsModelElement, nsXFormsStubElement)
 
 NS_IMETHODIMP
 nsXFormsModelElement::OnDestroyed()
@@ -281,7 +287,9 @@ nsXFormsModelElement::OnDestroyed()
   mElement = nsnull;
   mSchemas = nsnull;
 
-  mInstanceList.Clear();
+  if (mInstanceDocuments)
+    mInstanceDocuments->DropReferences();
+
   return NS_OK;
 }
 
@@ -298,8 +306,16 @@ nsXFormsModelElement::RemoveModelFromDoc
   RemoveFromModelList(domDoc, this);
 
   nsCOMPtr<nsIDOMEventTarget> targ = do_QueryInterface(domDoc);
-  if (targ)
+  if (targ) {
     targ->RemoveEventListener(NS_LITERAL_STRING("DOMContentLoaded"), this, PR_TRUE);
+
+    nsCOMPtr<nsIDOMWindowInternal> window;
+    nsXFormsUtils::GetWindowFromDocument(domDoc, getter_AddRefs(window));
+    targ = do_QueryInterface(window);
+    if (targ) {
+      targ->RemoveEventListener(NS_LITERAL_STRING("unload"), this, PR_TRUE);
+    }
+  }
 }
 
 NS_IMETHODIMP
@@ -314,10 +330,6 @@ NS_IMETHODIMP
 nsXFormsModelElement::WillChangeDocument(nsIDOMDocument* aNewDocument)
 {
   RemoveModelFromDocument();
-  if(!aNewDocument) {
-    // can't send this much later or the model won't still be in the document!
-    nsXFormsUtils::DispatchEvent(mElement, eEvent_ModelDestruct);
-  }
   return NS_OK;
 }
 
@@ -330,8 +342,16 @@ nsXFormsModelElement::DocumentChanged(ns
   AddToModelList(aNewDocument, this);
 
   nsCOMPtr<nsIDOMEventTarget> targ = do_QueryInterface(aNewDocument);
-  if (targ)
+  if (targ) {
     targ->AddEventListener(NS_LITERAL_STRING("DOMContentLoaded"), this, PR_TRUE);
+
+    nsCOMPtr<nsIDOMWindowInternal> window;
+    nsXFormsUtils::GetWindowFromDocument(aNewDocument, getter_AddRefs(window));
+    targ = do_QueryInterface(window);
+    if (targ) {
+      targ->AddEventListener(NS_LITERAL_STRING("unload"), this, PR_TRUE);
+    }
+  }
   
   return NS_OK;
 }
@@ -339,6 +359,36 @@ nsXFormsModelElement::DocumentChanged(ns
 NS_IMETHODIMP
 nsXFormsModelElement::DoneAddingChildren()
 {
+  return InitializeInstances();
+}
+
+nsresult
+nsXFormsModelElement::InitializeInstances()
+{
+  if (mInstancesInitialized || !mElement) {
+    return NS_OK;
+  }
+
+  mInstancesInitialized = PR_TRUE;
+
+  nsCOMPtr<nsIDOMNodeList> children;
+  mElement->GetChildNodes(getter_AddRefs(children));
+
+  PRUint32 childCount = 0;
+  if (children) {
+    children->GetLength(&childCount);
+  }
+
+  for (PRUint32 i = 0; i < childCount; ++i) {
+    nsCOMPtr<nsIDOMNode> child;
+    children->Item(i, getter_AddRefs(child));
+    if (nsXFormsUtils::IsXFormsElement(child, NS_LITERAL_STRING("instance"))) {
+      nsCOMPtr<nsIInstanceElementPrivate> instance(do_QueryInterface(child));
+      if (instance) {
+        instance->Initialize();
+      }
+    }
+  }
 
   // (XForms 4.2.1)
   // 1. load xml schemas
@@ -415,8 +465,13 @@ nsXFormsModelElement::DoneAddingChildren
   // If all of the children are added and there aren't any instance elements,
   // yet, then we need to make sure that one is ready in case the form author
   // is using lazy authoring.
-  PRUint32 instCount = mInstanceList.Count();
+  NS_ENSURE_STATE(mInstanceDocuments);
+  PRUint32 instCount;
+  mInstanceDocuments->GetLength(&instCount);
   if (!instCount) {
+#ifdef DEBUG
+    printf("Creating lazy instance\n");
+#endif
     nsCOMPtr<nsIDOMDocument> domDoc;
     mElement->GetOwnerDocument(getter_AddRefs(domDoc));
     nsCOMPtr<nsIDOMDocumentXBL> xblDoc(do_QueryInterface(domDoc));
@@ -426,8 +481,7 @@ nsXFormsModelElement::DoneAddingChildren
                            NS_LITERAL_STRING(XFORMS_LAZY_INSTANCE_BINDING));
       NS_ENSURE_SUCCESS(rv, rv);
 
-      NS_WARN_IF_FALSE(mInstanceList.Count() == 1, 
-                       "Installing lazy instance didn't succeed!");
+      mInstanceDocuments->GetLength(&instCount);
 
       nsCOMPtr<nsIDOMNodeList> list;
       xblDoc->GetAnonymousNodes(mElement, getter_AddRefs(list));
@@ -443,7 +497,7 @@ nsXFormsModelElement::DoneAddingChildren
           nsCOMPtr<nsIInstanceElementPrivate> instance =
             do_QueryInterface(item);
           if (instance) {
-            rv = instance->InitializeLazyInstance();
+            rv = instance->Initialize();
             NS_ENSURE_SUCCESS(rv, rv);
 
             mLazyModel = PR_TRUE;
@@ -452,6 +506,7 @@ nsXFormsModelElement::DoneAddingChildren
         }
       }
     }
+    NS_WARN_IF_FALSE(mLazyModel, "Installing lazy instance didn't succeed!");
   }
 
   // (XForms 4.2.1 - cont)
@@ -498,6 +553,8 @@ nsXFormsModelElement::HandleDefault(nsID
     Ready();
   } else if (type.EqualsASCII(sXFormsEventsEntries[eEvent_Reset].name)) {
     Reset();
+  } else if (type.EqualsASCII(sXFormsEventsEntries[eEvent_BindingException].name)) {
+    *aHandled = nsXFormsUtils::HandleBindingException(mElement);
   } else {
     *aHandled = PR_FALSE;
   }
@@ -542,12 +599,28 @@ nsXFormsModelElement::OnCreated(nsIXTFGe
 
   mSchemas = do_GetService(NS_SCHEMALOADER_CONTRACTID);
 
+  mInstanceDocuments = new nsXFormsModelInstanceDocuments();
+  NS_ASSERTION(mInstanceDocuments, "could not create mInstanceDocuments?!");
+
+  // Initialize hash tables
+  NS_ENSURE_TRUE(mNodeToType.Init(), NS_ERROR_OUT_OF_MEMORY);
+  NS_ENSURE_TRUE(mNodeToP3PType.Init(), NS_ERROR_OUT_OF_MEMORY);
+
   return NS_OK;
 }
 
 // nsIXFormsModelElement
 
 NS_IMETHODIMP
+nsXFormsModelElement::GetInstanceDocuments(nsIDOMNodeList **aDocuments)
+{
+  NS_ENSURE_STATE(mInstanceDocuments);
+  NS_ENSURE_ARG_POINTER(aDocuments);
+  NS_ADDREF(*aDocuments = mInstanceDocuments);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 nsXFormsModelElement::GetInstanceDocument(const nsAString& aInstanceID,
                                           nsIDOMDocument **aDocument)
 {
@@ -569,6 +642,12 @@ nsXFormsModelElement::Rebuild()
   rv = mMDG.Clear();
   NS_ENSURE_SUCCESS(rv, rv);
 
+  // Clear any type information
+  NS_ENSURE_TRUE(mNodeToType.IsInitialized() && mNodeToP3PType.IsInitialized(),
+                 NS_ERROR_FAILURE);
+  mNodeToType.Clear();
+  mNodeToP3PType.Clear();
+
   // 2. Re-attach all elements
   if (mDocumentLoaded) { // if it's not during initializing phase
     // Copy the form control list as it stands right now.
@@ -867,57 +946,13 @@ nsXFormsModelElement::HandleEvent(nsIDOM
 
   nsAutoString type;
   aEvent->GetType(type);
-  if (!type.EqualsLiteral("DOMContentLoaded"))
-    return NS_OK;
-
-  mDocumentLoaded = PR_TRUE;
 
-  // dispatch xforms-model-construct, xforms-rebuild, xforms-recalculate,
-  // xforms-revalidate
-
-  // We wait until DOMContentLoaded to dispatch xforms-model-construct,
-  // since the model may have an action handler for this event and Mozilla
-  // doesn't register XML Event listeners until the document is loaded.
-
-  // xforms-model-construct is not cancellable, so always proceed.
-
-  nsXFormsUtils::DispatchEvent(mElement, eEvent_ModelConstruct);
-
-  if (mPendingInlineSchemas.Count() > 0) {
-    nsCOMPtr<nsIDOMElement> el;
-    nsresult rv;
-    for (PRInt32 i=0; i<mPendingInlineSchemas.Count(); ++i) {
-      GetSchemaElementById(mElement, *mPendingInlineSchemas[i],
-                           getter_AddRefs(el));
-      if (!el) {
-        rv = NS_ERROR_UNEXPECTED;
-      } else {
-        nsCOMPtr<nsISchema> schema;
-        // no need to observe errors via the callback.  instead, rely on
-        // this method returning a failure code when it encounters errors.
-        rv = mSchemas->ProcessSchemaElement(el, nsnull,
-                                            getter_AddRefs(schema));
-        if (NS_SUCCEEDED(rv))
-          mSchemaCount++;
-      }
-      if (NS_FAILED(rv)) {
-        // this is a fatal error (XXX)
-        nsXFormsUtils::ReportError(NS_LITERAL_STRING("schemaLoadError"), mElement);
-        nsXFormsUtils::DispatchEvent(mElement, eEvent_LinkException);
-        return NS_OK;
-      }
-    }
-    if (IsComplete()) {
-      rv = FinishConstruction();
-      NS_ENSURE_SUCCESS(rv, rv);
-      nsXFormsUtils::DispatchEvent(mElement, eEvent_Refresh);
-    }
-    mPendingInlineSchemas.Clear();
+  if (type.EqualsLiteral("DOMContentLoaded")) {
+    return HandleLoad(aEvent);
+  }else if (type.EqualsLiteral("unload")) {
+    return HandleUnload(aEvent);
   }
 
-  // We may still be waiting on external documents to load.
-  MaybeNotifyCompletion();
-
   return NS_OK;
 }
 
@@ -977,26 +1012,15 @@ nsXFormsModelElement::GetTypeForControl(
 nsXFormsModelElement::GetTypeAndNSFromNode(nsIDOMNode *aInstanceData,
                                            nsAString &aType, nsAString &aNSUri)
 {
-  nsAutoString schemaTypePrefix;
-  nsresult rv = nsXFormsUtils::ParseTypeFromNode(aInstanceData, aType,
-                                                 schemaTypePrefix);
+  nsresult rv = GetTypeFromNode(aInstanceData, aType, aNSUri);
 
-  if(rv == NS_ERROR_NOT_AVAILABLE) {
+  if (rv == NS_ERROR_NOT_AVAILABLE) {
     // if there is no type assigned, then assume that the type is 'string'
     aNSUri.Assign(NS_LITERAL_STRING(NS_NAMESPACE_XML_SCHEMA));
     aType.Assign(NS_LITERAL_STRING("string"));
     rv = NS_OK;
-  } else {
-    if (schemaTypePrefix.IsEmpty()) {
-      aNSUri.AssignLiteral("");
-    } else {
-      // get the namespace url from the prefix
-      nsCOMPtr<nsIDOM3Node> domNode3 = do_QueryInterface(mElement, &rv);
-      NS_ENSURE_SUCCESS(rv, rv);
-
-      rv = domNode3->LookupNamespaceURI(schemaTypePrefix, aNSUri);
-    }
   }
+
   return rv;
 }
 
@@ -1029,14 +1053,16 @@ NS_IMETHODIMP
 nsXFormsModelElement::FindInstanceElement(const nsAString &aID,
                                           nsIInstanceElementPrivate **aElement)
 {
+  NS_ENSURE_STATE(mInstanceDocuments);
   *aElement = nsnull;
 
-  PRUint32 instCount = mInstanceList.Count();
+  PRUint32 instCount;
+  mInstanceDocuments->GetLength(&instCount);
   if (instCount) {
     nsCOMPtr<nsIDOMElement> element;
     nsAutoString id;
     for (PRUint32 i = 0; i < instCount; ++i) {
-      nsIInstanceElementPrivate* instEle = mInstanceList.ObjectAt(i);
+      nsIInstanceElementPrivate* instEle = mInstanceDocuments->GetInstanceAt(i);
       instEle->GetElement(getter_AddRefs(element));
 
       if (aID.IsEmpty()) {
@@ -1084,6 +1110,16 @@ nsXFormsModelElement::GetNodeValue(nsIDO
 }
  
 NS_IMETHODIMP
+nsXFormsModelElement::SetNodeContent(nsIDOMNode      *aContextNode,
+                                     nsIDOMNode      *aNodeContent,
+                                     PRBool          *aNodeChanged)
+{ 
+  return mMDG.SetNodeContent(aContextNode,
+                             aNodeContent,
+                             aNodeChanged);
+}
+
+NS_IMETHODIMP
 nsXFormsModelElement::ValidateNode(nsIDOMNode *aInstanceNode, PRBool *aResult)
 {
   NS_ENSURE_ARG_POINTER(aResult);
@@ -1143,6 +1179,80 @@ nsXFormsModelElement::HandleInstanceData
   return NS_OK;
 }
 
+NS_IMETHODIMP
+nsXFormsModelElement::GetTypeFromNode(nsIDOMNode *aInstanceData,
+                                      nsAString  &aType,
+                                      nsAString  &aNSUri)
+{
+  // aInstanceData could be an instance data node or it could be an attribute
+  // on an instance data node (basically the node that a control is bound to).
+
+  nsString *typeVal = nsnull;
+
+  // Get type stored directly on instance node
+  nsAutoString typeAttribute;
+  nsCOMPtr<nsIDOMElement> nodeElem(do_QueryInterface(aInstanceData));
+  if (nodeElem) {
+    nodeElem->GetAttributeNS(NS_LITERAL_STRING(NS_NAMESPACE_XML_SCHEMA_INSTANCE),
+                             NS_LITERAL_STRING("type"), typeAttribute);
+    if (!typeAttribute.IsEmpty()) {
+      typeVal = &typeAttribute;
+    }
+  }
+
+  // If there was no type information on the node itself, check for a type
+  // bound to the node via \<xforms:bind\>
+  if (!typeVal && !mNodeToType.Get(aInstanceData, &typeVal)) {
+    // No type information found
+    return NS_ERROR_NOT_AVAILABLE;
+  }
+
+  // split type (ns:type) into namespace and type.
+  nsAutoString prefix;
+  PRInt32 separator = typeVal->FindChar(':');
+  if ((PRUint32) separator == (typeVal->Length() - 1)) {
+    const PRUnichar *strings[] = { typeVal->get() };
+    nsXFormsUtils::ReportError(NS_LITERAL_STRING("missingTypeName"), strings, 1,
+                               mElement, nsnull);
+    return NS_ERROR_UNEXPECTED;
+  }
+
+  if (separator == kNotFound) {
+    // no namespace prefix, which is valid;
+    prefix = EmptyString();
+    aType.Assign(*typeVal);
+  } else {
+    prefix.Assign(Substring(*typeVal, 0, separator));
+    aType.Assign(Substring(*typeVal, ++separator, typeVal->Length()));
+  }
+
+  if (prefix.IsEmpty()) {
+    aNSUri = EmptyString();
+    return NS_OK;
+  }
+
+  // get the namespace url from the prefix using instance data node
+  nsresult rv;
+  nsCOMPtr<nsIDOM3Node> domNode3 = do_QueryInterface(aInstanceData, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = domNode3->LookupNamespaceURI(prefix, aNSUri);
+
+  if (DOMStringIsNull(aNSUri)) {
+    // if not found using instance data node, use <xf:instance> node
+    nsCOMPtr<nsIDOMNode> instanceNode;
+    rv = nsXFormsUtils::GetInstanceNodeForData(aInstanceData,
+                                               getter_AddRefs(instanceNode));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    domNode3 = do_QueryInterface(instanceNode, &rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = domNode3->LookupNamespaceURI(prefix, aNSUri);
+  }
+
+  return rv;
+}
+
+
 // nsIXFormsContextControl
 
 NS_IMETHODIMP
@@ -1293,11 +1403,15 @@ nsXFormsModelElement::Ready()
 void
 nsXFormsModelElement::BackupOrRestoreInstanceData(PRBool restore)
 {
+  if (!mInstanceDocuments)
+    return;
 
-  PRUint32 instCount = mInstanceList.Count();
+  PRUint32 instCount;
+  mInstanceDocuments->GetLength(&instCount);
   if (instCount) {
     for (PRUint32 i = 0; i < instCount; ++i) {
-      nsIInstanceElementPrivate *instance = mInstanceList.ObjectAt(i);
+      nsIInstanceElementPrivate *instance =
+        mInstanceDocuments->GetInstanceAt(i);
 
       // Don't know what to do with error if we get one.
       // Restore/BackupOriginalDocument will already output warnings.
@@ -1448,15 +1562,6 @@ nsXFormsModelElement::MaybeNotifyComplet
   }
 }
 
-static void
-DeleteAutoString(void    *aObject,
-                 nsIAtom *aPropertyName,
-                 void    *aPropertyValue,
-                 void    *aData)
-{
-  delete NS_STATIC_CAST(nsAutoString*, aPropertyValue);
-}
-
 nsresult
 nsXFormsModelElement::ProcessBind(nsIXFormsXPathEvaluator *aEvaluator,
                                   nsIDOMNode              *aContextNode,
@@ -1543,33 +1648,24 @@ nsXFormsModelElement::ProcessBind(nsIXFo
 
       // type and p3ptype are stored as properties on the instance node
       if (j == eModel_type || j == eModel_p3ptype) {
-        nsAutoPtr<nsAutoString> prop (new nsAutoString(propStrings[j]));
-        nsCOMPtr<nsIContent> content = do_QueryInterface(node);
-        if (content) {
-          rv = content->SetProperty(sModelPropsList[j],
-                                    prop,
-                                    DeleteAutoString);
-        } else {
-          nsCOMPtr<nsIAttribute> attribute = do_QueryInterface(node);
-          if (attribute) {
-            rv = attribute->SetProperty(sModelPropsList[j],
-                                        prop,
-                                        DeleteAutoString);
-          } else {
-            NS_WARNING("node is neither nsIContent or nsIAttribute");
-            continue;
-          }
-        }
-        if (NS_SUCCEEDED(rv)) {
-          prop.forget();
-        } else {
-          return rv;
-        }
-        if (rv == NS_PROPTABLE_PROP_OVERWRITTEN) {
+        nsClassHashtable<nsISupportsHashKey, nsString> *table;
+        table = j == eModel_type ? &mNodeToType : &mNodeToP3PType;
+        NS_ENSURE_TRUE(table->IsInitialized(), NS_ERROR_FAILURE);
+
+        // Check for existing value
+        if (table->Get(node, nsnull)) {
           multiMIP = PR_TRUE;
           break;
         }
 
+        // Insert value
+        nsAutoPtr<nsString> newString(new nsString(propStrings[j]));
+        NS_ENSURE_TRUE(newString, NS_ERROR_OUT_OF_MEMORY);
+        NS_ENSURE_TRUE(table->Put(node, newString), NS_ERROR_OUT_OF_MEMORY);
+
+        // string is succesfully stored in the table, we should not dealloc it
+        newString.forget();
+
         if (j == eModel_type) {
           // Inform MDG that it needs to check type. The only arguments
           // actually used are |eModel_constraint| and |node|.
@@ -1661,22 +1757,11 @@ nsXFormsModelElement::SetStates(nsIXForm
   return SetStatesInternal(aControl, aBoundNode, PR_TRUE);
 }
 
-NS_IMETHODIMP
-nsXFormsModelElement::GetInstanceList(nsCOMArray<nsIInstanceElementPrivate> **aInstanceList)
-{
-  if (aInstanceList) {
-    *aInstanceList = &mInstanceList;
-  }
-  return NS_OK;  
-}
-
 nsresult
 nsXFormsModelElement::AddInstanceElement(nsIInstanceElementPrivate *aInstEle) 
 {
-  // always append to the end of the list.  We need to keep the elements in
-  // document order since the first instance element is the default instance
-  // document for the model.
-  mInstanceList.AppendObject(aInstEle);
+  NS_ENSURE_STATE(mInstanceDocuments);
+  mInstanceDocuments->AddInstance(aInstEle);
 
   return NS_OK;
 }
@@ -1764,6 +1849,74 @@ nsXFormsModelElement::ProcessDeferredBin
 }
 
 nsresult
+nsXFormsModelElement::HandleLoad(nsIDOMEvent* aEvent)
+{
+  if (!mInstancesInitialized) {
+    // XXX This is for Bug 308106. In Gecko 1.8 DoneAddingChildren is not
+    //     called in XUL if the element doesn't have any child nodes.
+    InitializeInstances();
+  }
+
+  mDocumentLoaded = PR_TRUE;
+
+  // dispatch xforms-model-construct, xforms-rebuild, xforms-recalculate,
+  // xforms-revalidate
+
+  // We wait until DOMContentLoaded to dispatch xforms-model-construct,
+  // since the model may have an action handler for this event and Mozilla
+  // doesn't register XML Event listeners until the document is loaded.
+
+  // xforms-model-construct is not cancellable, so always proceed.
+
+  nsXFormsUtils::DispatchEvent(mElement, eEvent_ModelConstruct);
+
+  if (mPendingInlineSchemas.Count() > 0) {
+    nsCOMPtr<nsIDOMElement> el;
+    nsresult rv;
+    for (PRInt32 i=0; i<mPendingInlineSchemas.Count(); ++i) {
+      GetSchemaElementById(mElement, *mPendingInlineSchemas[i],
+                           getter_AddRefs(el));
+      if (!el) {
+        rv = NS_ERROR_UNEXPECTED;
+      } else {
+        nsCOMPtr<nsISchema> schema;
+        // no need to observe errors via the callback.  instead, rely on
+        // this method returning a failure code when it encounters errors.
+        rv = mSchemas->ProcessSchemaElement(el, nsnull,
+                                            getter_AddRefs(schema));
+        if (NS_SUCCEEDED(rv))
+          mSchemaCount++;
+      }
+      if (NS_FAILED(rv)) {
+        // this is a fatal error (XXX)
+        nsXFormsUtils::ReportError(NS_LITERAL_STRING("schemaLoadError"), mElement);
+        nsXFormsUtils::DispatchEvent(mElement, eEvent_LinkException);
+        return NS_OK;
+      }
+    }
+    if (IsComplete()) {
+      rv = FinishConstruction();
+      NS_ENSURE_SUCCESS(rv, rv);
+      nsXFormsUtils::DispatchEvent(mElement, eEvent_Refresh);
+    }
+    mPendingInlineSchemas.Clear();
+  }
+
+  // We may still be waiting on external documents to load.
+  MaybeNotifyCompletion();
+
+  return NS_OK;
+}
+
+nsresult
+nsXFormsModelElement::HandleUnload(nsIDOMEvent* aEvent)
+{
+  // due to fastback changes, had to move this notification out from under
+  // model's WillChangeDocument override.
+  return nsXFormsUtils::DispatchEvent(mElement, eEvent_ModelDestruct);
+}
+
+nsresult
 NS_NewXFormsModelElement(nsIXTFElement **aResult)
 {
   *aResult = new nsXFormsModelElement();
@@ -1773,3 +1926,124 @@ NS_NewXFormsModelElement(nsIXTFElement *
   NS_ADDREF(*aResult);
   return NS_OK;
 }
+
+
+// ---------------------------- //
+
+// nsXFormsModelInstanceDocuments
+
+NS_IMPL_ISUPPORTS2(nsXFormsModelInstanceDocuments, nsIDOMNodeList, nsIClassInfo)
+
+nsXFormsModelInstanceDocuments::nsXFormsModelInstanceDocuments()
+  : mInstanceList(16)
+{
+}
+
+NS_IMETHODIMP
+nsXFormsModelInstanceDocuments::GetLength(PRUint32* aLength)
+{
+  *aLength = mInstanceList.Count();
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXFormsModelInstanceDocuments::Item(PRUint32 aIndex, nsIDOMNode** aReturn)
+{
+  *aReturn = nsnull;
+  nsIInstanceElementPrivate* instance = mInstanceList.SafeObjectAt(aIndex);
+  if (instance) {
+    nsCOMPtr<nsIDOMDocument> doc;
+    if (NS_SUCCEEDED(instance->GetDocument(getter_AddRefs(doc))) && doc) {
+      NS_ADDREF(*aReturn = doc);
+    }
+  }
+
+  return NS_OK;
+}
+
+nsIInstanceElementPrivate*
+nsXFormsModelInstanceDocuments::GetInstanceAt(PRUint32 aIndex)
+{
+  return mInstanceList.ObjectAt(aIndex);
+}
+
+void
+nsXFormsModelInstanceDocuments::AddInstance(nsIInstanceElementPrivate *aInst)
+{
+  // always append to the end of the list.  We need to keep the elements in
+  // document order since the first instance element is the default instance
+  // document for the model.
+  mInstanceList.AppendObject(aInst);
+}
+
+void
+nsXFormsModelInstanceDocuments::DropReferences()
+{
+  mInstanceList.Clear();
+}
+
+// nsIClassInfo implementation
+
+static const nsIID sInstScriptingIIDs[] = {
+  NS_IDOMNODELIST_IID
+};
+
+NS_IMETHODIMP
+nsXFormsModelInstanceDocuments::GetInterfaces(PRUint32   *aCount,
+                                              nsIID   * **aArray)
+{
+  return
+    nsXFormsUtils::CloneScriptingInterfaces(sInstScriptingIIDs,
+                                            NS_ARRAY_LENGTH(sInstScriptingIIDs),
+                                            aCount, aArray);
+}
+
+NS_IMETHODIMP
+nsXFormsModelInstanceDocuments::GetHelperForLanguage(PRUint32 language,
+                                                     nsISupports **_retval)
+{
+  *_retval = nsnull;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXFormsModelInstanceDocuments::GetContractID(char * *aContractID)
+{
+  *aContractID = nsnull;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXFormsModelInstanceDocuments::GetClassDescription(char * *aClassDescription)
+{
+  *aClassDescription = nsnull;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXFormsModelInstanceDocuments::GetClassID(nsCID * *aClassID)
+{
+  *aClassID = nsnull;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXFormsModelInstanceDocuments::GetImplementationLanguage(PRUint32 *aLang)
+{
+  *aLang = nsIProgrammingLanguage::CPLUSPLUS;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXFormsModelInstanceDocuments::GetFlags(PRUint32 *aFlags)
+{
+  *aFlags = nsIClassInfo::DOM_OBJECT;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXFormsModelInstanceDocuments::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
+{
+  return NS_ERROR_NOT_AVAILABLE;
+}
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsModelElement.h mozilla.new/extensions/xforms/nsXFormsModelElement.h
--- mozilla/extensions/xforms/nsXFormsModelElement.h	2005-10-20 11:32:33.000000000 +0200
+++ mozilla.new/extensions/xforms/nsXFormsModelElement.h	2006-02-24 11:16:23.000000000 +0100
@@ -42,14 +42,17 @@
 
 #include "nsXFormsStubElement.h"
 #include "nsIModelElementPrivate.h"
+#include "nsIXFormsNSModelElement.h"
 #include "nsIDOMEventListener.h"
 #include "nsISchema.h"
 #include "nsCOMArray.h"
 #include "nsVoidArray.h"
 #include "nsCOMPtr.h"
 #include "nsIDOMDocument.h"
+#include "nsIDOMNodeList.h"
 #include "nsXFormsMDGEngine.h"
 #include "nsXFormsUtils.h"
+#include "nsIClassInfo.h"
 
 #include "nsISchemaLoader.h"
 #include "nsISchema.h"
@@ -60,6 +63,51 @@ class nsIDOMNode;
 class nsIXFormsXPathEvaluator;
 class nsIDOMXPathResult;
 class nsXFormsControl;
+class nsXFormsModelInstanceDocuments;
+
+/**
+ * Implementation of the instance node list returned by
+ * nsIXFormsModel::getInstanceDocuments.
+ *
+ * Manages the list of all instance elements that belong to a given
+ * nsXFormsModelElement.
+ */
+class nsXFormsModelInstanceDocuments : public nsIDOMNodeList,
+                                       public nsIClassInfo
+{
+public:
+  nsXFormsModelInstanceDocuments();
+
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSICLASSINFO
+  NS_DECL_NSIDOMNODELIST
+
+  /**
+   * Add an instance element
+   *
+   * @param aInstance         The new instance element
+   */
+  void AddInstance(nsIInstanceElementPrivate *aInstance);
+
+  /**
+   * Get the instance document at a given index
+   *
+   * @note Does NOT addref the returned element!
+   *
+   * @param aIndex            The index
+   * @return                  The instance element (or nsnull if not found)
+   */
+  nsIInstanceElementPrivate* GetInstanceAt(PRUint32 aIndex);
+
+  /**
+   * Instructs the class to drop references to all instance elements
+   */
+  void DropReferences();
+
+protected:
+  /** The array holding the instance elements */
+  nsCOMArray<nsIInstanceElementPrivate>    mInstanceList;
+};
 
 /**
  * Implementation of the XForms \<model\> element.
@@ -71,6 +119,7 @@ class nsXFormsControl;
  */
 class nsXFormsModelElement : public nsXFormsStubElement,
                              public nsIModelElementPrivate,
+                             public nsIXFormsNSModelElement,
                              public nsISchemaLoadListener,
                              public nsIDOMEventListener,
                              public nsIXFormsContextControl
@@ -81,6 +130,7 @@ public:
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_NSIXFORMSMODELELEMENT
   NS_DECL_NSIMODELELEMENTPRIVATE
+  NS_DECL_NSIXFORMSNSMODELELEMENT
   NS_DECL_NSISCHEMALOADLISTENER
   NS_DECL_NSIWEBSERVICEERRORHANDLER
   NS_DECL_NSIDOMEVENTLISTENER
@@ -128,6 +178,8 @@ private:
   /** Initializes the MIPs on all form controls */
   NS_HIDDEN_(nsresult) InitializeControls();
 
+  NS_HIDDEN_(nsresult) InitializeInstances();
+
   NS_HIDDEN_(nsresult) ProcessBindElements();
   NS_HIDDEN_(nsresult) FinishConstruction();
   NS_HIDDEN_(nsresult) ConstructDone();
@@ -178,6 +230,16 @@ private:
   PRBool IsComplete() const { return (mSchemaTotal == mSchemaCount
                                       && mPendingInstanceCount == 0);  }
 
+  /**
+   * Called by HandleEvent.  Event handler for the 'DOMContentLoaded' event.
+   */
+  NS_HIDDEN_(nsresult) HandleLoad(nsIDOMEvent *aEvent);
+
+  /**
+   * Called by HandleEvent.  Event handler for the 'unload' event.
+   */
+  NS_HIDDEN_(nsresult) HandleUnload(nsIDOMEvent *aEvent);
+
   nsIDOMElement            *mElement;
   nsCOMPtr<nsISchemaLoader> mSchemas;
   nsStringArray             mPendingInlineSchemas;
@@ -203,14 +265,32 @@ private:
   // xforms-revalidate yet
   PRBool mNeedsRefresh;
 
+  // This flag indicates whether instance elements have been initialized
+  PRBool mInstancesInitialized;
+
   /**
-   * List of instance elements contained by this model, including lazy-authored
-   * instance elements.
+   * All instance documents contained by this model, including lazy-authored
+   * instance documents.
    */
-  nsCOMArray<nsIInstanceElementPrivate>    mInstanceList;
+  nsRefPtr<nsXFormsModelInstanceDocuments> mInstanceDocuments;
 
   /** Indicates whether the model's instance was built by lazy authoring */
   PRBool mLazyModel;
+
+  /**
+   * Type information for nodes, with their type set through \<xforms:bind\>.
+   *
+   * @see http://www.w3.org/TR/xforms/slice6.html#model-prop-type
+   */
+  nsClassHashtable<nsISupportsHashKey, nsString> mNodeToType;
+
+  /**
+   * P3P type information for nodes, with their type set through
+   * \<xforms:bind\>.
+
+   * @see http://www.w3.org/TR/xforms/slice6.html#model-prop-p3ptype
+   */
+  nsClassHashtable<nsISupportsHashKey, nsString> mNodeToP3PType;
 };
 
 /**
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsRangeAccessors.cpp mozilla.new/extensions/xforms/nsXFormsRangeAccessors.cpp
--- mozilla/extensions/xforms/nsXFormsRangeAccessors.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/extensions/xforms/nsXFormsRangeAccessors.cpp	2006-02-07 16:30:11.000000000 +0100
@@ -0,0 +1,108 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla XForms support.
+ *
+ * The Initial Developer of the Original Code is
+ * Novell, Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Allan Beaufour <abeaufour@novell.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsXFormsRangeAccessors.h"
+#include "nsDOMString.h"
+#include "nsIDOMElement.h"
+#include "nsString.h"
+#include "nsXFormsUtils.h"
+
+NS_IMPL_ISUPPORTS_INHERITED2(nsXFormsRangeAccessors,
+                             nsXFormsAccessors,
+                             nsIXFormsRangeAccessors, 
+                             nsIClassInfo)
+
+// nsXFormsRangeAccessors
+nsresult
+nsXFormsRangeAccessors::AttributeGetter(const nsAString &aAttr, nsAString &aVal)
+{
+  nsAutoString val;
+  if (mElement) {
+    mElement->GetAttribute(aAttr, val);
+  }
+  if (val.IsEmpty()) {
+    SetDOMStringToNull(aVal);
+  } else {
+    aVal = val;
+  }
+
+  return NS_OK;
+}
+
+
+// nsIXFormsRangeElement
+
+// XXX this should do a max(type.minumum, @start)
+NS_IMETHODIMP
+nsXFormsRangeAccessors::GetRangeStart(nsAString &aMin)
+{
+  return AttributeGetter(NS_LITERAL_STRING("start"), aMin);
+}
+
+// XXX this should do min(type.maximu, @end)
+NS_IMETHODIMP
+nsXFormsRangeAccessors::GetRangeEnd(nsAString &aMax)
+{
+  return AttributeGetter(NS_LITERAL_STRING("end"), aMax);
+}
+
+// XXX if step is not set, it should be set to something "smart" and also
+// needs to be something that is valid for the given type. This could be
+// pushed to the widget though.
+NS_IMETHODIMP
+nsXFormsRangeAccessors::GetRangeStep(nsAString &aStep)
+{
+  return AttributeGetter(NS_LITERAL_STRING("step"), aStep);
+}
+
+
+// nsIClassInfo implementation
+
+static const nsIID sScriptingIIDs[] = {
+  NS_IXFORMSACCESSORS_IID,
+  NS_IXFORMSRANGEACCESSORS_IID,
+  
+};
+
+NS_IMETHODIMP
+nsXFormsRangeAccessors::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
+{
+  return nsXFormsUtils::CloneScriptingInterfaces(sScriptingIIDs,
+                                                 NS_ARRAY_LENGTH(sScriptingIIDs),
+                                                 aCount, aArray);
+}
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsRangeAccessors.h mozilla.new/extensions/xforms/nsXFormsRangeAccessors.h
--- mozilla/extensions/xforms/nsXFormsRangeAccessors.h	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/extensions/xforms/nsXFormsRangeAccessors.h	2006-02-07 16:30:11.000000000 +0100
@@ -0,0 +1,74 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla XForms support.
+ *
+ * The Initial Developer of the Original Code is
+ * Novell, Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Allan Beaufour <abeaufour@novell.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIXFormsRangeAccessors.h"
+#include "nsXFormsAccessors.h"
+
+/**
+ * Implementation for the accessors for a range element,
+ * nsIXFormsRangeAccessors.
+ *
+ * @todo Support out-of/in-range events (XXX)
+ */
+class nsXFormsRangeAccessors : public nsIXFormsRangeAccessors,
+                               public nsXFormsAccessors
+{
+public:
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIXFORMSRANGEACCESSORS
+  NS_FORWARD_NSIXFORMSACCESSORS(nsXFormsAccessors::)
+
+  // Constructor
+  nsXFormsRangeAccessors(nsIDelegateInternal* aDelegate,
+                         nsIDOMElement* aElement)
+    : nsXFormsAccessors(aDelegate, aElement)
+  {
+  }
+
+  // nsIClassInfo overrides
+  NS_IMETHOD GetInterfaces(PRUint32 *aCount, nsIID * **aArray);
+
+protected:
+  /**
+   * Gets the value of an attribute on the element (mElement).
+   *
+   * @param aAttr        The attribute
+   * @param aVal         The returned value ("DOMNull"s it if it's not there or empty)
+   */
+  nsresult AttributeGetter(const nsAString &aAttr, nsAString &aVal);
+};
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsRangeElement.cpp mozilla.new/extensions/xforms/nsXFormsRangeElement.cpp
--- mozilla/extensions/xforms/nsXFormsRangeElement.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/extensions/xforms/nsXFormsRangeElement.cpp	2006-02-07 16:30:11.000000000 +0100
@@ -0,0 +1,87 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla XForms support.
+ *
+ * The Initial Developer of the Original Code is
+ * Novell, Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Allan Beaufour <allan@beaufour.dk>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsXFormsDelegateStub.h"
+#include "nsXFormsRangeAccessors.h"
+
+/**
+ * Implementation of the XForms \<range\> element
+ * @see http://www.w3.org/TR/xforms/slice8.html#ui-range
+ *
+ * @todo Check data binding restrictions (XXX)
+ */
+class nsXFormsRangeElement : public nsXFormsDelegateStub
+{
+public:
+
+  // nsIXFormsDelegate overrides
+  NS_IMETHOD GetXFormsAccessors(nsIXFormsAccessors **aAccessor);
+
+#ifdef DEBUG_smaug
+  virtual const char* Name() { return "range"; }
+#endif
+};
+
+// nsIXFormsDelegate
+
+NS_IMETHODIMP
+nsXFormsRangeElement::GetXFormsAccessors(nsIXFormsAccessors **aAccessor)
+{
+  if (!mAccessor) {
+    mAccessor = new nsXFormsRangeAccessors(this, mElement);
+    if (!mAccessor) {
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+  }
+  NS_ADDREF(*aAccessor = mAccessor);
+  return NS_OK;
+}
+
+
+// Creator
+
+NS_HIDDEN_(nsresult)
+NS_NewXFormsRangeElement(nsIXTFElement **aResult)
+{
+  *aResult = new nsXFormsRangeElement();
+  if (!*aResult)
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  NS_ADDREF(*aResult);
+  return NS_OK;
+}
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsRepeatElement.cpp mozilla.new/extensions/xforms/nsXFormsRepeatElement.cpp
--- mozilla/extensions/xforms/nsXFormsRepeatElement.cpp	2005-10-04 20:28:24.000000000 +0200
+++ mozilla.new/extensions/xforms/nsXFormsRepeatElement.cpp	2006-02-14 10:01:13.000000000 +0100
@@ -766,11 +766,14 @@ nsXFormsRepeatElement::Refresh()
     rv = result->SnapshotItem(i - 1, getter_AddRefs(contextNode));
     NS_ENSURE_SUCCESS(rv, rv);
         
-    nsCOMPtr<nsIDOMElement> contextElement = do_QueryInterface(contextNode);
-    NS_ENSURE_TRUE(contextElement, NS_ERROR_FAILURE);
-
     // Set context node, position, and size
-    rv = riContext->SetContext(contextElement, i, contextSize);
+    rv = riContext->SetContext(contextNode, i, contextSize);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    // We need to insert the context node before adding the children, or the
+    // children will fail to set up their proper XForms context.
+    nsCOMPtr<nsIDOMNode> domNode;
+    rv = mHTMLElement->AppendChild(riElement, getter_AddRefs(domNode));
     NS_ENSURE_SUCCESS(rv, rv);
 
     // Iterate over template children, clone them, and append them to <contextcontainer>
@@ -778,6 +781,8 @@ nsXFormsRepeatElement::Refresh()
     rv = mElement->GetFirstChild(getter_AddRefs(child));
     NS_ENSURE_SUCCESS(rv, rv);
     while (child) {
+      /// XXX the node probably refreshes itself twice here, once on cloning
+      /// and once when it's inserted ... that's not necessary.
       nsCOMPtr<nsIDOMNode> childClone;
       rv = CloneNode(child, getter_AddRefs(childClone));
       NS_ENSURE_SUCCESS(rv, rv);
@@ -790,16 +795,6 @@ nsXFormsRepeatElement::Refresh()
       NS_ENSURE_SUCCESS(rv, rv);
       child = newNode;
     }
-
-    // Append node
-    nsCOMPtr<nsIDOMNode> domNode;
-    rv = mHTMLElement->AppendChild(riElement, getter_AddRefs(domNode));
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    // There is an awfull lot of evaluating being done by all the
-    // children, as they are created and inserted into the different
-    // places in the DOM, the only refresh necessary is the one when they
-    // are appended in mHTMLElement.
   }
 
   if (!mParent && !mCurrentIndex && mMaxIndex) {
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsSchemaValidator.cpp mozilla.new/extensions/xforms/nsXFormsSchemaValidator.cpp
--- mozilla/extensions/xforms/nsXFormsSchemaValidator.cpp	2005-07-26 22:18:35.000000000 +0200
+++ mozilla.new/extensions/xforms/nsXFormsSchemaValidator.cpp	2006-02-14 10:01:13.000000000 +0100
@@ -227,7 +227,7 @@ nsXFormsSchemaValidator::IsValidSchemaLi
   PRBool isValid = PR_FALSE;
 
   // listItem is like a string, but no whitespace.  listItems is a whitespace
-  // delimeted list of listItem, so therefore just need to see if it is a valid
+  // delimited list of listItem, so therefore just need to see if it is a valid
   // xsd:string
   mSchemaValidator->ValidateString(aValue, NS_LITERAL_STRING("string"),
                                    NS_LITERAL_STRING("http://www.w3.org/1999/XMLSchema"),
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsSubmissionElement.cpp mozilla.new/extensions/xforms/nsXFormsSubmissionElement.cpp
--- mozilla/extensions/xforms/nsXFormsSubmissionElement.cpp	2005-10-23 18:30:13.000000000 +0200
+++ mozilla.new/extensions/xforms/nsXFormsSubmissionElement.cpp	2006-02-24 11:16:23.000000000 +0100
@@ -74,7 +74,6 @@
 #include "nsIMultiplexInputStream.h"
 #include "nsIMIMEInputStream.h"
 #include "nsINameSpaceManager.h"
-#include "nsIDocument.h"
 #include "nsIContent.h"
 #include "nsIFileURL.h"
 #include "nsIMIMEService.h"
@@ -93,12 +92,10 @@
 #include "nsIPermissionManager.h"
 #include "nsIPrefBranch.h"
 #include "nsIPrefService.h"
+#include "nsIExternalProtocolService.h"
+#include "nsEscape.h"
 
 // namespace literals
-#define NAMESPACE_XML_SCHEMA \
-        NS_LITERAL_STRING("http://www.w3.org/2001/XMLSchema")
-#define NAMESPACE_XML_SCHEMA_INSTANCE \
-        NS_LITERAL_STRING("http://www.w3.org/2001/XMLSchema-instance")
 #define kXMLNSNameSpaceURI \
         NS_LITERAL_STRING("http://www.w3.org/2000/xmlns/")
 
@@ -382,7 +379,7 @@ nsXFormsSubmissionElement::OnChannelRedi
   nsCOMPtr<nsIDocument> doc(do_QueryInterface(domDoc));
   NS_ENSURE_STATE(doc);
 
-  if (!CheckSameOrigin(doc->GetDocumentURI(), newURI)) {
+  if (!CheckSameOrigin(doc, newURI)) {
     nsXFormsUtils::ReportError(NS_LITERAL_STRING("submitSendOrigin"),
                                mElement);
     return NS_ERROR_ABORT;
@@ -904,7 +901,7 @@ nsXFormsSubmissionElement::SerializeData
 }
 
 PRBool
-nsXFormsSubmissionElement::CheckSameOrigin(nsIURI *aBaseURI, nsIURI *aTestURI)
+nsXFormsSubmissionElement::CheckSameOrigin(nsIDocument *aBaseDocument, nsIURI *aTestURI)
 {
   // we default to true to allow regular posts to work like html forms.
   PRBool allowSubmission = PR_TRUE;
@@ -923,21 +920,22 @@ nsXFormsSubmissionElement::CheckSameOrig
 
     // if same origin is required, default to false
     allowSubmission = PR_FALSE;
+    nsIURI *baseURI = aBaseDocument->GetDocumentURI();
 
     // if we don't replace the instance, we allow file:// to submit data anywhere
     if (!mIsReplaceInstance) {
-      aBaseURI->SchemeIs("file", &allowSubmission);
+      baseURI->SchemeIs("file", &allowSubmission);
     }
 
     // let's check the permission manager
     if (!allowSubmission) {
-      allowSubmission = CheckPermissionManager(aBaseURI);
+      allowSubmission = CheckPermissionManager(baseURI);
     }
 
     // if none of the above checks have allowed the submission, we do a
     // same origin check.
     if (!allowSubmission) {
-      allowSubmission = nsXFormsUtils::CheckSameOrigin(aBaseURI, aTestURI);
+      allowSubmission = nsXFormsUtils::CheckSameOrigin(aBaseDocument, aTestURI);
     }
   }
 
@@ -1229,14 +1227,14 @@ nsXFormsSubmissionElement::CopyChildren(
         return NS_ERROR_ILLEGAL_VALUE;
       }
 
-      // if |destChild| is an element node of type 'xsd:anyURI', and if we have
-      // an attachments array, then we need to perform multipart/related
+      // If |currentNode| is an element node of type 'xsd:anyURI', and if we
+      // have an attachments array, then we need to perform multipart/related
       // processing (i.e., generate a ContentID for the child of this element,
       // and append a new attachment to the attachments array).
 
       PRUint32 encType;
       if (attachments &&
-          NS_SUCCEEDED(GetElementEncodingType(destChild, &encType)) &&
+          NS_SUCCEEDED(GetElementEncodingType(currentNode, &encType, model)) &&
           encType == ELEMENT_ENCTYPE_URI)
       {
         // ok, looks like we have a local file to upload
@@ -1445,7 +1443,8 @@ nsXFormsSubmissionElement::SerializeData
 
   nsCOMPtr<nsIInputStream> xml;
   SubmissionAttachmentArray attachments;
-  SerializeDataXML(data, getter_AddRefs(xml), type, &attachments);
+  nsresult rv = SerializeDataXML(data, getter_AddRefs(xml), type, &attachments);
+  NS_ENSURE_SUCCESS(rv, rv);
 
   // XXX we should output a 'charset=' with the 'Content-Type' header
 
@@ -1454,7 +1453,7 @@ nsXFormsSubmissionElement::SerializeData
                 +  NS_LITERAL_CSTRING("\r\nContent-Type: ") + type
                 +  NS_LITERAL_CSTRING("\r\nContent-ID: <") + start
                 +  NS_LITERAL_CSTRING(">\r\n\r\n");
-  nsresult rv = AppendPostDataChunk(postDataChunk, multiStream);
+  rv = AppendPostDataChunk(postDataChunk, multiStream);
   NS_ENSURE_SUCCESS(rv, rv);
 
   multiStream->AppendStream(xml);
@@ -1657,7 +1656,7 @@ nsXFormsSubmissionElement::AppendMultipa
     }
     else
     {
-      // for base64binary and hexBinary types, we assume that the data is
+      // for base64Binary and hexBinary types, we assume that the data is
       // already encoded.  this assumption is based on section 8.1.6 of the
       // xforms spec.
 
@@ -1700,47 +1699,35 @@ nsXFormsSubmissionElement::AppendPostDat
 }
 
 nsresult
-nsXFormsSubmissionElement::GetElementEncodingType(nsIDOMNode *node, PRUint32 *encType)
+nsXFormsSubmissionElement::GetElementEncodingType(nsIDOMNode             *node,
+                                                  PRUint32               *encType,
+                                                  nsIModelElementPrivate *aModel)
 {
   *encType = ELEMENT_ENCTYPE_STRING; // default
 
   nsCOMPtr<nsIDOMElement> element = do_QueryInterface(node);
   NS_ENSURE_TRUE(element, NS_ERROR_UNEXPECTED);
 
-  nsAutoString type;
-  element->GetAttributeNS(NS_LITERAL_STRING(NS_NAMESPACE_XML_SCHEMA_INSTANCE),
-                          NS_LITERAL_STRING("type"), type);
-  if (!type.IsEmpty())
-  {
-    // check for 'xsd:base64binary', 'xsd:hexBinary', or 'xsd:anyURI'
+  // check for 'xsd:base64Binary', 'xsd:hexBinary', or 'xsd:anyURI'
+  nsAutoString type, nsuri;
+  nsresult rv;
+  if (aModel) {
+    rv = aModel->GetTypeFromNode(node, type, nsuri);
+  } else {
+    rv = nsXFormsUtils::ParseTypeFromNode(node, type, nsuri);
+  }
+  if (NS_SUCCEEDED(rv) &&
+      nsuri.EqualsLiteral(NS_NAMESPACE_XML_SCHEMA) &&
+      !type.IsEmpty())
+  {
+    if (type.Equals(NS_LITERAL_STRING("anyURI")))
+      *encType = ELEMENT_ENCTYPE_URI;
+    else if (type.Equals(NS_LITERAL_STRING("base64Binary")))
+      *encType = ELEMENT_ENCTYPE_BASE64;
+    else if (type.Equals(NS_LITERAL_STRING("hexBinary")))
+      *encType = ELEMENT_ENCTYPE_HEX;
 
     // XXX need to handle derived types (fixing bug 263384 will help)
-
-    // get 'xsd' namespace prefix
-    nsCOMPtr<nsIDOM3Node> dom3Node = do_QueryInterface(node);
-    NS_ENSURE_TRUE(dom3Node, NS_ERROR_UNEXPECTED);
-
-    nsAutoString prefix;
-    dom3Node->LookupPrefix(NS_LITERAL_STRING(NS_NAMESPACE_XML_SCHEMA), prefix);
-
-    if (prefix.IsEmpty())
-    {
-      NS_WARNING("namespace prefix not found! -- assuming 'xsd'");
-      prefix.AssignLiteral("xsd"); // XXX HACK HACK HACK
-    }
-
-    if (type.Length() > prefix.Length() &&
-        prefix.Equals(StringHead(type, prefix.Length())) &&
-        type.CharAt(prefix.Length()) == PRUnichar(':'))
-    {
-      const nsSubstring &tail = Substring(type, prefix.Length() + 1);
-      if (tail.Equals(NS_LITERAL_STRING("anyURI")))
-        *encType = ELEMENT_ENCTYPE_URI;
-      else if (tail.Equals(NS_LITERAL_STRING("base64binary")))
-        *encType = ELEMENT_ENCTYPE_BASE64;
-      else if (tail.Equals(NS_LITERAL_STRING("hexBinary")))
-        *encType = ELEMENT_ENCTYPE_HEX;
-    }
   }
 
   return NS_OK;
@@ -1803,7 +1790,89 @@ nsXFormsSubmissionElement::SendData(cons
 
   nsresult rv;
 
-  if (!CheckSameOrigin(doc->GetDocumentURI(), uri)) {
+  // handle mailto: submission
+  if (!mIsReplaceInstance) {
+    PRBool isMailto;
+    rv = uri->SchemeIs("mailto", &isMailto);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    if (isMailto) {
+      nsCOMPtr<nsIExternalProtocolService> extProtService =
+        do_GetService("@mozilla.org/uriloader/external-protocol-service;1");
+      NS_ENSURE_STATE(extProtService);
+
+      PRBool hasExposedMailClient;
+      rv = extProtService->ExternalProtocolHandlerExists("mailto",
+                                                         &hasExposedMailClient);
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      if (hasExposedMailClient) {
+        nsCAutoString mailtoUrl(uriSpec);
+
+        // A mailto url looks like this: mailto:foo@bar.com, which can be followed
+        // by parameters (subject and body).  The first parameter has to have an
+        // "?" before it, and an additional one needs to have an "&".
+        // So if "?" already exists in the string, we use "&".
+
+        if (mailtoUrl.Find("&body=") != kNotFound ||
+            mailtoUrl.Find("?body=") != kNotFound) {
+          // body parameter already exists, so report a warning
+          nsXFormsUtils::ReportError(NS_LITERAL_STRING("warnMailtoBodyParam"),
+                                     mElement, nsIScriptError::warningFlag);
+        }
+
+        if (mailtoUrl.FindChar('?') != kNotFound)
+          mailtoUrl.AppendLiteral("&body=");
+        else
+          mailtoUrl.AppendLiteral("?body=");
+
+        // get the stream contents
+        PRUint32 len, read, numReadIn = 1;
+        stream->Available(&len);
+        char *buf = new char[len+1];
+        memset(buf, 0, len+1);
+
+        // Read returns 0 if eos
+        while (numReadIn != 0) {
+          numReadIn = stream->Read(buf, len, &read);
+          NS_EscapeURL(buf, esc_AlwaysCopy, read, mailtoUrl);
+        }
+
+        delete [] buf;
+
+        // create an nsIUri out of the string
+        nsCOMPtr<nsIURI> mailUri;
+        ios->NewURI(mailtoUrl,
+                    nsnull,
+                    nsnull,
+                    getter_AddRefs(mailUri));
+        NS_ENSURE_STATE(mailUri);
+
+        // let the OS handle the uri
+        rv = extProtService->LoadURI(mailUri, nsnull);
+
+        if (NS_FAILED(rv)) {
+          // opening an mail client failed.
+          nsXFormsUtils::ReportError(NS_LITERAL_STRING("submitMailtoFailed"),
+                                     mElement);
+          EndSubmit(PR_FALSE);
+        } else {
+          // the protocol service succeeded
+          EndSubmit(PR_TRUE);
+        }
+
+      } else {
+        // no system mail client found
+        nsXFormsUtils::ReportError(NS_LITERAL_STRING("submitMailtoInit"),
+                                   mElement);
+        EndSubmit(PR_FALSE);
+      }
+
+      return NS_OK;
+    }
+  }
+
+  if (!CheckSameOrigin(doc, uri)) {
     nsXFormsUtils::ReportError(NS_LITERAL_STRING("submitSendOrigin"),
                                mElement);
     return NS_ERROR_ABORT;
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsSubmissionElement.h mozilla.new/extensions/xforms/nsXFormsSubmissionElement.h
--- mozilla/extensions/xforms/nsXFormsSubmissionElement.h	2005-10-04 20:28:24.000000000 +0200
+++ mozilla.new/extensions/xforms/nsXFormsSubmissionElement.h	2006-02-24 11:16:23.000000000 +0100
@@ -49,6 +49,7 @@
 #include "nsIChannelEventSink.h"
 #include "nsIInterfaceRequestor.h"
 #include "nsHashSets.h"
+#include "nsIDocument.h"
 
 
 class nsIMultiplexInputStream;
@@ -110,7 +111,7 @@ public:
   NS_HIDDEN_(nsresult) SerializeDataMultipartFormData(nsIDOMNode *data, nsIInputStream **, nsCString &contentType);
   NS_HIDDEN_(nsresult) AppendMultipartFormData(nsIDOMNode *data, const nsCString &boundary, nsCString &buf, nsIMultiplexInputStream *);
   NS_HIDDEN_(nsresult) AppendPostDataChunk(nsCString &postDataChunk, nsIMultiplexInputStream *multiStream);
-  NS_HIDDEN_(nsresult) GetElementEncodingType(nsIDOMNode *data, PRUint32 *encType);
+  NS_HIDDEN_(nsresult) GetElementEncodingType(nsIDOMNode *data, PRUint32 *encType, nsIModelElementPrivate* aModel = nsnull);
   NS_HIDDEN_(nsresult) CreateFileStream(const nsString &absURI, nsIFile **file, nsIInputStream **stream);
   NS_HIDDEN_(nsresult) SendData(const nsCString &uri, nsIInputStream *stream, const nsCString &contentType);
 
@@ -128,7 +129,7 @@ private:
    * @return true if aTestURI has the same origin as aBaseURI or if
    * there is no need for a same origin check.
    */
-  PRBool CheckSameOrigin(nsIURI *aBaseURI, nsIURI *aTestURI);
+  PRBool CheckSameOrigin(nsIDocument *aBaseDocument, nsIURI *aTestURI);
   PRBool CheckPermissionManager(nsIURI *aBaseURI);
   nsresult AddNameSpaces(nsIDOMElement* aTarget, nsIDOMNode* aSource,
                          nsStringHashSet* aPrefixHash);
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsUploadElement.cpp mozilla.new/extensions/xforms/nsXFormsUploadElement.cpp
--- mozilla/extensions/xforms/nsXFormsUploadElement.cpp	2005-10-23 18:30:13.000000000 +0200
+++ mozilla.new/extensions/xforms/nsXFormsUploadElement.cpp	2006-02-24 11:16:24.000000000 +0100
@@ -51,7 +51,6 @@
 #include "nsIDOMAbstractView.h"
 #include "nsIDOMWindowInternal.h"
 #include "nsIStringBundle.h"
-#include "nsIDOM3Node.h"
 #include "nsAutoBuffer.h"
 #include "nsIEventStateManager.h"
 #include "prmem.h"
@@ -147,26 +146,19 @@ nsBoundType
 nsXFormsUploadElement::GetBoundType()
 {
   nsBoundType result = TYPE_DEFAULT;
+  if (!mModel)
+    return result;
 
   // get type bound to node
-  nsAutoString type, prefix, nsuri;
-  nsresult rv = nsXFormsUtils::ParseTypeFromNode(mBoundNode, type, prefix);
-
-  if (NS_SUCCEEDED(rv)) {
-    // get the namespace url from the prefix
-    nsCOMPtr<nsIDOM3Node> domNode3 = do_QueryInterface(mElement, &rv);
-    if (NS_SUCCEEDED(rv)) {
-      rv = domNode3->LookupNamespaceURI(prefix, nsuri);
-
-      if (NS_SUCCEEDED(rv) && nsuri.EqualsLiteral(NS_NAMESPACE_XML_SCHEMA)) {
-        if (type.EqualsLiteral("anyURI")) {
-          result = TYPE_ANYURI;
-        } else if (type.EqualsLiteral("base64Binary")) {
-          result = TYPE_BASE64;
-        } else if (type.EqualsLiteral("hexBinary")) {
-          result = TYPE_HEX;
-        }
-      }
+  nsAutoString type, nsuri;
+  nsresult rv = mModel->GetTypeFromNode(mBoundNode, type, nsuri);
+  if (NS_SUCCEEDED(rv) && nsuri.EqualsLiteral(NS_NAMESPACE_XML_SCHEMA)) {
+    if (type.EqualsLiteral("anyURI")) {
+      result = TYPE_ANYURI;
+    } else if (type.EqualsLiteral("base64Binary")) {
+      result = TYPE_BASE64;
+    } else if (type.EqualsLiteral("hexBinary")) {
+      result = TYPE_HEX;
     }
   }
 
@@ -208,12 +200,9 @@ nsXFormsUploadElement::PickFile()
 
   // get nsIDOMWindowInternal
   nsCOMPtr<nsIDOMDocument> doc;
+  nsCOMPtr<nsIDOMWindowInternal> internal;
   mElement->GetOwnerDocument(getter_AddRefs(doc));
-  nsCOMPtr<nsIDOMDocumentView> dview = do_QueryInterface(doc);
-  NS_ENSURE_STATE(dview);
-  nsCOMPtr<nsIDOMAbstractView> aview;
-  dview->GetDefaultView(getter_AddRefs(aview));
-  nsCOMPtr<nsIDOMWindowInternal> internal = do_QueryInterface(aview);
+  rv = nsXFormsUtils::GetWindowFromDocument(doc, getter_AddRefs(internal));
   NS_ENSURE_STATE(internal);
 
   // init filepicker
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsUtilityService.cpp mozilla.new/extensions/xforms/nsXFormsUtilityService.cpp
--- mozilla/extensions/xforms/nsXFormsUtilityService.cpp	2005-08-04 23:15:37.000000000 +0200
+++ mozilla.new/extensions/xforms/nsXFormsUtilityService.cpp	2006-02-14 10:01:13.000000000 +0100
@@ -113,60 +113,33 @@ nsXFormsUtilityService::IsNodeAssocWithM
                                               PRBool     *aModelAssocWithNode)
 {
 
-  nsCOMPtr<nsIDOMElement> element = do_QueryInterface(aNode);
+  nsCOMPtr<nsIDOMNode> modelNode;
 
   nsAutoString namespaceURI;
   aNode->GetNamespaceURI(namespaceURI);
-
   // If the node is in the XForms namespace and XTF based, then it should
   //   be able to be handled by GetModel.  Otherwise it is probably an instance
   //   node in a instance document.
   if (namespaceURI.EqualsLiteral(NS_NAMESPACE_XFORMS)) {
+    nsCOMPtr<nsIDOMElement> element = do_QueryInterface(aNode);
     nsCOMPtr<nsIModelElementPrivate> modelPriv = nsXFormsUtils::GetModel(element);
-    nsCOMPtr<nsIDOMNode> modelNode = do_QueryInterface(modelPriv);
-
-    if (modelNode && (modelNode == aModel)) {
-      *aModelAssocWithNode = PR_TRUE;
-    } else { 
-      *aModelAssocWithNode = PR_FALSE;
-    }
+    modelNode = do_QueryInterface(modelPriv);
   } else { 
     // We are assuming that if the node coming in isn't a proper XForms element,
     //   then it is an instance element in an instance doc.  Now we just have
     //   to determine if the given model contains this instance document.
-    nsCOMPtr<nsIDOMDocument> document;
-    aNode->GetOwnerDocument(getter_AddRefs(document));
-    *aModelAssocWithNode = PR_FALSE;
-
-    // Guess that we'd better make sure that it is a model
-    nsCOMPtr<nsIXFormsModelElement> modelEle = do_QueryInterface(aModel);
-    if (modelEle) {
-      // OK, we know that this is a model element.  So now we have to go
-      //   instance element by instance element and find the associated
-      //   document.  If it is equal to the document that contains aNode,
-      //   then aNode is associated with this aModel element and we can return
-      //   true.
-      nsCOMPtr<nsIModelElementPrivate>model = do_QueryInterface(modelEle);
-      nsCOMPtr<nsIInstanceElementPrivate> instElement;
-      nsCOMPtr<nsIDOMDocument> instDocument;
-
-      nsCOMArray<nsIInstanceElementPrivate> *instList = nsnull;
-      model->GetInstanceList(&instList);
-      NS_ENSURE_TRUE(instList, NS_ERROR_FAILURE);
-
-      for (int i = 0; i < instList->Count(); ++i) {
-        instElement = instList->ObjectAt(i);
-    
-        instElement->GetDocument(getter_AddRefs(instDocument));
-        if (instDocument) {
-          if (instDocument == document) {
-            *aModelAssocWithNode = PR_TRUE;
-            break;
-          }
-        }
-      }
+    nsCOMPtr<nsIDOMNode> instNode;
+    nsresult rv =
+      nsXFormsUtils::GetInstanceNodeForData(aNode, getter_AddRefs(instNode));
+    if (NS_SUCCEEDED(rv) && instNode) {
+      instNode->GetParentNode(getter_AddRefs(modelNode));
     }
+  }
 
+  if (modelNode && (modelNode == aModel)) {
+    *aModelAssocWithNode = PR_TRUE;
+  } else {
+    *aModelAssocWithNode = PR_FALSE;
   }
 
   return NS_OK;
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsUtils.cpp mozilla.new/extensions/xforms/nsXFormsUtils.cpp
--- mozilla/extensions/xforms/nsXFormsUtils.cpp	2005-10-23 18:30:13.000000000 +0200
+++ mozilla.new/extensions/xforms/nsXFormsUtils.cpp	2006-02-24 11:16:25.000000000 +0100
@@ -90,6 +90,16 @@
 #include "nsIDOMNamedNodeMap.h"
 #include "nsIParserService.h"
 
+#include "nsIPrefBranch.h"
+#include "nsIPrefService.h"
+#include "nsIDOMDocumentView.h"
+#include "nsIDOMAbstractView.h"
+#include "nsPIDOMWindow.h"
+
+#include "nsIDOMDocumentType.h"
+#include "nsIDOMEntity.h"
+#include "nsIDOMNotation.h"
+
 #define CANCELABLE 0x01
 #define BUBBLES    0x02
 
@@ -386,10 +396,6 @@ nsXFormsUtils::EvaluateXPath(const nsASt
                              nsCOMArray<nsIDOMNode> *aSet,
                              nsStringArray          *aIndexesUsed)
 {
-  nsCOMPtr<nsIDOMDocument> doc;
-  aContextNode->GetOwnerDocument(getter_AddRefs(doc));
-  NS_ENSURE_TRUE(doc, nsnull);
-
   nsCOMPtr<nsIXFormsXPathEvaluator> eval = 
            do_CreateInstance("@mozilla.org/dom/xforms-xpath-evaluator;1");
   NS_ENSURE_TRUE(eval, nsnull);
@@ -505,7 +511,7 @@ nsXFormsUtils::EvaluateNodeBinding(nsIDO
 
       return NS_OK;
     } else {
-      // If there is a (outer) bind element, we retrive its nodeset.
+      // If there is a (outer) bind element, we retrieve its nodeset.
       bindElement->GetAttribute(NS_LITERAL_STRING("nodeset"), expr);
     }
   } else {
@@ -566,10 +572,10 @@ nsXFormsUtils::EvaluateNodeBinding(nsIDO
               }
 
               if (NS_SUCCEEDED(rv)) {
-                nsCOMArray<nsIInstanceElementPrivate> *instList = nsnull;
-                (*aModel)->GetInstanceList(&instList);
-                nsCOMPtr<nsIInstanceElementPrivate> instance = 
-                  instList->ObjectAt(0);
+                nsCOMPtr<nsIInstanceElementPrivate> instance;
+                rv = (*aModel)->FindInstanceElement(EmptyString(),
+                                                    getter_AddRefs(instance));
+                NS_ENSURE_SUCCESS(rv, rv);
                 nsCOMPtr<nsIDOMDocument> domdoc;
                 instance->GetDocument(getter_AddRefs(domdoc));
                 nsCOMPtr<nsIDOMElement> instanceDataEle;
@@ -590,6 +596,9 @@ nsXFormsUtils::EvaluateNodeBinding(nsIDO
                                   contextPosition, contextSize, aDeps,
                                   aIndexesUsed);
             } else {
+                const PRUnichar *strings[] = { expr.get() };
+                nsXFormsUtils::ReportError(NS_LITERAL_STRING("invalidQName"),
+                                           strings, 1, aElement, aElement);
               nsXFormsUtils::DispatchEvent(aElement, eEvent_BindingException);
             }
           }
@@ -1102,28 +1111,54 @@ nsXFormsUtils::FindParentContext(nsIDOME
 }
 
 /* static */ PRBool
-nsXFormsUtils::CheckSameOrigin(nsIURI *aBaseURI, nsIURI *aTestURI)
+nsXFormsUtils::CheckSameOrigin(nsIDocument *aBaseDocument, nsIURI *aTestURI)
 {
   nsresult rv;
 
-  // check to see if we're allowed to load this URI
+  // get the base document's principal
+  nsIPrincipal *basePrincipal = aBaseDocument->GetPrincipal();
+
+  if (basePrincipal) {
+    // check for the UniversalBrowserRead capability.
+    PRBool crossSiteAccessEnabled;
+    rv = basePrincipal->IsCapabilityEnabled("UniversalBrowserRead", nsnull,
+                                            &crossSiteAccessEnabled);
+    if (NS_SUCCEEDED(rv) && crossSiteAccessEnabled)
+      return PR_TRUE;
+
+    // check the security manager and do a same original check on the principal
   nsCOMPtr<nsIScriptSecurityManager> secMan =
       do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID);
   if (secMan) {
-    rv = secMan->CheckSameOriginURI(aBaseURI, aTestURI);
+      // get a principal for the uri we are testing
+      nsCOMPtr<nsIPrincipal> testPrincipal;
+      rv = secMan->GetCodebasePrincipal(aTestURI, getter_AddRefs(testPrincipal));
+
+      if (NS_SUCCEEDED(rv)) {
+        rv = secMan->CheckSameOriginPrincipal(aBaseDocument->GetPrincipal(),
+                                              testPrincipal);
     if (NS_SUCCEEDED(rv))
       return PR_TRUE;
   }
+    }
+  }
 
   // else, check with the permission manager to see if this host is
   // permitted to access sites from other domains.
 
   nsCOMPtr<nsIPermissionManager> permMgr =
       do_GetService(NS_PERMISSIONMANAGER_CONTRACTID);
-  PRUint32 perm;
-  rv = permMgr->TestPermission(aBaseURI, "xforms-load", &perm);
-  if (NS_SUCCEEDED(rv) && perm == nsIPermissionManager::ALLOW_ACTION)
-    return PR_TRUE; 
+  NS_ENSURE_TRUE(permMgr, PR_FALSE);
+
+  nsCOMPtr<nsIURI> principalURI;
+  rv = basePrincipal->GetURI(getter_AddRefs(principalURI));
+
+  if (NS_SUCCEEDED(rv)) {
+    PRUint32 perm;
+    rv = permMgr->TestPermission(principalURI, "xforms-load", &perm);
+    if (NS_SUCCEEDED(rv) && perm == nsIPermissionManager::ALLOW_ACTION)
+      return PR_TRUE;
+  }
 
   return PR_FALSE;
 }
@@ -1230,67 +1265,26 @@ nsXFormsUtils::GetInstanceNodeForData(ns
 }
 
 /* static */ nsresult
-nsXFormsUtils::ParseTypeFromNode(nsIDOMNode *aInstanceData,
-                                 nsAString &aType, nsAString &aNSPrefix)
+nsXFormsUtils::ParseTypeFromNode(nsIDOMNode             *aInstanceData,
+                                 nsAString              &aType,
+                                 nsAString              &aNSUri)
 {
-  nsresult rv = NS_OK;
-
-  // aInstanceData could be an instance data node or it could be an attribute
-  // on an instance data node (basically the node that a control is bound to).
-
-  nsAutoString *typeVal = nsnull;
-
-  // Get type stored directly on instance node
-  nsAutoString typeAttribute;
-  nsCOMPtr<nsIDOMElement> nodeElem(do_QueryInterface(aInstanceData));
-  if (nodeElem) {
-    nodeElem->GetAttributeNS(NS_LITERAL_STRING(NS_NAMESPACE_XML_SCHEMA_INSTANCE),
-                             NS_LITERAL_STRING("type"), typeAttribute);
-    if (!typeAttribute.IsEmpty()) {
-      typeVal = &typeAttribute;
-    }
-  }
-
-  if (!typeVal) {
-    // Get MIP type bound to node
-    nsCOMPtr<nsIContent> nodeContent(do_QueryInterface(aInstanceData));
-    if (nodeContent) {
-      typeVal =
-        NS_STATIC_CAST(nsAutoString*,
-                       nodeContent->GetProperty(nsXFormsAtoms::type, &rv));
-    } else {
-      nsCOMPtr<nsIAttribute> nodeAttribute(do_QueryInterface(aInstanceData));
-      if (!nodeAttribute)
-        // node is neither content or attribute!
-        return NS_ERROR_FAILURE;
-
-      typeVal =
-        NS_STATIC_CAST(nsAutoString*,
-                       nodeAttribute->GetProperty(nsXFormsAtoms::type, &rv));
-    }
-  }
-
-  if (NS_FAILED(rv) || !typeVal) {
-    return NS_ERROR_NOT_AVAILABLE;
-  }
-
-  // split type (ns:type) into namespace and type.
-  PRInt32 separator = typeVal->FindChar(':');
-  if ((PRUint32) separator == (typeVal->Length() - 1)) {
-    const PRUnichar *strings[] = { typeVal->get() };
-    // XXX: get an element from the document this came from
-    ReportError(NS_LITERAL_STRING("missingTypeName"), strings, 1, nsnull, nsnull);
-    return NS_ERROR_UNEXPECTED;
-  } else if (separator == kNotFound) {
-    // no namespace prefix, which is valid;
-    aNSPrefix.AssignLiteral("");
-    aType.Assign(*typeVal);
-  } else {
-    aNSPrefix.Assign(Substring(*typeVal, 0, separator));
-    aType.Assign(Substring(*typeVal, ++separator, typeVal->Length()));
-  }
-
-  return NS_OK;
+  nsresult rv;
+  
+  // Find the model for the instance data node
+  nsCOMPtr<nsIDOMNode> instanceNode;
+  rv = nsXFormsUtils::GetInstanceNodeForData(aInstanceData,
+                                             getter_AddRefs(instanceNode));
+  NS_ENSURE_SUCCESS(rv, rv);
+  
+  nsCOMPtr<nsIDOMNode> modelNode;
+  rv = instanceNode->GetParentNode(getter_AddRefs(modelNode));
+  NS_ENSURE_SUCCESS(rv, rv);
+  
+  nsCOMPtr<nsIModelElementPrivate> model(do_QueryInterface(modelNode));
+  NS_ENSURE_STATE(model);
+  
+  return model->GetTypeFromNode(aInstanceData, aType, aNSUri);
 }
 
 /* static */ void
@@ -1548,3 +1542,441 @@ nsXFormsUtils::GetElementById(nsIDOMDocu
 
   return NS_OK;
 }
+
+
+/* static */
+PRBool
+nsXFormsUtils::HandleBindingException(nsIDOMElement *aElement)
+{
+  if (!aElement) {
+    return PR_FALSE;
+  }
+  nsCOMPtr<nsIDOMDocument> doc;
+  aElement->GetOwnerDocument(getter_AddRefs(doc));
+
+  nsCOMPtr<nsIDocument> iDoc(do_QueryInterface(doc));
+  if (!iDoc) {
+    return PR_FALSE;
+  }
+
+  // check for fatalError property, enforcing that only one fatal error will
+  // be shown to the user
+  if (iDoc->GetProperty(nsXFormsAtoms::fatalError)) {
+    return PR_FALSE;
+  }
+  iDoc->SetProperty(nsXFormsAtoms::fatalError, iDoc);
+
+  // Check for preference, disabling this popup
+  PRBool disablePopup = PR_FALSE;
+  nsresult rv;
+  nsCOMPtr<nsIPrefBranch> pref = do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);
+  if (NS_SUCCEEDED(rv) && pref) {
+    PRBool val;
+    if (NS_SUCCEEDED(pref->GetBoolPref("xforms.disablePopup", &val)))
+      disablePopup = val;
+  }
+  if (disablePopup)
+    return PR_FALSE;
+
+  // Get nsIDOMWindowInternal
+  nsCOMPtr<nsIDOMWindowInternal> internal;
+  rv = nsXFormsUtils::GetWindowFromDocument(doc, getter_AddRefs(internal));
+  if (NS_FAILED(rv) || !internal) {
+    return PR_FALSE;
+  }
+
+
+  // Show popup
+  nsCOMPtr<nsIDOMWindow> messageWindow;
+  rv = internal->OpenDialog(NS_LITERAL_STRING("chrome://xforms/content/bindingex.xul"),
+                            NS_LITERAL_STRING("XFormsBindingException"),
+                            NS_LITERAL_STRING("modal,dialog,chrome,dependent"),
+                            nsnull, getter_AddRefs(messageWindow));
+  return NS_SUCCEEDED(rv);
+}
+
+/* static */ PRBool
+nsXFormsUtils::AreEntitiesEqual(nsIDOMNamedNodeMap *aEntities1,
+                                nsIDOMNamedNodeMap *aEntities2)
+{
+  if (!aEntities1 && !aEntities2) {
+    return PR_TRUE;
+  }
+
+  if (!aEntities1 || !aEntities2) {
+    return PR_FALSE;
+  }
+
+  PRUint32 entLength1, entLength2;
+  nsresult rv1 = aEntities1->GetLength(&entLength1);
+  nsresult rv2 = aEntities2->GetLength(&entLength2);
+  if (NS_FAILED(rv1) || NS_FAILED(rv2) || entLength1 != entLength2) {
+    return PR_FALSE;
+  }
+
+  nsAutoString buffer1, buffer2;
+  for (PRUint32 i = 0; i < entLength1; ++i) {
+    nsCOMPtr<nsIDOMNode> entNode1, entNode2;
+
+    rv1 = aEntities1->Item(i, getter_AddRefs(entNode1));
+    rv2 = aEntities2->Item(i, getter_AddRefs(entNode2));
+    if (NS_FAILED(rv1) || NS_FAILED(rv2) || !entNode1 || !entNode2) {
+      return PR_FALSE;
+    }
+
+    nsCOMPtr<nsIDOMEntity> ent1, ent2;
+    ent1 = do_QueryInterface(entNode1);
+    ent2 = do_QueryInterface(entNode2);
+    if (!ent1 || !ent2) {
+      return PR_FALSE;
+    }
+
+    rv1 = ent1->GetPublicId(buffer1);
+    rv2 = ent2->GetPublicId(buffer2);
+    if (NS_FAILED(rv1) || NS_FAILED(rv2) || !buffer1.Equals(buffer2)) {
+      return PR_FALSE;
+    }
+
+    rv1 = ent1->GetSystemId(buffer1);
+    rv2 = ent2->GetSystemId(buffer2);
+    if (NS_FAILED(rv1) || NS_FAILED(rv2) || !buffer1.Equals(buffer2)) {
+      return PR_FALSE;
+    }
+
+    rv1 = ent1->GetNotationName(buffer1);
+    rv2 = ent2->GetNotationName(buffer2);
+    if (NS_FAILED(rv1) || NS_FAILED(rv2) || !buffer1.Equals(buffer2)) {
+      return PR_FALSE;
+    }
+
+    // XXX: These will need to be uncommented when Mozilla supports these from
+    // DOM3
+#if 0
+    rv1 = ent1->GetInputEncoding(buffer1);
+    rv2 = ent2->GetInputEncoding(buffer2);
+    if (NS_FAILED(rv1) || NS_FAILED(rv2) || !buffer1.Equals(buffer2)) {
+      return PR_FALSE;
+    }
+
+    rv1 = ent1->GetXmlEncoding(buffer1);
+    rv2 = ent2->GetXmlEncoding(buffer2);
+    if (NS_FAILED(rv1) || NS_FAILED(rv2) || !buffer1.Equals(buffer2)) {
+      return PR_FALSE;
+    }
+    rv1 = ent1->GetXmlVersion(buffer1);
+    rv2 = ent2->GetXmlVersion(buffer2);
+    if (NS_FAILED(rv1) || NS_FAILED(rv2) || !buffer1.Equals(buffer2)) {
+      return PR_FALSE;
+    }
+#endif
+
+  }
+  return PR_TRUE;
+}
+
+/* static */ PRBool
+nsXFormsUtils::AreNotationsEqual(nsIDOMNamedNodeMap *aNotations1,
+                                 nsIDOMNamedNodeMap *aNotations2)
+{
+  if (!aNotations1 && !aNotations2) {
+    return PR_TRUE;
+  }
+
+  if (!aNotations1 || !aNotations2) {
+    return PR_FALSE;
+  }
+
+  PRUint32 notLength1, notLength2;
+  nsresult rv1 = aNotations1->GetLength(&notLength1);
+  nsresult rv2 = aNotations2->GetLength(&notLength2);
+  if (NS_FAILED(rv1) || NS_FAILED(rv2) || notLength1 != notLength2) {
+    return PR_FALSE;
+  }
+
+  nsAutoString buffer1, buffer2;
+  for (PRUint32 j = 0; j < notLength1; ++j) {
+    nsCOMPtr<nsIDOMNode> notNode1, notNode2;
+
+    rv1 = aNotations1->Item(j, getter_AddRefs(notNode1));
+    rv2 = aNotations2->Item(j, getter_AddRefs(notNode2));
+    if (NS_FAILED(rv1) || NS_FAILED(rv2) || !notNode1 || !notNode2) {
+      return PR_FALSE;
+    }
+
+    nsCOMPtr<nsIDOMNotation> notation1, notation2;
+    notation1 = do_QueryInterface(notNode1);
+    notation2 = do_QueryInterface(notNode2);
+    if (!notation1 || !notation2) {
+      return PR_FALSE;
+    }
+
+    rv1 = notation1->GetPublicId(buffer1);
+    rv2 = notation2->GetPublicId(buffer2);
+    if (NS_FAILED(rv1) || NS_FAILED(rv2) || !buffer1.Equals(buffer2)) {
+      return PR_FALSE;
+    }
+
+    rv1 = notation1->GetSystemId(buffer1);
+    rv2 = notation2->GetSystemId(buffer2);
+    if (NS_FAILED(rv1) || NS_FAILED(rv2) || !buffer1.Equals(buffer2)) {
+      return PR_FALSE;
+    }
+  }
+
+  return PR_TRUE;
+}
+
+/* static */ PRBool
+nsXFormsUtils::AreNodesEqual(nsIDOMNode *aFirstNode, nsIDOMNode *aSecondNode,
+                             PRBool aAlreadyNormalized)
+{
+  if (!aFirstNode || !aSecondNode) {
+    return PR_FALSE;
+  }
+
+  nsresult rv1, rv2;
+  PRUint16 firstType, secondType;
+  rv1 = aFirstNode->GetNodeType(&firstType);
+  rv2 = aSecondNode->GetNodeType(&secondType);
+  if (NS_FAILED(rv1) || NS_FAILED(rv2) || firstType != secondType) {
+    return PR_FALSE;
+  }
+
+  nsAutoString buffer1, buffer2;
+  if (firstType == nsIDOMNode::DOCUMENT_TYPE_NODE) {
+    nsCOMPtr<nsIDOMDocumentType> doc1 = do_QueryInterface(aFirstNode);
+    nsCOMPtr<nsIDOMDocumentType> doc2 = do_QueryInterface(aSecondNode);
+    if (!doc1 || !doc2) {
+      return PR_FALSE;
+    }
+
+    rv1 = doc1->GetName(buffer1);
+    rv2 = doc2->GetName(buffer2);
+    if (NS_FAILED(rv1) || NS_FAILED(rv2) || !buffer1.Equals(buffer2)) {
+      return PR_FALSE;
+    }
+
+    rv1 = doc1->GetPublicId(buffer1);
+    rv2 = doc2->GetPublicId(buffer2);
+    if (NS_FAILED(rv1) || NS_FAILED(rv2) || !buffer1.Equals(buffer2)) {
+      return PR_FALSE;
+    }
+
+    rv1 = doc1->GetSystemId(buffer1);
+    rv2 = doc2->GetSystemId(buffer2);
+    if (NS_FAILED(rv1) || NS_FAILED(rv2) || !buffer1.Equals(buffer2)) {
+      return PR_FALSE;
+    }
+
+    rv1 = doc1->GetInternalSubset(buffer1);
+    rv2 = doc2->GetInternalSubset(buffer2);
+    if (NS_FAILED(rv1) || NS_FAILED(rv2) || !buffer1.Equals(buffer2)) {
+      return PR_FALSE;
+    }
+
+    nsCOMPtr<nsIDOMNamedNodeMap> map1, map2;
+    rv1 = doc1->GetEntities(getter_AddRefs(map1));
+    rv2 = doc2->GetEntities(getter_AddRefs(map2));
+
+    // XXX need to handle the case where neither has entities?
+    if (NS_FAILED(rv1) || NS_FAILED(rv2)) {
+      return PR_FALSE;
+    }
+
+    PRBool equal = nsXFormsUtils::AreEntitiesEqual(map1, map2);
+    if (!equal) {
+      return PR_FALSE;
+    }
+
+    rv1 = doc1->GetNotations(getter_AddRefs(map1));
+    rv2 = doc2->GetNotations(getter_AddRefs(map2));
+    if (NS_FAILED(rv1) || NS_FAILED(rv2)) {
+      return PR_FALSE;
+    }
+
+    equal = nsXFormsUtils::AreNotationsEqual(map1, map2);
+    if (!equal) {
+      return PR_FALSE;
+    }
+
+  }
+
+  rv1 = aFirstNode->GetNodeName(buffer1);
+  rv2 = aSecondNode->GetNodeName(buffer2);
+  if (NS_FAILED(rv1) || NS_FAILED(rv2) || !buffer1.Equals(buffer2)) {
+    return PR_FALSE;
+  }
+
+  rv1 = aFirstNode->GetLocalName(buffer1);
+  rv2 = aSecondNode->GetLocalName(buffer2);
+  if (NS_FAILED(rv1) || NS_FAILED(rv2) || !buffer1.Equals(buffer2)) {
+    return PR_FALSE;
+  }
+
+  rv1 = aFirstNode->GetNamespaceURI(buffer1);
+  rv2 = aSecondNode->GetNamespaceURI(buffer2);
+  if (NS_FAILED(rv1) || NS_FAILED(rv2) || !buffer1.Equals(buffer2)) {
+    return PR_FALSE;
+  }
+
+  rv1 = aFirstNode->GetPrefix(buffer1);
+  rv2 = aSecondNode->GetPrefix(buffer2);
+  if (NS_FAILED(rv1) || NS_FAILED(rv2) || !buffer1.Equals(buffer2)) {
+    return PR_FALSE;
+  }
+
+  rv1 = aFirstNode->GetNodeValue(buffer1);
+  rv2 = aSecondNode->GetNodeValue(buffer2);
+  if (NS_FAILED(rv1) || NS_FAILED(rv2) || !buffer1.Equals(buffer2)) {
+    return PR_FALSE;
+  }
+
+  PRBool hasAttr1, hasAttr2;
+  rv1 = aFirstNode->HasAttributes(&hasAttr1);
+  rv2 = aSecondNode->HasAttributes(&hasAttr2);
+  if (NS_FAILED(rv1) || NS_FAILED(rv2) || hasAttr1 != hasAttr2) {
+    return PR_FALSE;
+  }
+
+  if (hasAttr1) {
+    nsCOMPtr<nsIDOMNamedNodeMap> attrs1, attrs2;
+    PRUint32 attrLength1, attrLength2;
+
+    rv1 = aFirstNode->GetAttributes(getter_AddRefs(attrs1));
+    rv2 = aSecondNode->GetAttributes(getter_AddRefs(attrs2));
+    if (NS_FAILED(rv1) || NS_FAILED(rv2)) {
+      return PR_FALSE;
+    }
+
+    rv1 = attrs1->GetLength(&attrLength1);
+    rv2 = attrs2->GetLength(&attrLength2);
+    if (NS_FAILED(rv1) || NS_FAILED(rv2) || attrLength1 != attrLength2) {
+      return PR_FALSE;
+    }
+
+    // the order of the attributes on the two nodes doesn't matter.  But
+    // every attribute on node1 must exist on node2 (and no more)
+    for (PRUint32 i = 0; i < attrLength1; ++i) {
+      nsCOMPtr<nsIDOMNode> attr1, attr2;
+      rv1 = attrs1->Item(i, getter_AddRefs(attr1));
+      if (!attr1) {
+        return PR_FALSE;
+      }
+
+      attr1->GetLocalName(buffer1);
+      attr1->GetNamespaceURI(buffer2);
+      attrs2->GetNamedItemNS(buffer2, buffer1, getter_AddRefs(attr2));
+      if (!attr2) {
+        return PR_FALSE;
+      }
+
+      rv1 = attr1->GetNodeValue(buffer1);
+      rv2 = attr2->GetNodeValue(buffer2);
+      if (NS_FAILED(rv1) || NS_FAILED(rv2) || !buffer1.Equals(buffer2)) {
+        return PR_FALSE;
+      }
+    }
+  }
+
+  // now looking at the child nodes.  They have to be 'equal' and at the same
+  // index inside each of the parent nodes.
+  PRBool hasChildren1, hasChildren2;
+  rv1 = aFirstNode->HasChildNodes(&hasChildren1);
+  rv2 = aSecondNode->HasChildNodes(&hasChildren2);
+  if (NS_FAILED(rv1) || NS_FAILED(rv2) || hasChildren1 != hasChildren2) {
+    return PR_FALSE;
+  }
+
+  if (hasChildren1) {
+    nsCOMPtr<nsIDOMNodeList> children1, children2;
+    PRUint32 childrenLength1, childrenLength2;
+
+    rv1 = aFirstNode->GetChildNodes(getter_AddRefs(children1));
+    rv2 = aSecondNode->GetChildNodes(getter_AddRefs(children2));
+    if (NS_FAILED(rv1) || NS_FAILED(rv2) || !children1 || !children2) {
+      return PR_FALSE;
+    }
+
+    rv1 = children1->GetLength(&childrenLength1);
+    rv2 = children2->GetLength(&childrenLength2);
+    if (NS_FAILED(rv1) || NS_FAILED(rv2) || childrenLength1 != childrenLength2) {
+      return PR_FALSE;
+    }
+
+    nsCOMPtr<nsIDOMNode> clone1, clone2;
+    if (!aAlreadyNormalized) {
+      // well we avoided this as long as we can.  If we haven't already
+      // normalized all children, now is the time to do it.  We'll have to clone
+      // nodes since the normalization process actually changes the DOM.
+     
+      rv1 = aFirstNode->CloneNode(PR_TRUE, getter_AddRefs(clone1));
+      if (NS_FAILED(rv1) || !clone1) {
+        return PR_FALSE;
+      }
+      rv2 = aSecondNode->CloneNode(PR_TRUE, getter_AddRefs(clone2));
+      if (NS_FAILED(rv2) || !clone2) {
+        return PR_FALSE;
+      }
+
+      rv1 = clone1->Normalize();
+      rv2 = clone2->Normalize();
+      if (NS_FAILED(rv1) || NS_FAILED(rv2)) {
+        return PR_FALSE;
+      }
+
+      // since this already worked once on the original nodes, won't bother
+      // checking the results for the clones
+      clone1->GetChildNodes(getter_AddRefs(children1));
+      clone2->GetChildNodes(getter_AddRefs(children2));
+
+      // get length again since normalizing may have eliminated some text nodes
+      rv1 = children1->GetLength(&childrenLength1);
+      rv2 = children2->GetLength(&childrenLength2);
+      if (NS_FAILED(rv1) || NS_FAILED(rv2) || childrenLength1 != childrenLength2) {
+        return PR_FALSE;
+      }
+    }
+
+    for (PRUint32 i = 0; i < childrenLength1; ++i) {
+      nsCOMPtr<nsIDOMNode> child1, child2;
+
+      rv1 = children1->Item(i, getter_AddRefs(child1));
+      rv2 = children2->Item(i, getter_AddRefs(child2));
+      if (NS_FAILED(rv1) || NS_FAILED(rv2)) {
+        return PR_FALSE;
+      }
+
+      PRBool areEqual = nsXFormsUtils::AreNodesEqual(child1, child2, PR_TRUE);
+      if (!areEqual) {
+        return PR_FALSE;
+      }
+    }
+  }
+
+  return PR_TRUE;
+
+}
+
+
+/* static */
+nsresult
+nsXFormsUtils::GetWindowFromDocument(nsIDOMDocument         *aDoc,
+                                     nsIDOMWindowInternal  **aWindow)
+{
+  NS_ENSURE_ARG(aDoc);
+  NS_ENSURE_ARG_POINTER(aWindow);
+  *aWindow = nsnull;
+
+  // Get nsIDOMWindowInternal
+  nsCOMPtr<nsIDOMDocumentView> dview(do_QueryInterface(aDoc));
+  NS_ENSURE_STATE(dview);
+
+  nsCOMPtr<nsIDOMAbstractView> aview;
+  dview->GetDefaultView(getter_AddRefs(aview));
+
+  nsCOMPtr<nsIDOMWindowInternal> internal(do_QueryInterface(aview));
+  NS_ENSURE_STATE(internal);
+
+  NS_ADDREF(*aWindow = internal);
+  return NS_OK;
+}
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsUtils.h mozilla.new/extensions/xforms/nsXFormsUtils.h
--- mozilla/extensions/xforms/nsXFormsUtils.h	2005-10-23 18:30:13.000000000 +0200
+++ mozilla.new/extensions/xforms/nsXFormsUtils.h	2006-02-14 10:01:13.000000000 +0100
@@ -44,10 +44,12 @@
 #include "nsCOMPtr.h"
 #include "nsCOMArray.h"
 #include "nsIDOMNode.h"
+#include "nsIDocument.h"
 #include "nsIDOMXPathResult.h"
 #include "nsIModelElementPrivate.h"
 #include "nsIScriptError.h"
 #include "nsVoidArray.h"
+#include "nsIDOMWindowInternal.h"
 
 class nsIDOMElement;
 class nsIXFormsModelElement;
@@ -349,9 +351,9 @@ public:
                                                 PRInt32                 *aContextSize);
 
   /**
-   * @return true if aTestURI has the same origin as aBaseURI
+   * @return true if aTestURI has the same origin as aBaseDocument
    */
-  static NS_HIDDEN_(PRBool) CheckSameOrigin(nsIURI *aBaseURI,
+  static NS_HIDDEN_(PRBool) CheckSameOrigin(nsIDocument *aBaseDocument,
                                             nsIURI *aTestURI);
 
   /**
@@ -382,12 +384,16 @@ public:
                                                      nsIDOMNode  **aInstanceNode);
 
   /**
-   * This function takes an instance data node, finds the type bound to it, and
-   * returns the seperated out type (integer) and namespace prefix (xsd).
+   * Returns the type bound to the given node.
+   *
+   * @param aInstanceData   An instance data node or attribute on an instance
+   *                        data node from which to retrieve type.
+   * @param aType           On return, type of given node.
+   * @param aNSUri          On return, namespace URI of aType.
    */
   static NS_HIDDEN_(nsresult) ParseTypeFromNode(nsIDOMNode *aInstanceData,
                                                 nsAString  &aType,
-                                                nsAString  &aNSPrefix);
+                                                nsAString  &aNSUri);
 
   /**
    * Outputs to the JavaScript console.
@@ -448,6 +454,60 @@ public:
                                              const PRBool      aOnlyXForms,
                                              nsIDOMElement    *aCaller,
                                              nsIDOMElement   **aElement);
+
+
+  /**
+   * Shows an error dialog for the user the first time an
+   * xforms-binding-exception event is received by the control.
+   *
+   * The dialog can be disabled via the |xforms.disablePopup| preference.
+   *
+   * @param aElement         Element the exception occured at
+   * @return                 Whether handling was successful
+   */
+  static PRBool HandleBindingException(nsIDOMElement *aElement);
+
+  /**
+   * Returns whether the given NamedNodeMaps of Entities are equal
+   *
+   */
+  static NS_HIDDEN_(PRBool) AreEntitiesEqual(nsIDOMNamedNodeMap *aEntities1,
+                                             nsIDOMNamedNodeMap *aEntities2);
+
+  /**
+   * Returns whether the given NamedNodeMaps of Notations are equal
+   *
+   */
+  static NS_HIDDEN_(PRBool) AreNotationsEqual(nsIDOMNamedNodeMap *aNotations1,
+                                              nsIDOMNamedNodeMap *aNotations2);
+
+  /**
+   * Returns whether the given nodes are equal as described in the isEqualNode
+   * function defined in the DOM Level 3 Core spec.
+   * http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/DOM3-Core.html#core-Node3-isEqualNode
+   *
+   * XXX: this is just temporary until isEqualNode is implemented in Mozilla
+   * (https://bugzilla.mozilla.org/show_bug.cgi?id=159167)
+   *
+   * @param aFirstNode          The first node to compare
+   * @param aSecondNode         The second node to compare
+   * @param aAlreadyNormalized  Whether the two nodes and their children, etc.
+   *                            have already been normalized to allow for
+   *                            more accurate child node comparisons, as
+   *                            recommended in the DOM Level 3 Core spec.
+   */
+  static NS_HIDDEN_(PRBool) AreNodesEqual(nsIDOMNode *aFirstNode,
+                                          nsIDOMNode *aSecondNode,
+                                          PRBool      aAlreadyNormalized = PR_FALSE);
+
+  /**
+   * Retrieve the window object from the given document
+   *
+   * @param aDoc              The document to get window object from
+   * @param aWindow           The found window object
+   */
+  static NS_HIDDEN_(nsresult) GetWindowFromDocument(nsIDOMDocument        *aDoc,
+                                                    nsIDOMWindowInternal **aWindow);
 };
 
 #endif
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsXPathParser.cpp mozilla.new/extensions/xforms/nsXFormsXPathParser.cpp
--- mozilla/extensions/xforms/nsXFormsXPathParser.cpp	2005-04-28 09:17:49.000000000 +0200
+++ mozilla.new/extensions/xforms/nsXFormsXPathParser.cpp	2006-02-14 10:01:13.000000000 +0100
@@ -584,6 +584,8 @@ nsXFormsXPathParser::PopToken()
   if (mPeek == nsXFormsXPathScanner::WHITESPACE) { // Skip whitespaces
     mPeek = mScanner.NextToken();
   }
+  NS_WARN_IF_FALSE(mPeek != nsXFormsXPathScanner::ERRORXPATHTOKEN,
+                   "Scanner returned ERROR token!");
   return temp;
 }
 
diff -uprN --exclude=CVS mozilla/extensions/xforms/nsXFormsXPathScanner.cpp mozilla.new/extensions/xforms/nsXFormsXPathScanner.cpp
--- mozilla/extensions/xforms/nsXFormsXPathScanner.cpp	2005-02-24 17:18:46.000000000 +0100
+++ mozilla.new/extensions/xforms/nsXFormsXPathScanner.cpp	2006-02-14 10:01:13.000000000 +0100
@@ -363,29 +363,29 @@ nsXFormsXPathScanner::ScanQName()
     second = ScanNCName();
   }
 
-  nsDependentSubstring image = Substring(mExpression, Offset());
+  nsDependentSubstring image = Substring(mExpression, Offset() + 1);
 
   if (SolveDiambiguate()) {
-    if (StringBeginsWith(image, NS_LITERAL_STRING(" and")))
+    if (StringBeginsWith(image, NS_LITERAL_STRING("and")))
       return AND;
-    else if (StringBeginsWith(image, NS_LITERAL_STRING(" or")))
+    if (StringBeginsWith(image, NS_LITERAL_STRING("or")))
       return OR;
-    else if (StringBeginsWith(image, NS_LITERAL_STRING(" mod")))
+    if (StringBeginsWith(image, NS_LITERAL_STRING("mod")))
       return MOD;
-    else if (StringBeginsWith(image, NS_LITERAL_STRING(" div")))
+    if (StringBeginsWith(image, NS_LITERAL_STRING("div")))
       return DIV;
     return ERRORXPATHTOKEN;
   }
 
   PRUnichar c = NextNonWhite();
   if (c == '(') {
-    if (StringBeginsWith(image, NS_LITERAL_STRING(" comment")))
+    if (StringBeginsWith(image, NS_LITERAL_STRING("comment")))
       return COMMENT;
-    else if (StringBeginsWith(image, NS_LITERAL_STRING(" text")))
+    if (StringBeginsWith(image, NS_LITERAL_STRING("text")))
       return TEXT;
-    else if (StringBeginsWith(image, NS_LITERAL_STRING(" processing-instruction")))
+    if (StringBeginsWith(image, NS_LITERAL_STRING("processing-instruction")))
       return PI;
-    else if (StringBeginsWith(image, NS_LITERAL_STRING(" node")))
+    if (StringBeginsWith(image, NS_LITERAL_STRING("node")))
       return NODE;
 
     return FUNCTIONNAME;
@@ -393,32 +393,33 @@ nsXFormsXPathScanner::ScanQName()
 
   PRInt32 of = GetOffsetForNonWhite();
   if (PeekChar(of) == ':' && PeekChar(of + 1) == ':') {
-    if (StringBeginsWith(image, NS_LITERAL_STRING(" ancestor")))
+    if (StringBeginsWith(image, NS_LITERAL_STRING("ancestor")))
       return ANCESTOR;
-    else if (StringBeginsWith(image, NS_LITERAL_STRING(" ancestor-or-self")))
+    if (StringBeginsWith(image, NS_LITERAL_STRING("ancestor-or-self")))
       return ANCESTOR_OR_SELF;
-    else if (StringBeginsWith(image, NS_LITERAL_STRING(" attribute")))
+    if (StringBeginsWith(image, NS_LITERAL_STRING("attribute")))
       return ATTRIBUTE;
-    else if (StringBeginsWith(image, NS_LITERAL_STRING(" child")))
+    if (StringBeginsWith(image, NS_LITERAL_STRING("child")))
       return CHILD;
-    else if (StringBeginsWith(image, NS_LITERAL_STRING(" descendant")))
+    if (StringBeginsWith(image, NS_LITERAL_STRING("descendant")))
       return DESCENDANT;
-    else if (StringBeginsWith(image, NS_LITERAL_STRING(" descendant-or-self")))
+    if (StringBeginsWith(image, NS_LITERAL_STRING("descendant-or-self")))
       return DESCENDANT_OR_SELF;
-    else if (StringBeginsWith(image, NS_LITERAL_STRING(" following")))
+    if (StringBeginsWith(image, NS_LITERAL_STRING("following")))
       return FOLLOWING;
-    else if (StringBeginsWith(image, NS_LITERAL_STRING(" following-sibling")))
+    if (StringBeginsWith(image, NS_LITERAL_STRING("following-sibling")))
       return FOLLOWING_SIBLING;
-    else if (StringBeginsWith(image, NS_LITERAL_STRING(" namespace")))
+    if (StringBeginsWith(image, NS_LITERAL_STRING("namespace")))
       return NAMESPACE;
-    else if (StringBeginsWith(image, NS_LITERAL_STRING(" parent")))
+    if (StringBeginsWith(image, NS_LITERAL_STRING("parent")))
       return PARENT;
-    else if (StringBeginsWith(image, NS_LITERAL_STRING(" preceding")))
+    if (StringBeginsWith(image, NS_LITERAL_STRING("preceding")))
       return PRECEDING;
-    else if (StringBeginsWith(image, NS_LITERAL_STRING(" preceding-sibling")))
+    if (StringBeginsWith(image, NS_LITERAL_STRING("preceding-sibling")))
       return PRECEDING_SIBLING;
-    else if (StringBeginsWith(image, NS_LITERAL_STRING(" self")))
+    if (StringBeginsWith(image, NS_LITERAL_STRING("self")))
       return SELF;
+
     return ERRORXPATHTOKEN;
   }
   return second != NONE ? QNAME : NCNAME;
diff -uprN --exclude=CVS mozilla/extensions/xforms/resources/content/bindingex.xul mozilla.new/extensions/xforms/resources/content/bindingex.xul
--- mozilla/extensions/xforms/resources/content/bindingex.xul	2005-10-04 20:28:26.000000000 +0200
+++ mozilla.new/extensions/xforms/resources/content/bindingex.xul	2006-02-14 10:01:13.000000000 +0100
@@ -43,7 +43,22 @@
         title="&xforms.bindingdialog.title;"
         buttons="accept"
         xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
-        onload="document.getElementById('XFormsBindingDialog').getButton('accept').focus();">
+        onload="document.documentElement.getButton('accept').focus();">
+
+  <script type="application/x-javascript">
+    function toJSConsole() {
+      var js = Components.classes["@mozilla.org/appshell/window-mediator;1"]
+                         .getService(Components.interfaces.nsIWindowMediator)
+                         .getMostRecentWindow('global:console');
+      if (js)
+        js.focus();
+      else
+        Components.classes["@mozilla.org/embedcomp/window-watcher;1"]
+                  .getService(Components.interfaces.nsIWindowWatcher)
+                  .openWindow(null, "chrome://global/content/console.xul",
+                              "", "all,dialog=no", null);
+      }
+  </script>
 
   <hbox flex="1">
     <hbox align="start">
@@ -54,7 +69,7 @@
       <description class="header descr1">
         &xforms.bindingdialog.description1;
       </description>
-      <label class="descr2 text-link" onclick="open('chrome://global/content/console.xul', 'global:console', 'menubar=no,resizable=yes')">
+      <label class="descr2 text-link" onclick="toJSConsole()">
         &xforms.bindingdialog.description2;
       </label>
     </vbox>
Dateien mozilla/extensions/xforms/resources/content/calendar.png und mozilla.new/extensions/xforms/resources/content/calendar.png sind verschieden.
diff -uprN --exclude=CVS mozilla/extensions/xforms/resources/content/range.xml mozilla.new/extensions/xforms/resources/content/range.xml
--- mozilla/extensions/xforms/resources/content/range.xml	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/extensions/xforms/resources/content/range.xml	2006-02-07 16:30:12.000000000 +0100
@@ -0,0 +1,492 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- ***** BEGIN LICENSE BLOCK *****
+   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
+   -
+   - The contents of this file are subject to the Mozilla Public License Version
+   - 1.1 (the "License"); you may not use this file except in compliance with
+   - the License. You may obtain a copy of the License at
+   - http://www.mozilla.org/MPL/
+   -
+   - Software distributed under the License is distributed on an "AS IS" basis,
+   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+   - for the specific language governing rights and limitations under the
+   - License.
+   -
+   - The Original Code is Mozilla XForms support.
+   -
+   - The Initial Developer of the Original Code is
+   - Novell, Inc.
+   - Portions created by the Initial Developer are Copyright (C) 2005
+   - the Initial Developer. All Rights Reserved.
+   -
+   - Contributor(s):
+   -  Allan Beaufour <abeaufour@novell.com>
+   -
+   - Alternatively, the contents of this file may be used under the terms of
+   - either the GNU General Public License Version 2 or later (the "GPL"), or
+   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+   - in which case the provisions of the GPL or the LGPL are applicable instead
+   - of those above. If you wish to allow use of your version of this file only
+   - under the terms of either the GPL or the LGPL, and not to allow others to
+   - use your version of this file under the terms of the MPL, indicate your
+   - decision by deleting the provisions above and replace them with the notice
+   - and other provisions required by the GPL or the LGPL. If you do not delete
+   - the provisions above, a recipient may use your version of this file under
+   - the terms of any one of the MPL, the GPL or the LGPL.
+   -
+   - ***** END LICENSE BLOCK ***** -->
+
+<!--
+   ASSUMPTIONS:
+   *> @begin is valid, @end and @init value might not be
+      this means that steps and ticks are calculated with begin as starting point
+   *> Takes integers and floats
+
+   TODO: XXX
+   *> limit amount of ticks
+   *> handle undefined begin / end
+   *> handle end < begin (including negative steps)
+   *> @incremental should round if it is bound to integer
+
+   BUGS: XXX
+   *> leaves a trace behind, hor.bar gets darker, etc... fix transparency
+-->
+
+<bindings xmlns="http://www.mozilla.org/xbl"
+          xmlns:html="http://www.w3.org/1999/xhtml">
+      
+  <binding id="xformswidget-range"
+           extends="chrome://xforms/content/xforms.xml#xformswidget-base">
+    <content>
+      <children includes="label"/>
+      <html:span anonid="labelBegin" style="margin-right: 3px;"></html:span>
+      <!-- width and height set by CSS? -->
+      <html:canvas tabindex="0" anonid="canvas" width="260" height="40"
+                   onkeydown="this.parentNode.handleKey(event)"
+                   onmousedown="this.parentNode.handleMouseDown(event)"
+                   onmouseup="this.parentNode.handleMouseUp(event)"
+                   onmouseout="this.parentNode.handleMouseOut(event)"
+                   onmousemove="this.parentNode.handleMouseMove(event)">
+      </html:canvas>
+      <html:span anonid="labelEnd" style="margin-left: 3px;"> </html:span>
+      <children/>
+    </content>
+
+    <implementation implements="nsIXFormsUIWidget">
+      <!-- The "skin", should be set via CSS -->
+      <field name="strokeStyle" readonly="true">"#8f9ca4"</field>
+      <field name="strokeStyleMove" readonly="true">"red"</field>
+      <field name="fillStyle" readonly="true">"#eff3f1"</field>
+
+      <!-- Is the range initialized -->
+      <field name="isInitialized">false</field>
+
+      <!-- out of range -->
+      <field name="outOfRange">false</field>
+
+      <!-- are we currently moving the slider? -->
+      <field name="isMoving">false</field>
+
+      <!-- creates the sliderpath -->
+      <method name="sliderPath">
+        <parameter name="aPos"/>
+        <body>
+          this.ctx.beginPath();
+          var h = this.height - this.tickheight;
+          this.ctx.moveTo(aPos, h);
+          this.ctx.lineTo(aPos - this.sliderwidth, h - this.slidertip);
+          this.ctx.lineTo(aPos - this.sliderwidth, this.tickheight);
+          this.ctx.lineTo(aPos + this.sliderwidth, this.tickheight);
+          this.ctx.lineTo(aPos + this.sliderwidth, h - this.slidertip);
+          this.ctx.closePath();
+        </body>
+      </method>
+
+      <!-- creates the sliderpath -->
+      <method name="drawSlider">
+        <parameter name="aPos"/>
+        <parameter name="aMove"/>
+        <body>
+          this.ctx.save();
+
+          // do path
+          this.ctx.lineWidth = 1;
+          this.sliderPath(aPos);
+          this.ctx.strokeStyle = aMove ? this.strokeStyleMove : this.strokeStyle;
+          this.ctx.stroke();
+          this.sliderPath(aPos);
+          this.ctx.fillStyle = this.fillStyle;
+          this.ctx.fill();
+          
+          this.ctx.restore();
+        </body>
+      </method>
+
+      <!-- takes a value and calculates the x position -->
+      <method name="calcPos">
+        <parameter name="val"/>
+        <body>
+          var pos = val - this.rBegin;
+          if (this.rStep) {
+            pos = (pos / this.rStep) * this.stepsp;
+          } else {
+            pos = (pos / (this.rEnd - this.rBegin)) * this.barwidth;
+          }
+          return Math.round(pos) + this.margin;
+        </body>
+      </method>
+
+      <!-- sets the slider to a new value -->
+      <method name="setSlider">
+        <!-- The new value -->
+        <parameter name="aVal"/>
+        <!-- The mode:
+             - move: just moving the slider around, not setting the value
+
+             - set: enforce slider position from instance data,
+                    ie. do not correct it to fit a step, etc.
+
+             - [default]: set the slider to the given value, adjusting it
+                          to fit inside the allowed range
+        -->
+        <parameter name="aMode"/>
+
+        <body>
+          <![CDATA[
+
+          aVal = parseFloat(aVal);
+          if (aMode != "set" && isNaN(aVal)) {
+            return this.delegate.reportError("rangeSetSliderNaN");
+          }
+
+          var outOfRange = false;
+          if (aMode != "move") {
+            if (aMode == "set" && 
+                (isNaN(aVal) || aVal > this.adjEnd || aVal < this.rBegin)) {
+              outOfRange = true;
+            } else {
+              if (this.rStep) {
+                // adjust aVal to limits
+                valmod = (aVal - this.rBegin) % this.rStep;
+                if (valmod) {
+                  if (aMode == "set") {
+                    outOfRange = true;
+                  } else if (valmod < (this.rStep / 2)) {
+                    aVal -= valmod;
+                  } else {
+                    aVal += this.rStep - valmod;
+                  }
+                }
+              }
+              if (aVal > this.adjEnd) {
+                aVal = this.adjEnd;
+              } else if (aVal < this.rBegin) {
+                aVal = this.rBegin;
+              }
+            }
+          }
+
+          if (!outOfRange && (aMode != "move" || this.isIncremental)) {
+            // Store new value
+            this.accessors.setValue(aVal);
+          }
+
+          if (this.rVal == aVal && !this.justMoved) {
+            // slider is already drawn at correct position
+            return;
+          }
+
+          this.ctx.save();
+
+          // clear old slider
+          this.ctx.clearRect(this.calcPos(this.rVal) - this.sliderwidth - 1, this.tickheight - 1,
+                             this.sliderwidth * 2 + 2, this.tickheight * 3 + 2);
+
+          // (re)draw horisontal bar
+          this.ctx.lineWidth = 1;
+          this.ctx.fillStyle = this.fillStyle;
+          this.ctx.strokeStyle = this.strokeStyle;
+          mid = Math.round(this.height / 2);
+          // XXX only needs to be redrawn for old slider pos
+          this.ctx.fillRect(this.margin, mid - 1, this.barwidth, 3);
+          this.ctx.strokeRect(this.margin, mid - 1, this.barwidth, 3);
+
+          // check whether out-of-range state has changed, and dispatch event if it has
+          if (outOfRange != this.outOfRange) {
+            // XXX we need to set the style too
+            this.outOfRange = outOfRange;
+            var event = outOfRange ? "xforms-out-of-range" : "xforms-in-range";
+            this.dispatchXFormsNotificationEvent(event, this);
+          }
+
+          // if out-of-range, we cannot represent the value
+          if (outOfRange) {
+            this.rVal = null;
+            return null;
+          }
+
+          // draw slider at new position
+          this.justMoved = (aMode == "move");
+          this.drawSlider(this.calcPos(aVal), this.justMoved);
+
+          this.ctx.restore();
+
+          // Store new value
+          return this.rVal = aVal;
+          ]]>
+        </body>
+      </method>
+
+      <!-- get x,y offset for mouse events -->
+      <method name="getOffset">
+        <parameter name="event"/>
+        <body>
+          var obj;
+          if (document.getBoxObjectFor) {
+            obj = document.getBoxObjectFor(this.canvas);
+          } else {
+            obj = { x: event.target.offsetLeft, y: event.target.offsetTop };
+          }
+          return obj;
+        </body>
+      </method>
+
+      <!-- calculate slider position from mouse position -->
+      <method name="calcMousePos">
+        <parameter name="obj"/>
+        <parameter name="x"/>
+        <body>
+          x -= obj.margin;
+          if (obj.rStep) {
+            x = (x / obj.stepsp) * obj.rStep;
+          } else {
+            x = (x / this.barwidth) * (this.rEnd - this.rBegin);
+          }
+          return x + obj.rBegin;  
+        </body>
+      </method>
+
+      <!-- handle mouse down -->
+      <method name="handleMouseDown">
+        <parameter name="event"/>
+        <body>
+          <![CDATA[
+          if (event.button == 0) {
+            this.currentOffset = this.getOffset(event);
+            this.originalVal = this.rVal;
+            this.isMoving = true;
+            var xpos = event.clientX - this.currentOffset.x;
+            if (xpos < this.margin) {
+              xpos = this.margin;
+            }
+            if (xpos > (this.barwidth + this.margin)) {
+              xpos = this.barwidth;
+            }
+            this.setSlider(this.calcMousePos(this, xpos), "move");
+            return;
+          }
+          ]]>
+        </body>
+      </method>
+
+      <!-- handle mouse up -->
+      <method name="handleMouseUp">
+        <parameter name="event"/>
+        <body>
+          if (event.button != 0 || !this.isMoving) {
+            return;
+          }
+          var x = event.clientX - this.currentOffset.x;
+          this.setSlider(this.calcMousePos(this, x));
+          this.isMoving = false;
+        </body>
+      </method>
+
+      <!-- handle mouse moves -->
+      <method name="handleMouseMove">
+        <parameter name="event"/>
+        <body>
+          <![CDATA[
+          if (!this.isMoving) {
+            return;
+          }
+          var xpos = event.clientX - this.currentOffset.x;
+          if (xpos < this.margin) {
+            xpos = this.margin;
+          }
+          if (xpos > (this.barwidth + this.margin)) {
+            xpos = this.barwidth + this.margin;
+          }
+          this.setSlider(this.calcMousePos(this, xpos), "move");
+          ]]>
+        </body>
+      </method>
+
+      <!-- handle mouse out -->
+      <method name="handleMouseOut">
+        <parameter name="event"/>
+        <body>
+          if (!this.isMoving) {
+            return;
+          }
+          this.isMoving = false;
+          this.setSlider(this.originalVal);
+        </body>
+      </method>
+
+      <method name="handleKey">
+        <parameter name="event"/>
+        <body>
+          var move;
+          if (this.rStep) {
+            move = this.rStep;
+          } else {
+            move = (this.rEnd - this.rBegin) / 20;
+          }
+
+          if (event.keyCode == event.DOM_VK_LEFT) {
+            this.setSlider(this.rVal - move);
+          } else if (event.keyCode == event.DOM_VK_RIGHT) {
+            this.setSlider(this.rVal + move);
+          } else if (event.keyCode == event.DOM_VK_PAGE_DOWN) {
+            this.setSlider(this.rVal - move * 2);
+          } else if (event.keyCode == event.DOM_VK_PAGE_UP) {
+            this.setSlider(this.rVal + move * 2);
+          } else if (event.keyCode == event.DOM_VK_HOME) {
+            this.setSlider(this.rBegin);
+          } else if (event.keyCode == event.DOM_VK_END) {
+            this.setSlider(this.rEnd);
+          }
+        </body>
+      </method>
+
+      <method name="refresh">
+        <body>
+          <![CDATA[
+          if (!this.isInitialized) {
+            if (!this.delegate) {
+              return;
+            }
+            var labelBegin = document.getAnonymousElementByAttribute(this, "anonid", "labelBegin");
+            var labelEnd = document.getAnonymousElementByAttribute(this, "anonid", "labelEnd");
+            var canvas = document.getAnonymousElementByAttribute(this, "anonid", "canvas");
+            this.isInitialized = this.createRange(canvas, labelBegin, labelEnd,
+                                                  this.accessors.getRangeStart(),
+                                                  this.accessors.getRangeEnd(),
+                                                  this.accessors.getRangeStep());
+          }
+
+          // XXX: does not clear range if bound node "disappears"
+          if (this.isInitialized && this.accessors.hasBoundNode()) {
+            this.setSlider(this.accessors.getValue(), "set");
+          }
+          ]]>
+        </body>
+      </method>
+
+      <method name="focus">
+        <body>
+          this.canvas.focus();
+          return true;
+        </body>
+      </method>
+
+      <!-- create new range object -->
+      <method name="createRange">
+        <parameter name="aCanvas"/>
+        <parameter name="aLabelBegin"/>
+        <parameter name="aLabelEnd"/>
+        <parameter name="aBegin"/>
+        <parameter name="aEnd"/>
+        <parameter name="aStep"/>
+        <body>
+          <![CDATA[
+          if (!(aCanvas && aLabelBegin && aLabelEnd)) {
+            this.delegate.reportError("rangeNullObjects");
+            return false;
+          }
+
+          this.rBegin = parseFloat(aBegin);
+          this.rEnd = parseFloat(aEnd);
+          this.rStep = parseFloat(aStep);
+          this.rVal = this.rBegin;
+          this.isIncremental = this.getAttribute("incremental") == "true";
+          this.justMoved = false;
+
+          if (isNaN(this.rBegin) || isNaN(this.rEnd)) {
+            this.delegate.reportError("rangeNullInit");
+            return false;
+          }
+
+          // XXX should we handle this?
+          if (this.rBegin >= this.rEnd) {
+            this.delegate.reportError("rangeBeginEndError");
+            return false;
+          }
+
+          if (isNaN(this.rStep)) {
+            this.rStep = null;
+          } else if (this.rStep < 0) {
+            // XXX better handling
+            this.rStep = -this.rStep;
+          }
+
+          // set labels
+          aLabelBegin.appendChild(document.createTextNode(this.rBegin));
+          aLabelEnd.appendChild(document.createTextNode(this.rEnd));
+
+          // get canvas
+          this.canvas = aCanvas;
+          this.height = this.canvas.height;
+
+          // get and set context
+          this.ctx = this.canvas.getContext("2d");
+          this.ctx.globalAlpha = 1.0;
+          this.ctx.lineWidth = 1;
+
+          // size of horisontal bar
+          this.margin = Math.round(this.canvas.width / 45);
+          if (this.margin < 4) {
+            this.margin = 4;
+          }
+          this.barwidth = this.canvas.width - (2 * this.margin);
+
+          // slider size
+          this.sliderwidth = this.margin - 1;
+          if (this.sliderwidth < 4) {
+            this.sliderwidth = 4;
+          }
+          this.slidertip = Math.round(this.height / 10);
+          this.tickheight = this.slidertip * 2;
+
+          if (!this.rStep) {
+            this.adjEnd = this.rEnd;
+            return true;
+          }
+
+          // begin and end might not be a step
+          this.adjEnd = this.rEnd - ((this.rEnd - this.rBegin) % this.rStep);
+          this.steps  = (this.adjEnd - this.rBegin) / this.rStep;
+          this.stepsp = (this.barwidth * (this.adjEnd / this.rEnd)) / this.steps;
+          this.width = this.steps * this.stepsp;
+
+          // ticks (== steps for the moment)
+          this.ticks = this.steps;
+          this.ticksp = this.stepsp;
+
+          for (var i = 0; i <= this.ticks; ++i) {
+            var pos = Math.round(this.margin + i * this.ticksp);
+            this.ctx.moveTo(pos, this.height - this.tickheight + 1);
+            this.ctx.lineTo(pos, this.height);
+            this.ctx.closePath();
+            this.ctx.stroke();
+          }
+
+
+          return true;
+          ]]>
+        </body>
+      </method>
+    </implementation>
+  </binding>
+</bindings>
diff -uprN --exclude=CVS mozilla/extensions/xforms/resources/content/select1.xml mozilla.new/extensions/xforms/resources/content/select1.xml
--- mozilla/extensions/xforms/resources/content/select1.xml	2005-10-25 20:23:25.000000000 +0200
+++ mozilla.new/extensions/xforms/resources/content/select1.xml	2006-02-24 11:16:25.000000000 +0100
@@ -62,12 +62,13 @@
                  anonid="container"><html:input
                  class="-moz-xforms-select1-input"
                  anonid="control"
+                 xbl:inherits="accesskey"
                  onfocus="this.parentNode.parentNode.dispatchDOMUIEvent('DOMFocusIn')"
                  onblur="this.parentNode.parentNode.handleBlur(); this.parentNode.parentNode.dispatchDOMUIEvent('DOMFocusOut');"
                  onclick="this.parentNode.parentNode.handleControlClick();"
                  onkeypress="this.parentNode.parentNode.handleKeyPress(event);"
                  onkeyup="this.parentNode.parentNode.handleKeyUp(event);"
-      /><html:input class="-moz-xforms-select1-dropdown"
+      /><html:input class="-moz-xforms-select1-dropdown xf-value"
                     type="button"
                     anonid="dropmarker"
                     tabindex="-1"
@@ -87,6 +88,7 @@
       <!-- This is either an nsIXFormsItemElement or null. -->
       <field name="_selected">null</field>
       <field name="_tmpSelected">null</field>
+      <field name="_lastSelectedItem">null</field>
       <field name="popupOpen">false</field>
       <field name="shouldHandleBlur">true</field>
 
@@ -153,7 +155,7 @@
           <![CDATA[
           if (this.selectionOpen && !this._selected) {
             if (this.getAttribute("incremental") != "false") {
-              this.delegate.value = this.inputField.value;
+              this._handleSelection();
             }
           } else {
             this.togglePopup();
@@ -172,7 +174,26 @@
               this.togglePopup();
               if (open && this._selected) {
                 this.updateInputField();
-                this.delegate.value = this._selected.value;
+                this._handleSelection();
+
+                // need to keep the xforms-select and xforms-deselect event
+                // dispatching after _handleSelection.  That function might
+                // deselect this._selected if this user selected item is a
+                // copyItem bound to a non-element node.  We don't want to
+                // dispatch a xforms-select/deselect in that case since it
+                // really isn't considered to be a valid selection to begin with
+                // (causes a xforms-binding-exception).
+                if (this._lastSelectedItem != this._selected) {
+                  if (this._lastSelectedItem) {
+                    this.dispatchSelectEvent(this._lastSelectedItem, "xforms-deselect");
+                  }
+  
+                  if (this._selected) {
+                    this.dispatchSelectEvent(this._selected, "xforms-select");
+                  }
+  
+                  this._lastSelectedItem = this._selected;
+                }
               }
             } else if (key == aEvent.DOM_VK_UP ||
                        key == aEvent.DOM_VK_DOWN) {
@@ -187,9 +208,26 @@
               if (!this.popupOpen && this.getAttribute("incremental") != "false") {
                 if (this._selected) {
                   this.updateInputField();
-                  this.delegate.value = this._selected.value;
-                } else if (this.selectionOpen) {
-                  this.delegate.value = this.inputField.value;
+                }
+                this._handleSelection();
+
+                // need to keep the xforms-select and xforms-deselect event
+                // dispatching after _handleSelection.  That function might
+                // deselect this._selected if the selected item is a copyItem
+                // bound to a non-element node.  We don't want to dispatch a
+                // xforms-select/deselect in that case since it really isn't
+                // considered to be a valid selection to begin with (causes
+                // a xforms-binding-exception).
+                if (this._lastSelectedItem != this._selected) {
+                  if (this._lastSelectedItem) {
+                    this.dispatchSelectEvent(this._lastSelectedItem, "xforms-deselect");
+                  }
+  
+                  if (this._selected) {
+                    this.dispatchSelectEvent(this._selected, "xforms-select");
+                  }
+  
+                  this._lastSelectedItem = this._selected;
                 }
               }
             } else if (key == aEvent.DOM_VK_TAB) {
@@ -231,7 +269,7 @@
                 this._selected = null;
               }
               if (this.getAttribute("incremental") != "false") {
-                this.delegate.value = this.inputField.value;
+                this._handleSelection();
               }
             }
 
@@ -323,7 +361,7 @@
         <body>
           <![CDATA[
             var label = null;
-            var next = null;
+            var next = null, nextItem = null;
             var node = this.firstChild;
             while (node) {
               if (node.namespaceURI == this.XFORMS_NS &&
@@ -345,12 +383,14 @@
             next = this.findNextSelectable(node, aDown);
             if (next) {
               if (this._selected) {
+                this._lastSelected = this._selected;
                 this._selected.setActive(false);
                 this._selected = null;
               }
 
-              this._selected = next.QueryInterface(Components.interfaces.nsIXFormsItemElement);
-              if (this._selected) {
+              nextItem = next.QueryInterface(Components.interfaces.nsIXFormsItemElement);
+              if (nextItem) {
+                this._selected = nextItem;
                 this._selected.setActive(true);
                 this.updateInputField();
               }
@@ -391,8 +431,26 @@
 
             if (this._selected) {
               this.updateInputField();
-              this.delegate.value =
-                this._selected.value;
+              this._handleSelection();
+
+              // need to keep the xforms-select and xforms-deselect event
+              // dispatching after _handleSelection.  That function might
+              // deselect this._selected if the selected item is a copyItem
+              // bound to a non-element node.  We don't want to dispatch a
+              // xforms-select/deselect in that case since it really isn't
+              // considered to be a valid selection to begin with (causes
+              // a xforms-binding-exception).
+              if (this._lastSelectedItem != this._selected) {
+                if (this._lastSelectedItem) {
+                  this.dispatchSelectEvent(this._lastSelectedItem, "xforms-deselect");
+                }
+
+                if (this._selected) {
+                  this.dispatchSelectEvent(this._selected, "xforms-select");
+                }
+
+                this._lastSelectedItem = this._selected;
+              }
             }
             this.inputField.focus();
           ]]>
@@ -461,7 +519,7 @@
       <method name="togglePopup">
         <body>
           <![CDATA[
-          if (!this.popupOpen && !this.delegate.isReadonly) {
+          if (!this.popupOpen && !this.accessors.isReadonly()) {
             // Calculating the size and position of the popup.
             var style = "";
             var containerBox = document.getBoxObjectFor(this.container);
@@ -545,27 +603,112 @@
         <body>
           <![CDATA[
           try {
-            var newValue = this.stringValue;
+            var nodeValue = null, newValue = null;
+            var boundNode = this.accessors.getBoundNode();
+            var outOfRange = false;
+            if (boundNode && boundNode.hasChildNodes()) {
+              // Since this is a select1, there should normally be just one
+              // child node here.  But no guarantee that a select1 generated
+              // the value coming in.  So we'll look for text node with 
+              // non-whitespace characters to compare with an item's xf:value.
+              // Any other node that we encounter we look to match with an
+              // item's xf:copy.  If more than one of either of these exists
+              // in the instance data, we need to generate a xforms-out-of-range
+              // event and style the select1 as out-of-range since by
+              // definition a select1 can not select more than one item.
+              var child = boundNode.firstChild;
+              while (child) {
+                var type = child.nodeType;
+                if (type == Node.TEXT_NODE) {
+                  // if child is a text node completely filled with
+                  // whitespace let's ignore it and get the next node
+                  var string = child.nodeValue;
+                  var nonWhitespace = false;
+                  if (string) {
+                    // this regexp tests whether only whitespace is contained
+                    // between the beginning and ending of the string.
+                    nonWhitespace = !(/^\s*$/.test(string));
+                  }
+                  if (nonWhitespace) {
+                    if (newValue || nodeValue) {
+                      // oh oh!  We've already found a selectable node in the
+                      // instance data and now we have another.  That shouldn't
+                      // happen.
+                      // XXX generate xforms-out-of-range exception and style
+                      // control as out-of-range
+                      outOfRange = true;
+                    }
+                    newValue = string;
+                  }
+                } else {
+                  // if it's not a text node, we'll assume that we are looking at
+                  // a node worth comparing.  As such, look for an
+                  // item with a copy element that might match this node.
+                  if (newValue || nodeValue) {
+                      // oh oh!  We've already found a selectable node in the
+                      // instance data and now we have another.  That shouldn't
+                      // happen.
+                    // XXX generate xforms-out-of-range exception and style
+                    // control as out-of-range
+                    outOfRange = true;
+                  }
+                  nodeValue = child;
+                }
+
+                if (child == boundNode.lastChild) {
+                  break;
+                }
+                child = child.nextSibling;
+              }
+            }
 
-            if (!this.selectionOpen || this.delegate.isReadonly) {
+            if (outOfRange) {
+              // can't possibly work, no sense continuing.
+              this.inputField.value = "";
+              this._selected.setActive(false);
+              this._selected = null;
+              return false;
+            }
+
+            if (!this.selectionOpen || this.accessors.isReadonly()) {
               this.inputField.setAttribute("readonly", "readonly");
             } else {
               this.inputField.removeAttribute("readonly");
             }
 
-            if (this._selected) {
-              if (newValue ==
-                  this._selected.value) {
-                return true;
+            if (this._selected && !this._selected.isCopyItem) {
+              var envelope = this._getSelectedValue();
+              if (envelope) {
+                var textNode = null;
+                if (envelope.nodeType == Node.ELEMENT_NODE) {
+                  textNode = envelope.firstChild;
+                  if (newValue == textNode.nodeValue) {
+                    // value in instance data already selected.  Nothin' left
+                    // to do.
+                    return true;
+                  }
+                } else {
+                  if (newValue == contentEnvelope.nodeValue) {
+                    // value in instance data already selected.  Nothin' left
+                    // to do.
+                    return true;
+                  }
+                }
               }
               this._selected.setActive(false);
               this._selected = null;
+              this._lastSelectedItem = null;
             }
 
-            this.selectItemByValue(newValue);
+            if (newValue) {
+              this.selectItemByValue(newValue);
+            } else if (nodeValue) {
+              this.selectItemByNode(nodeValue);
+            }
             
             if (this._selected) {
               this.updateInputField();
+              this._lastSelectedItem = this._selected;
             } else if (this.selectionOpen) {
               this.inputField.value = newValue;
             } else {
@@ -596,7 +739,8 @@
             item = null;
             try {
               if (node.nodeType == document.ELEMENT_NODE &&
-                  node.namespaceURI == this.XFORMS_NS && node.localName != "label") {
+                  node.namespaceURI == this.XFORMS_NS &&
+                  node.localName != "label") {
 
                 item = node.QueryInterface(Components.interfaces.nsIXFormsSelectChild);
                 if (item) {
@@ -621,6 +765,45 @@
         </body>
       </method>
 
+      <method name="selectItemByNode">
+        <parameter name="aNode"/>
+        <body>
+          <![CDATA[
+
+          // select the copyItem in this select1 whose copyNode equals aNode
+
+          var node = this.firstChild;
+          var item;
+          while (node) {
+            item = null;
+            try {
+              if (node.nodeType == document.ELEMENT_NODE &&
+                  node.namespaceURI == this.XFORMS_NS &&
+                  node.localName != "label") {
+
+                item = node.QueryInterface(Components.interfaces.nsIXFormsSelectChild);
+                if (item) {
+                  item = item.selectItemByNode(aNode);
+                  if (item) {
+                    if (this._selected) {
+                      this._selected.setActive(false);
+                      this._selected = null;
+                    }
+                    this._selected = item.QueryInterface(Components.interfaces.nsIXFormsItemElement);
+                    if (this._selected) {
+                      this._selected.setActive(true);
+                      return;
+                    }
+                  }
+                }
+              }
+            } catch (ex) {}
+            node = node.nextSibling;
+          }
+          ]]>
+        </body>
+      </method>
+
       <method name="handleBlur">
         <body>
           <![CDATA[
@@ -640,16 +823,169 @@
               return;
             }
 
-            if (this.selectionOpen && !this._selected) {
-              this.delegate.value = this.inputField.value;
-            } else if (this._selected) {
+            if (this._selected) {
               this.updateInputField();
-              this.delegate.value = this._selected.value;
             }
+
+            this._handleSelection(true);
+          }
+          ]]>
+        </body>
+      </method>
+
+      <!-- _handleSelection updates the bound node with the value from the
+            currently selected item's value element or copy element. -->
+      <method name="_handleSelection">
+        <parameter name="aInBlur"/>
+        <body>
+          <![CDATA[
+          var boundNode = this.accessors.getBoundNode();
+          if (!boundNode) {
+            return;
+          }
+
+          if (this.selectionOpen && !this._selected) {
+            this.accessors.setValue(this.inputField.value);
+            return;
+          }
+
+          if (!this._selected) {
+            // no reason to continue
+            return;
+          }
+
+          if (aInBlur && aInBlur == true) {
+            // if _handleSelection is called due to a blur, we only really care
+            // about making sure the bound node is in sync if @incremental is
+            // false.  Otherwise the bound node is already up to date so might
+            // as well return.
+            if (this.getAttribute("incremental") != "false") {
+              return;
+            }
+          }
+
+          if (boundNode.nodeType != boundNode.ELEMENT_NODE) {
+            // if the boundNode type isn't an ELEMENT_NODE, then contentEnvelope
+            // isn't an ELEMENT_NODE (since it is a clone of the bound node).
+            // So if contentEnvelope has a value, it will be the nodeValue.
+            var envelope = this._getSelectedValue();
+            if (envelope) {
+              this.accessors.setValue(envelope.nodeValue);
+              return;
+            }
+
+            // not allowed to copy a node under a non ELEMENT node, so
+            // generating a binding exception per spec.
+            var ev = document.createEvent("Events");
+            ev.initEvent("xforms-binding-exception", true, false);
+            this.dispatchEvent(ev);
+
+            // well, whatever we had selected isn't going to cut it.  But the
+            // user did choose to deselect the previous item in favor of this
+            // this item, so we really shouldn't go back to what
+            // was there before.  So we'll go to nothing.  Make sure bound
+            // node reflects this.  Seems to be consistent with what Novell
+            // and formsPlayer does, too.
+            this._selected.setActive(false);
+            this._selected = null;
+            this.inputField.value = "";
+            this.accessors.setValue("");
+            return;
+          }
+
+          var contentEnvelope = this._getSelectedValue();
+          var copyInvolved = this._selected.isCopyItem;
+          if (!copyInvolved && this._lastSelectedItem) {
+            copyInvolved = this._lastSelectedItem.isCopyItem;
+          }
+          if (!copyInvolved) {
+            // Since we aren't selecting a copyItem nor causing a copyItem to
+            // be deselected, no sense using setContent.  Too expensive.
+            this.accessors.setValue(contentEnvelope.textContent);
+          } else {
+            this.accessors.setContent(contentEnvelope, true);
+          }
+
           }
           ]]>
         </body>
       </method>
+
+      <method name="dispatchSelectEvent">
+        <parameter name="aElement"/>
+        <parameter name="aName"/>
+        <body>
+          var ev = document.createEvent("Events");
+          ev.initEvent(aName, true, false);
+
+          var elm = aElement;
+
+          // per http://www.w3.org/TR/2005/PER-xforms-20051006/index-all.html#evt-select
+          // we send the event to the itemset if it is a parent.
+          if (elm.parentNode.localName == "itemset")
+            elm = elm.parentNode;
+
+          elm.dispatchEvent(ev);
+          return true;
+        </body>
+      </method>
+
+      <method name="_getSelectedValue">
+        <body>
+        <![CDATA[
+          // The purpose of this function is to return the select1's currently
+          // selected item's value in a contentEnvelope.  It achieves this by
+          // cloning the bound node to create the contentEnvelope which will be
+          // returned.  If the contentEnvelope is an element node, the contents
+          // of the selected item's value will be inserted as a child of the
+          // contentEnvelope.  If it is a textnode, the selected item value will
+          // be put in the contentEnvelope.nodeValue.
+
+          if (!this._selected) {
+            // this will probably only happen if there was an exception
+            // somewhere else first.  But no sense continuing below and adding
+            // more exceptions to the console.
+            return null;
+          }
+
+          var boundNode = this.accessors.getBoundNode();
+          if (!boundNode)  {
+            return;
+          }
+
+          var contentEnvelope = boundNode.cloneNode(false);
+          if (!contentEnvelope) {
+            return null;
+          }
+
+          if (contentEnvelope.nodeType == Node.ELEMENT_NODE) { 
+            var contentNode = null;
+            if (this._selected.isCopyItem) {
+              var copyNode = this._selected.copyNode;
+              if (copyNode) {
+                contentNode = copyNode.cloneNode(true);
+              }
+            } else {
+              contentNode = document.createTextNode(this._selected.value);
+            }
+
+            contentEnvelope.appendChild(contentNode);
+          } else {
+            // if the selected item is not a copyItem, then we'll just put the
+            // item's value in the nodeValue for the contentEnvelope.  Otherwise
+            // we are stuck trying to stick an element node under a non-element
+            // node and that ainna gonna work.
+            if (!this._selected.isCopyItem) {
+              contentEnvelope.nodeValue = this._selected.value;
+            } else {
+              contentEnvelope = null;
+            }
+          }
+
+          return contentEnvelope;
+        ]]>
+        </body>
+      </method>
     </implementation>
   </binding>
 
diff -uprN --exclude=CVS mozilla/extensions/xforms/resources/content/select.xml mozilla.new/extensions/xforms/resources/content/select.xml
--- mozilla/extensions/xforms/resources/content/select.xml	2005-10-25 20:23:25.000000000 +0200
+++ mozilla.new/extensions/xforms/resources/content/select.xml	2006-02-24 11:16:25.000000000 +0100
@@ -82,7 +82,8 @@
         <html:span>
            <children includes="label"/>
         </html:span>
-        <html:select xbl:inherits="style"
+        <html:select xbl:inherits="style, accesskey"
+                     class="xf-value"
                      onchange="this.parentNode.parentNode.selectionChanged();"
                      onfocus="this.parentNode.parentNode.dispatchDOMUIEvent('DOMFocusIn');"
                      onblur="this.parentNode.parentNode.handleBlur(); this.parentNode.parentNode.dispatchDOMUIEvent('DOMFocusOut');"
@@ -117,7 +118,7 @@
         </setter>
       </property>
 
-      <field name="_delegateValueCache">null</field>
+      <field name="_accessorValueCache">null</field>
 
       <field name="_refreshing">false</field>
       <method name="refresh">
@@ -128,33 +129,57 @@
           if (this._refreshing)
             return;
 
-          if (this.delegate.isReadonly) {
+          if (this.accessors.isReadonly()) {
             this.uiElement.setAttribute("readonly", "readonly");
           } else {
             this.uiElement.removeAttribute("readonly");
           }
 
-          if (!this.delegate.hasBoundNode)
-            return;
-
           this._refreshing = true;
 
+          // if this node contains a non TEXT node, then we have to throw
+          // the 'just string values' logic out the window
+          var boundNode = this.accessors.getBoundNode();
+          var containsNonText = false;
+          if (boundNode && boundNode.hasChildNodes()) {
+            var child = boundNode.firstChild;
+            while (child) {
+              var type = child.nodeType;
+              if (type != Node.TEXT_NODE && type != Node.CDATA_SECTION_NODE) {
+                containsNonText = true;
+                this._accessorValueCache = null;
+                break;
+              }
+              child = child.nextSibling;
+            }
+          }
+
           // We detect if the instance data we bind to has changed.  If it has,
           // changed, we simply update the selection.  If it hasn't, that means
           // we rebuild the select UI.  We also rebuild if the delegate cache is
           // null (first load).
-          if (this._delegateValueCache == null ||
-              this._delegateValueCache == this.delegate.value) {
-            // refresh was not called due to instance data changing, so build the
-            // UI.
-            this._buildSelect();
-          } else {
+          if (this._accessorValueCache == null ||
+              this._accessorValueCache == this.accessors.getValue() || 
+              containsNonText) {
+            // if we reached here and the instance data only contains text
+            // nodes, then we need to rebuild the control since we know it
+            // wasn't due to a simple instance data changing scenario.  But if
+            // the bound node contains non TEXT nodes, then it is too expensive
+            // to figure out if this was because a child node changed somewhere
+            // along the way.  We'd basically have to cache the whole bound node
+            // subtree to compare against.  To avoid this we'll just rebuild the
+            // control from scratch.
+
+            // XXX at a future time we need to figure out which will be more
+            //     efficient give the most probable use cases.
+            this._buildSelect(containsNonText);
+          } else if (!containsNonText) {
             // update selection
             this._updateSelection();
-          }
 
-          // store the delegate value
-          this._delegateValueCache = this.delegate.value;
+            // store the delegate value
+            this._accessorValueCache = this.accessors.getValue();
+          }
 
           this._refreshing = false;
 
@@ -165,25 +190,92 @@
 
       <field name="_controlArraySize">0</field>
       <field name="_controlArray">new Array()</field>
+      <field name="_selectedElementSize">0</field>
+      <field name="_selectedElementArray">new Array()</field>
       <field name="_defaultHash">null</field>
 
       <method name="_buildSelect">
+        <parameter name="aContainsNonText"/>
         <body>
         <![CDATA[
           // select builds its own UI by parsing it's children.
 
-          // replace new line (\n), tabs (\t) and carriage returns (\r) with "".
-          var value = this.delegate.value.replace(/\n|\t|\r/g, " ");
+          // if delegate.value has something, then only text node(s) should
+          // exist under the bound node
 
-          // get an array of values selected in the bound node
-          var selectedArray = value.split(" ");
+          // holds an array of DOMElements that exist under bound node,
+          this._selectedElementSize = 0;
+          this._selectedElementArray = new Array();
+
+          if (!aContainsNonText) {
+            // replace new line (\n), tabs (\t) and carriage returns (\r) with
+            // "".
+            var value = "";
+            var accessValue = this.accessors.getValue();
+  
+            if (accessValue)
+              value = accessValue.replace(/\n|\t|\r/g, " ");
+  
+            // get an array of values selected in the bound node
+            var selectedArray = value.split(" ");
+  
+            // create a hash from the default values so we can store how often
+            // we encountered them.  This allows us to figure out later if any
+            // were not hit, which requires us to send an event.
+            this._defaultHash = new Object();
+            for (var run = 0; run < selectedArray.length; run++) {
+              this._defaultHash[selectedArray[run]] = {hits: 0}
+            }
+          } else {
+            var boundNode = this.accessors.getBoundNode();
+            var child = boundNode ? boundNode.firstChild : null;
+            this._defaultHash = null;
+            while (child) {
+              var type = child.nodeType;
+              if (type == Node.TEXT_NODE || 
+                  type == Node.CDATA_SECTION_NODE) {
+                // if child is a text node completely filled with
+                // whitespace let's ignore it and get the next node
+                var string = child.nodeValue;
+                var nonWhitespace = false;
+                if (string) {
+                  // this regexp tests whether only whitespace is contained
+                  // between the beginning and ending of the string.
+                  nonWhitespace = !(/^\s*$/.test(string));
+                }
+                if (nonWhitespace) {
+                  // replace new line (\n), tabs (\t) and carriage returns (\r)
+                  // with " ".
+                  var value = string.replace(/\n|\t|\r/g, " ");
+                 
+                  // get an array of values selected in the bound node
+                  var selectedArray = value.split(" ");
+      
+                  // create a hash from the default values so we can store how
+                  // often we encountered them.  This allows us to figure out
+                  // later if any were not hit, which requires us to send an
+                  // event.
+                  if (!this._defaultHash) {
+                    this._defaultHash = new Object();
+                  }
+                  for (var run = 0; run < selectedArray.length; run++) {
+                    this._defaultHash[selectedArray[run]] = {hits: 0}
+                  }
+                }
+              } else {
+                // if it's not a text node, we'll assume that we are looking at
+                // a node worth comparing.  As such, look for an
+                // item with a copy element that might match this node.
+                this._selectedElementArray[this._selectedElementSize] = 
+                  {element: child, hits: 0}
+                this._selectedElementSize++;
+              }
 
-          // create a hash from the default values so we can store how often
-          // we encountered them.  This allows us to figure out later if any were
-          // not hit, which requires us to send an event.
-          this._defaultHash = new Object();
-          for (var run = 0; run < selectedArray.length; run++) {
-            this._defaultHash[selectedArray[run]] = {hits: 0}
+              if (child == boundNode.lastChild) {
+                break;
+              }
+              child = child.nextSibling;
+            }
           }
 
           // clear the UI children
@@ -223,12 +315,13 @@
                 var uiElement =
                   child.QueryInterface(Components.interfaces.nsIXFormsItemSetUIElement);
                 var containers = uiElement.anonymousItemSetContent.childNodes;
+
+                // go through each item in the itemset and add it to the
+                // html:select.  Select any of the items that contain a value
+                // that also appears under the bound node.
                 for (var y = 0; y < containers.length; y++) {
                   if (containers[y].nodeType == containers[y].ELEMENT_NODE) {
-                    var value = this._addItemSetItem(containers[y]);
-
-                    // check if we should pre-select this option
-                    this.preselectItem(value);
+                    this._addItemSetItem(containers[y]);
                   }
                 }
               }
@@ -245,6 +338,18 @@
             }
           }
 
+          // check if any default elements were not found
+          for (var j = 0; j < this._selectedElementSize; j++) {
+            if (this._selectedElementArray[j].hits == 0) {
+              // XXX: some of default values not found, we need to throw an
+              // xforms-out-of-range event, but only if the select is 'closed'.
+              // If the select is open, the missing elements should be added
+              // and selected per 8.1.10 in the spec.
+            }
+          }
+
+
+
           return true;
          ]]>
         </body>
@@ -295,7 +400,7 @@
 
           // add to the control array
           this._controlArray[this._controlArraySize] =
-            {control: aControl, option: option, type: "item"}
+            {control: aControl, option: option, type: "item", wasSelected: false}
           this._controlArraySize++;
 
           return option;
@@ -342,7 +447,7 @@
 
                 // add to the control array
                 this._controlArray[this._controlArraySize] =
-                  {control: child, option: option, type: "item"}
+                  {control: child, option: option, type: "item", wasSelected: false}
                 this._controlArraySize++;
 
                 // check if we should pre-select this option
@@ -363,18 +468,47 @@
         <body>
         <![CDATA[
           var itemElm = aItemElement.QueryInterface(Components.interfaces.nsIXFormsItemElement);
-          var itemValue = itemElm.value;
+          var copyItem = itemElm.isCopyItem;
+          var itemValue = copyItem ? "" : itemElm.value;
           var itemLabel = itemElm.labelText;
 
-          var option = this._buildSelectItem(itemLabel, itemValue, aItemElement, true);
+          var option = this._buildSelectItem(itemLabel, itemValue, aItemElement,
+                                             true);
+
+          // if this item contains a copy element AND if the bound node contains
+          // non-text elements, then see if any of these non-text elements match
+          // this copyItem's node.
+          if (copyItem && this._selectedElementSize > 0) {
+            var item = aItemElement.QueryInterface(Components.interfaces.nsIXFormsSelectChild); 
+            for (var j = 0; j < this._selectedElementSize; j++ ) {
+              var selectedItem =
+                item.selectItemByNode(this._selectedElementArray[j].element);
+              if (selectedItem) {
+                this._selectedElementArray[j].hits++;
+                option.selected = true;
+                // XXX It is possible that two identical elements are under the
+                // bound node.  I guess we shouldn't mark one and not the other
+                // if there is an item in the select that matches it.  So we'll
+                // go through the whole list.  But this is quite an edge case
+                // and will cause more inefficiency just to prevent an errant
+                // xforms-out-of-range.
+              }
+            }
+          }
 
           // add to the control array
           this._controlArray[this._controlArraySize] =
-            {control: aItemElement, option: option, type: "item"}
+            {control: aItemElement, option: option, type: "item", wasSelected: option.selected}
           this._controlArraySize++;
 
           this.uiElement.appendChild(option);
 
+          if (!copyItem) {
+            // if this item contains a value element, then make sure to select
+            // this item if its value exists under the bound node.
+            this.preselectItem(itemValue);
+          }
+
           return itemValue;
         ]]>
         </body>
@@ -386,44 +520,211 @@
         <![CDATA[
           // if incremental, change instance data and send the value-changed event
           if (this.incremental) {
-            this._setBoundValue();
+            this._handleSelection();
+          } else {
+            // per the spec, if not incremental, we still need to send the
+            // deselect/select events. which _getSelectedValues() does for us
+            this._getSelectedValues();
           }
         ]]>
         </body>
       </method>
 
-      <method name="_setBoundValue">
+      <method name="_handleSelection">
         <body>
         <![CDATA[
-          this.delegate.value = this._getSelectedValues();
+          var boundNode = this.accessors.getBoundNode();
+          if (!boundNode) {
+            return;
+          }
+
+          // if a copy item is selected or deselected, then we need to replace
+          // ALL of the current content with the newly selected content.  Which
+          // means calling setContent.  setValue only messes with the first
+          // textnode under the bound node.
+          var copySelectedOrDeselected = new Boolean();
+          copySelectedOrDeselected.value = false;
+          var contentEnvelope = this._getSelectedValues(copySelectedOrDeselected);
+          if (contentEnvelope) {
+            if (boundNode.nodeType == Node.ELEMENT_NODE) {
+              // we shouldn't call setContent if we haven't selected any
+              // copyItems.  We can't just test for a single text node under
+              // the bound node because this could still have been the result
+              // of a copyItem being selected.  And if a copyItem is selected,
+              // then we need to do the whole rebuild, recalculate, revalidate,
+              // refresh process according to the spec...whether we really need
+              // to or not.
+              if (copySelectedOrDeselected.value == false) {
+                this.accessors.setValue(contentEnvelope.textContent);
+              } else {
+                this.accessors.setContent(contentEnvelope, true);
+              }
+            } else {
+              // if some copyItems were selected by the user prior to the call
+              // to _getSelectedValues, then we would not have set up
+              // _delegateValueCache.  Since the node we are bound to can't
+              // be set by copyItems (its not an ELEMENT_NODE), any copyItems
+              // in this select would have been deselected during
+              // _getSelectedValues.  Thus, anything in the contentEnvelope at
+              // this point should just be strings and so we can set
+              // delegate.value directly and use _delegateValueCache after all.
+
+              this.accessors.setValue(contentEnvelope.nodeValue);
+              this._accessorValueCache = contentEnvelope.nodeValue;
+            }
+          }
         ]]>
         </body>
       </method>
 
       <method name="_getSelectedValues">
+        <parameter name="aIsACopyItemSelectedOrDeselected"/>
         <body>
         <![CDATA[
           var selectedValues = "";
+          var newSelectedControls = new Array();
 
           // select if found, unselect if not
           var options = this._controlArray;
 
+          if (aIsACopyItemSelectedOrDeselected) {
+            aIsACopyItemSelectedOrDeselected.value = false;
+          }
+
+          var boundNode = this.accessors.getBoundNode();
+          if (!boundNode) {
+            return;
+          }
+
+          // we are cloning boundNode to create a node that we will return.
+          // By the end of this function, assuming all went well,
+          // contentEnvelope will contain the values and copyNodes that are
+          // represented by the selected items in this xf:select.  Cloning
+          // the boundNode to use as the envelope so that the caller could
+          // just pass the results straight into accessors.setContent().
+          var contentEnvelope = null;
+          contentEnvelope = boundNode.cloneNode(false);
+          if (!contentEnvelope) {
+            return;
+          }
+          var boundType = boundNode.nodeType;
+          var copyNode;
+
+          // keep in mind, to maintain compatibility with XSmiles and Novell, we
+          // ultimately need to end up with all 'value' elements contained in a
+          // text node and this text node needs to be the first child of the
+          // bound node.
           for (var i = 0; i < options.length; i++) {
             var isSelected =
               options[i].option ? options[i].option.selected : options[i].checkbox.checked;
 
             if (isSelected) {
-              // space delimeted list
+              // space delimited list
               if (selectedValues.length > 0) {
                 selectedValues += " ";
               }
 
-              selectedValues +=
-                options[i].control.QueryInterface(Components.interfaces.nsIXFormsSelectChild).value;
+              var item = options[i].control.QueryInterface(Components.interfaces.nsIXFormsItemElement);
+              if (item.isCopyItem) {
+                if (boundType && (boundType != Node.ELEMENT_NODE)) {
+                  // if we are trying to do a copy without being bound to an
+                  // element node, then we need to throw a binding exception
+                  // per spec.
+                  bindingException = document.createEvent("Events");
+                  bindingException.initEvent("xforms-binding-exception", true, false);
+                  this.dispatchEvent(bindingException);
+
+                  // we should probably un-select the option so that the list
+                  // of selected data is accurate.  This WON'T cause a
+                  // xforms-select/deselect to fire.  Since the user just
+                  // selected this item and we are automatically deselecting
+                  // it from underneath the user, we'll treat it like nothing
+                  // happened.
+                  if (options[i].option) {
+                    options[i].option.selected = false;
+                  } else {
+                    options[i].checkbox.checked = false;
+                  }
+                } else {
+                  copyNode = item.copyNode;
+                  if (copyNode) {
+                    var clone = copyNode.cloneNode(true);
+                    contentEnvelope.appendChild(clone);
+                  }
+
+                  // if it wasn't selected before add to the list of newly
+                  // selected items
+                  if (!options[i].wasSelected) {
+                    newSelectedControls.push(options[i].control);
+                    if (aIsACopyItemSelectedOrDeselected && 
+                        aIsACopyItemSelectedOrDeselected.value != true) {
+                      aIsACopyItemSelectedOrDeselected.value = true;
+                    }
+                  }
+    
+                  options[i].wasSelected = true;
+                }
+              } else {
+                // not a copyItem, so grab the item's value and append it to our
+                // space seperated list.
+                selectedValues +=
+                  options[i].control.QueryInterface(Components.interfaces.nsIXFormsSelectChild).value;
+
+                // if it wasn't selected before add to the list of newly
+                // selected items
+                if (!options[i].wasSelected) {
+                  newSelectedControls.push(options[i].control);
+                }
+  
+                options[i].wasSelected = true;
+              }
+            } else {
+              // it was selected before, but now unselected
+              if (options[i].wasSelected) {
+                this.dispatchSelectEvent(options[i].control, "xforms-deselect")
+
+                // if a copyItem was deselected, we need to make sure to do a
+                // rebuild.  By setting aIsACopyItemSelectedOrDeselected, this
+                // should tell _handleSelection to use setContent with
+                // aForceUpdate = true
+                var item = options[i].control.QueryInterface(Components.interfaces.nsIXFormsItemElement);
+                if (item.isCopyItem) {
+                  if (aIsACopyItemSelectedOrDeselected && 
+                      aIsACopyItemSelectedOrDeselected.value != true) {
+                    aIsACopyItemSelectedOrDeselected.value = true;
+                  }
+                }
+            }
+
+              options[i].wasSelected = false;
+            }
+          }
+
+          // write out the text nodes before we handle copy
+          if (boundType == Node.ELEMENT_NODE) {
+            if (selectedValues.length > 0) {
+              var textNode = document.createTextNode(selectedValues);
+              if (copyNode) {
+                // making sure all selected 'values' are in the first text node
+                // under the bound node.
+                var firstChild = contentEnvelope.firstChild;
+                contentEnvelope.insertBefore(textNode, firstChild);
+              } else { 
+                contentEnvelope.appendChild(textNode);
+              }
             }
+          } else {
+            contentEnvelope.nodeValue = selectedValues;
+          }
+
+          selectedValues = "";
+
+          // we send xforms-select after all deselect events are thrown
+          for (var i = 0; i < newSelectedControls.length; i++) {
+            this.dispatchSelectEvent(newSelectedControls[i], "xforms-select")
           }
 
-          return selectedValues;
+          return contentEnvelope;
         ]]>
         </body>
       </method>
@@ -431,8 +732,15 @@
       <method name="_updateSelection">
         <body>
         <![CDATA[
+          // this function only looks through the text values that are stored
+          // under the bound node and selects the xf:items that have
+          // corresponding values to that list.  As such, copyItems will
+          // be ignored.
+
           // get an array of values selected in the bound node
-          var selectedArray = this.delegate.value.split(" ");
+          var selectedArray = new Array();
+          if (this.accessors.getValue())
+            selectedArray = this.accessors.getValue().split(" ");
 
           // store the values in a hash for quick access
           this._defaultHash = new Object();
@@ -444,8 +752,11 @@
           var options = this._controlArray;
 
           for (var i = 0; i < options.length; i++) {
-            var value =
-              options[i].control.QueryInterface(Components.interfaces.nsIXFormsSelectChild).value;
+            var item = options[i].control.QueryInterface(Components.interfaces.nsIXFormsSelectChild);
+            if (item.isCopyItem) {
+              break;
+            }
+            var value = item.value;
             var selectionValue = (this._defaultHash[value] != null);
 
             // either a checkbox or an option
@@ -491,7 +802,7 @@
         <![CDATA[
           // update instance data if we are not incremental
           if (!this.incremental) {
-            this._setBoundValue();
+            this._handleSelection();
           }
         ]]>
         </body>
@@ -502,15 +813,37 @@
         <body>
         <![CDATA[
           // check if we should pre-select this option
-          if (this._defaultHash[aValue] != null) {
+          if (this._defaultHash && this._defaultHash[aValue] != null) {
             var control = this._controlArray[this._controlArraySize - 1]
             this._setItemSelection(control, true);
 
+            // tell the control it was selected
+            control.wasSelected = true;
+
             this._defaultHash[aValue].hits++;
           }
         ]]>
         </body>
       </method>
+
+      <method name="dispatchSelectEvent">
+        <parameter name="aElement"/>
+        <parameter name="aName"/>
+        <body>
+          var ev = document.createEvent("Events");
+          ev.initEvent(aName, true, false);
+
+          var elm = aElement;
+
+          // per http://www.w3.org/TR/2005/PER-xforms-20051006/index-all.html#evt-select
+          // we send the event to the itemset if it is a parent.
+          if (elm.parentNode.localName == "itemset")
+            elm = elm.parentNode;
+
+          elm.dispatchEvent(ev);
+          return true;
+        </body>
+      </method>
     </implementation>
   </binding>
 
@@ -525,6 +858,7 @@
             <children includes="label"/>
           </html:td>
           <html:td anonid="checkbox-group"
+                   class="xf-value"
                    onchange="this.parentNode.parentNode.parentNode.selectionChanged();">
           </html:td>
         </html:tr>
@@ -600,7 +934,7 @@
 
           // add to the control array
           this._controlArray[this._controlArraySize] =
-            {control: aControl, checkbox: item.firstChild, type: "item"}
+            {control: aControl, checkbox: item.firstChild, type: "item", wasSelected: false}
           this._controlArraySize++;
         ]]>
         </body>
@@ -652,7 +986,7 @@
 
                 // add to the control array
                 this._controlArray[this._controlArraySize] =
-                  {control: child, checkbox: item.firstChild, type: "item"}
+                  {control: child, checkbox: item.firstChild, type: "item", wasSelected: false}
                 this._controlArraySize++;
 
                 // check if we should pre-select this option
@@ -674,18 +1008,47 @@
         <body>
         <![CDATA[
           var itemElm = aItemElement.QueryInterface(Components.interfaces.nsIXFormsItemElement);
+          var copyItem = itemElm.isCopyItem;
           var itemValue = itemElm.value;
-          var itemLabel = itemElm.labelText;
-
-          var item = this._buildSelectItem(itemLabel, itemValue, aItemElement, true);
+          var itemLabel = copyItem ? "" : itemElm.labelText;
+          
+          var item = this._buildSelectItem(itemLabel, itemValue, aItemElement,
+                                           true);
 
           // add to the control array
           this._controlArray[this._controlArraySize] =
-            {control: aItemElement, checkbox: item.firstChild, type: "item"}
+            {control: aItemElement, checkbox: item.firstChild, type: "item", wasSelected: false}
           this._controlArraySize++;
 
           this.uiElement.appendChild(item);
 
+          // if this item contains a copy element AND if the bound node contains
+          // non-text elements, then see if any of these non-text elements match
+          // this copyItem's node.
+          if (copyItem && this._selectedElementSize > 0) {
+            var item = aItemElement.QueryInterface(Components.interfaces.nsIXFormsSelectChild); 
+            for (var j = 0; j < this._selectedElementSize; j++ ) {
+              var selectedItem =
+                item.selectItemByNode(this._selectedElementArray[j].element);
+              if (selectedItem) {
+                this._selectedElementArray[j].hits++;
+                item.firstChild.checked = true;
+
+                this._controlArray[this._controlArraySize - 1].wasSelected = true;
+                // XXX It is possible that two identical elements are under the
+                // bound node.  I guess we shouldn't mark one and not the other
+                // if there is an item in the select that matches it.  So we'll
+                // go through the whole list.  But this is quite an edge case
+                // and will cause more inefficiency just to prevent an errant
+                // xforms-out-of-range.
+              }
+            }
+          } else if (!copyItem) {
+            // if this item contains a value element, then make sure to select
+            // this item if its value exists under the bound node.
+            this.preselectItem(itemValue);
+          }
+
           return itemValue;
         ]]>
         </body>
diff -uprN --exclude=CVS mozilla/extensions/xforms/resources/content/xforms.css mozilla.new/extensions/xforms/resources/content/xforms.css
--- mozilla/extensions/xforms/resources/content/xforms.css	2005-10-23 18:30:14.000000000 +0200
+++ mozilla.new/extensions/xforms/resources/content/xforms.css	2006-02-14 10:01:13.000000000 +0100
@@ -1,38 +1,41 @@
-# ***** BEGIN LICENSE BLOCK *****
-# Version: MPL 1.1/GPL 2.0/LGPL 2.1
-#
-# The contents of this file are subject to the Mozilla Public License Version
-# 1.1 (the "License"); you may not use this file except in compliance with
-# the License. You may obtain a copy of the License at
-# http://www.mozilla.org/MPL/
-#
-# Software distributed under the License is distributed on an "AS IS" basis,
-# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
-# for the specific language governing rights and limitations under the
-# License.
-#
-# The Original Code is Mozilla XForms support.
-#
-# The Initial Developer of the Original Code is
-# IBM Corporation.
-# Portions created by the Initial Developer are Copyright (C) 2005
-# the Initial Developer. All Rights Reserved.
-#
-# Contributor(s):
-#
-# Alternatively, the contents of this file may be used under the terms of
-# either the GNU General Public License Version 2 or later (the "GPL"), or
-# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
-# in which case the provisions of the GPL or the LGPL are applicable instead
-# of those above. If you wish to allow use of your version of this file only
-# under the terms of either the GPL or the LGPL, and not to allow others to
-# use your version of this file under the terms of the MPL, indicate your
-# decision by deleting the provisions above and replace them with the notice
-# and other provisions required by the GPL or the LGPL. If you do not delete
-# the provisions above, a recipient may use your version of this file under
-# the terms of any one of the MPL, the GPL or the LGPL.
-#
-# ***** END LICENSE BLOCK *****
+/*
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla XForms support.
+ *
+ * The Initial Developer of the Original Code is
+ * IBM Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK *****
+ */
+
 @namespace url(http://www.w3.org/2002/xforms);
 @namespace html url(http://www.w3.org/1999/xhtml);
 @namespace mozType url(http://www.mozilla.org/projects/xforms/2005/type);
@@ -77,6 +80,10 @@ output {
   -moz-binding: url('chrome://xforms/content/xforms.xml#xformswidget-output');
 }
 
+range {
+  -moz-binding: url('chrome://xforms/content/range.xml#xformswidget-range');
+}
+
 input {
   -moz-binding: url('chrome://xforms/content/xforms.xml#xformswidget-input');
 }
@@ -85,6 +92,81 @@ input[mozType|type="http://www.w3.org/20
   -moz-binding: url('chrome://xforms/content/xforms.xml#xformswidget-input-boolean');
 }
 
+input[mozType|type="http://www.w3.org/2001/XMLSchema#date"] {
+  -moz-binding: url('chrome://xforms/content/xforms.xml#xformswidget-input-date');
+}
+
+input[mozType|type="http://www.w3.org/2001/XMLSchema#date"] html|input[anonid="dropmarker"] {
+  min-width:27px;
+  min-height: 1.3em;
+  background-image: url(chrome://xforms/content/calendar.png) !important;
+  background-position: center !important;
+  background-repeat: no-repeat !important;
+}
+
+input[mozType|type="http://www.w3.org/2001/XMLSchema#date"] html|div[anonid="picker"] {
+  border: 1px outset black !important;
+  background-color: -moz-Field;
+  font: -moz-list;
+  text-align: start;
+}
+
+input[mozType|type="http://www.w3.org/2001/XMLSchema#date"] html|td {
+  border: 1px solid transparent;
+  text-align: center;
+}
+
+input[mozType|type="http://www.w3.org/2001/XMLSchema#date"] html|td.prevMonth,
+input[mozType|type="http://www.w3.org/2001/XMLSchema#date"] html|td.nextMonth {
+  color: GrayText;
+}
+
+input[mozType|type="http://www.w3.org/2001/XMLSchema#date"] html|td.prevMonth:hover,
+input[mozType|type="http://www.w3.org/2001/XMLSchema#date"] html|td.nextMonth:hover {
+  background-color: grey;
+  cursor: pointer;
+}
+
+input[mozType|type="http://www.w3.org/2001/XMLSchema#date"] html|td.currentMonth {
+  color: black;
+}
+
+input[mozType|type="http://www.w3.org/2001/XMLSchema#date"] html|td.currentMonth:hover {
+  color: HighlightText;
+  background-color: Highlight;
+  cursor: pointer;
+}
+
+input[mozType|type="http://www.w3.org/2001/XMLSchema#date"] html|td[tabindex="0"] {
+  border: 1px solid black;
+}
+
+html|input.-moz-date-back-button {
+  width: 20px;
+  background-image: url("chrome://global/skin/arrow/arrow-lft.gif") !important;
+  background-repeat: no-repeat !important;
+  background-position: center !important;
+}
+
+html|input.-moz-date-fwd-button {
+  width: 20px;
+  background-image: url("chrome://global/skin/arrow/arrow-rit.gif") !important;
+  background-repeat: no-repeat !important;
+  background-position: center !important;
+}
+
+input[mozType|type="http://www.w3.org/2001/XMLSchema#gMonth"] {
+  -moz-binding: url('chrome://xforms/content/xforms.xml#xformswidget-input-month');
+}
+
+input[mozType|type="http://www.w3.org/2001/XMLSchema#gDay"] {
+  -moz-binding: url('chrome://xforms/content/xforms.xml#xformswidget-input-day');
+}
+
+input[mozType|type="http://www.w3.org/2001/XMLSchema#gYear"] {
+  -moz-binding: url('chrome://xforms/content/xforms.xml#xformswidget-input-year');
+}
+
 secret {
   -moz-binding: url('chrome://xforms/content/xforms.xml#xformswidget-secret');
 }
@@ -109,6 +191,17 @@ label {
   -moz-binding: url('chrome://xforms/content/xforms.xml#xformswidget-label');
 }
 
+input > label,
+secret > label,
+textarea > label,
+trigger > label,
+submit > label,
+select > label,
+select1 > label,
+upload > label {
+  -moz-binding: url('chrome://xforms/content/xforms.xml#xformswidget-label-accesskey');
+}
+
 select1 {
   -moz-binding: url('chrome://xforms/content/select1.xml#xformswidget-select1');
 }
@@ -125,6 +218,8 @@ select1 item {
   white-space : nowrap;
 }
 
+
+html|input.-moz-xforms-date-dropdown,
 html|input.-moz-xforms-select1-dropdown {
   width: 12px;
   height: 1.3em;
@@ -164,6 +259,7 @@ html|input.-moz-xforms-select1-input:foc
   border: 1px dotted black;
 }
 
+html|span.-moz-date-container,
 html|span.-moz-select1-container {
   margin: 0px;
   margin-bottom: 1px;
@@ -268,3 +364,7 @@ upload[mozType|type="http://www.w3.org/2
   -moz-binding: url('chrome://xforms/content/xforms.xml#xformswidget-upload');
 }
 
+/* default MIP styling */
+*:disabled {
+  display: none;
+}
diff -uprN --exclude=CVS mozilla/extensions/xforms/resources/content/xforms.xml mozilla.new/extensions/xforms/resources/content/xforms.xml
--- mozilla/extensions/xforms/resources/content/xforms.xml	2005-10-25 20:23:25.000000000 +0200
+++ mozilla.new/extensions/xforms/resources/content/xforms.xml	2006-02-14 10:01:13.000000000 +0100
@@ -65,16 +65,17 @@
 
       <destructor>
         this._delegate = null;
+        this._accessors = null;
       </destructor>
 
-      <field name="_delegate">null</field>
-
       <property name="XFORMS_NS" readonly="true">
         <getter>
           return "http://www.w3.org/2002/xforms";
         </getter>
       </property>
 
+      <field name="_delegate">null</field>
+
       <property name="delegate" readonly="true">
         <getter>
           if (!this._delegate)
@@ -83,9 +84,21 @@
         </getter>
       </property>
 
+      <field name="_accessors">null</field>
+
+      <property name="accessors" readonly="true">
+        <getter>
+        <![CDATA[
+          if (!this._accessors && this.delegate)
+            this._accessors = this.delegate.getXFormsAccessors();
+          return this._accessors;
+        ]]>
+        </getter>
+      </property>
+
       <property name="stringValue" readonly="true">
         <getter>
-          var value = this.delegate.value;
+          var value = this.accessors.getValue();
           return value != null ? value : "";
         </getter>
       </property>
@@ -109,6 +122,7 @@
         </body>
       </method>
 
+      <!-- Dispatch UI Event to the control itself -->
       <method name="dispatchDOMUIEvent">
         <parameter name="aType"/>
         <body>
@@ -119,6 +133,20 @@
         </body>
       </method>
 
+      <!--
+          Dispatch an _XForms notification event_ to a node.
+          See http://www.w3.org/TR/xforms/slice4.html#evt-notify
+      -->
+      <method name="dispatchXFormsNotificationEvent">
+        <parameter name="aEventName"/>
+        <parameter name="aTarget"/>
+        <body>
+          var ev = document.createEvent("Events");
+          ev.initEvent(aEventName, true, false);
+          aTarget.dispatchEvent(ev);
+          return true;
+        </body>
+      </method>
     </implementation>
   </binding>
   
@@ -127,15 +155,23 @@
            extends="chrome://xforms/content/xforms.xml#xformswidget-base">
     <content>
       <children includes="label"/>
-      <html:span anonid="content"></html:span>
+      <!-- XXX initialize span with a space until repeat is xbl-ized.  Part
+           of workaround for bug 322975 
+      -->
+      <html:span class="xf-value" anonid="content"> </html:span>
       <children/>
     </content>
     
     <implementation implements="nsIXFormsUIWidget">
       <method name="refresh">
         <body>
-          document.getAnonymousElementByAttribute(this, "anonid", "content").textContent =
+          // XXX changing from setting textContent to setting nodeValue of
+          // first child (text node created by space character initializer
+          // above).  Workaround for bug 322975.  Probably should be changed
+          // back after repeat is xbl-ized
+          document.getAnonymousElementByAttribute(this, "anonid", "content").firstChild.nodeValue =
             this.stringValue;
+
           return true;
         </body>
       </method>
@@ -157,7 +193,7 @@
           var anoncontent =
             document.getAnonymousElementByAttribute(this, "anonid", "anoncontent");
 
-          if (this.delegate.hasBoundNode || this.delegate.value != null) {
+          if (this.accessors.hasBoundNode() || this.accessors.getValue() != null) {
             anoncontent.setAttribute("style", "display:none;");
           } else {
             anoncontent.removeAttribute("style");
@@ -170,17 +206,86 @@
       </method>
     </implementation>
   </binding>
-  
+
+  <!-- LABEL: <ACCESKEY SUPPORT> -->
+  <binding id="xformswidget-label-accesskey"
+           extends="chrome://xforms/content/xforms.xml#xformswidget-base">
+    <content>
+      <html:span anonid="content"></html:span>
+      <html:span anonid="anoncontent" style="display:none;">
+        <children/>
+      </html:span>
+    </content>
+    <implementation implements="nsIXFormsUIWidget">
+      <method name="refresh">
+        <body>
+        <![CDATA[
+          // we cannot access the <children/> content in XBL1, so we switch to
+          // always cloning the content into the content span.
+          var content =
+            document.getAnonymousElementByAttribute(this, "anonid", "content");
+
+          var hasElementChildren = false;
+          var hasBoundValue = false;
+
+          if (this.accessors.hasBoundNode() || this.accessors.getValue() != null) {
+            content.textContent = this.stringValue;
+            hasBoundValue = true;
+          } else {
+            // clone the contents child by child
+            var node;
+            for (var i = 0; i < this.childNodes.length; i++) {
+              if (!hasElementChildren && this.childNodes[i].nodeType == Node.ELEMENT_NODE)
+                hasElementChildren = true;
+
+              content.appendChild(this.childNodes[i].cloneNode(true));
+            }
+          }
+
+          // XXX: if label has element node children, we skip accesskey underlining
+          if (!hasElementChildren && this.parentNode.hasAttribute("accesskey")) {
+            var accesskey = this.parentNode.getAttribute("accesskey");
+
+            // bail if no accesskey or accesskey is longer than 1 character
+            if (!accesskey || accesskey.length != 1)
+              return true;
+
+            var str = content.textContent;
+            var location = str.indexOf(accesskey);
+
+            if (location > -1) {
+              // we create a range around the character we want and surround it
+              // with an <html:u>
+              var range = document.createRange();
+              range.setStart(content.firstChild, location)
+              range.setEnd(content.firstChild, location+1)
+
+              var u = document.createElementNS("http://www.w3.org/1999/xhtml", "u");
+              range.surroundContents(u);
+            } else {
+              // if we didn't find the accesskey, append it to the end
+              content.textContent += "(" + accesskey + ")";
+            }
+          }
+
+          return true;
+        ]]>
+        </body>
+      </method>
+    </implementation>
+  </binding>
+
   <!-- INPUT: <DEFAULT> -->
   <binding id="xformswidget-input"
            extends="chrome://xforms/content/xforms.xml#xformswidget-base">
     <content>
       <children includes="label"/>
       <html:input anonid="control"
-                  onblur="this.parentNode.delegate.value = this.value; this.parentNode.dispatchDOMUIEvent('DOMFocusOut')"
+                  class="xf-value"
+                  onblur="this.parentNode.accessors.setValue(this.value); this.parentNode.dispatchDOMUIEvent('DOMFocusOut')"
                   onfocus="this.parentNode.dispatchDOMUIEvent('DOMFocusIn')"
                   onclick="this.parentNode._change();"
-                  onkeyup="this.parentNode._change();"
+                  onkeyup="if (event.keyCode != event.DOM_VK_TAB) this.parentNode._change();"
                   onkeypress="if (event.keyCode == event.DOM_VK_RETURN) this.parentNode.dispatchDOMUIEvent('DOMActivate');"
                   xbl:inherits="accesskey"/>
       <children/>
@@ -202,7 +307,7 @@
       <method name="_change">
         <body>
           if (this.getAttribute("incremental") == "true") {
-            this.delegate.value = this.inputField.value;
+            this.accessors.setValue(this.inputField.value);
           }
           return true;
         </body>
@@ -211,7 +316,7 @@
       <method name="refresh">
         <body>
           this.inputField.value = this.stringValue;
-          if (this.delegate.isReadonly) {
+          if (this.accessors.isReadonly()) {
             this.inputField.setAttribute("readonly", "readonly");
           } else {
             this.inputField.removeAttribute("readonly");
@@ -244,7 +349,7 @@
           }
           
           this.inputField.value = value;
-          if (this.delegate.isReadonly) {
+          if (this.accessors.isReadonly()) {
             this.inputField.setAttribute("readonly", "readonly");
           } else {
             this.inputField.removeAttribute("readonly");
@@ -261,9 +366,9 @@
         <body>
           if (this.getAttribute("incremental") != "false") {
             if (this.inputField.checked) {
-              this.delegate.value = "true";
+              this.accessors.setValue("true");
             } else {
-              this.delegate.value = "false";
+              this.accessors.setValue("false");
             }
           }
         </body>
@@ -271,6 +376,698 @@
     </implementation>
   </binding>
 
+  <!-- INPUT: DATE -->
+  <binding id="xformswidget-input-date"
+           extends="chrome://xforms/content/xforms.xml#xformswidget-input">
+    <content>
+      <children/>
+      <html:input anonid="control"
+                  onblur="this.parentNode.accessors.setValue(this.value); this.parentNode.dispatchDOMUIEvent('DOMFocusOut');"
+                  onfocus="this.parentNode.dispatchDOMUIEvent('DOMFocusIn'); this.parentNode._hidePicker(true);"
+                  onclick="this.parentNode._change(); this.parentNode._hidePicker(true);"
+                  onkeypress="if (event.keyCode == event.DOM_VK_RETURN) this.parentNode.dispatchDOMUIEvent('DOMActivate');"
+                  xbl:inherits="accesskey" size="10"/>
+      <html:input type="button" anonid="dropmarker" title="&xforms.datepicker.title;"
+                  onkeypress="if (event.keyCode == event.DOM_VK_ENTER) this.parentNode._togglePicker();"
+                  onclick="this.parentNode._togglePicker();"/>
+      <html:div style="position:absolute; display:none;" anonid="picker">
+        <html:table>
+           <html:tbody anonid="tbody">
+            <html:tr>
+              <html:td colspan="1">
+                <html:input type="button" anonid="back-button"
+                            class="-moz-date-back-button" title="Previous Month"
+                            onclick="this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.goBack(true);"/>
+              </html:td>
+              <html:td colspan="5" align="center">
+                <html:span anonid="date"/>
+              </html:td>
+              <html:td colspan="1">
+                <html:input type="button" anonid="fwd-button"
+                            class="-moz-date-fwd-button" title="Next Month"
+                            onclick="this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.goForward(true);"/>
+              </html:td>
+            </html:tr>
+          </html:tbody>
+        </html:table>
+      </html:div>
+    </content>
+
+    <implementation>
+      <method name="refresh">
+        <body>
+          return true;
+        </body>
+      </method>
+
+      <field name="_picker">null</field>
+      <property name="picker" readonly="true">
+        <getter>
+          if (!this._picker) {
+            this._picker =
+              document.getAnonymousElementByAttribute(this, "anonid", "picker");
+          }
+          return this._picker;
+        </getter>
+      </property>
+
+      <field name="_dateField">null</field>
+
+      <property name="dateField" readonly="true">
+        <getter>
+          if (!this._dateField) {
+            this._dateField =
+              document.getAnonymousElementByAttribute(this, "anonid", "date");
+          }
+          return this._dateField;
+        </getter>
+      </property>
+
+      <field name="_uibuilt">false</field>
+      <field name="_isPickerVisible">false</field>
+      <field name="_cells">null</field>
+      <field name="_date">null</field>
+
+      <field name="_currentCellIndex">-1</field>
+
+      <method name="_togglePicker">
+        <body>
+        <![CDATA[
+          if (this._isPickerVisible)
+            this._hidePicker(true);
+          else
+            this._showPicker();
+        ]]>
+        </body>
+      </method>
+
+
+      <method name="_showPicker">
+        <body>
+        <![CDATA[
+          // show the picker
+          var picker = this.picker;
+
+          if (this._isPickerVisible) {
+            return;
+          }
+
+          picker.style.display = "block";
+          this._isPickerVisible = true;
+
+          var value = this.inputField.value;
+          // js date likes YYYY/MM/DD, schema's is YYYY-MM-DD
+          value = value.replace(/-/g, "/");
+
+          // we check if the delgate is valid since javascript Date()
+          // returns a valid date for 2005-04-56.
+          var tmpDate = new Date(value);
+          if (!this.accessors.isValid() || tmpDate == "Invalid Date")
+            this._date = new Date();
+          else
+            this._date = tmpDate;
+
+          if (!this._uibuilt)
+            this._buildUI(this._date);
+
+          // position the dropdown, aligning it's right side with the calendar
+          // button's right side
+          var dropmarker = document.getAnonymousElementByAttribute(this, "anonid", "dropmarker");
+          var dropmarkerBox = document.getBoxObjectFor(dropmarker);
+          var width = document.getBoxObjectFor(picker).width;
+
+          var position = dropmarkerBox.x - width + dropmarkerBox.width;
+
+          // reset position if it will bleed to the left or right
+          if (position < 0) {
+            position = 0;
+          } else if ((position + width) > window.innerWidth) {
+            // we use window.innerWidth because XHTML documents are not always
+            // 100% width, and innerWidth will always give use the browser size.
+            position = window.innerWidth - width;
+          }
+
+          picker.style.left = position + "px";
+
+          this._refreshCells(this._date, this._date.getDate());
+        ]]>
+        </body>
+      </method>
+
+      <method name="_hidePicker">
+        <parameter name="aFocusInput"/>
+        <body>
+        <![CDATA[
+          if (!this._isPickerVisible)
+            return;
+
+          this._cells[this._currentCellIndex].node.setAttribute("tabindex", "-1");
+          this._currentCellIndex = -1;
+          this.picker.style.display = "none";
+          this._isPickerVisible = false;
+
+          if (aFocusInput)
+            this.inputField.focus();
+        ]]>
+        </body>
+      </method>
+
+      <method name="_buildUI">
+        <parameter name="aDate"/>
+        <body>
+        <![CDATA[
+          var xhtmlNS = "http://www.w3.org/1999/xhtml";
+
+          // shortname defaults
+          var dayShort = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
+
+          // try to get localized short names.
+          // May 2005's first day is a Sunday - also, month is 0-indexed in JS
+          var day;
+          for (var i = 0; i < 7; i++) {
+            day = new Date(2005, 4, i+1).toLocaleFormat("%a");
+            if (day)
+              dayShort[i] = day;
+          }
+
+          var month = aDate.getMonth();
+          var year = aDate.getFullYear();
+
+          // clear the cells array
+          this._cells = new Array();
+
+          var table = document.getAnonymousElementByAttribute(this, "anonid", "tbody");
+          var row, cell, header, caption;
+
+          // create the table headers
+          row = document.createElementNS(xhtmlNS, "tr");
+
+          for (var i = 0; i < 7; i++) {
+            header = document.createElementNS(xhtmlNS, "th");
+            // day shorthands
+            header.textContent = dayShort[i];
+            row.appendChild(header);
+          }
+
+          table.appendChild(row);
+
+          // create a table of 7 columns, 6 rows
+          for (var i = 0; i < 6; i++) {
+            row = document.createElementNS(xhtmlNS, "tr");
+
+            for (var y = 0; y < 7; y++) {
+              cell = document.createElementNS(xhtmlNS, "td");
+              cell.setAttribute("num", this._cells.length)
+              this._cells[this._cells.length] = {row:i, col:y, node: cell};
+
+              row.appendChild(cell);
+            }
+
+            table.appendChild(row);
+          }
+
+          this._uibuilt = true;
+        ]]>
+        </body>
+      </method>
+
+      <method name="_refreshCells">
+        <parameter name="aDate"/>
+        <parameter name="aDayToSelect"/>
+        <parameter name="aSkipFocus"/>
+        <body>
+        <![CDATA[
+          var month = aDate.getMonth();
+          var year = aDate.getFullYear();
+
+          var totaldays = this._getDaysInMonth(month, year);
+
+          // first day of month is?
+          var firstDay = new Date(year, month, 1).getDay();
+
+          // get the previous month's date so we can prefill that section.  The
+          // next month is easy, we go from 1..x as far as we need
+          var prevDate = this._getPrevDate(month, year);
+          var showsPrevDays = 0;
+
+          // init cells
+          for (var i = 0; i < this._cells.length; i++) {
+            if (i < firstDay || i >= (firstDay + totaldays)) {
+              // either previous or next month
+              if (i < firstDay) {
+                // previous month
+                var prevyear = prevDate.getFullYear();
+                var prevmonth = prevDate.getMonth();
+
+                var maxprev = this._getDaysInMonth(prevmonth, prevyear);
+                this._cells[i].node.textContent = maxprev - firstDay + i + 1;
+
+                this._cells[i].node.className = "prevMonth"
+                showsPrevDays++;
+              } else {
+                // next month
+                this._cells[i].node.textContent = i - (firstDay + totaldays) + 1;
+                this._cells[i].node.className = "nextMonth"
+              }
+            } else {
+              // current month
+              // this._cells add one since the first day is 1, not 0!
+              this._cells[i].node.textContent = i - firstDay + 1;
+              this._cells[i].node.className = "currentMonth";
+            }
+
+            this._cells[i].node.setAttribute("tabindex", "-1");
+          }
+
+          // first time
+          if (this._currentCellIndex == -1) {
+            // select the current day
+            this._currentCellIndex = aDate.getDate() + showsPrevDays - 1;
+          } else {
+            // if the day is larger that the total days in this month
+            if (aDayToSelect > totaldays)
+              aDayToSelect = totaldays;
+
+            this._currentCellIndex = aDayToSelect + showsPrevDays - 1;
+          }
+
+          this._cells[this._currentCellIndex].node.setAttribute("tabindex", "0");
+
+          if (!aSkipFocus)
+            this._cells[this._currentCellIndex].node.focus();
+
+          // update the month year heading
+          this.dateField.textContent = this._date.toLocaleFormat("%B %Y");
+        ]]>
+        </body>
+      </method>
+
+      <method name="_getPrevDate">
+        <parameter name="aMonth"/>
+        <parameter name="aYear"/>
+        <body>
+          var month, year = aYear;
+
+          if (aMonth == 0) {
+            month = 11
+            year--;
+          } else {
+            month = aMonth - 1;
+          }
+
+          return new Date(year, month);
+        </body>
+      </method>
+
+      <method name="_getNextDate">
+        <parameter name="aMonth"/>
+        <parameter name="aYear"/>
+        <body>
+          var month, year = aYear;
+
+          if (aMonth == 11) {
+            month = 0
+            year++;
+          } else {
+            month = aMonth + 1;
+          }
+
+          return new Date(year, month);
+        </body>
+      </method>
+
+      <method name="_getDaysInMonth">
+        <parameter name="aMonth"/>
+        <parameter name="aYear"/>
+        <body>
+        <![CDATA[
+          var days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
+
+          // check for leap year
+          if ((aYear % 4 == 0 && aYear % 100 != 0) || aYear % 400 == 0)
+            days[1] = 29;
+
+          return days[aMonth];
+        ]]>
+        </body>
+      </method>
+
+      <method name="goBack">
+        <parameter name="aCalledFromButton"/>
+        <body>
+        <![CDATA[
+          var day = parseInt(this._cells[this._currentCellIndex].node.textContent);
+          this._date = this._getPrevDate(this._date.getMonth(), this._date.getFullYear());
+          this._refreshCells(this._date, day, aCalledFromButton);
+        ]]>
+        </body>
+      </method>
+
+      <method name="goForward">
+        <parameter name="aCalledFromButton"/>
+        <body>
+        <![CDATA[
+          var day = parseInt(this._cells[this._currentCellIndex].node.textContent);
+          this._date = this._getNextDate(this._date.getMonth(), this._date.getFullYear());
+          this._refreshCells(this._date, day, aCalledFromButton);
+        ]]>
+        </body>
+      </method>
+
+      <method name="selectCell">
+        <parameter name="aCellNum"/>
+        <body>
+        <![CDATA[
+          if (aCellNum == this._currentCellIndex)
+            return;
+
+          this._cells[this._currentCellIndex].node.setAttribute("tabindex", "-1");
+
+          this._currentCellIndex = aCellNum;
+
+          this._cells[this._currentCellIndex].node.setAttribute("tabindex", "0");
+          this._cells[this._currentCellIndex].node.focus();
+        ]]>
+        </body>
+      </method>
+
+      <method name="_valueSet">
+        <body>
+        <![CDATA[
+          // called when a cell is choosen (enter or mouse click)
+          var value = this._cells[this._currentCellIndex].node.textContent;
+
+          var date = new Date(this._date.getFullYear(), this._date.getMonth(),
+                              parseInt(value));
+          this.inputField.value = date.toLocaleFormat("%Y-%m-%d");
+
+          this._hidePicker(true);
+        ]]>
+        </body>
+      </method>
+
+    </implementation>
+
+    <handlers>
+      <handler event="keypress">
+      <![CDATA[
+        // first we handle events that will always toggle the picker dropdown -
+        // F4 and alt-down/up
+        if (event.keyCode == event.DOM_VK_F4 ||
+            event.altKey && (event.keyCode == event.DOM_VK_DOWN || 
+                             event.keyCode == event.DOM_VK_UP)) {
+          // first set the accessor value, since the input's value hasn't
+          // been validated yet, and forcing this will.
+          this.accessors.setValue(this.inputField.value);
+
+          this._togglePicker();
+        } else if (this._isPickerVisible) {
+          // handle events if the picker dropdown is visible - we always
+          // hide the picker if focus returns to the input
+          var index = this._currentCellIndex;
+          var currentElement = event.originalTarget;
+
+          if (event.keyCode == event.DOM_VK_DOWN) {
+            if (currentElement.localName == "input") {
+              // if we are on the button, down should focus the current selected
+              // cell
+              this.selectCell(this._currentCellIndex);
+            } else if ((index + 7) < this._cells.length) {
+              this.selectCell(index + 7);
+            }
+          } else if (event.keyCode == event.DOM_VK_UP) {
+            // td means we are on a cell
+            if (currentElement.localName == "td" && (index - 7) >= 0) {
+              this.selectCell(index - 7);
+            } else {
+              // focus the back button
+              document.getAnonymousElementByAttribute(this, "anonid", "back-button").focus();
+            }
+          } else if (event.keyCode == event.DOM_VK_LEFT) {
+            // ctrl-left goes back a month
+            if (event.ctrlKey) {
+              this.goBack();
+            } else if (currentElement.localName == "input") {
+              // input means we are on one of the back/fwd buttons
+              document.getAnonymousElementByAttribute(this, "anonid", "back-button").focus();
+            } else if ((index - 1) >= 0) {
+              this.selectCell(index - 1);
+            }
+          } else if (event.keyCode == event.DOM_VK_RIGHT) {
+            // ctrl-right goes forward a month
+            if (event.ctrlKey) {
+              this.goForward();
+            } else if (currentElement.localName == "input") {
+              // input means we are on one of the back/fwd buttons
+              document.getAnonymousElementByAttribute(this, "anonid", "fwd-button").focus();
+            } else if ((index + 1) < this._cells.length) {
+              this.selectCell(index + 1);
+            }
+          } else if (event.keyCode == event.DOM_VK_RETURN &&
+                     event.originalTarget.localName == "td") {
+            var type = event.originalTarget.className;
+            if (type == "currentMonth") {
+              this.selectCell(event.originalTarget.getAttribute("num"));
+              this._valueSet();
+            } else if (type == "prevMonth") {
+              this.goBack();
+            } else if (type == "nextMonth") {
+              this.goForward();
+            }
+          } else if (event.keyCode == event.DOM_VK_ESCAPE) {
+            this._hidePicker(true);
+          }
+        } else {
+          // pressing down if the picker is hidden will show it
+          if (event.keyCode == event.DOM_VK_DOWN)
+            // first set the accessor value, since the input's value hasn't
+            // been validated yet, and forcing this will.
+            this.accessors.setValue(this.inputField.value);
+
+            this._showPicker();
+          }
+        }
+      ]]>
+      </handler>
+
+      <handler event="mousedown">
+      <![CDATA[
+        if (event.originalTarget.localName == "td") {
+          var type = event.originalTarget.className;
+          var cell = parseInt(event.originalTarget.getAttribute("num"));
+
+          if (type == "currentMonth") {
+            this.selectCell(cell);
+            this._valueSet();
+          } else if (type == "prevMonth") {
+            this._currentCellIndex = cell;
+            this.goBack();
+          } else if (type == "nextMonth") {
+            this._currentCellIndex = cell;
+            this.goForward();
+          }
+        }
+      ]]>
+      </handler>
+
+      <handler event="xforms-next">
+      <![CDATA[
+        this._hidePicker(false);
+      ]]>
+      </handler>
+
+      <handler event="xforms-previous">
+      <![CDATA[
+        this._hidePicker(false);
+      ]]>
+      </handler>
+    </handlers>
+  </binding>
+
+ <!-- INPUT: Month -->
+  <binding id="xformswidget-input-month"
+           extends="chrome://xforms/content/xforms.xml#xformswidget-base">
+    <content>
+      <children/>
+      <html:select anonid="control" xbl:inherits="style, accesskey"
+                   onchange="this.parentNode._change();"
+                   onblur="this.parentNode._setValue()">
+        <html:option value=""></html:option>
+      </html:select>
+    </content>
+
+    <implementation implements="nsIXFormsUIWidget">
+
+      <constructor>
+        <![CDATA[
+          this._build();
+        ]]>
+      </constructor>
+
+      <method name="refresh">
+        <body>
+        <![CDATA[
+          this.select.readonly = this.accessors.isReadonly();
+
+          if (this.accessors.isValid())
+            this.select.value = this.stringValue.substr(2,2)
+          else
+            this.select.value = "";
+
+          return true;
+        ]]>
+        </body>
+      </method>
+
+      <method name="_build">
+        <body>
+        <![CDATA[
+         // create the select options
+         var xhtmlNS = "http://www.w3.org/1999/xhtml";
+
+         var date = new Date();
+         var option, monthName;
+         for (var i = 0; i < 12; i++) {
+           option = document.createElementNS(xhtmlNS, "option");
+
+           var value = i + 1;
+           if (value < 10)
+             value = "0" + value;
+           option.setAttribute("value", value);
+
+           date.setMonth(i);
+           monthName = date.toLocaleFormat("%B");
+
+           var txt = document.createTextNode(monthName);
+           option.appendChild(txt);
+           this.select.appendChild(option);
+         }
+
+         this.refresh();
+        ]]>
+        </body>
+      </method>
+
+      <method name="_change">
+        <body>
+          if (this.getAttribute("incremental") == "true") {
+            this._setValue();
+          }
+        </body>
+      </method>
+
+      <method name="_setValue">
+        <body>
+          if (this.select.value != "")
+            this.accessors.setValue("--" + this.select.value);
+          else
+            this.accessors.setValue("");
+        </body>
+      </method>
+
+      <field name="_select">null</field>
+      <property name="select" readonly="true">
+        <getter>
+          if (!this._select) {
+            this._select =
+              document.getAnonymousElementByAttribute(this, "anonid", "control");
+          }
+          return this._select;
+        </getter>
+      </property>
+    </implementation>
+  </binding>
+
+  <!-- INPUT: Day -->
+  <binding id="xformswidget-input-day"
+           extends="chrome://xforms/content/xforms.xml#xformswidget-base">
+    <content>
+      <children/>
+      <html:select anonid="control" xbl:inherits="style, accesskey"
+                   onchange="this.parentNode._change();"
+                   onblur="this.parentNode._setValue()">
+        <html:option value=""></html:option>
+      </html:select>
+    </content>
+
+    <implementation implements="nsIXFormsUIWidget">
+
+      <constructor>
+        <![CDATA[
+          this._build();
+        ]]>
+      </constructor>
+
+      <method name="refresh">
+        <body>
+        <![CDATA[
+          this.select.readonly = this.accessors.isReadonly();
+
+          if (this.accessors.isValid())
+            this.select.value = this.stringValue.substr(3,2)
+          else
+            this.select.value = "";
+
+          return true;
+        ]]>
+        </body>
+      </method>
+
+      <method name="_build">
+        <body>
+        <![CDATA[
+         // create the select options
+         var xhtmlNS = "http://www.w3.org/1999/xhtml";
+
+         var date = new Date();
+         var option, monthName;
+         for (var i = 0; i < 31; i++) {
+           option = document.createElementNS(xhtmlNS, "option");
+
+           var value = i + 1;
+           option.textContent = value;
+
+           if (value < 10)
+             value = "0" + value;
+           option.setAttribute("value", value);
+
+           this.select.appendChild(option);
+         }
+
+         this.refresh();
+        ]]>
+        </body>
+      </method>
+
+      <method name="_change">
+        <body>
+          if (this.getAttribute("incremental") == "true") {
+            this._setValue();
+          }
+        </body>
+      </method>
+
+      <method name="_setValue">
+        <body>
+          if (this.select.value != "")
+            this.accessors.setValue("---" + this.select.value);
+          else
+            this.accessors.setValue("");
+        </body>
+      </method>
+
+      <field name="_select">null</field>
+      <property name="select" readonly="true">
+        <getter>
+          if (!this._select) {
+            this._select =
+              document.getAnonymousElementByAttribute(this, "anonid", "control");
+          }
+          return this._select;
+        </getter>
+      </property>
+    </implementation>
+  </binding>
 
   <!-- SECRET: <DEFAULT> -->
   <binding id="xformswidget-secret"
@@ -280,7 +1077,7 @@
         <body>
           this.inputField.setAttribute("type","password");
           this.inputField.value = this.stringValue;
-          this.inputField.readonly = this.delegate.isReadonly;
+          this.inputField.readonly = this.accessors.isReadonly();
           return true;
         </body>
       </method>
@@ -293,7 +1090,8 @@
     <content>
       <children includes="label"/>
       <html:textarea anonid="control"
-                     onblur="this.parentNode.delegate.value = this.value; this.parentNode.dispatchDOMUIEvent('DOMFocusOut')"
+                     class="xf-value"
+                     onblur="this.parentNode.accessors.setValue(this.value); this.parentNode.dispatchDOMUIEvent('DOMFocusOut')"
                      onfocus="this.parentNode.dispatchDOMUIEvent('DOMFocusIn')"
                      onkeyup="this.parentNode._change();"
                      xbl:inherits="accesskey"/>
@@ -315,7 +1113,11 @@
 
       <method name="refresh">
         <body>
-          this.controlField.readonly = this.delegate.isReadonly;
+          if (this.accessors.isReadonly()) {
+            this.controlField.setAttribute("readonly", "readonly");
+          } else {
+            this.controlField.removeAttribute("readonly");
+          }
           // If the value has not changed, no need to update the
           // value of the control, because that makes the textarea widget
           // to scroll up.
@@ -329,7 +1131,7 @@
       <method name="_change">
         <body>
           if (this.getAttribute("incremental") == "true") {
-            this.delegate.value = this.controlField.value;
+            this.accessors.setValue(this.controlField.value);
           }
           return true;
         </body>
@@ -455,8 +1257,8 @@
     <content>
       <children includes="label"/>
       <html:input anonid="upload_text_control"
-                  readonly="true"
-                  xbl:inherits="accesskey"/>
+                  class="xf-value"
+                  readonly="true"/>
       <html:button anonid="upload_browse_button"
                    type="button"
                    onclick="this.parentNode.uploadElem.pickFile();"
@@ -466,7 +1268,7 @@
                    type="button"
                    onclick="this.parentNode.uploadElem.clearFile();"
                    onkeypress="if (event.keyCode == event.DOM_VK_RETURN) this.parentNode.dispatchDOMUIEvent('DOMActivate');"
-                   xbl:inherits="accesskey"> &xforms.upload.cleartext; </html:button>
+                   > &xforms.upload.cleartext; </html:button>
       <children/>
     </content>
 
@@ -544,6 +1346,7 @@
     <content>
       <children includes="label"/>
       <html:input readonly="true"
+                  class="xf-value"
                   xbl:inherits="accesskey"/>
       <html:button type="button"
                    disabled="true"
diff -uprN --exclude=CVS mozilla/extensions/xforms/resources/locale/en-US/xforms.dtd mozilla.new/extensions/xforms/resources/locale/en-US/xforms.dtd
--- mozilla/extensions/xforms/resources/locale/en-US/xforms.dtd	2005-10-23 18:30:14.000000000 +0200
+++ mozilla.new/extensions/xforms/resources/locale/en-US/xforms.dtd	2006-02-14 10:01:13.000000000 +0100
@@ -46,3 +46,5 @@
 
 <!ENTITY xforms.upload.browsetext "Browse...">
 <!ENTITY xforms.upload.cleartext "Clear">
+
+<!ENTITY xforms.datepicker.title "Show Date Picker">
diff -uprN --exclude=CVS mozilla/extensions/xforms/resources/locale/en-US/xforms.properties mozilla.new/extensions/xforms/resources/locale/en-US/xforms.properties
--- mozilla/extensions/xforms/resources/locale/en-US/xforms.properties	2005-10-23 18:30:14.000000000 +0200
+++ mozilla.new/extensions/xforms/resources/locale/en-US/xforms.properties	2006-02-24 11:16:25.000000000 +0100
@@ -58,8 +58,19 @@ labelLink2Error      = XForms Error (19)
 invalidSeparator     = XForms Error (20): Submission separator may only be either "&" or ";", but found "%S".
 instanceBindError    = XForms Error (21): Submission failed trying to replace instance document '%S'.  Instance document doesn't exist in same model as submission element.
 instanceInstanceLoad = XForms Error (22): Instance document trying to load external instance: %S
-encodingMemoryError  = XForms Error (23): Not enough available memory to encode file %S, size = %S.
-uploadBoundTypeError = XForms Error (24): Upload element not bound to valid datatype.  Must be bound to datatype 'xsd:anyURI', 'xsd:base64Binary', or 'xsd:hexBinary'.
+rangeSetSliderNaN    = XForms Error (23): NaN passed to setSlider()
+rangeNullObjects     = XForms Error (24): One or more of the passed objects were null
+rangeNullInit        = XForms Error (25): One or more init() parameters is NaN
+rangeBeginEndError   = XForms Error (26): Begin is higher than end?
+encodingMemoryError  = XForms Error (27): Not enough available memory to encode file %S, size = %S.
+uploadBoundTypeError = XForms Error (28): Upload element not bound to valid datatype.  Must be bound to datatype 'xsd:anyURI', 'xsd:base64Binary', or 'xsd:hexBinary'.
+copyError            = XForms Error (29): A copy element was found whose parent is not an itemset element
+submitMailtoInit     = XForms Error (30): No mailto: handler found
+submitMailtoFailed   = XForms Error (31): Failed to load a mail client for a mailto: submission
+invalidQName         = XForms Error (32): Failed to create node.  %S is not a valid QName.
+
+# Warning Messages:
+warnMailtoBodyParam  = XForms Warning (1): The submission action uri already contains a body parameter.
 
 # XForms Permission Messages:
 xformsXDPermissionDialogTitle = Allowed Sites - XForms Cross Domain Access
diff -uprN --exclude=CVS mozilla/gfx/public/nsTransform2D.h mozilla.new/gfx/public/nsTransform2D.h
--- mozilla/gfx/public/nsTransform2D.h	2004-05-18 20:09:12.000000000 +0200
+++ mozilla.new/gfx/public/nsTransform2D.h	2006-03-03 07:14:21.000000000 +0100
@@ -250,6 +250,9 @@ public:
   **/
 
   void AddScale(float ptX, float ptY);
+
+private:
+  nscoord ToCoordRound(float aCoord);
 };
 
 #endif
diff -uprN --exclude=CVS mozilla/gfx/src/gtk/nsFontMetricsPango.cpp mozilla.new/gfx/src/gtk/nsFontMetricsPango.cpp
--- mozilla/gfx/src/gtk/nsFontMetricsPango.cpp	2005-09-16 08:16:02.000000000 +0200
+++ mozilla.new/gfx/src/gtk/nsFontMetricsPango.cpp	2006-02-24 11:16:41.000000000 +0100
@@ -36,6 +36,7 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
+#include <strings.h>
 #include "nsFont.h"
 #include "nsIDeviceContext.h"
 #include "nsICharsetConverterManager.h"
@@ -981,7 +982,7 @@ nsFontMetricsPango::GetPosition(const PR
 
     // Jump to the end if it's not found.
     if (!found) {
-        if (inx = 0)
+        if (inx == 0)
             retval = 0;
         else if (trailing)
             retval = aLength;
diff -uprN --exclude=CVS mozilla/gfx/src/nsTransform2D.cpp mozilla.new/gfx/src/nsTransform2D.cpp
--- mozilla/gfx/src/nsTransform2D.cpp	2005-03-28 23:03:01.000000000 +0200
+++ mozilla.new/gfx/src/nsTransform2D.cpp	2006-03-03 07:14:21.000000000 +0100
@@ -433,7 +433,12 @@ void nsTransform2D :: TransformCoord(nsc
 
     case MG_2DSCALE | MG_2DTRANSLATION:
       *ptX = NSToCoordRound(*ptX * m00 + m20);
+
+#if defined(_MSC_VER) && _MSC_VER < 1300
+      *ptY = ToCoordRound(*ptY * m11 + m21);
+#else
       *ptY = NSToCoordRound(*ptY * m11 + m21);
+#endif
       break;
 
     default:
@@ -575,3 +580,9 @@ void nsTransform2D :: AddScale(float ptX
 
   type |= MG_2DSCALE;
 }
+
+nscoord nsTransform2D::ToCoordRound(float aCoord)
+{
+  return NSToCoordRound(aCoord);
+}
+
diff -uprN --exclude=CVS mozilla/gfx/src/windows/nsDrawingSurfaceWin.cpp mozilla.new/gfx/src/windows/nsDrawingSurfaceWin.cpp
--- mozilla/gfx/src/windows/nsDrawingSurfaceWin.cpp	2005-03-07 03:35:47.000000000 +0100
+++ mozilla.new/gfx/src/windows/nsDrawingSurfaceWin.cpp	2006-02-24 11:16:41.000000000 +0100
@@ -565,17 +565,17 @@ BITMAPINFO * nsDrawingSurfaceWin :: Crea
       mPixFormat.mGreenZeroMask = 0xff;
       mPixFormat.mBlueZeroMask = 0xff;
       mPixFormat.mAlphaZeroMask = 0;
-      mPixFormat.mRedMask = 0xff;
+      mPixFormat.mRedMask = 0xff0000;
       mPixFormat.mGreenMask = 0xff00;
-      mPixFormat.mBlueMask = 0xff0000;
+      mPixFormat.mBlueMask = 0xff;
       mPixFormat.mAlphaMask = 0;
       mPixFormat.mRedCount = 8;
       mPixFormat.mGreenCount = 8;
       mPixFormat.mBlueCount = 8;
       mPixFormat.mAlphaCount = 0;
-      mPixFormat.mRedShift = 0;
+      mPixFormat.mRedShift = 16;
       mPixFormat.mGreenShift = 8;
-      mPixFormat.mBlueShift = 16;
+      mPixFormat.mBlueShift = 0;
       mPixFormat.mAlphaShift = 0;
       
       break;
diff -uprN --exclude=CVS mozilla/gfx/src/windows/nsFontMetricsWin.cpp mozilla.new/gfx/src/windows/nsFontMetricsWin.cpp
--- mozilla/gfx/src/windows/nsFontMetricsWin.cpp	2005-08-30 02:28:18.000000000 +0200
+++ mozilla.new/gfx/src/windows/nsFontMetricsWin.cpp	2006-02-24 11:16:41.000000000 +0100
@@ -1305,7 +1305,7 @@ static PRUint8 gBitToUnicodeRange[] = 
  /* 66 */ kRangeArabic,                 // fe50 - fe6f     Small Form Variants
  /* 67 */ kRangeArabic,                 // fe70 - fefe     Arabic Presen. FormsB
  /* 68 */ kRangeSetCJK,                 // ff00 - ffef     Half/Fullwidth Forms
- /* 69 */ kRangeSetCJK,                 // fff0 - fffd     Specials
+ /* 69 */ kRangeSpecials,               // fff0 - fffd     Specials
  /* 70 */ kRangeTibetan,                // 0f00 - 0fcf     Tibetan
  /* 71 */ kRangeSyriac,                 // 0700 - 074f     Syriac
  /* 72 */ kRangeThaana,                 // 0780 - 07bf     Thaana
@@ -2716,6 +2716,9 @@ nsFontMetricsWin::SameAsPreviousMap(int 
     if (tmp->flags & NS_GLOBALFONT_SKIP) {
       continue;
     }
+    if (!tmp->ccmap) {
+      continue;
+    }
     if (tmp->ccmap == font->ccmap) {
       font->flags |= NS_GLOBALFONT_SKIP;
       return 1;
@@ -2730,6 +2733,24 @@ nsFontMetricsWin::SameAsPreviousMap(int 
   return 0;
 }
 
+#ifndef WINCE
+static
+void BitFromUnicodeRange(PRUint32 range, DWORD* usb)
+{
+  for (int i = 0, dword = 0; dword < 3; ++dword) {
+    for (int bit = 0; bit < sizeof(DWORD) * 8; ++bit, ++i) {
+      if (range == gBitToUnicodeRange[i]) {
+        usb[dword] |= 1 << bit;
+      }
+    }
+  }
+}
+#endif
+
+#ifdef DEBUG_emk
+static LARGE_INTEGER freq, prev;
+#endif
+
 nsFontWin*
 nsFontMetricsWin::FindGlobalFont(HDC aDC, PRUint32 c)
 {
@@ -2739,6 +2760,12 @@ nsFontMetricsWin::FindGlobalFont(HDC aDC
       return nsnull;
     }
   }
+#ifndef WINCE
+  PRUint32 range = (c <= 0xFFFF) ? FindCharUnicodeRange(c) : kRangeSurrogate;
+  DWORD usb[4];
+  memset(usb, 0, sizeof(usb));
+  BitFromUnicodeRange(range, usb);
+#endif
   int count = gGlobalFonts->Count();
   for (int i = 0; i < count; ++i) {
     nsGlobalFont* font = (nsGlobalFont*)gGlobalFonts->ElementAt(i);
@@ -2746,6 +2773,15 @@ nsFontMetricsWin::FindGlobalFont(HDC aDC
       continue;
     }
     if (!font->ccmap) {
+#ifndef WINCE
+      // bail out if Unicode range indicates the font have no glyph
+      if (font->flags & NS_GLOBALFONT_TRUETYPE &&
+          !(font->signature.fsUsb[0] & usb[0]) &&
+          !(font->signature.fsUsb[1] & usb[1]) &&
+          !(font->signature.fsUsb[2] & usb[2])) {
+        continue;
+      }
+#endif
       // don't adjust here, we just want to quickly get the CMAP. Adjusting
       // is meant to only happen when loading the final font in LoadFont()
       HFONT hfont = ::CreateFontIndirect(&font->logFont);
@@ -2761,14 +2797,28 @@ nsFontMetricsWin::FindGlobalFont(HDC aDC
         font->flags |= NS_GLOBALFONT_SKIP;
         continue;
       }
+#ifdef DEBUG_emk
+      LARGE_INTEGER now;
+      QueryPerformanceCounter(&now);
+      printf("CCMAP loaded: %g sec, %s [%08X][%08X][%08X]\n", (now.QuadPart - prev.QuadPart) / (double)freq.QuadPart,
+        font->logFont.lfFaceName, font->signature.fsUsb[0], font->signature.fsUsb[1], font->signature.fsUsb[2]);
+      prev = now;
+#endif
       if (SameAsPreviousMap(i)) {
         continue;
       }
     }
     if (CCMAP_HAS_CHAR_EXT(font->ccmap, c)) {
+#ifdef DEBUG_emk
+      printf("font found:[%s]\n", font->logFont.lfFaceName);
+      printf("U+%04X (%d)[%08X][%08X][%08X]\n", c, range, usb[0], usb[1], usb[2]);
+#endif
       return LoadGlobalFont(aDC, font);
     }
   }
+#ifdef DEBUG_emk
+  printf("U+%04X (%d)[%08X][%08X][%08X]\n", c, range, usb[0], usb[1], usb[2]);
+#endif
   return nsnull;
 }
 
@@ -3541,6 +3591,11 @@ nsFontMetricsWin::FindPrefFont(HDC aDC, 
 nsFontWin*
 nsFontMetricsWin::FindFont(HDC aDC, PRUint32 aChar)
 {
+#ifdef DEBUG_emk
+  LARGE_INTEGER start, end;
+  QueryPerformanceFrequency(&freq);
+  QueryPerformanceCounter(&start);
+#endif
   // the first font should be for invisible ignorable characters
   if (mLoadedFonts.Count() < 1)
     mLoadedFonts.AppendElement(gFontForIgnorable);
@@ -3555,8 +3610,15 @@ nsFontMetricsWin::FindFont(HDC aDC, PRUi
       if (!font) {
         font = FindPrefFont(aDC, aChar);
         if (!font) {
+#ifdef DEBUG_emk
+          QueryPerformanceCounter(&prev);
+#endif
           font = FindGlobalFont(aDC, aChar);
           if (!font) {
+#ifdef DEBUG_emk
+            QueryPerformanceCounter(&end);
+            printf("%g sec.\n", (end.QuadPart - start.QuadPart) / (double)freq.QuadPart);
+#endif
             font = FindSubstituteFont(aDC, aChar);
           }
         }
@@ -4622,27 +4684,40 @@ GenerateSingleByte(nsCharsetInfo* aSelf)
   int i;
 
   memset(map, 0, sizeof(map));
-  memset(mb + 128, 0, 160 - 128);
-  for (i = 0; i < 127; ++i) {
-    mb[i] = i;
-  }
-  mb[145] = 145;
-  mb[146] = 146;
-
-  if (aSelf->mCodePage == 1250) {
-    mb[138] = 138;
-    mb[140] = 140;
-    mb[141] = 141;
-    mb[142] = 142;
-    mb[143] = 143;
-    mb[154] = 154;
-    mb[156] = 156;
-    mb[158] = 158;
-    mb[159] = 159;
-  }
+  if (UseAFunctions()) {
+    // A-functions use this function for TrueType
+    for (i = 0; i <= 255; ++i) {
+      mb[i] = i;
+    }
+  } else {
+    memset(mb + 128, 0, 160 - 128);
+    for (i = 0; i <= 127; ++i) {
+      mb[i] = i;
+    }
+    mb[145] = 145;
+    mb[146] = 146;
+
+    if (aSelf->mCodePage == 1250) {
+      mb[138] = 138;
+      mb[140] = 140;
+      mb[141] = 141;
+      mb[142] = 142;
+      mb[143] = 143;
+      mb[154] = 154;
+      mb[156] = 156;
+      mb[158] = 158;
+      mb[159] = 159;
+    }
+
+    for (i = 160; i <= 255; ++i) {
+      mb[i] = i;
+    }
 
-  for (i = 160; i < 255; ++i) {
-    mb[i] = i;
+    //win95/98 have problem in some raster fonts (MS Sans Serif and MS Serif) in
+    //rendering 0xb7. So let's skip this in charmap, that will let system resort 
+    //to other fonts.  
+    if (IsWin95OrWin98())
+      mb[0xb7] = 0;
   }
 
   int len = MultiByteToWideChar(aSelf->mCodePage, 0, (char*) mb, 256, wc, 256);
@@ -4651,12 +4726,7 @@ GenerateSingleByte(nsCharsetInfo* aSelf)
     printf("%s: MultiByteToWideChar returned %d\n", aSelf->mName, len);
   }
 #endif
-  for (i = 0; i < 256; ++i) {
-    //win95/98 have problem in some raster fonts (MS Sans Serif and MS Serif) in
-    //rendering 0xb7. So let's skip this in charmap, that will let system resort 
-    //to other fonts.  
-    if ( i == 0x00b7 && IsWin95OrWin98() && !UseAFunctions())
-      continue;
+  for (i = 0; i <= 255; ++i) {
     ADD_GLYPH(map, wc[i]);
   }
   return MapToCCMap(map);
@@ -5594,7 +5664,23 @@ SignatureMatchesLangGroup(FONTSIGNATURE*
 static int
 FontMatchesGenericType(nsGlobalFont* aFont, const char* aGeneric)
 {
-  switch (aFont->logFont.lfPitchAndFamily & 0xF0) {
+  PRUint8 family = aFont->logFont.lfPitchAndFamily & 0xF0;
+  PRUint8 pitch = aFont->logFont.lfPitchAndFamily & 0x0F;
+
+  // Japanese 'Mincho' fonts do not belong to FF_MODERN even if
+  // they are fixed pitch because they have variable stroke width.
+  if (family == FF_ROMAN && pitch & FIXED_PITCH) {
+    return !strcmp(aGeneric, "monospace");
+  }
+
+  // Japanese 'Gothic' fonts do not belong to FF_SWISS even if
+  // they are variable pitch because they have constant stroke width.
+  if (family == FF_MODERN && pitch & VARIABLE_PITCH) {
+    return !strcmp(aGeneric, "sans-serif");
+  }
+
+  // All other fonts will be grouped correctly using family...
+  switch (family) {
     case FF_DONTCARE:   return 1;
     case FF_ROMAN:      return !strcmp(aGeneric, "serif");
     case FF_SWISS:      return !strcmp(aGeneric, "sans-serif");
diff -uprN --exclude=CVS mozilla/gfx/src/windows/nsUnicodeRange.cpp mozilla.new/gfx/src/windows/nsUnicodeRange.cpp
--- mozilla/gfx/src/windows/nsUnicodeRange.cpp	2005-04-30 04:57:56.000000000 +0200
+++ mozilla.new/gfx/src/windows/nsUnicodeRange.cpp	2006-02-24 11:16:41.000000000 +0100
@@ -206,7 +206,7 @@ const char *gUnicodeRangeToLangGroupTabl
 
 
 
-#define NUM_OF_SUBTABLES      7
+#define NUM_OF_SUBTABLES      8
 #define SUBTABLE_SIZE         16
 
 static PRUint8 gUnicodeSubrangeTable[NUM_OF_SUBTABLES][SUBTABLE_SIZE] = 
@@ -339,8 +339,26 @@ static PRUint8 gUnicodeSubrangeTable[NUM
                              //                CJK compatibility forms, 
                              //                small form variants
     
-    kRangeSetCJK,            //uffxx, halfwidth and fullwidth forms, includes Special
-  }
+    kRangeTableBase+7,       //uffxx, halfwidth and fullwidth forms, includes Special
+  },
+  { //table for 0xff00 - 0xffff
+    kRangeSetCJK,            //uff0x, fullwidth latin
+    kRangeSetCJK,            //uff1x, fullwidth latin
+    kRangeSetCJK,            //uff2x, fullwidth latin
+    kRangeSetCJK,            //uff3x, fullwidth latin
+    kRangeSetCJK,            //uff4x, fullwidth latin
+    kRangeSetCJK,            //uff5x, fullwidth latin
+    kRangeSetCJK,            //uff6x, halfwidth katakana
+    kRangeSetCJK,            //uff7x, halfwidth katakana
+    kRangeSetCJK,            //uff8x, halfwidth katakana
+    kRangeSetCJK,            //uff9x, halfwidth katakana
+    kRangeSetCJK,            //uffax, halfwidth hangul jamo
+    kRangeSetCJK,            //uffbx, halfwidth hangul jamo
+    kRangeSetCJK,            //uffcx, halfwidth hangul jamo
+    kRangeSetCJK,            //uffdx, halfwidth hangul jamo
+    kRangeSetCJK,            //uffex, fullwidth symbols
+    kRangeSpecials,          //ufffx, Specials
+  },
 };
 
 // Most scripts between U+0700 and U+16FF are assigned a chunk of 128 (0x80) 
@@ -407,9 +425,11 @@ PRUint32 FindCharUnicodeRange(PRUnichar 
 
   // otherwise, we have one more table to look at
   range = gUnicodeSubrangeTable[range - kRangeTableBase][(ch & 0x0f00) >> 8];
+  if (range < kRangeTableBase)
+    return range;
   if (range < kRangeTertiaryTable)
-    return range;     
+    return gUnicodeSubrangeTable[range - kRangeTableBase][(ch & 0x00f0) >> 4];
 
   // Yet another table to look at : U+0700 - U+16FF : 128 code point blocks
-  return  gUnicodeTertiaryRangeTable[(ch - 0x0700) >> 7];
+  return gUnicodeTertiaryRangeTable[(ch - 0x0700) >> 7];
 }
diff -uprN --exclude=CVS mozilla/gfx/src/windows/nsUnicodeRange.h mozilla.new/gfx/src/windows/nsUnicodeRange.h
--- mozilla/gfx/src/windows/nsUnicodeRange.h	2005-04-30 04:57:56.000000000 +0200
+++ mozilla.new/gfx/src/windows/nsUnicodeRange.h	2006-02-24 11:16:41.000000000 +0100
@@ -102,6 +102,7 @@ const PRUint8   kRangeDingbats          
 const PRUint8   kRangeBraillePattern       = 54;
 const PRUint8   kRangeYi                   = 55;
 const PRUint8   kRangeCombiningDiacriticalMarks = 56;
+const PRUint8   kRangeSpecials             = 57;
 
 const PRUint8   kRangeTableBase   = 128;    //values over 127 are reserved for internal use only
 const PRUint8   kRangeTertiaryTable  = 145; // leave room for 16 subtable 
diff -uprN --exclude=CVS mozilla/js/src/jsapi.c mozilla.new/js/src/jsapi.c
--- mozilla/js/src/jsapi.c	2005-11-01 03:18:51.000000000 +0100
+++ mozilla.new/js/src/jsapi.c	2006-02-24 11:16:27.000000000 +0100
@@ -1877,6 +1877,19 @@ JS_IsAboutToBeFinalized(JSContext *cx, v
     return js_IsAboutToBeFinalized(cx, thing);
 }
 
+JS_PUBLIC_API(void)
+JS_SetGCParameter(JSRuntime *rt, JSGCParamKey key, uint32 value)
+{
+    switch (key) {
+      case JSGC_MAX_BYTES:
+        rt->gcMaxBytes = value;
+        break;
+      case JSGC_MAX_MALLOC_BYTES:
+        rt->gcMaxMallocBytes = value;
+        break;
+    }
+}
+
 JS_PUBLIC_API(intN)
 JS_AddExternalStringFinalizer(JSStringFinalizeOp finalizer)
 {
@@ -2001,6 +2014,7 @@ JS_InitClass(JSContext *cx, JSObject *ob
 {
     JSAtom *atom;
     JSObject *proto, *ctor;
+    JSTempValueRooter tvr;
     jsval cval, rval;
     JSBool named;
     JSFunction *fun;
@@ -2015,8 +2029,8 @@ JS_InitClass(JSContext *cx, JSObject *ob
     if (!proto)
         return NULL;
 
-    if (!js_EnterLocalRootScope(cx))
-        goto bad2;
+    /* After this point, control must exit via label bad or out. */
+    JS_PUSH_SINGLE_TEMP_ROOT(cx, OBJECT_TO_JSVAL(proto), &tvr);
 
     if (!constructor) {
         /* Lacking a constructor, name the prototype (e.g., Math). */
@@ -2078,17 +2092,16 @@ JS_InitClass(JSContext *cx, JSObject *ob
         (static_fs && !JS_DefineFunctions(cx, ctor, static_fs))) {
         goto bad;
     }
-    js_LeaveLocalRootScope(cx);
+
+out:
+    JS_POP_TEMP_ROOT(cx, &tvr);
     return proto;
 
 bad:
-    js_LeaveLocalRootScope(cx);
     if (named)
         (void) OBJ_DELETE_PROPERTY(cx, obj, ATOM_TO_JSID(atom), &rval);
-
-bad2:
-    cx->newborn[GCX_OBJECT] = NULL;
-    return NULL;
+    proto = NULL;
+    goto out;
 }
 
 #ifdef JS_THREADSAFE
@@ -4145,7 +4158,7 @@ JS_CallFunctionName(JSContext *cx, JSObj
         return JS_FALSE;
     ok = js_InternalCall(cx, obj, fval, argc, argv, rval);
     LAST_FRAME_CHECKS(cx, ok);
-    return JS_TRUE;
+    return ok;
 }
 
 JS_PUBLIC_API(JSBool)
diff -uprN --exclude=CVS mozilla/js/src/jsapi.h mozilla.new/js/src/jsapi.h
--- mozilla/js/src/jsapi.h	2005-10-22 01:30:15.000000000 +0200
+++ mozilla.new/js/src/jsapi.h	2006-02-24 11:16:27.000000000 +0100
@@ -739,6 +739,14 @@ JS_SetGCCallbackRT(JSRuntime *rt, JSGCCa
 extern JS_PUBLIC_API(JSBool)
 JS_IsAboutToBeFinalized(JSContext *cx, void *thing);
 
+typedef enum JSGCParamKey {
+    JSGC_MAX_BYTES        = 0,  /* maximum nominal heap before last ditch GC */
+    JSGC_MAX_MALLOC_BYTES = 1   /* # of JS_malloc bytes before last ditch GC */
+} JSGCParamKey;
+
+extern JS_PUBLIC_API(void)
+JS_SetGCParameter(JSRuntime *rt, JSGCParamKey key, uint32 value);
+
 /*
  * Add a finalizer for external strings created by JS_NewExternalString (see
  * below) using a type-code returned from this function, and that understands
diff -uprN --exclude=CVS mozilla/js/src/jscntxt.h mozilla.new/js/src/jscntxt.h
--- mozilla/js/src/jscntxt.h	2006-01-11 23:04:47.000000000 +0100
+++ mozilla.new/js/src/jscntxt.h	2006-02-24 11:16:27.000000000 +0100
@@ -84,6 +84,7 @@ struct JSRuntime {
     uint32              gcBytes;
     uint32              gcLastBytes;
     uint32              gcMaxBytes;
+    uint32              gcMaxMallocBytes;
     uint32              gcLevel;
     uint32              gcNumber;
     JSPackedBool        gcPoke;
@@ -362,6 +363,62 @@ typedef struct JSLocalRootStack {
 
 #define JSLRS_NULL_MARK ((uint32) -1)
 
+typedef struct JSTempValueRooter JSTempValueRooter;
+
+/*
+ * If count is -1, then u.value contains the single value to root.  Otherwise
+ * u.array points to a stack-allocated vector of jsvals.  Note that the vector
+ * may have length 0 or 1 for full generality, so we need -1 to discriminate
+ * the union.
+ *
+ * If you need to protect a result value that flows out of a C function across
+ * several layers of other functions, use the js_LeaveLocalRootScopeWithResult
+ * internal API (see further below) instead.
+ */
+struct JSTempValueRooter {
+    JSTempValueRooter   *down;
+    jsint               count;
+    union {
+        jsval           value;
+        jsval           *array;
+    } u;
+};
+
+#define JS_PUSH_TEMP_ROOT_COMMON(cx,tvr)                                      \
+    JS_BEGIN_MACRO                                                            \
+        JS_ASSERT((cx)->tempValueRooters != (tvr));                           \
+        (tvr)->down = (cx)->tempValueRooters;                                 \
+        (cx)->tempValueRooters = (tvr);                                       \
+    JS_END_MACRO
+
+#define JS_PUSH_SINGLE_TEMP_ROOT(cx,val,tvr)                                  \
+    JS_BEGIN_MACRO                                                            \
+        JS_PUSH_TEMP_ROOT_COMMON(cx, tvr);                                    \
+        (tvr)->count = -1;                                                    \
+        (tvr)->u.value = (val);                                               \
+    JS_END_MACRO
+
+#define JS_PUSH_TEMP_ROOT(cx,cnt,arr,tvr)                                     \
+    JS_BEGIN_MACRO                                                            \
+        JS_PUSH_TEMP_ROOT_COMMON(cx, tvr);                                    \
+        (tvr)->count = (cnt);                                                 \
+        (tvr)->u.array = (arr);                                               \
+    JS_END_MACRO
+
+#define JS_POP_TEMP_ROOT(cx,tvr)                                              \
+    JS_BEGIN_MACRO                                                            \
+        JS_ASSERT((cx)->tempValueRooters == (tvr));                           \
+        (cx)->tempValueRooters = (tvr)->down;                                 \
+    JS_END_MACRO
+
+#define JS_TEMP_ROOT_EVAL(cx,cnt,val,expr)                                    \
+    JS_BEGIN_MACRO                                                            \
+        JSTempValueRooter tvr;                                                \
+        JS_PUSH_TEMP_ROOT(cx, cnt, val, &tvr);                                \
+        (expr);                                                               \
+        JS_POP_TEMP_ROOT(cx, &tvr);                                           \
+    JS_END_MACRO
+
 struct JSContext {
     JSCList             links;
 
@@ -482,8 +539,11 @@ struct JSContext {
     /* PDL of stack headers describing stack slots not rooted by argv, etc. */
     JSStackHeader       *stackHeaders;
 
-    /* Optional stack of scoped local GC roots. */
+    /* Optional stack of heap-allocated scoped local GC roots. */
     JSLocalRootStack    *localRootStack;
+
+    /* Stack of thread-stack-allocated temporary GC roots. */
+    JSTempValueRooter   *tempValueRooters;
 };
 
 /*
diff -uprN --exclude=CVS mozilla/js/src/jsdhash.h mozilla.new/js/src/jsdhash.h
--- mozilla/js/src/jsdhash.h	2005-08-19 21:36:57.000000000 +0200
+++ mozilla.new/js/src/jsdhash.h	2006-02-24 11:16:27.000000000 +0100
@@ -45,7 +45,7 @@
 
 JS_BEGIN_EXTERN_C
 
-#if defined(__GNUC__) && defined(__i386__) && (__GNUC__ >= 3) && !defined(XP_OS2) && !defined(XP_MACOSX)
+#if defined(__GNUC__) && defined(__i386__) && (__GNUC__ >= 3) && !defined(XP_OS2)
 #define JS_DHASH_FASTCALL __attribute__ ((regparm (3),stdcall))
 #else
 #define JS_DHASH_FASTCALL
diff -uprN --exclude=CVS mozilla/js/src/jsemit.c mozilla.new/js/src/jsemit.c
--- mozilla/js/src/jsemit.c	2006-01-11 23:04:47.000000000 +0100
+++ mozilla.new/js/src/jsemit.c	2006-03-03 07:13:06.000000000 +0100
@@ -546,7 +546,7 @@ BuildSpanDepTable(JSContext *cx, JSCodeG
     const JSCodeSpec *cs;
     ptrdiff_t len, off;
 
-    pc = CG_BASE(cg);
+    pc = CG_BASE(cg) + cg->spanDepTodo;
     end = CG_NEXT(cg);
     while (pc < end) {
         op = (JSOp)*pc;
@@ -611,6 +611,7 @@ BuildSpanDepTable(JSContext *cx, JSCodeG
 #endif /* JS_HAS_SWITCH_STATEMENT */
         }
 
+        JS_ASSERT(len > 0);
         pc += len;
     }
 
@@ -1037,6 +1038,7 @@ OptimizeSpanDeps(JSContext *cx, JSCodeGe
                 }
             }
         }
+        cg->main.lastNoteOffset += growth;
 
         /*
          * Fix try/catch notes (O(numTryNotes * log2(numSpanDeps)), but it's
@@ -1130,6 +1132,7 @@ OptimizeSpanDeps(JSContext *cx, JSCodeGe
     FreeJumpTargets(cg, cg->jumpTargets);
     cg->jumpTargets = NULL;
     cg->numSpanDeps = cg->numJumpTargets = 0;
+    cg->spanDepTodo = CG_OFFSET(cg);
     return JS_TRUE;
 }
 
@@ -3264,6 +3267,12 @@ js_EmitTree(JSContext *cx, JSCodeGenerat
                 }
                 /* FALL THROUGH */
 
+#if JS_HAS_XML_SUPPORT
+              case TOK_UNARYOP:
+#endif
+#if JS_HAS_LVALUE_RETURN
+              case TOK_LP:
+#endif
               case TOK_LB:
                 /*
                  * We separate the first/next bytecode from the enumerator
@@ -3289,6 +3298,27 @@ js_EmitTree(JSContext *cx, JSCodeGenerat
                 if (beq < 0)
                     return JS_FALSE;
 
+#if JS_HAS_LVALUE_RETURN
+                if (pn3->pn_type == TOK_LP) {
+                    JS_ASSERT(pn3->pn_op == JSOP_SETCALL);
+                    if (!js_EmitTree(cx, cg, pn3))
+                        return JS_FALSE;
+                    if (!js_Emit1(cx, cg, JSOP_ENUMELEM))
+                        return JS_FALSE;
+                    break;
+                }
+#endif
+#if JS_HAS_XML_SUPPORT
+                if (pn3->pn_type == TOK_UNARYOP) {
+                    JS_ASSERT(pn3->pn_op == JSOP_BINDXMLNAME);
+                    if (!js_EmitTree(cx, cg, pn3))
+                        return JS_FALSE;
+                    if (!js_Emit1(cx, cg, JSOP_ENUMELEM))
+                        return JS_FALSE;
+                    break;
+                }
+#endif
+
                 /* Now that we're safely past the IFEQ, commit side effects. */
                 if (!EmitElemOp(cx, pn3, JSOP_ENUMELEM, cg))
                     return JS_FALSE;
diff -uprN --exclude=CVS mozilla/js/src/jsemit.h mozilla.new/js/src/jsemit.h
--- mozilla/js/src/jsemit.h	2005-10-22 01:30:15.000000000 +0200
+++ mozilla.new/js/src/jsemit.h	2006-03-03 07:13:06.000000000 +0100
@@ -186,11 +186,13 @@ struct JSJumpTarget {
 
 struct JSCodeGenerator {
     JSTreeContext   treeContext;    /* base state: statement info stack, etc. */
+
     JSArenaPool     *codePool;      /* pointer to thread code arena pool */
     JSArenaPool     *notePool;      /* pointer to thread srcnote arena pool */
     void            *codeMark;      /* low watermark in cg->codePool */
     void            *noteMark;      /* low watermark in cg->notePool */
     void            *tempMark;      /* low watermark in cx->tempPool */
+
     struct {
         jsbytecode  *base;          /* base of JS bytecode vector */
         jsbytecode  *limit;         /* one byte beyond end of bytecode */
@@ -201,20 +203,27 @@ struct JSCodeGenerator {
         ptrdiff_t   lastNoteOffset; /* code offset for last source note */
         uintN       currentLine;    /* line number for tree-based srcnote gen */
     } prolog, main, *current;
+
     const char      *filename;      /* null or weak link to source filename */
     uintN           firstLine;      /* first line, for js_NewScriptFromCG */
     JSPrincipals    *principals;    /* principals for constant folding eval */
     JSAtomList      atomList;       /* literals indexed for mapping */
+
     intN            stackDepth;     /* current stack depth in script frame */
     uintN           maxStackDepth;  /* maximum stack depth so far */
+
     JSTryNote       *tryBase;       /* first exception handling note */
     JSTryNote       *tryNext;       /* next available note */
     size_t          tryNoteSpace;   /* # of bytes allocated at tryBase */
+
     JSSpanDep       *spanDeps;      /* span dependent instruction records */
     JSJumpTarget    *jumpTargets;   /* AVL tree of jump target offsets */
     JSJumpTarget    *jtFreeList;    /* JT_LEFT-linked list of free structs */
     uintN           numSpanDeps;    /* number of span dependencies */
     uintN           numJumpTargets; /* number of jump targets */
+    ptrdiff_t       spanDepTodo;    /* offset from main.base of potentially
+                                       unoptimized spandeps */
+
     uintN           emitLevel;      /* js_EmitTree recursion level */
     JSAtomList      constList;      /* compile time constants */
     JSCodeGenerator *parent;        /* Enclosing function or global context */
diff -uprN --exclude=CVS mozilla/js/src/jsfun.c mozilla.new/js/src/jsfun.c
--- mozilla/js/src/jsfun.c	2006-01-11 23:04:47.000000000 +0100
+++ mozilla.new/js/src/jsfun.c	2006-02-24 11:16:27.000000000 +0100
@@ -722,7 +722,7 @@ static JSBool
 call_enumerate(JSContext *cx, JSObject *obj)
 {
     JSStackFrame *fp;
-    JSObject *funobj;
+    JSObject *funobj, *pobj;
     JSScope *scope;
     JSScopeProperty *sprop, *cprop;
     JSPropertyOp getter;
@@ -771,9 +771,20 @@ call_enumerate(JSContext *cx, JSObject *
         JS_ASSERT(atom->flags & ATOM_HIDDEN);
         atom = atom->entry.value;
 
-        if (!js_LookupProperty(cx, obj, ATOM_TO_JSID(atom), &obj, &prop))
+        if (!js_LookupProperty(cx, obj, ATOM_TO_JSID(atom), &pobj, &prop))
             return JS_FALSE;
-        JS_ASSERT(obj && prop);
+
+        /*
+         * If we found the property in a different object, don't try sticking
+         * it into wrong slots vector. This can occur because we have a mutable
+         * __proto__ slot, and cloned function objects rely on their __proto__
+         * to delegate to the object that contains the var and arg properties.
+         */
+        if (!prop || pobj != obj) {
+            if (prop)
+                OBJ_DROP_PROPERTY(cx, pobj, prop);
+            continue;
+        }
         cprop = (JSScopeProperty *)prop;
         LOCKED_OBJ_SET_SLOT(obj, cprop->slot, vec[(uint16) sprop->shortid]);
         OBJ_DROP_PROPERTY(cx, obj, prop);
@@ -1032,8 +1043,8 @@ fun_enumerate(JSContext *cx, JSObject *o
     prototypeId = ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom);
     if (!OBJ_LOOKUP_PROPERTY(cx, obj, prototypeId, &pobj, &prop))
         return JS_FALSE;
-    JS_ASSERT(prop);
-    OBJ_DROP_PROPERTY(cx, pobj, prop);
+    if (prop)
+        OBJ_DROP_PROPERTY(cx, pobj, prop);
     return JS_TRUE;
 }
 
@@ -1502,6 +1513,7 @@ static JSBool
 fun_call(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
     jsval fval, *sp, *oldsp;
+    JSString *str;
     JSObject *tmp;
     void *mark;
     uintN i;
@@ -1513,10 +1525,13 @@ fun_call(JSContext *cx, JSObject *obj, u
     fval = argv[-1];
 
     if (!JSVAL_IS_FUNCTION(cx, fval)) {
-        JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
-                             JSMSG_INCOMPATIBLE_PROTO,
-                             js_Function_str, call_str,
-                             JS_GetStringBytes(JS_ValueToString(cx, fval)));
+        str = JS_ValueToString(cx, fval);
+        if (str) {
+            JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
+                                 JSMSG_INCOMPATIBLE_PROTO,
+                                 js_Function_str, call_str,
+                                 JS_GetStringBytes(str));
+        }
         return JS_FALSE;
     }
 
@@ -1562,6 +1577,7 @@ static JSBool
 fun_apply(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
     jsval fval, *sp, *oldsp;
+    JSString *str;
     JSObject *aobj;
     jsuint length;
     void *mark;
@@ -1579,10 +1595,13 @@ fun_apply(JSContext *cx, JSObject *obj, 
     fval = argv[-1];
 
     if (!JSVAL_IS_FUNCTION(cx, fval)) {
-        JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
-                             JSMSG_INCOMPATIBLE_PROTO,
-                             js_Function_str, "apply",
-                             JS_GetStringBytes(JS_ValueToString(cx, fval)));
+        str = JS_ValueToString(cx, fval);
+        if (str) {
+            JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
+                                 JSMSG_INCOMPATIBLE_PROTO,
+                                 js_Function_str, "apply",
+                                 JS_GetStringBytes(str));
+        }
         return JS_FALSE;
     }
 
@@ -1757,7 +1776,7 @@ Function(JSContext *cx, JSObject *obj, u
     }
 
     /* Belt-and-braces: check that the caller has access to parent. */
-    if (!js_CheckPrincipalsAccess(cx, parent, principals, "Function"))
+    if (!js_CheckPrincipalsAccess(cx, parent, principals, js_Function_str))
         return JS_FALSE;
 
     n = argc ? argc - 1 : 0;
@@ -2121,6 +2140,7 @@ js_ValueToFunctionObject(JSContext *cx, 
     JSFunction *fun;
     JSObject *funobj;
     JSStackFrame *caller;
+    JSPrincipals *principals;
 
     if (JSVAL_IS_FUNCTION(cx, *vp))
         return JSVAL_TO_OBJECT(*vp);
@@ -2132,10 +2152,21 @@ js_ValueToFunctionObject(JSContext *cx, 
     *vp = OBJECT_TO_JSVAL(funobj);
 
     caller = JS_GetScriptedCaller(cx, cx->fp);
-    if (caller &&
-        !js_CheckPrincipalsAccess(cx, funobj,
-                                  caller->script->principals,
-                                  JS_GetFunctionName(fun))) {
+    if (caller) {
+        principals = caller->script->principals;
+    } else {
+        /* No scripted caller, don't allow access. */
+        principals = NULL;
+    }
+
+    /*
+     * FIXME: Reparameterize so we don't call js_AtomToPrintableString unless
+     *        there is an error (bug 324694).
+     */
+    if (!js_CheckPrincipalsAccess(cx, funobj, principals,
+                                  fun->atom
+                                  ? js_AtomToPrintableString(cx, fun->atom)
+                                  : js_anonymous_str)) {
         return NULL;
     }
     return funobj;
diff -uprN --exclude=CVS mozilla/js/src/jsgc.c mozilla.new/js/src/jsgc.c
--- mozilla/js/src/jsgc.c	2005-11-01 03:21:39.000000000 +0100
+++ mozilla.new/js/src/jsgc.c	2006-03-03 07:13:06.000000000 +0100
@@ -333,17 +333,20 @@ js_InitGC(JSRuntime *rt, uint32 maxbytes
     JS_ASSERT(GC_FLAGS_SIZE >= GC_PAGE_SIZE);
     JS_ASSERT(sizeof(JSStackHeader) >= 2 * sizeof(jsval));
 
-    for (i = 0; i < GC_NUM_FREELISTS; i++) {
-        JS_InitArenaPool(&rt->gcArenaPool[i], "gc-arena", GC_ARENA_SIZE,
-                         GC_FREELIST_NBYTES(i));
-    }
+    for (i = 0; i < GC_NUM_FREELISTS; i++)
+        JS_InitArenaPool(&rt->gcArenaPool[i], "gc-arena", GC_ARENA_SIZE, 1);
     if (!JS_DHashTableInit(&rt->gcRootsHash, JS_DHashGetStubOps(), NULL,
                            sizeof(JSGCRootHashEntry), GC_ROOTS_SIZE)) {
         rt->gcRootsHash.ops = NULL;
         return JS_FALSE;
     }
     rt->gcLocksHash = NULL;     /* create lazily */
-    rt->gcMaxBytes = maxbytes;
+
+    /*
+     * Separate gcMaxMallocBytes from gcMaxBytes but initialize to maxbytes
+     * for default backward API compatibility.
+     */
+    rt->gcMaxBytes = rt->gcMaxMallocBytes = maxbytes;
     return JS_TRUE;
 }
 
@@ -589,7 +592,7 @@ retry:
         METER(rt->gcStats.recycle[i]++);
     } else {
         if (rt->gcBytes < rt->gcMaxBytes &&
-            (tried_gc || rt->gcMallocBytes < rt->gcMaxBytes))
+            (tried_gc || rt->gcMallocBytes < rt->gcMaxMallocBytes))
         {
             /*
              * Inline form of JS_ARENA_ALLOCATE adapted to truncate the current
@@ -1530,6 +1533,7 @@ js_GC(JSContext *cx, uintN gcflags)
     JSStackFrame *fp, *chain;
     uintN i, depth, nslots, type;
     JSStackHeader *sh;
+    JSTempValueRooter *tvr;
     size_t nbytes, nflags;
     JSArena *a, **ap;
     uint8 flags, *flagp, *split;
@@ -1799,6 +1803,16 @@ restart:
 
         if (acx->localRootStack)
             js_MarkLocalRoots(cx, acx->localRootStack);
+        for (tvr = acx->tempValueRooters; tvr; tvr = tvr->down) {
+            if (tvr->count < 0) {
+                if (JSVAL_IS_GCTHING(tvr->u.value)) {
+                    GC_MARK(cx, JSVAL_TO_GCTHING(tvr->u.value), "tvr->u.value",
+                            NULL);
+                }
+            } else {
+                GC_MARK_JSVALS(cx, tvr->count, tvr->u.array, "tvr->u.array");
+            }
+        }
     }
 #ifdef DUMP_CALL_TABLE
     js_DumpCallTable(cx);
@@ -1819,7 +1833,6 @@ restart:
      */
     js_SweepAtomState(&rt->atomState);
     js_SweepScopeProperties(rt);
-    js_SweepScriptFilenames(rt);
     for (i = 0; i < GC_NUM_FREELISTS; i++) {
         nbytes = GC_FREELIST_NBYTES(i);
         nflags = nbytes / sizeof(JSGCThing);
@@ -1864,6 +1877,14 @@ restart:
     }
 
     /*
+     * Sweep script filenames after sweeping functions in the generic loop
+     * above. In this way when scripted function's finalizer destroys script
+     * triggering a call to rt->destroyScriptHook, the hook can still access
+     * script's filename. See bug 323267.
+     */
+    js_SweepScriptFilenames(rt);
+
+    /*
      * Free phase.
      * Free any unused arenas and rebuild the JSGCThing freelist.
      */
diff -uprN --exclude=CVS mozilla/js/src/jsinterp.c mozilla.new/js/src/jsinterp.c
--- mozilla/js/src/jsinterp.c	2006-01-11 23:04:48.000000000 +0100
+++ mozilla.new/js/src/jsinterp.c	2006-02-24 11:16:27.000000000 +0100
@@ -1982,6 +1982,17 @@ js_Interpret(JSContext *cx, jsbytecode *
                         LOAD_INTERRUPT_HANDLER(rt);
                     }
                 }
+
+#if JS_HAS_CALL_OBJECT
+                /*
+                 * If frame has a call object, sync values and clear the back-
+                 * pointer. This can happen for a lightweight function if it
+                 * calls eval unexpectedly (in a way that is hidden from the
+                 * compiler). See bug 325540.
+                 */
+                if (fp->callobj)
+                    ok &= js_PutCallObject(cx, fp);
+#endif
 #if JS_HAS_ARGS_OBJECT
                 if (fp->argsobj)
                     ok &= js_PutArgsObject(cx, fp);
diff -uprN --exclude=CVS mozilla/js/src/jsobj.c mozilla.new/js/src/jsobj.c
--- mozilla/js/src/jsobj.c	2006-01-11 23:04:48.000000000 +0100
+++ mozilla.new/js/src/jsobj.c	2006-02-24 11:16:27.000000000 +0100
@@ -1262,10 +1262,9 @@ obj_eval(JSContext *cx, JSObject *obj, u
      * caller's principals has access to scopeobj.
      */
     ok = js_CheckPrincipalsAccess(cx, scopeobj, principals, js_eval_str);
-    if (!ok)
-        goto out;
+    if (ok)
+        ok = js_Execute(cx, scopeobj, script, caller, JSFRAME_EVAL, rval);
 
-    ok = js_Execute(cx, scopeobj, script, caller, JSFRAME_EVAL, rval);
     JS_DestroyScript(cx, script);
 
 out:
@@ -2123,6 +2122,7 @@ js_ConstructObject(JSContext *cx, JSClas
                    JSObject *parent, uintN argc, jsval *argv)
 {
     jsval cval, rval;
+    JSTempValueRooter tvr;
     JSObject *obj, *ctor;
 
     if (!js_FindConstructor(cx, parent, clasp->name, &cval))
@@ -2133,6 +2133,13 @@ js_ConstructObject(JSContext *cx, JSClas
     }
 
     /*
+     * Protect cval in case a crazy getter for .prototype uproots it.  After
+     * this point, all control flow must exit through label out with obj set.
+     */
+    JS_PUSH_SINGLE_TEMP_ROOT(cx, cval, &tvr);
+    obj = NULL;
+
+    /*
      * If proto or parent are NULL, set them to Constructor.prototype and/or
      * Constructor.__parent__, just like JSOP_NEW does.
      */
@@ -2144,7 +2151,7 @@ js_ConstructObject(JSContext *cx, JSClas
                               ATOM_TO_JSID(cx->runtime->atomState
                                            .classPrototypeAtom),
                               &rval)) {
-            return NULL;
+            goto out;
         }
         if (JSVAL_IS_OBJECT(rval))
             proto = JSVAL_TO_OBJECT(rval);
@@ -2152,14 +2159,19 @@ js_ConstructObject(JSContext *cx, JSClas
 
     obj = js_NewObject(cx, clasp, proto, parent);
     if (!obj)
-        return NULL;
+        goto out;
 
-    if (!js_InternalConstruct(cx, obj, cval, argc, argv, &rval))
-        goto bad;
-    return JSVAL_IS_OBJECT(rval) ? JSVAL_TO_OBJECT(rval) : obj;
-bad:
-    cx->newborn[GCX_OBJECT] = NULL;
-    return NULL;
+    if (!js_InternalConstruct(cx, obj, cval, argc, argv, &rval)) {
+        cx->newborn[GCX_OBJECT] = NULL;
+        obj = NULL;
+        goto out;
+    }
+
+    if (!JSVAL_IS_PRIMITIVE(rval))
+        obj = JSVAL_TO_OBJECT(rval);
+out:
+    JS_POP_TEMP_ROOT(cx, &tvr);
+    return obj;
 }
 
 void
@@ -2265,7 +2277,7 @@ js_FreeSlot(JSContext *cx, JSObject *obj
 #if JS_BUG_EMPTY_INDEX_ZERO
 #define CHECK_FOR_EMPTY_INDEX(id)                                             \
     JS_BEGIN_MACRO                                                            \
-        if (JSSTRING_LENGTH(_str) == 0)                                       \
+        if (JSSTRING_LENGTH(str_) == 0)                                       \
             id = JSVAL_ZERO;                                                  \
     JS_END_MACRO
 #else
diff -uprN --exclude=CVS mozilla/js/src/jsopcode.c mozilla.new/js/src/jsopcode.c
--- mozilla/js/src/jsopcode.c	2006-01-09 06:48:37.000000000 +0100
+++ mozilla.new/js/src/jsopcode.c	2006-03-03 07:13:06.000000000 +0100
@@ -892,7 +892,7 @@ Decompile(SprintStack *ss, jsbytecode *p
     JSString *str;
     JSBool ok;
 #if JS_HAS_XML_SUPPORT
-    JSBool inXML, quoteAttr;
+    JSBool foreach, inXML, quoteAttr;
 #else
 #define inXML JS_FALSE
 #endif
@@ -954,7 +954,7 @@ Decompile(SprintStack *ss, jsbytecode *p
     sn = NULL;
     rval = NULL;
 #if JS_HAS_XML_SUPPORT
-    inXML = quoteAttr = JS_FALSE;
+    foreach = inXML = quoteAttr = JS_FALSE;
 #endif
 
     while (pc < endpc) {
@@ -1569,7 +1569,8 @@ Decompile(SprintStack *ss, jsbytecode *p
 
               do_forinbody:
 #if JS_HAS_XML_SUPPORT
-                if (lastop == JSOP_FOREACH) {
+                if (foreach) {
+                    foreach = JS_FALSE;
                     js_printf(jp, "\tfor %s (%s%s",
                               js_each_str, VarPrefix(sn), lval);
                 } else
@@ -1581,10 +1582,10 @@ Decompile(SprintStack *ss, jsbytecode *p
                         return JS_FALSE;
                     RETRACT(&ss->sprinter, xval);
                     js_printf(jp, *lval ? ".%s" : "%s", xval);
-                } else if (xval) {
+                } else if (xval && *xval) {
                     js_printf(jp,
                               (js_CodeSpec[lastop].format & JOF_XMLNAME)
-                              ? ".%s%s"
+                              ? ".%s"
                               : "[%s]",
                               xval);
                 }
@@ -2380,6 +2381,7 @@ Decompile(SprintStack *ss, jsbytecode *p
 #if JS_HAS_LEXICAL_CLOSURE
               BEGIN_LITOPX_CASE(JSOP_CLOSURE)
                 JS_ASSERT(ATOM_IS_OBJECT(atom));
+                todo = -2;
                 goto do_function;
               END_LITOPX_CASE
 #endif
@@ -2632,12 +2634,16 @@ Decompile(SprintStack *ss, jsbytecode *p
                 inXML = JS_FALSE;
                 break;
 
+              case JSOP_FOREACH:
+                foreach = JS_TRUE;
+                todo = -2;
+                break;
+
               case JSOP_TOXML:
                 inXML = JS_FALSE;
-                /* fall through */
+                /* FALL THROUGH */
 
               case JSOP_XMLNAME:
-              case JSOP_FOREACH:
               case JSOP_FILTER:
                 /* Conversion and prefix ops do nothing in the decompiler. */
                 todo = -2;
diff -uprN --exclude=CVS mozilla/js/src/jsparse.c mozilla.new/js/src/jsparse.c
--- mozilla/js/src/jsparse.c	2006-01-11 23:04:48.000000000 +0100
+++ mozilla.new/js/src/jsparse.c	2006-03-03 07:13:06.000000000 +0100
@@ -1576,10 +1576,19 @@ Statement(JSContext *cx, JSTokenStream *
             stmtInfo.type = STMT_FOR_IN_LOOP;
 
             /* Check that the left side of the 'in' is valid. */
+            while (pn1->pn_type == TOK_RP)
+                pn1 = pn1->pn_kid;
             if ((pn1->pn_type == TOK_VAR)
                 ? (pn1->pn_count > 1 || pn1->pn_op == JSOP_DEFCONST)
                 : (pn1->pn_type != TOK_NAME &&
                    pn1->pn_type != TOK_DOT &&
+#if JS_HAS_LVALUE_RETURN
+                   pn1->pn_type != TOK_LP &&
+#endif
+#if JS_HAS_XML_SUPPORT
+                   (pn1->pn_type != TOK_UNARYOP ||
+                    pn1->pn_op != JSOP_XMLNAME) &&
+#endif
                    pn1->pn_type != TOK_LB)) {
                 js_ReportCompileErrorNumber(cx, ts,
                                             JSREPORT_TS | JSREPORT_ERROR,
@@ -1597,6 +1606,14 @@ Statement(JSContext *cx, JSTokenStream *
                     pn1->pn_extra |= PNX_POPVAR;
             } else {
                 pn2 = pn1;
+#if JS_HAS_LVALUE_RETURN
+                if (pn2->pn_type == TOK_LP)
+                    pn2->pn_op = JSOP_SETCALL;
+#endif
+#if JS_HAS_XML_SUPPORT
+                if (pn2->pn_type == TOK_UNARYOP)
+                    pn2->pn_op = JSOP_BINDXMLNAME;
+#endif
             }
 
             /* Beware 'for (arguments in ...)' with or without a 'var'. */
@@ -4326,7 +4343,7 @@ FoldXMLConstants(JSContext *cx, JSParseN
           case TOK_XMLSPACE:
           case TOK_XMLTEXT:
           case TOK_STRING:
-            if (pn->pn_arity == PN_LIST)
+            if (pn2->pn_arity == PN_LIST)
                 goto cantfold;
             str = ATOM_TO_STRING(pn2->pn_atom);
             break;
diff -uprN --exclude=CVS mozilla/js/src/jsregexp.c mozilla.new/js/src/jsregexp.c
--- mozilla/js/src/jsregexp.c	2005-10-14 21:00:39.000000000 +0200
+++ mozilla.new/js/src/jsregexp.c	2006-02-24 11:16:28.000000000 +0100
@@ -2034,10 +2034,6 @@ js_NewRegExpOpt(JSContext *cx, JSTokenSt
     return js_NewRegExp(cx, ts, str, flags, flat);
 }
 
-
-#define HOLD_REGEXP(cx, re) JS_ATOMIC_INCREMENT(&(re)->nrefs)
-#define DROP_REGEXP(cx, re) js_DestroyRegExp(cx, re)
-
 /*
  * Save the current state of the match - the position in the input
  * text as well as the position in the bytecode. The state of any
diff -uprN --exclude=CVS mozilla/js/src/jsregexp.h mozilla.new/js/src/jsregexp.h
--- mozilla/js/src/jsregexp.h	2005-09-30 23:57:31.000000000 +0200
+++ mozilla.new/js/src/jsregexp.h	2006-02-24 11:16:28.000000000 +0100
@@ -117,6 +117,9 @@ extern JSRegExp *
 js_NewRegExpOpt(JSContext *cx, JSTokenStream *ts,
                 JSString *str, JSString *opt, JSBool flat);
 
+#define HOLD_REGEXP(cx, re) JS_ATOMIC_INCREMENT(&(re)->nrefs)
+#define DROP_REGEXP(cx, re) js_DestroyRegExp(cx, re)
+
 extern void
 js_DestroyRegExp(JSContext *cx, JSRegExp *re);
 
diff -uprN --exclude=CVS mozilla/js/src/jsstr.c mozilla.new/js/src/jsstr.c
--- mozilla/js/src/jsstr.c	2005-11-01 01:31:26.000000000 +0100
+++ mozilla.new/js/src/jsstr.c	2006-02-24 11:16:35.000000000 +0100
@@ -1168,7 +1168,9 @@ match_or_replace(JSContext *cx, JSObject
             return JS_FALSE;
         reobj = NULL;
     }
+    /* From here on, all control flow must reach the matching DROP. */
     data->regexp = re;
+    HOLD_REGEXP(cx, re);
 
     if (re->flags & JSREG_GLOB)
         data->flags |= GLOBAL_REGEXP;
@@ -1184,23 +1186,23 @@ match_or_replace(JSContext *cx, JSObject
         if (reobj) {
             /* Set the lastIndex property's reserved slot to 0. */
             ok = js_SetLastIndex(cx, reobj, 0);
-            if (!ok)
-                return JS_FALSE;
         } else {
             ok = JS_TRUE;
         }
-        length = JSSTRING_LENGTH(str);
-        for (count = 0; index <= length; count++) {
-            ok = js_ExecuteRegExp(cx, re, str, &index, JS_TRUE, rval);
-            if (!ok || *rval != JSVAL_TRUE)
-                break;
-            ok = glob(cx, count, data);
-            if (!ok)
-                break;
-            if (cx->regExpStatics.lastMatch.length == 0) {
-                if (index == length)
+        if (ok) {
+            length = JSSTRING_LENGTH(str);
+            for (count = 0; index <= length; count++) {
+                ok = js_ExecuteRegExp(cx, re, str, &index, JS_TRUE, rval);
+                if (!ok || *rval != JSVAL_TRUE)
                     break;
-                index++;
+                ok = glob(cx, count, data);
+                if (!ok)
+                    break;
+                if (cx->regExpStatics.lastMatch.length == 0) {
+                    if (index == length)
+                        break;
+                    index++;
+                }
             }
         }
     } else {
@@ -1241,6 +1243,7 @@ match_or_replace(JSContext *cx, JSObject
         ok = js_ExecuteRegExp(cx, re, str, &index, test, rval);
     }
 
+    DROP_REGEXP(cx, re);
     if (reobj) {
         /* Tell our caller that it doesn't need to destroy data->regexp. */
         data->flags &= ~KEEP_REGEXP;
@@ -1249,6 +1252,7 @@ match_or_replace(JSContext *cx, JSObject
         data->regexp = NULL;
         js_DestroyRegExp(cx, re);
     }
+
     return ok;
 }
 
diff -uprN --exclude=CVS mozilla/js/src/jsxml.c mozilla.new/js/src/jsxml.c
--- mozilla/js/src/jsxml.c	2006-01-11 23:04:49.000000000 +0100
+++ mozilla.new/js/src/jsxml.c	2006-03-03 07:13:08.000000000 +0100
@@ -1225,7 +1225,12 @@ XMLArrayTruncate(JSContext *cx, JSXMLArr
 #define XMLARRAY_HAS_MEMBER(a,e,f)  (XMLArrayFindMember(a, (void *)(e), f) != \
                                      XML_NOT_FOUND)
 #define XMLARRAY_MEMBER(a,i,t)      ((t *) (a)->vector[i])
-#define XMLARRAY_SET_MEMBER(a,i,e)  ((a)->vector[i] = (void *)(e))
+#define XMLARRAY_SET_MEMBER(a,i,e)                                            \
+    JS_BEGIN_MACRO                                                            \
+      if ((a)->length <= (i))                                                 \
+          (a)->length = (i) + 1;                                              \
+      ((a)->vector[i] = (void *)(e));                                         \
+    JS_END_MACRO
 #define XMLARRAY_ADD_MEMBER(x,a,i,e)XMLArrayAddMember(x, a, i, (void *)(e))
 #define XMLARRAY_INSERT(x,a,i,n)    XMLArrayInsert(x, a, i, n)
 #define XMLARRAY_APPEND(x,a,e)      XMLARRAY_ADD_MEMBER(x, a, (a)->length, (e))
@@ -1258,6 +1263,12 @@ enum xml_static_tinyid {
 };
 
 static JSBool
+xml_setting_getter(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
+{
+    return JS_TRUE;
+}
+
+static JSBool
 xml_setting_setter(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
     JSBool b;
@@ -1277,16 +1288,16 @@ xml_setting_setter(JSContext *cx, JSObje
 
 static JSPropertySpec xml_static_props[] = {
     {js_ignoreComments_str,     XML_IGNORE_COMMENTS,   JSPROP_PERMANENT,
-                                NULL, xml_setting_setter},
+                                xml_setting_getter, xml_setting_setter},
     {js_ignoreProcessingInstructions_str,
                    XML_IGNORE_PROCESSING_INSTRUCTIONS, JSPROP_PERMANENT,
-                                NULL, xml_setting_setter},
+                                xml_setting_getter, xml_setting_setter},
     {js_ignoreWhitespace_str,   XML_IGNORE_WHITESPACE, JSPROP_PERMANENT,
-                                NULL, xml_setting_setter},
+                                xml_setting_getter, xml_setting_setter},
     {js_prettyPrinting_str,     XML_PRETTY_PRINTING,   JSPROP_PERMANENT,
-                                NULL, xml_setting_setter},
+                                xml_setting_getter, xml_setting_setter},
     {js_prettyIndent_str,       XML_PRETTY_INDENT,     JSPROP_PERMANENT,
-                                NULL, NULL},
+                                xml_setting_getter, NULL},
     {0,0,0,0,0}
 };
 
@@ -1483,8 +1494,10 @@ ParseNodeToXML(JSContext *cx, JSParseNod
         xml = ParseNodeToXML(cx, pn2, inScopeNSes, flags);
         if (!xml)
             goto fail;
-        flags &= ~XSF_PRECOMPILED_ROOT;
+        if (js_PushLocalRoot(cx, cx->localRootStack, (jsval)xml) < 0)
+            goto fail;
 
+        flags &= ~XSF_PRECOMPILED_ROOT;
         n = pn->pn_count;
         JS_ASSERT(n >= 2);
         n -= 2;
@@ -1511,10 +1524,8 @@ ParseNodeToXML(JSContext *cx, JSParseNod
                 continue;
             }
 
-            if (!kid) {
-                xml->xml_kids.length = i;
+            if (!kid)
                 goto fail;
-            }
 
             /* Store kid in xml right away, to protect it from GC. */
             XMLARRAY_SET_MEMBER(&xml->xml_kids, i, kid);
@@ -1532,7 +1543,6 @@ ParseNodeToXML(JSContext *cx, JSParseNod
         }
 
         JS_ASSERT(i == n);
-        xml->xml_kids.length = n;
         if (n < pn->pn_count - 2)
             XMLArrayTrim(&xml->xml_kids);
         XMLARRAY_TRUNCATE(cx, inScopeNSes, length);
@@ -1565,16 +1575,13 @@ ParseNodeToXML(JSContext *cx, JSParseNod
                 continue;
             }
 
-            if (!kid) {
-                xml->xml_kids.length = i;
+            if (!kid)
                 goto fail;
-            }
 
             XMLARRAY_SET_MEMBER(&xml->xml_kids, i, kid);
             ++i;
         }
 
-        xml->xml_kids.length = n;
         if (n < pn->pn_count)
             XMLArrayTrim(&xml->xml_kids);
         break;
@@ -1583,7 +1590,7 @@ ParseNodeToXML(JSContext *cx, JSParseNod
       case TOK_XMLPTAGC:
         length = inScopeNSes->length;
         pn2 = pn->pn_head;
-        JS_ASSERT(pn2->pn_type = TOK_XMLNAME);
+        JS_ASSERT(pn2->pn_type == TOK_XMLNAME);
         if (pn2->pn_arity == PN_LIST)
             goto syntax;
 
@@ -1732,10 +1739,8 @@ ParseNodeToXML(JSContext *cx, JSParseNod
             JS_ASSERT(pn2->pn_type == TOK_XMLATTR);
 
             attr = js_NewXML(cx, JSXML_CLASS_ATTRIBUTE);
-            if (!attr) {
-                xml->xml_attrs.length = i;
+            if (!attr)
                 goto fail;
-            }
 
             XMLARRAY_SET_MEMBER(&xml->xml_attrs, i, attr);
             attr->parent = xml;
@@ -1743,8 +1748,6 @@ ParseNodeToXML(JSContext *cx, JSParseNod
             attr->xml_value = ATOM_TO_STRING(pn2->pn_atom);
         }
 
-        xml->xml_attrs.length = n;
-
         /* Point tag closes its own namespace scope. */
         if (pn->pn_type == TOK_XMLPTAGC)
             XMLARRAY_TRUNCATE(cx, inScopeNSes, length);
@@ -1834,23 +1837,44 @@ GetXMLSetting(JSContext *cx, const char 
 }
 
 static JSBool
-GetBooleanXMLSetting(JSContext *cx, const char *name, JSBool *bp)
+FillSettingsCache(JSContext *cx)
 {
     int i;
+    const char *name;
     jsval v;
+    JSBool isSet;
 
-    if (cx->xmlSettingFlags & XSF_CACHE_VALID) {
-        for (i = 0; xml_static_props[i].name; i++) {
-            if (!strcmp(xml_static_props[i].name, name)) {
-                *bp = (cx->xmlSettingFlags & JS_BIT(i)) != 0;
-                return JS_TRUE;
-            }
-        }
-        *bp = JS_FALSE;
-        return JS_TRUE;
+    /* Note: XML_PRETTY_INDENT is not a boolean setting. */
+    for (i = XML_IGNORE_COMMENTS; i < XML_PRETTY_INDENT; i++) {
+        name = xml_static_props[i].name;
+        if (!GetXMLSetting(cx, name, &v) || !js_ValueToBoolean(cx, v, &isSet))
+            return JS_FALSE;
+        if (isSet)
+            cx->xmlSettingFlags |= JS_BIT(i);
+        else
+            cx->xmlSettingFlags &= ~JS_BIT(i);
     }
 
-    return GetXMLSetting(cx, name, &v) && js_ValueToBoolean(cx, v, bp);
+    cx->xmlSettingFlags |= XSF_CACHE_VALID;
+    return JS_TRUE;
+}
+
+static JSBool
+GetBooleanXMLSetting(JSContext *cx, const char *name, JSBool *bp)
+{
+    int i;
+
+    if (!(cx->xmlSettingFlags & XSF_CACHE_VALID) && !FillSettingsCache(cx))
+        return JS_FALSE;
+
+    for (i = 0; xml_static_props[i].name; i++) {
+        if (!strcmp(xml_static_props[i].name, name)) {
+            *bp = (cx->xmlSettingFlags & JS_BIT(i)) != 0;
+            return JS_TRUE;
+        }
+    }
+    *bp = JS_FALSE;
+    return JS_TRUE;
 }
 
 static JSBool
@@ -2886,7 +2910,7 @@ XMLToXMLString(JSContext *cx, JSXML *xml
     str = js_NewString(cx, sb.base, STRING_BUFFER_OFFSET(&sb), 0);
 out:
     JS_LeaveLocalRootScope(cx);
-    if (!str)
+    if (!str && STRING_BUFFER_OK(&sb))
         js_FinishStringBuffer(&sb);
     XMLArrayFinish(cx, &decls);
     if (ancdecls.capacity != 0)
@@ -3050,7 +3074,7 @@ construct:
 out:
     qn = (JSXMLQName *) JS_GetPrivate(cx, obj);
     atom = cx->runtime->atomState.lazy.functionNamespaceURIAtom;
-    if (atom &&
+    if (qn->uri && atom &&
         (qn->uri == ATOM_TO_STRING(atom) ||
          !js_CompareStrings(qn->uri, ATOM_TO_STRING(atom)))) {
         if (!JS_ValueToId(cx, STRING_TO_JSVAL(qn->localName), funidp))
@@ -3141,7 +3165,6 @@ Append(JSContext *cx, JSXML *list, JSXML
             kid = XMLARRAY_MEMBER(&xml->xml_kids, j, JSXML);
             XMLARRAY_SET_MEMBER(&list->xml_kids, i + j, kid);
         }
-        list->xml_kids.length = k;
         return JS_TRUE;
     }
 
@@ -3234,12 +3257,12 @@ DeepCopySetInLRS(JSContext *cx, JSXMLArr
             kid2->xml_value = str;
         }
 
-        XMLARRAY_SET_MEMBER(to, j++, kid2);
+        XMLARRAY_SET_MEMBER(to, j, kid2);
+        ++j;
         if (parent->xml_class != JSXML_CLASS_LIST)
             kid2->parent = parent;
     }
 
-    to->length = j;
     if (j < n)
         XMLArrayTrim(to);
     return JS_TRUE;
@@ -3297,7 +3320,6 @@ DeepCopyInLRS(JSContext *cx, JSXML *xml,
                 }
                 XMLARRAY_SET_MEMBER(&copy->xml_namespaces, i, ns2);
             }
-            copy->xml_namespaces.length = n;
 
             ok = DeepCopySetInLRS(cx, &xml->xml_attrs, &copy->xml_attrs, copy,
                                   0);
@@ -3566,6 +3588,8 @@ Replace(JSContext *cx, JSXML *xml, jsval
 static JSBool
 CheckCycle(JSContext *cx, JSXML *xml, JSXML *kid)
 {
+    JS_ASSERT(kid->xml_class != JSXML_CLASS_LIST);
+
     do {
         if (xml == kid) {
             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
@@ -3599,8 +3623,6 @@ Insert(JSContext *cx, JSXML *xml, jsval 
         vobj = JSVAL_TO_OBJECT(v);
         if (OBJECT_IS_XML(cx, vobj)) {
             vxml = (JSXML *) JS_GetPrivate(cx, vobj);
-            if (!CheckCycle(cx, xml, vxml))
-                return JS_FALSE;
             if (vxml->xml_class == JSXML_CLASS_LIST)
                 n = vxml->xml_kids.length;
         }
@@ -3615,6 +3637,8 @@ Insert(JSContext *cx, JSXML *xml, jsval 
     if (vxml && vxml->xml_class == JSXML_CLASS_LIST) {
         for (j = 0; j < n; j++) {
             kid = XMLARRAY_MEMBER(&vxml->xml_kids, j, JSXML);
+            if (!CheckCycle(cx, xml, kid))
+                return JS_FALSE;
             kid->parent = xml;
             XMLARRAY_SET_MEMBER(&xml->xml_kids, i + j, kid);
 
@@ -4318,7 +4342,6 @@ PutProperty(JSContext *cx, JSObject *obj
                     kid2 = XMLARRAY_MEMBER(&vxml->xml_kids, k, JSXML);
                     XMLARRAY_SET_MEMBER(&copy->xml_kids, k, kid2);
                 }
-                copy->xml_kids.length = n;
 
                 JS_ASSERT(parent != xml);
                 if (parent) {
@@ -4593,6 +4616,7 @@ PutProperty(JSContext *cx, JSObject *obj
 
         /* 12. */
         k = n = xml->xml_kids.length;
+        kid2 = NULL;
         while (k != 0) {
             --k;
             kid = XMLARRAY_MEMBER(&xml->xml_kids, k, JSXML);
@@ -4605,9 +4629,32 @@ PutProperty(JSContext *cx, JSObject *obj
                 ok = IndexToIdVal(cx, k, &id);
                 if (!ok)
                     goto out;
+                kid2 = kid;
             }
         }
 
+        /*
+         * Erratum: ECMA-357 specified child insertion inconsistently:
+         * insertChildBefore and insertChildAfter insert an arbitrary XML
+         * instance, and therefore can create cycles, but appendChild as
+         * specified by the "Overview" of 13.4.4.3 calls [[DeepCopy]] on
+         * its argument.  But the "Semantics" in 13.4.4.3 do not include
+         * any [[DeepCopy]] call.
+         *
+         * Fixing this (https://bugzilla.mozilla.org/show_bug.cgi?id=312692)
+         * required adding cycle detection, and allowing duplicate kids to
+         * be created (see comment 6 in the bug).  Allowing duplicate kid
+         * references means the loop above will delete all but the lowest
+         * indexed reference, and each [[DeleteByIndex]] nulls the kid's
+         * parent.  Thus the need to restore parent here.  This is covered
+         * by https://bugzilla.mozilla.org/show_bug.cgi?id=327564.
+         */
+        if (kid2) {
+            JS_ASSERT(kid2->parent == xml || !kid2->parent);
+            if (!kid2->parent)
+                kid2->parent = xml;
+        }
+
         /* 13. */
         if (JSVAL_IS_VOID(id)) {
             /* 13(a). */
@@ -4694,6 +4741,7 @@ ResolveValue(JSContext *cx, JSXML *list,
 {
     JSXML *target, *base;
     JSXMLQName *targetprop;
+    JSObject *targetpropobj;
     jsval id, tv;
 
     /* Our caller must be protecting newborn objects. */
@@ -4708,10 +4756,15 @@ ResolveValue(JSContext *cx, JSXML *list,
 
     target = list->xml_target;
     targetprop = list->xml_targetprop;
-    if (!target ||
-        !targetprop ||
-        OBJ_GET_CLASS(cx, targetprop->object) == &js_AttributeNameClass ||
-        IS_STAR(targetprop->localName)) {
+    if (!target || !targetprop || IS_STAR(targetprop->localName)) {
+        *result = NULL;
+        return JS_TRUE;
+    }
+
+    targetpropobj = js_GetXMLQNameObject(cx, targetprop);
+    if (!targetpropobj)
+        return JS_FALSE;
+    if (OBJ_GET_CLASS(cx, targetpropobj) == &js_AttributeNameClass) {
         *result = NULL;
         return JS_TRUE;
     }
@@ -4725,7 +4778,7 @@ ResolveValue(JSContext *cx, JSXML *list,
     if (!js_GetXMLObject(cx, base))
         return JS_FALSE;
 
-    id = OBJECT_TO_JSVAL(targetprop->object);
+    id = OBJECT_TO_JSVAL(targetpropobj);
     if (!GetProperty(cx, base->object, id, &tv))
         return JS_FALSE;
     target = (JSXML *) JS_GetPrivate(cx, JSVAL_TO_OBJECT(tv));
@@ -6097,7 +6150,6 @@ xml_namespace(JSContext *cx, JSObject *o
             XMLARRAY_SET_MEMBER(&inScopeNSes, i, ns);
         }
 
-        inScopeNSes.length = i;
         ns = ok ? GetNamespace(cx, xml->name, &inScopeNSes) : NULL;
         XMLArrayFinish(cx, &inScopeNSes);
         if (!ns)
@@ -7175,9 +7227,9 @@ xml_mark_tail(JSContext *cx, JSXML *xml,
 
     if (xml->xml_class == JSXML_CLASS_LIST) {
         if (xml->xml_target)
-            js_MarkXML(cx, xml->xml_target, arg);
+            JS_MarkGCThing(cx, xml->xml_target, "target", arg);
         if (xml->xml_targetprop)
-            js_MarkXMLQName(cx, xml->xml_targetprop, arg);
+            JS_MarkGCThing(cx, xml->xml_targetprop, "targetprop", arg);
     } else {
         namespace_mark_vector(cx,
                               (JSXMLNamespace **) xml->xml_namespaces.vector,
diff -uprN --exclude=CVS mozilla/js/src/Makefile.in mozilla.new/js/src/Makefile.in
--- mozilla/js/src/Makefile.in	2005-06-01 16:26:26.000000000 +0200
+++ mozilla.new/js/src/Makefile.in	2006-02-24 11:16:27.000000000 +0100
@@ -370,14 +370,32 @@ ifdef HOST_NSPR_MDCPUCFG
 HOST_CC := $(HOST_CC) -DMDCPUCFG=$(TARGET_NSPR_MDCPUCFG)
 endif
 
+ifdef CROSS_COMPILE
+# jscpucfg needs to know when it's supposed to produce a config for the target
+JSCPUCFG_DEFINES = -DCROSS_COMPILE=1
+
+# This is incredibly hacky.  Darwin NSPR uses the same MDCPUCFG for multiple
+# processors, and determines which processor to configure for based on
+# #ifdef i386.  This macro is among the NSPR defines, but is also automatically
+# defined by the compiler when building for i386.  It therefore needs to be
+# defined here if targeting i386, and explicitly undefined otherwise.
+ifeq ($(OS_ARCH),Darwin)
+ifeq ($(TARGET_CPU),powerpc)
+DEFINES += -Ui386
+else
+DEFINES += -Di386=1
+endif
+endif
+endif
+
 ifeq ($(OS_ARCH),QNX)
 ifneq ($(OS_TARGET),NTO)
 # QNX's compiler apparently can't build a binary directly from a source file.
 jscpucfg.o: jscpucfg.c Makefile.in
-	$(HOST_CC) $(HOST_CFLAGS) -c $(DEFINES) $(NSPR_CFLAGS) -o $@ $<
+	$(HOST_CC) $(HOST_CFLAGS) -c $(JSCPUCFG_DEFINES) $(DEFINES) $(NSPR_CFLAGS) -o $@ $<
 
 jscpucfg: jscpucfg.o
-	$(HOST_CC) $(HOST_CFLAGS) $(DEFINES) -o $@ $<
+	$(HOST_CC) $(HOST_CFLAGS) $(JSCPUCFG_DEFINES) $(DEFINES) -o $@ $<
 endif
 else
 ifeq ($(OS_ARCH),WINCE)
@@ -385,7 +403,7 @@ jscpucfg$(HOST_BIN_SUFFIX):
 	echo no need to build jscpucfg $<
 else
 jscpucfg$(HOST_BIN_SUFFIX): jscpucfg.c Makefile.in
-	$(HOST_CC) $(HOST_CFLAGS) $(DEFINES) $(NSPR_CFLAGS) $(OUTOPTION)$@ $<
+	$(HOST_CC) $(HOST_CFLAGS) $(JSCPUCFG_DEFINES) $(DEFINES) $(NSPR_CFLAGS) $(OUTOPTION)$@ $<
 endif
 endif
 
diff -uprN --exclude=CVS mozilla/js/src/xpconnect/src/xpccallcontext.cpp mozilla.new/js/src/xpconnect/src/xpccallcontext.cpp
--- mozilla/js/src/xpconnect/src/xpccallcontext.cpp	2005-01-12 20:20:01.000000000 +0100
+++ mozilla.new/js/src/xpconnect/src/xpccallcontext.cpp	2006-02-24 11:16:36.000000000 +0100
@@ -345,7 +345,11 @@ XPCCallContext::~XPCCallContext()
         }
         else
         {
-            JS_ClearNewbornRoots(mJSContext);
+            // Don't clear newborns if JS frames (compilation or execution)
+            // are active!  Doing so violates ancient invariants in the JS
+            // engine, and it's not necessary to fix JS component leaks.
+            if (!mJSContext->fp)
+                JS_ClearNewbornRoots(mJSContext);
         }
     }
 
diff -uprN --exclude=CVS mozilla/js/src/xpconnect/src/xpccomponents.cpp mozilla.new/js/src/xpconnect/src/xpccomponents.cpp
--- mozilla/js/src/xpconnect/src/xpccomponents.cpp	2005-11-03 04:14:00.000000000 +0100
+++ mozilla.new/js/src/xpconnect/src/xpccomponents.cpp	2006-02-24 11:16:36.000000000 +0100
@@ -2244,10 +2244,16 @@ nsXPCComponents_utils_Sandbox::CallOrCon
     if(NS_FAILED(rv))
         return ThrowAndFail(NS_ERROR_XPC_UNEXPECTED, cx, _retval);
 
-    JSObject *sandbox = JS_NewObject(cx, &SandboxClass, nsnull, nsnull);
+    XPCAutoJSContext tempcx(JS_NewContext(JS_GetRuntime(cx), 1024), PR_FALSE);
+    if (!tempcx)
+        return ThrowAndFail(NS_ERROR_OUT_OF_MEMORY, cx, _retval);
+
+    JSObject *sandbox = JS_NewObject(tempcx, &SandboxClass, nsnull, nsnull);
     if (!sandbox)
         return ThrowAndFail(NS_ERROR_XPC_UNEXPECTED, cx, _retval);
 
+    JS_SetGlobalObject(tempcx, sandbox);
+
     rv = xpc->InitClasses(cx, sandbox);
     if (NS_SUCCEEDED(rv) &&
         !JS_DefineFunctions(cx, sandbox, SandboxFunctions)) {
@@ -2400,7 +2406,7 @@ nsXPCComponents_Utils::EvalInSandbox(con
         return NS_ERROR_FAILURE;
     }
 
-    JSContext *sandcx = JS_NewContext(JS_GetRuntime(cx), 1024);
+    XPCAutoJSContext sandcx(JS_NewContext(JS_GetRuntime(cx), 1024), false);
     if(!sandcx) {
         JS_ReportError(cx, "Can't prepare context for evalInSandbox");
         JSPRINCIPALS_DROP(cx, jsPrincipals);
@@ -2417,7 +2423,6 @@ nsXPCComponents_Utils::EvalInSandbox(con
             JS_ReportError(cx,
                     "Unable to initialize XPConnect with the sandbox context");
             JSPRINCIPALS_DROP(cx, jsPrincipals);
-            JS_DestroyContextNoGC(sandcx);
             return NS_ERROR_FAILURE;
         }
 
@@ -2434,7 +2439,7 @@ nsXPCComponents_Utils::EvalInSandbox(con
     JSStackFrame frame;
     memset(&frame, 0, sizeof frame);
 
-    sandcx->fp = &frame;
+    NS_STATIC_CAST(JSContext *, sandcx)->fp = &frame;
 
     // Get the current source info from xpc. Use the codebase as a fallback,
     // though.
@@ -2457,7 +2462,6 @@ nsXPCComponents_Utils::EvalInSandbox(con
                                               PromiseFlatString(source).get()),
                                           source.Length(), filename.get(),
                                           lineNo, rval)) {
-
         jsval exn;
         if (JS_GetPendingException(sandcx, &exn)) {
             JS_SetPendingException(cx, exn);
@@ -2473,7 +2477,6 @@ nsXPCComponents_Utils::EvalInSandbox(con
         stack->Pop(nsnull);
     }
 
-    JS_DestroyContextNoGC(sandcx);
     JSPRINCIPALS_DROP(cx, jsPrincipals);
     return rv;
 #endif /* !XPCONNECT_STANDALONE */
diff -uprN --exclude=CVS mozilla/js/src/xpconnect/src/xpcconvert.cpp mozilla.new/js/src/xpconnect/src/xpcconvert.cpp
--- mozilla/js/src/xpconnect/src/xpcconvert.cpp	2005-06-01 03:21:23.000000000 +0200
+++ mozilla.new/js/src/xpconnect/src/xpcconvert.cpp	2006-03-12 20:04:08.000000000 +0100
@@ -1169,6 +1169,12 @@ XPCConvert::JSObject2NativeInterface(XPC
         }
         // else...
         
+        // XXX E4X breaks the world. Don't try wrapping E4X objects!
+        // This hack can be removed (or changed accordingly) when the
+        // DOM <-> E4X bindings are complete, see bug 270553
+        if(JS_TypeOfValue(cx, OBJECT_TO_JSVAL(src)) == JSTYPE_XML)
+            return JS_FALSE;
+
         // Does the JSObject have 'nsISupportness'?
         // XXX hmm, I wonder if this matters anymore with no 
         // oldstyle DOM objects around.
diff -uprN --exclude=CVS mozilla/js/src/xpconnect/src/XPCNativeWrapper.cpp mozilla.new/js/src/xpconnect/src/XPCNativeWrapper.cpp
--- mozilla/js/src/xpconnect/src/XPCNativeWrapper.cpp	2006-01-11 23:04:49.000000000 +0100
+++ mozilla.new/js/src/xpconnect/src/XPCNativeWrapper.cpp	2006-02-24 11:16:36.000000000 +0100
@@ -1211,10 +1211,6 @@ XPC_NW_Equality(JSContext *cx, JSObject 
   return JS_TRUE;
 }
 
-extern JSBool JS_DLL_CALLBACK
-XPC_WN_Shared_ToString(JSContext *cx, JSObject *obj,
-                       uintN argc, jsval *argv, jsval *vp);
-
 JS_STATIC_DLL_CALLBACK(JSBool)
 XPC_NW_toString(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                 jsval *rval)
@@ -1233,6 +1229,10 @@ XPC_NW_toString(JSContext *cx, JSObject 
     return JS_FALSE;
 
   jsid id = rt->GetStringID(XPCJSRuntime::IDX_TO_STRING);
+  jsval idAsVal;
+  if (!::JS_IdToValue(cx, id, &idAsVal)) {
+    return JS_FALSE;
+  }
 
   XPCWrappedNative *wrappedNative =
     XPCNativeWrapper::GetWrappedNative(cx, obj);
@@ -1249,49 +1249,71 @@ XPC_NW_toString(JSContext *cx, JSObject 
     return JS_TRUE;
   }
 
+  // Someone is trying to call toString on our wrapped object.
   JSObject *wn_obj = wrappedNative->GetFlatJSObject();
-  jsval toStringVal;
-
-  // Check whether toString has been overridden from its XPCWrappedNative
-  // default native method.
-  if (!OBJ_GET_PROPERTY(cx, wn_obj, id, &toStringVal)) {
-    return JS_FALSE;
+  XPCCallContext ccx(JS_CALLER, cx, wn_obj, nsnull, idAsVal);
+  if (!ccx.IsValid()) {
+    // Shouldn't really happen.
+    return ThrowException(NS_ERROR_FAILURE, cx);
   }
 
-  JSBool overridden = JS_TypeOfValue(cx, toStringVal) != JSTYPE_FUNCTION;
-  if (!overridden) {
-    JSObject *toStringFunObj = JSVAL_TO_OBJECT(toStringVal);
-    JSFunction *toStringFun = (JSFunction*) ::JS_GetPrivate(cx, toStringFunObj);
+  XPCNativeInterface *iface = ccx.GetInterface();
+  XPCNativeMember *member = ccx.GetMember();
+  JSBool overridden = JS_FALSE;
+  jsval toStringVal;
 
-    overridden =
-      ::JS_GetFunctionNative(cx, toStringFun) != XPC_WN_Shared_ToString;
+  // First, try to see if the object declares a toString in its IDL. If it does,
+  // then we need to defer to that.
+  if (iface && member) {
+    if (!member->GetValue(ccx, iface, &toStringVal)) {
+      return JS_FALSE;
+    }
+
+    overridden = member->IsMethod();
   }
 
-  JSString* str;
+  JSString* str = nsnull;
   if (overridden) {
-    // Something overrides XPCWrappedNative.prototype.toString, we
-    // should defer to it.
+    // Defer to the IDL-declared toString.
 
-    str = ::JS_ValueToString(cx, OBJECT_TO_JSVAL(wn_obj));
-  } else {
+    AUTO_MARK_JSVAL(ccx, toStringVal);
+
+    JSObject *funobj = xpc_CloneJSFunction(ccx, JSVAL_TO_OBJECT(toStringVal),
+                                           wn_obj);
+    if (!funobj) {
+      return JS_FALSE;
+    }
+
+    jsval v;
+    if (!::JS_CallFunctionValue(cx, wn_obj, OBJECT_TO_JSVAL(funobj), argc, argv,
+                                &v)) {
+      return JS_FALSE;
+    }
+
+    if (JSVAL_IS_STRING(v)) {
+      str = JSVAL_TO_STRING(v);
+    }
+  }
+
+  if (!str) {
     // Ok, we do no damage, and add value, by returning our own idea
     // of what toString() should be.
+    // Note: We can't just call JS_ValueToString on the wrapped object. Instead,
+    // we need to call the wrapper's ToString in order to safely convert our
+    // object to a string.
 
     nsAutoString resultString;
     resultString.AppendLiteral("[object XPCNativeWrapper");
 
-    if (wrappedNative) {
-      JSString *str = ::JS_ValueToString(cx, OBJECT_TO_JSVAL(wn_obj));
-      if (!str) {
-        return JS_FALSE;
-      }
-
-      resultString.Append(' ');
-      resultString.Append(NS_REINTERPRET_CAST(PRUnichar *,
-                                              ::JS_GetStringChars(str)),
-                          ::JS_GetStringLength(str));
+    char *wrapperStr = wrappedNative->ToString(ccx);
+    if (!wrapperStr) {
+      return JS_FALSE;
     }
 
+    resultString.Append(' ');
+    resultString.AppendASCII(wrapperStr);
+    JS_smprintf_free(wrapperStr);
+
     resultString.Append(']');
 
     str = ::JS_NewUCStringCopyN(cx, NS_REINTERPRET_CAST(const jschar *,
diff -uprN --exclude=CVS mozilla/js/src/xpconnect/src/xpcprivate.h mozilla.new/js/src/xpconnect/src/xpcprivate.h
--- mozilla/js/src/xpconnect/src/xpcprivate.h	2005-10-19 23:48:32.000000000 +0200
+++ mozilla.new/js/src/xpconnect/src/xpcprivate.h	2006-02-24 11:16:36.000000000 +0100
@@ -385,6 +385,34 @@ private:
     static void operator delete(void* /*memory*/) {}
 };
 
+// A helper class to deal with temporary JS contexts. It destroys the context
+// when it goes out of scope.
+class XPCAutoJSContext
+{
+public:
+    XPCAutoJSContext(JSContext *aContext, PRBool aGCOnDestroy)
+        : mContext(aContext), mGCOnDestroy(aGCOnDestroy)
+    {
+    }
+
+    ~XPCAutoJSContext()
+    {
+        if(!mContext)
+            return;
+
+        if(mGCOnDestroy)
+            JS_DestroyContext(mContext);
+        else
+            JS_DestroyContextNoGC(mContext);
+    }
+
+    operator JSContext * () {return mContext;}
+
+private:
+    JSContext *mContext;
+    PRBool mGCOnDestroy;
+};
+
 /***************************************************************************
 ****************************************************************************
 *
@@ -3106,6 +3134,31 @@ private:
     jsrefcount mDepth;
 };
 
+class AutoJSSuspendRequestWithNoCallContext
+{
+public:
+    AutoJSSuspendRequestWithNoCallContext(JSContext *aCX)
+      : mCX(aCX) {SuspendRequest();}
+    ~AutoJSSuspendRequestWithNoCallContext() {ResumeRequest();}
+
+    void ResumeRequest() {
+        if(mCX) {
+            JS_ResumeRequest(mCX, mDepth);
+            mCX = nsnull;
+        }
+    }
+private:
+    void SuspendRequest() {
+        if(JS_GetContextThread(mCX))
+            mDepth = JS_SuspendRequest(mCX);
+        else
+            mCX = nsnull;
+    }
+private:
+    JSContext* mCX;
+    jsrefcount mDepth;
+};
+
 /*****************************************/
 
 class AutoJSRequestWithNoCallContext
diff -uprN --exclude=CVS mozilla/js/src/xpconnect/src/xpcruntimesvc.cpp mozilla.new/js/src/xpconnect/src/xpcruntimesvc.cpp
--- mozilla/js/src/xpconnect/src/xpcruntimesvc.cpp	2005-05-12 05:55:41.000000000 +0200
+++ mozilla.new/js/src/xpconnect/src/xpcruntimesvc.cpp	2006-02-24 11:16:36.000000000 +0100
@@ -140,6 +140,14 @@ nsJSRuntimeServiceImpl::GetRuntime(JSRun
         mRuntime = JS_NewRuntime(gGCSize);
         if(!mRuntime)
             return NS_ERROR_OUT_OF_MEMORY;
+
+        // Unconstrain the runtime's threshold on nominal heap size, to avoid
+        // triggering GC too often if operating continuously near an arbitrary
+        // finite threshold (0xffffffff is infinity for uint32 parameters).
+        // This leaves the maximum-JS_malloc-bytes threshold still in effect
+        // to cause period, and we hope hygienic, last-ditch GCs from within
+        // the GC's allocator.
+        JS_SetGCParameter(mRuntime, JSGC_MAX_BYTES, 0xffffffff);
     }
     *runtime = mRuntime;
     return NS_OK;
diff -uprN --exclude=CVS mozilla/js/src/xpconnect/src/xpcwrappedjsclass.cpp mozilla.new/js/src/xpconnect/src/xpcwrappedjsclass.cpp
--- mozilla/js/src/xpconnect/src/xpcwrappedjsclass.cpp	2005-11-03 05:33:58.000000000 +0100
+++ mozilla.new/js/src/xpconnect/src/xpcwrappedjsclass.cpp	2006-03-03 07:13:08.000000000 +0100
@@ -1337,6 +1337,9 @@ pre_call_clean_up:
     // Make sure "this" doesn't get deleted during this call.
     nsCOMPtr<nsIXPCWrappedJSClass> kungFuDeathGrip(this);
 
+    result = JSVAL_NULL;
+    AUTO_MARK_JSVAL(ccx, &result);
+
     if(!readyToDoTheCall)
         goto done;
 
diff -uprN --exclude=CVS mozilla/js/src/xpconnect/src/xpcwrappednativejsops.cpp mozilla.new/js/src/xpconnect/src/xpcwrappednativejsops.cpp
--- mozilla/js/src/xpconnect/src/xpcwrappednativejsops.cpp	2005-10-11 23:17:10.000000000 +0200
+++ mozilla.new/js/src/xpconnect/src/xpcwrappednativejsops.cpp	2006-02-24 11:16:36.000000000 +0100
@@ -119,7 +119,7 @@ ToStringGuts(XPCCallContext& ccx)
 
 /***************************************************************************/
 
-JSBool JS_DLL_CALLBACK
+JS_STATIC_DLL_CALLBACK(JSBool)
 XPC_WN_Shared_ToString(JSContext *cx, JSObject *obj,
                        uintN argc, jsval *argv, jsval *vp)
 {
diff -uprN --exclude=CVS mozilla/layout/base/nsCSSFrameConstructor.cpp mozilla.new/layout/base/nsCSSFrameConstructor.cpp
--- mozilla/layout/base/nsCSSFrameConstructor.cpp	2006-01-09 06:48:53.000000000 +0100
+++ mozilla.new/layout/base/nsCSSFrameConstructor.cpp	2006-03-12 20:04:19.000000000 +0100
@@ -22,6 +22,7 @@
  *
  * Contributor(s):
  *   Dan Rosen <dr@netscape.com>
+ *   Mats Palmgren <mats.palmgren@bredband.net>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
@@ -273,7 +274,7 @@ static FrameCtorDebugFlags gFlags[] = {
 #include "nsPopupSetFrame.h"
 #include "nsTreeColFrame.h"
 #include "nsIBoxObject.h"
-#include "nsIListBoxObject.h"
+#include "nsPIListBoxObject.h"
 #include "nsListBoxBodyFrame.h"
 #include "nsListItemFrame.h"
 
@@ -390,6 +391,11 @@ static PRInt32 FFWC_nextInFlows=0;
 static PRInt32 FFWC_slowSearchForText=0;
 #endif
 
+static nsresult
+DeletingFrameSubtree(nsPresContext*  aPresContext,
+                     nsFrameManager* aFrameManager,
+                     nsIFrame*       aFrame);
+
 #ifdef  MOZ_SVG
 
 // Test to see if this language is supported
@@ -526,7 +532,11 @@ GetIBContainingBlockFor(nsIFrame* aFrame
       return aFrame;
     }
 
-    if (!IsFrameSpecial(parentFrame))
+    // Note that we ignore non-special frames which have a pseudo on their
+    // style context -- they're not the frames we're looking for!  In
+    // particular, they may be hiding a real parent that _is_ special.
+    if (!IsFrameSpecial(parentFrame) &&
+        !parentFrame->GetStyleContext()->GetPseudoType())
       break;
 
     aFrame = parentFrame;
@@ -1106,12 +1116,18 @@ public:
   ~nsFrameConstructorState();
   
   // Function to push the existing absolute containing block state and
-  // create a new scope.
+  // create a new scope. Code that uses this function should get matching
+  // logic in GetAbsoluteContainingBlock.
   void PushAbsoluteContainingBlock(nsIFrame* aNewAbsoluteContainingBlock,
                                    nsFrameConstructorSaveState& aSaveState);
 
   // Function to push the existing float containing block state and
-  // create a new scope
+  // create a new scope. Code that uses this function should get matching
+  // logic in GetFloatContainingBlock.
+  // Pushing a null float containing block forbids any frames from being
+  // floated until a new float containing block is pushed.
+  // XXX we should get rid of null float containing blocks and teach the
+  // various frame classes to deal with floats instead.
   void PushFloatContainingBlock(nsIFrame* aNewFloatContainingBlock,
                                 nsFrameConstructorSaveState& aSaveState,
                                 PRBool aFirstLetterStyle,
@@ -5320,9 +5336,14 @@ nsCSSFrameConstructor::ConstructTextFram
 
 #ifdef MOZ_SVG
   nsresult rv;
-  nsCOMPtr<nsISVGTextContainerFrame> svg_parent = do_QueryInterface(aParentFrame);
-  if (svg_parent)
+
+  if (aParentFrame->IsFrameOfType(nsIFrame::eSVG)) {
+    nsCOMPtr<nsISVGTextContainerFrame> svg_parent = do_QueryInterface(aParentFrame);
+    if (!svg_parent) {
+      return NS_OK;
+    }
     rv = NS_NewSVGGlyphFrame(mPresShell, aContent, aParentFrame, &newFrame);
+  }
   else
     rv = NS_NewTextFrame(mPresShell, &newFrame);
 #else
@@ -5880,6 +5901,11 @@ nsCSSFrameConstructor::ConstructXULFrame
   PRBool isXULNS = (aNameSpaceID == kNameSpaceID_XUL);
   PRBool isXULDisplay = IsXULDisplayType(display);
 
+  // don't apply xul display types to tag based frames
+  if (isXULDisplay && !isXULNS) {
+    isXULDisplay = !IsSpecialContent(aContent, aTag, aNameSpaceID);
+  }
+ 
   if (isXULNS || isXULDisplay) {
     PRBool mayBeScrollable = PR_FALSE;
 
@@ -7059,6 +7085,10 @@ nsCSSFrameConstructor::ConstructMathMLFr
       return rv;
     }
 
+    // Push a null float containing block to disable floating within mathml
+    nsFrameConstructorSaveState saveState;
+    aState.PushFloatContainingBlock(nsnull, saveState, PR_FALSE, PR_FALSE);
+
     // MathML frames are inline frames, so just process their kids
     nsFrameItems childItems;
     rv = ProcessChildren(aState, aContent, newFrame, PR_TRUE,
@@ -7714,6 +7744,19 @@ nsCSSFrameConstructor::ConstructFrameInt
     return ConstructTextFrame(aState, aContent, adjParentFrame, styleContext,
                               *frameItems, pseudoParent);
 
+#ifdef MOZ_SVG
+  // Don't create frames for non-SVG children of SVG elements
+  if (aNameSpaceID != kNameSpaceID_SVG &&
+      aParentFrame &&
+      aParentFrame->IsFrameOfType(nsIFrame::eSVG)
+#ifdef MOZ_SVG_FOREIGNOBJECT
+      && !aParentFrame->IsFrameOfType(nsIFrame::eSVGForeignObject)
+#endif
+      ) {
+    return NS_OK;
+  }
+#endif
+ 
   // Style resolution can normally happen lazily.  However, getting the
   // Visibility struct can cause |SetBidiEnabled| to be called on the
   // pres context, and this needs to happen before we start reflow, so
@@ -7981,7 +8024,7 @@ nsCSSFrameConstructor::GetFloatContainin
   
   // Starting with aFrame, look for a frame that is a float containing block
   for (nsIFrame* containingBlock = aFrame;
-       containingBlock;
+       containingBlock && !containingBlock->IsFrameOfType(nsIFrame::eMathML);
        containingBlock = containingBlock->GetParent()) {
     if (containingBlock->IsFloatContainingBlock()) {
       return containingBlock;
@@ -8879,13 +8922,6 @@ nsCSSFrameConstructor::AddDummyFrameToSe
   return NS_ERROR_FAILURE;
 }
 
-// defined below
-static nsresult
-DeletingFrameSubtree(nsPresContext*  aPresContext,
-                     nsIPresShell*    aPresShell,
-                     nsFrameManager*  aFrameManager,
-                     nsIFrame*        aFrame);
-
 nsresult
 nsCSSFrameConstructor::RemoveDummyFrameFromSelect(nsIContent*     aContainer,
                                                   nsIContent*     aChild,
@@ -8913,8 +8949,8 @@ nsCSSFrameConstructor::RemoveDummyFrameF
           nsIFrame* parentFrame = dummyFrame->GetParent();
 
           nsFrameManager *frameManager = mPresShell->FrameManager();
-          DeletingFrameSubtree(mPresShell->GetPresContext(), mPresShell,
-                               frameManager, dummyFrame);
+          ::DeletingFrameSubtree(mPresShell->GetPresContext(),
+                                 frameManager, dummyFrame);
           frameManager->RemoveFrame(parentFrame, nsnull, dummyFrame);
           return NS_OK;
         }
@@ -9061,19 +9097,24 @@ PRBool NotifyListBoxBody(nsPresContext* 
     nsCOMPtr<nsIDOMXULElement> xulElement = do_QueryInterface(aContainer);
     nsCOMPtr<nsIBoxObject> boxObject;
     xulElement->GetBoxObject(getter_AddRefs(boxObject));
-    nsCOMPtr<nsIListBoxObject> listBoxObject = do_QueryInterface(boxObject);
+    nsCOMPtr<nsPIListBoxObject> listBoxObject = do_QueryInterface(boxObject);
     if (listBoxObject) {
-      nsIListBoxObject* listboxBody;
-      listBoxObject->GetListboxBody(&listboxBody);
+      nsIListBoxObject* listboxBody = listBoxObject->GetListBoxBody();
       if (listboxBody) {
         nsListBoxBodyFrame *listBoxBodyFrame = NS_STATIC_CAST(nsListBoxBodyFrame*, listboxBody);
-        if (aOperation == CONTENT_REMOVED)
-          listBoxBodyFrame->OnContentRemoved(aPresContext, aChildFrame, aIndexInContainer);
-        else
+        if (aOperation == CONTENT_REMOVED) {
+          // Except if we have an aChildFrame and its parent is not the right
+          // thing, then we don't do this.  Pseudo frames are so much fun....
+          if (!aChildFrame || aChildFrame->GetParent() == listBoxBodyFrame) {
+            listBoxBodyFrame->OnContentRemoved(aPresContext, aChildFrame,
+                                               aIndexInContainer);
+            return PR_TRUE;
+          }
+        } else {
           listBoxBodyFrame->OnContentInserted(aPresContext, aChild);
-        //NS_RELEASE(listBoxBodyFrame); frames aren't refcounted
+          return PR_TRUE;
+        }
       }
-      return PR_TRUE;
     }
   }
 
@@ -9556,15 +9597,12 @@ nsCSSFrameConstructor::ReinsertContent(n
  */
 static nsresult
 DoDeletingFrameSubtree(nsPresContext*  aPresContext,
-                       nsIPresShell*    aPresShell,
-                       nsFrameManager*  aFrameManager,
-                       nsVoidArray&     aDestroyQueue,
-                       nsIFrame*        aRemovedFrame,
-                       nsIFrame*        aFrame)
+                       nsFrameManager* aFrameManager,
+                       nsVoidArray&    aDestroyQueue,
+                       nsIFrame*       aRemovedFrame,
+                       nsIFrame*       aFrame)
 {
-  NS_PRECONDITION(aFrameManager, "no frame manager");
-
-  // Remove the mapping from the content object to its frame
+  // Remove the mapping from the content object to its frame.
   nsIContent* content = aFrame->GetContent();
   if (content) {
     aFrameManager->SetPrimaryFrameFor(content, nsnull);
@@ -9572,58 +9610,54 @@ DoDeletingFrameSubtree(nsPresContext*  a
     aFrameManager->ClearAllUndisplayedContentIn(content);
   }
 
-  // Walk aFrame's child frames
   nsIAtom* childListName = nsnull;
   PRInt32 childListIndex = 0;
 
   do {
-    // Walk aFrame's child frames looking for placeholder frames
+    // Walk aFrame's normal flow child frames looking for placeholder frames.
     nsIFrame* childFrame = aFrame->GetFirstChild(childListName);
-    while (childFrame) {
-      // The subtree we need to follow to get to the children; by
-      // default, the childFrame.
-      nsIFrame* subtree = childFrame;
-
-      // See if it's a placeholder frame
-      if (nsLayoutAtoms::placeholderFrame == childFrame->GetType()) {
-        // Get the out-of-flow frame
+    for (; childFrame; childFrame = childFrame->GetNextSibling()) {
+      if (NS_LIKELY(nsLayoutAtoms::placeholderFrame != childFrame->GetType())) {
+        DoDeletingFrameSubtree(aPresContext, aFrameManager, aDestroyQueue,
+                               aRemovedFrame, childFrame);
+
+      } else {
         nsIFrame* outOfFlowFrame =
           nsPlaceholderFrame::GetRealFrameForPlaceholder(childFrame);
   
-        // Remove the mapping from the out-of-flow frame to its placeholder
+        // Remove the mapping from the out-of-flow frame to its placeholder.
         aFrameManager->UnregisterPlaceholderFrame((nsPlaceholderFrame*)childFrame);
-        
-        // Destroy the out-of-flow frame only if aRemovedFrame is _not_
+        ((nsPlaceholderFrame*)childFrame)->SetOutOfFlowFrame(nsnull);
+
+        // Queue the out-of-flow frame to be destroyed only if aRemovedFrame is _not_
         // one of its ancestor frames or if it is a popup frame. 
         // If aRemovedFrame is an ancestor of the out-of-flow frame, then 
         // the out-of-flow frame will be destroyed by aRemovedFrame.
-        const nsStyleDisplay* display = outOfFlowFrame->GetStyleDisplay();
-        if (display->mDisplay == NS_STYLE_DISPLAY_POPUP ||
+        if (outOfFlowFrame->GetStyleDisplay()->mDisplay == NS_STYLE_DISPLAY_POPUP ||
             !nsLayoutUtils::IsProperAncestorFrame(aRemovedFrame, outOfFlowFrame)) {
-          if (aDestroyQueue.IndexOf(outOfFlowFrame) < 0)
-            aDestroyQueue.AppendElement(outOfFlowFrame);
-
-          // We want to descend into the out-of-flow frame's subtree,
-          // not the placeholder frame's!
-          subtree = outOfFlowFrame;
+          NS_ASSERTION(aDestroyQueue.IndexOf(outOfFlowFrame) == kNotFound,
+                       "out-of-flow is already in the destroy queue");
+          aDestroyQueue.AppendElement(outOfFlowFrame);
+          // Recurse into the out-of-flow, it is now the aRemovedFrame.
+          DoDeletingFrameSubtree(aPresContext, aFrameManager, aDestroyQueue,
+                                 outOfFlowFrame, outOfFlowFrame);
+        }
+        else {
+          // Also recurse into the out-of-flow when it's a descendant of aRemovedFrame
+          // since we don't walk those lists, see |childListName| increment below.
+          DoDeletingFrameSubtree(aPresContext, aFrameManager, aDestroyQueue,
+                                 aRemovedFrame, outOfFlowFrame);
         }
-
-        // Note that if outOfFlowFrame is aRemovedFrame's descendant we don't
-        // need to explicitly recurse into outOfFlowFrame here, since we'll do
-        // it whenever we recurse into the appropriate child and into its
-        // appropriate child list.
       }
-
-      // Recursively find and delete any of its out-of-flow frames,
-      // and remove the mapping from content objects to frames
-      DoDeletingFrameSubtree(aPresContext, aPresShell, aFrameManager, aDestroyQueue,
-                             aRemovedFrame, subtree);
-  
-      // Get the next sibling child frame
-      childFrame = childFrame->GetNextSibling();
     }
 
-    childListName = aFrame->GetAdditionalChildListName(childListIndex++);
+    // Move to next child list but skip lists with frames we should have
+    // a placeholder for.
+    do {
+      childListName = aFrame->GetAdditionalChildListName(childListIndex++);
+    } while (childListName == nsLayoutAtoms::floatList    ||
+             childListName == nsLayoutAtoms::absoluteList ||
+             childListName == nsLayoutAtoms::fixedList);
   } while (childListName);
 
   return NS_OK;
@@ -9635,80 +9669,76 @@ DoDeletingFrameSubtree(nsPresContext*  a
  */
 static nsresult
 DeletingFrameSubtree(nsPresContext*  aPresContext,
-                     nsIPresShell*    aPresShell,
-                     nsFrameManager*  aFrameManager,
-                     nsIFrame*        aFrame)
+                     nsFrameManager* aFrameManager,
+                     nsIFrame*       aFrame)
 {
-  // If there's no frame manager it's probably because the pres shell is
-  // being destroyed
   NS_ENSURE_TRUE(aFrame, NS_OK); // XXXldb Remove this sometime in the future.
-  if (aFrameManager) {
-    nsAutoVoidArray destroyQueue;
 
-    // If it's a "special" block-in-inline frame, then we need to
-    // remember to delete our special siblings, too.  Since every one of
-    // the next-in-flows has the same special sibling, just do this
-    // once, rather than in the loop below.
-    if (IsFrameSpecial(aFrame)) {
-      nsIFrame* specialSibling;
-      GetSpecialSibling(aFrameManager, aFrame, &specialSibling);
-      if (specialSibling)
-        DeletingFrameSubtree(aPresContext, aPresShell, aFrameManager,
-                             specialSibling);
-    }
+  // If there's no frame manager it's probably because the pres shell is
+  // being destroyed.
+  if (NS_UNLIKELY(!aFrameManager)) {
+    return NS_OK;
+  }
 
-    do {
-      DoDeletingFrameSubtree(aPresContext, aPresShell, aFrameManager,
-                             destroyQueue, aFrame, aFrame);
+  nsAutoVoidArray destroyQueue;
+
+  // If it's a "special" block-in-inline frame, then we can't really deal.
+  // That really shouldn't be happening.
+  NS_ASSERTION(!IsFrameSpecial(aFrame),
+               "DeletingFrameSubtree on a special frame.  Prepare to crash.");
+
+  do {
+    DoDeletingFrameSubtree(aPresContext, aFrameManager, destroyQueue,
+                           aFrame, aFrame);
 
-      // If it's split, then get the continuing frame. Note that we only do
-      // this for the top-most frame being deleted. Don't do it if we're
-      // recursing over a subtree, because those continuing frames should be
-      // found as part of the walk over the top-most frame's continuing frames.
-      // Walking them again will make this an N^2/2 algorithm
-      aFrame = aFrame->GetNextInFlow();
-    } while (aFrame);
-
-    // Now destroy any frames that have been enqueued for destruction.
-    for (PRInt32 i = destroyQueue.Count() - 1; i >= 0; --i) {
-      nsIFrame* outOfFlowFrame = NS_STATIC_CAST(nsIFrame*, destroyQueue[i]);
+    // If it's split, then get the continuing frame. Note that we only do
+    // this for the top-most frame being deleted. Don't do it if we're
+    // recursing over a subtree, because those continuing frames should be
+    // found as part of the walk over the top-most frame's continuing frames.
+    // Walking them again will make this an N^2/2 algorithm.
+    aFrame = aFrame->GetNextInFlow();
+  } while (aFrame);
+
+  // Now destroy any out-of-flow frames that have been enqueued for destruction.
+  for (PRInt32 i = destroyQueue.Count() - 1; i >= 0; --i) {
+    nsIFrame* outOfFlowFrame = NS_STATIC_CAST(nsIFrame*, destroyQueue[i]);
 
 #ifdef MOZ_XUL
-      const nsStyleDisplay* display = outOfFlowFrame->GetStyleDisplay();
-      if (display->mDisplay == NS_STYLE_DISPLAY_POPUP) {
-        // Locate the root popup set and remove ourselves from the popup set's list
-        // of popup frames.
-        nsIFrame* rootFrame = aFrameManager->GetRootFrame();
-        if (rootFrame)
-          rootFrame = rootFrame->GetFirstChild(nsnull);
-        nsCOMPtr<nsIRootBox> rootBox(do_QueryInterface(rootFrame));
-        NS_ASSERTION(rootBox, "unexpected null pointer");
-        if (rootBox) {
-          nsIFrame* popupSetFrame;
-          rootBox->GetPopupSetFrame(&popupSetFrame);
-          NS_ASSERTION(popupSetFrame, "unexpected null pointer");
-          if (popupSetFrame) {
-            nsCOMPtr<nsIPopupSetFrame> popupSet(do_QueryInterface(popupSetFrame));
-            NS_ASSERTION(popupSet, "unexpected null pointer");
-            if (popupSet)
-              popupSet->RemovePopupFrame(outOfFlowFrame);
-          }
+    const nsStyleDisplay* display = outOfFlowFrame->GetStyleDisplay();
+    if (display->mDisplay == NS_STYLE_DISPLAY_POPUP) {
+      // Locate the root popup set and remove ourselves from the popup set's list
+      // of popup frames.
+      nsIFrame* rootFrame = aFrameManager->GetRootFrame();
+      if (rootFrame)
+        rootFrame = rootFrame->GetFirstChild(nsnull);
+      nsCOMPtr<nsIRootBox> rootBox(do_QueryInterface(rootFrame));
+      NS_ASSERTION(rootBox, "unexpected null pointer");
+      if (rootBox) {
+        nsIFrame* popupSetFrame;
+        rootBox->GetPopupSetFrame(&popupSetFrame);
+        NS_ASSERTION(popupSetFrame, "unexpected null pointer");
+        if (popupSetFrame) {
+          nsCOMPtr<nsIPopupSetFrame> popupSet(do_QueryInterface(popupSetFrame));
+          NS_ASSERTION(popupSet, "unexpected null pointer");
+          if (popupSet)
+            popupSet->RemovePopupFrame(outOfFlowFrame);
         }
-      } else
+      }
+    } else
 #endif
-      {
-        // Get the out-of-flow frame's parent
-        nsIFrame* parentFrame = outOfFlowFrame->GetParent();
+    {
+      // Get the out-of-flow frame's parent
+      nsIFrame* parentFrame = outOfFlowFrame->GetParent();
   
-        // Get the child list name for the out-of-flow frame
-        nsCOMPtr<nsIAtom> listName;
-        GetChildListNameFor(parentFrame, outOfFlowFrame,
-                            getter_AddRefs(listName));
-  
-        // Ask the parent to delete the out-of-flow frame
-        aFrameManager->RemoveFrame(parentFrame,
-                                   listName, outOfFlowFrame);
-      }
+      // Get the child list name for the out-of-flow frame
+      nsCOMPtr<nsIAtom> listName;
+      GetChildListNameFor(parentFrame, outOfFlowFrame,
+                          getter_AddRefs(listName));
+  
+      // Ask the out-of-flow's parent to delete the out-of-flow
+      // frame from the right list.
+      aFrameManager->RemoveFrame(parentFrame,
+                                 listName, outOfFlowFrame);
     }
   }
 
@@ -9722,8 +9752,8 @@ nsCSSFrameConstructor::RemoveMappingsFor
   // Save the frame tree's state before deleting it
   CaptureStateFor(aRemovedFrame, mTempFrameTreeState);
 
-  return DeletingFrameSubtree(mPresShell->GetPresContext(), mPresShell,
-                              mPresShell->FrameManager(), aRemovedFrame);
+  return ::DeletingFrameSubtree(mPresShell->GetPresContext(),
+                                mPresShell->FrameManager(), aRemovedFrame);
 }
 
 nsresult
@@ -9881,7 +9911,7 @@ nsCSSFrameConstructor::ContentRemoved(ns
 
     // Walk the frame subtree deleting any out-of-flow frames, and
     // remove the mapping from content objects to frames
-    DeletingFrameSubtree(presContext, mPresShell, frameManager, childFrame);
+    ::DeletingFrameSubtree(presContext, frameManager, childFrame);
 
     // See if the child frame is a floating frame
     //   (positioned frames are handled below in the "else" clause)
@@ -9916,8 +9946,7 @@ nsCSSFrameConstructor::ContentRemoved(ns
         // that it doesn't retain a dangling pointer to memory)
         if (placeholderFrame) {
           parentFrame = placeholderFrame->GetParent();
-          DeletingFrameSubtree(presContext, mPresShell, frameManager,
-                               placeholderFrame);
+          ::DeletingFrameSubtree(presContext, frameManager, placeholderFrame);
           frameManager->RemoveFrame(parentFrame, nsnull, placeholderFrame);
           return NS_OK;
         }
@@ -9953,8 +9982,7 @@ nsCSSFrameConstructor::ContentRemoved(ns
         // that it doesn't retain a dangling pointer to memory)
         if (placeholderFrame) {
           parentFrame = placeholderFrame->GetParent();
-          DeletingFrameSubtree(presContext, mPresShell, frameManager,
-                               placeholderFrame);
+          DeletingFrameSubtree(presContext, frameManager, placeholderFrame);
           rv = frameManager->RemoveFrame(parentFrame,
                                          nsnull, placeholderFrame);
         }
@@ -10077,7 +10105,6 @@ UpdateViewsForTree(nsPresContext* aPresC
           // get out of flow frame and start over there
           nsIFrame* outOfFlowFrame =
             nsPlaceholderFrame::GetRealFrameForPlaceholder(child);
-          NS_ASSERTION(outOfFlowFrame, "no out-of-flow frame");
 
           DoApplyRenderingChangeToTree(aPresContext, outOfFlowFrame,
                                        aViewManager, aFrameManager, aChange);
@@ -10877,8 +10904,8 @@ nsCSSFrameConstructor::CantRenderReplace
 
       // Replace the old frame with the new frame
 
-      DeletingFrameSubtree(mPresShell->GetPresContext(), mPresShell,
-                           frameManager, aFrame);
+      ::DeletingFrameSubtree(mPresShell->GetPresContext(), frameManager,
+                             aFrame);
 
       // Reset the primary frame mapping
       frameManager->SetPrimaryFrameFor(content, newFrame);
@@ -11027,8 +11054,7 @@ nsCSSFrameConstructor::CantRenderReplace
         newFrame = state.mFloatedItems.childList;
         state.mFloatedItems.childList = nsnull;
       }
-      DeletingFrameSubtree(state.mPresContext, mPresShell,
-                           state.mFrameManager, aFrame);
+      ::DeletingFrameSubtree(state.mPresContext, state.mFrameManager, aFrame);
       state.mFrameManager->ReplaceFrame(parentFrame, listName, aFrame,
                                         newFrame);
 
@@ -11701,7 +11727,7 @@ nsCSSFrameConstructor::GetInsertionPoint
 
   nsIBindingManager *bindingManager = mDocument->BindingManager();
 
-  nsCOMPtr<nsIContent> insertionElement;
+  nsIContent* insertionElement;
   if (aChildContent) {
     // We've got an explicit insertion child. Check to see if it's
     // anonymous.
@@ -11746,6 +11772,16 @@ nsCSSFrameConstructor::GetInsertionPoint
     }
   }
 
+  // fieldsets have multiple insertion points.  Note that we might
+  // have to look at insertionElement here...
+  if (aMultiple && !*aMultiple) {
+    nsIContent* content = insertionElement ? insertionElement : container;
+    if (content->IsContentOfType(nsIContent::eHTML) &&
+        content->Tag() == nsHTMLAtoms::fieldset) {
+      *aMultiple = PR_TRUE;
+    }
+  }
+
   return NS_OK;
 }
 
@@ -12606,8 +12642,8 @@ nsCSSFrameConstructor::WrapFramesInFirst
     }
     else {
       // Take the old textFrame out of the inline parents child list
-      DeletingFrameSubtree(aState.mPresContext, mPresShell, 
-                           aState.mFrameManager, textFrame);
+      ::DeletingFrameSubtree(aState.mPresContext, aState.mFrameManager,
+                             textFrame);
       parentFrame->RemoveFrame(nsnull, textFrame);
 
       // Insert in the letter frame(s)
@@ -12760,8 +12796,7 @@ nsCSSFrameConstructor::RemoveFloatingFir
     nsIFrame* nextTextParent = nextTextFrame->GetParent();
     if (nextTextParent) {
       nsSplittableFrame::BreakFromPrevFlow(nextTextFrame);
-      DeletingFrameSubtree(aPresContext, aPresShell, 
-                           aFrameManager, nextTextFrame);
+      ::DeletingFrameSubtree(aPresContext, aFrameManager, nextTextFrame);
       aFrameManager->RemoveFrame(nextTextParent, nsnull, nextTextFrame);
     }
   }
@@ -12786,7 +12821,7 @@ nsCSSFrameConstructor::RemoveFloatingFir
   aFrameManager->UnregisterPlaceholderFrame(placeholderFrame);
 
   // Remove the float frame
-  DeletingFrameSubtree(aPresContext, aPresShell, aFrameManager, floatFrame);
+  ::DeletingFrameSubtree(aPresContext, aFrameManager, floatFrame);
   aFrameManager->RemoveFrame(aBlockFrame, nsLayoutAtoms::floatList,
                              floatFrame);
 
@@ -12837,13 +12872,11 @@ nsCSSFrameConstructor::RemoveFirstLetter
       textFrame->Init(aPresContext, textContent, aFrame, newSC, nsnull);
 
       // Next rip out the kid and replace it with the text frame
-      nsFrameManager* frameManager = aFrameManager;
-      DeletingFrameSubtree(aPresContext, aPresShell, frameManager, kid);
-      frameManager->RemoveFrame(aFrame, nsnull, kid);
+      ::DeletingFrameSubtree(aPresContext, aFrameManager, kid);
+      aFrameManager->RemoveFrame(aFrame, nsnull, kid);
 
       // Insert text frame in its place
-      frameManager->InsertFrames(aFrame, nsnull,
-                                 prevSibling, textFrame);
+      aFrameManager->InsertFrames(aFrame, nsnull, prevSibling, textFrame);
 
       *aStopLooking = PR_TRUE;
       break;
@@ -12903,8 +12936,8 @@ nsCSSFrameConstructor::RecoverLetterFram
   }
   if (parentFrame) {
     // Take the old textFrame out of the parents child list
-    DeletingFrameSubtree(aState.mPresContext, mPresShell,
-                         aState.mFrameManager, textFrame);
+    ::DeletingFrameSubtree(aState.mPresContext, aState.mFrameManager,
+                           textFrame);
     parentFrame->RemoveFrame(nsnull, textFrame);
 
     // Insert in the letter frame(s)
@@ -13418,6 +13451,18 @@ nsCSSFrameConstructor::WipeContainingBlo
   tmp.SetFrames(aState.mFloatedItems.childList);
   tmp.DestroyFrames(presContext);
   aState.mFloatedItems.childList = nsnull;
+
+  // If we don't have a containing block, try to find our closest non-inline
+  // ancestor.  We're guaranteed to have one, since
+  // nsStyleContext::ApplyStyleFixups enforces that the root is display:none,
+  // display:table, or display:block.
+  if (!aContainingBlock) {
+    aContainingBlock = aFrame;
+    do {
+      aContainingBlock = aContainingBlock->GetParent();
+      NS_ASSERTION(aContainingBlock, "Must have non-inline frame as root!");
+    } while (IsInlineFrame(aContainingBlock));
+  }
   
   // Tell parent of the containing block to reformulate the
   // entire block. This is painful and definitely not optimal
@@ -13441,8 +13486,8 @@ nsCSSFrameConstructor::WipeContainingBlo
   if (parentContainer) {
     ReinsertContent(parentContainer, blockContent);
   }
-  else {
-    NS_ERROR("uh oh. the block we need to reframe has no parent!");
+  else if (blockContent->GetCurrentDoc() == mDocument) {
+    ReconstructDocElementHierarchy();
   }
   return PR_TRUE;
 }
@@ -13552,8 +13597,16 @@ nsCSSFrameConstructor::SplitToContaining
   if (! aBlockChildFrame)
     return NS_ERROR_NULL_POINTER;
 
-  if (IsBlockFrame(aFrame)) {
-    // If aFrame is a block frame, then we're done: make
+  // Check whether the frame is an inline.  Here "an inline" is an
+  // actual inline frame (positioned or not) or a lineframe
+  // (corresponding to :first-line), since the latter should stop at
+  // the first block it runs into and we might be inserting one in the
+  // middle of it.
+  nsIAtom* frameType = aFrame->GetType();
+  if (frameType != nsLayoutAtoms::inlineFrame &&
+      frameType != nsLayoutAtoms::positionedInlineFrame &&
+      frameType != nsLayoutAtoms::lineFrame) {
+    // If aFrame is a block-like frame, then we're done: make
     // aBlockChildFrame and aRightInlineChildFrame children of aFrame,
     // and insert aBlockChildFrame and aRightInlineChildFrame after
     // aLeftInlineChildFrame
@@ -13780,8 +13833,8 @@ nsresult nsCSSFrameConstructor::RemoveFi
         mPresShell->GetPlaceholderFrameFor(fixedChild, &placeholderFrame);
         NS_ASSERTION(placeholderFrame, "no placeholder for fixed-pos frame");
         nsIFrame* placeholderParent = placeholderFrame->GetParent();
-        DeletingFrameSubtree(aState.mPresContext, mPresShell, aState.mFrameManager,
-                             placeholderFrame);
+        ::DeletingFrameSubtree(aState.mPresContext, aState.mFrameManager,
+                               placeholderFrame);
         rv = aState.mFrameManager->RemoveFrame(placeholderParent, nsnull,
                                                placeholderFrame);
         if (NS_FAILED(rv)) {
@@ -13789,8 +13842,8 @@ nsresult nsCSSFrameConstructor::RemoveFi
           break;
         }
 
-        DeletingFrameSubtree(aState.mPresContext, mPresShell, aState.mFrameManager,
-                             fixedChild);
+        ::DeletingFrameSubtree(aState.mPresContext, aState.mFrameManager,
+                               fixedChild);
         rv = aState.mFrameManager->RemoveFrame(mFixedContainingBlock,
                                                nsLayoutAtoms::fixedList,
                                                fixedChild);
diff -uprN --exclude=CVS mozilla/layout/base/nsImageLoader.cpp mozilla.new/layout/base/nsImageLoader.cpp
--- mozilla/layout/base/nsImageLoader.cpp	2004-12-08 20:39:48.000000000 +0100
+++ mozilla.new/layout/base/nsImageLoader.cpp	2006-02-24 11:16:42.000000000 +0100
@@ -123,7 +123,13 @@ nsImageLoader::Load(imgIRequest *aImage)
     mRequest = nsnull;
   }
 
-  return aImage->Clone(this, getter_AddRefs(mRequest));
+  // Make sure to clone into a temporary, then set mRequest, since
+  // cloning may notify and we don't want to trigger paints from this
+  // code.
+  nsCOMPtr<imgIRequest> newRequest;
+  nsresult rv = aImage->Clone(this, getter_AddRefs(newRequest));
+  mRequest.swap(newRequest);
+  return rv;
 }
 
                     
diff -uprN --exclude=CVS mozilla/layout/generic/nsBlockFrame.cpp mozilla.new/layout/generic/nsBlockFrame.cpp
--- mozilla/layout/generic/nsBlockFrame.cpp	2006-01-09 06:48:54.000000000 +0100
+++ mozilla.new/layout/generic/nsBlockFrame.cpp	2006-02-24 11:16:42.000000000 +0100
@@ -5659,14 +5659,10 @@ found_frame:;
     NS_ASSERTION(this == aDeletedFrame->GetParent(), "messed up delete code");
     NS_ASSERTION(line->Contains(aDeletedFrame), "frame not in line");
 
-    // See if the frame being deleted is the last one on the line
-    PRBool isLastFrameOnLine = PR_FALSE;
-    if (1 == line->GetChildCount()) {
-      isLastFrameOnLine = PR_TRUE;
-    }
-    else if (line->LastChild() == aDeletedFrame) {
-      isLastFrameOnLine = PR_TRUE;
-    }
+    // If the frame being deleted is the last one on the line then
+    // optimize away the line->Contains(next-in-flow) call below.
+    PRBool isLastFrameOnLine = (1 == line->GetChildCount() ||
+                                line->LastChild() == aDeletedFrame);
 
     // Remove aDeletedFrame from the line
     nsIFrame* nextFrame = aDeletedFrame->GetNextSibling();
@@ -5703,7 +5699,8 @@ found_frame:;
     // to destroy that too.
     nsIFrame* deletedNextInFlow = aDeletedFrame->GetNextInFlow();
 #ifdef NOISY_REMOVE_FRAME
-    printf("DoRemoveFrame: line=%p frame=", line.get());
+    printf("DoRemoveFrame: %s line=%p frame=",
+           searchingOverflowList?"overflow":"normal", line.get());
     nsFrame::ListTag(stdout, aDeletedFrame);
     printf(" prevSibling=%p deletedNextInFlow=%p\n", prevSibling, deletedNextInFlow);
 #endif
@@ -5714,8 +5711,13 @@ found_frame:;
     }
     aDeletedFrame = deletedNextInFlow;
 
+    PRBool haveAdvancedToNextLine = PR_FALSE;
     // If line is empty, remove it now.
     if (0 == lineChildCount) {
+#ifdef NOISY_REMOVE_FRAME
+        printf("DoRemoveFrame: %s line=%p became empty so it will be removed\n",
+               searchingOverflowList?"overflow":"normal", line.get());
+#endif
       nsLineBox *cur = line;
       if (!searchingOverflowList) {
         line = mLines.erase(line);
@@ -5726,7 +5728,8 @@ found_frame:;
         nsRect lineCombinedArea(cur->GetCombinedArea());
 #ifdef NOISY_BLOCK_INVALIDATE
         printf("%p invalidate 10 (%d, %d, %d, %d)\n",
-               this, lineCombinedArea.x, lineCombinedArea.y, lineCombinedArea.width, lineCombinedArea.height);
+               this, lineCombinedArea.x, lineCombinedArea.y,
+               lineCombinedArea.width, lineCombinedArea.height);
 #endif
         Invalidate(lineCombinedArea);
       } else {
@@ -5745,16 +5748,19 @@ found_frame:;
       if (line != line_end) {
         line->MarkPreviousMarginDirty();
       }
+      haveAdvancedToNextLine = PR_TRUE;
     } else {
       // Make the line that just lost a frame dirty, and advance to
       // the next line.
-      if (!deletedNextInFlow || !line->Contains(deletedNextInFlow)) {
+      if (!deletedNextInFlow || isLastFrameOnLine ||
+          !line->Contains(deletedNextInFlow)) {
         line->MarkDirty();
         ++line;
+        haveAdvancedToNextLine = PR_TRUE;
       }
     }
 
-    if (nsnull != deletedNextInFlow) {
+    if (deletedNextInFlow) {
       // Continuations for placeholder frames don't always appear in
       // consecutive lines. So for placeholders, just continue the slow easy way.
       if (isPlaceholder) {
@@ -5769,15 +5775,22 @@ found_frame:;
         break;
       }
 
-      // If we just removed the last frame on the line then we need
-      // to advance to the next line.
-      if (isLastFrameOnLine) {
-        TryAllLines(&line, &line_end, &searchingOverflowList);
-        // Detect the case when we've run off the end of the normal line
-        // list and we're starting the overflow line list
-        if (prevSibling && !prevSibling->GetNextSibling()) {
+      // If we advanced to the next line then check if we should switch to the
+      // overflow line list.
+      if (haveAdvancedToNextLine) {
+        if (line != line_end && !searchingOverflowList &&
+            !line->Contains(deletedNextInFlow)) {
+          // We have advanced to the next *normal* line but the next-in-flow
+          // is not there - force a switch to the overflow line list.
+          line = line_end;
           prevSibling = nsnull;
         }
+        TryAllLines(&line, &line_end, &searchingOverflowList);
+#ifdef NOISY_REMOVE_FRAME
+        printf("DoRemoveFrame: now on %s line=%p prevSibling=%p\n",
+               searchingOverflowList?"overflow":"normal", line.get(),
+               prevSibling);
+#endif
       }
     }
   }
diff -uprN --exclude=CVS mozilla/layout/generic/nsContainerFrame.cpp mozilla.new/layout/generic/nsContainerFrame.cpp
--- mozilla/layout/generic/nsContainerFrame.cpp	2005-09-06 23:15:12.000000000 +0200
+++ mozilla.new/layout/generic/nsContainerFrame.cpp	2006-03-12 20:04:19.000000000 +0100
@@ -541,6 +541,7 @@ SyncFrameViewGeometryDependentProperties
     if (doc) {
       nsIContent *rootElem = doc->GetRootContent();
       if (!doc->GetParentDocument() &&
+          (nsCOMPtr<nsISupports>(doc->GetContainer())) &&
           rootElem && rootElem->IsContentOfType(nsIContent::eXUL)) {
         // we're XUL at the root of the document hierarchy. Try to make our
         // window translucent.
diff -uprN --exclude=CVS mozilla/layout/generic/nsFrame.cpp mozilla.new/layout/generic/nsFrame.cpp
--- mozilla/layout/generic/nsFrame.cpp	2006-01-09 06:48:54.000000000 +0100
+++ mozilla.new/layout/generic/nsFrame.cpp	2006-02-24 11:16:42.000000000 +0100
@@ -4473,6 +4473,19 @@ GetIBSpecialSibling(nsPresContext* aPres
   return NS_OK;
 }
 
+static PRBool
+IsTablePseudo(nsIAtom* aPseudo)
+{
+  return
+    aPseudo == nsCSSAnonBoxes::tableOuter ||
+    aPseudo == nsCSSAnonBoxes::table ||
+    aPseudo == nsCSSAnonBoxes::tableRowGroup ||
+    aPseudo == nsCSSAnonBoxes::tableRow ||
+    aPseudo == nsCSSAnonBoxes::tableCell ||
+    aPseudo == nsCSSAnonBoxes::tableColGroup ||
+    aPseudo == nsCSSAnonBoxes::tableCol;
+}
+
 /**
  * Get the parent, corrected for the mangled frame tree resulting from
  * having a block within an inline.  The result only differs from the
@@ -4490,17 +4503,22 @@ GetCorrectedParent(nsPresContext* aPresC
   nsIFrame *parent = aFrame->GetParent();
   *aSpecialParent = parent;
   if (parent) {
-    nsIAtom* parentPseudo = parent->GetStyleContext()->GetPseudoType();
+    nsIAtom* pseudo = aFrame->GetStyleContext()->GetPseudoType();
 
     // if this frame itself is not scrolled-content, then skip any scrolled-content
     // parents since they're basically anonymous as far as the style system goes
-    if (parentPseudo == nsCSSAnonBoxes::scrolledContent) {
-      nsIAtom* pseudo = aFrame->GetStyleContext()->GetPseudoType();
-      if (pseudo != nsCSSAnonBoxes::scrolledContent) {
-        do {
-          parent = parent->GetParent();
-          parentPseudo = parent->GetStyleContext()->GetPseudoType();
-        } while (parentPseudo == nsCSSAnonBoxes::scrolledContent);
+    if (pseudo != nsCSSAnonBoxes::scrolledContent) {
+      while (parent->GetStyleContext()->GetPseudoType() ==
+             nsCSSAnonBoxes::scrolledContent) {
+        parent = parent->GetParent();
+      }
+    }
+
+    // If the frame is not a table pseudo frame, we want to move up
+    // the tree till we get to a non-table-pseudo frame.
+    if (!IsTablePseudo(pseudo)) {
+      while (IsTablePseudo(parent->GetStyleContext()->GetPseudoType())) {
+        parent = parent->GetParent();
       }
     }
 
diff -uprN --exclude=CVS mozilla/layout/generic/nsIFrame.h mozilla.new/layout/generic/nsIFrame.h
--- mozilla/layout/generic/nsIFrame.h	2005-09-02 22:25:54.000000000 +0200
+++ mozilla.new/layout/generic/nsIFrame.h	2006-03-03 07:14:34.000000000 +0100
@@ -1074,6 +1074,25 @@ public:
    */
   virtual nsIAtom* GetType() const = 0;
   
+
+  /**
+   * Bit-flags to pass to IsFrameOfType()
+   */
+  enum {
+    eMathML =           1 << 0,
+    eSVG =              1 << 1,
+    eSVGForeignObject = 1 << 2
+  };
+
+  /**
+   * API for doing a quick check if a frame is of a given
+   * type. Returns true if the frame matches ALL flags passed in.
+   */
+  virtual PRBool IsFrameOfType(PRUint32 aFlags) const
+  {
+    return !aFlags;
+  }
+
   /**
    * Is this frame a containing block for non-positioned elements?
    */
diff -uprN --exclude=CVS mozilla/layout/generic/nsSelection.cpp mozilla.new/layout/generic/nsSelection.cpp
--- mozilla/layout/generic/nsSelection.cpp	2005-08-28 02:45:04.000000000 +0200
+++ mozilla.new/layout/generic/nsSelection.cpp	2006-02-14 10:01:27.000000000 +0100
@@ -4235,10 +4235,8 @@ nsSelection::SetDelayedCaretData(nsMouse
     mDelayedMouseEventValid = PR_TRUE;
     mDelayedMouseEvent      = *aMouseEvent;
 
-    // XXX: Hmmm, should we AddRef mDelayedMouseEvent->widget?
-    //      Doing so might introduce a leak if things in the app
-    //      are not released in the correct order though, so for now
-    //      don't do anything.
+    // Don't cache the widget.  We don't need it and it could go away.
+    mDelayedMouseEvent.widget = nsnull;
   }
   else
     mDelayedMouseEventValid = PR_FALSE;
diff -uprN --exclude=CVS mozilla/layout/generic/nsTextFrame.cpp mozilla.new/layout/generic/nsTextFrame.cpp
--- mozilla/layout/generic/nsTextFrame.cpp	2006-01-09 06:48:54.000000000 +0100
+++ mozilla.new/layout/generic/nsTextFrame.cpp	2006-02-14 10:01:28.000000000 +0100
@@ -807,6 +807,23 @@ public:
                       TextPaintStyle& aStyle,
                       nscoord dx, nscoord dy);
 
+ /**
+  * ComputeTotalWordDimensions and ComputeWordFragmentDimensions work
+  * together to measure a text that spans multiple frames, e.g., as in
+  *   "baseText<b>moreText<i>moreDeepText</i></b>moreAlsoHere"
+  * where the total text shoudn't be broken (or the joined pieces should be
+  * passed to the linebreaker for examination, especially in i18n cases).
+  *
+  * ComputeTotalWordDimensions will loop over ComputeWordFragmentDimensions
+  * to look-ahead and accumulate the joining fragments.
+  *
+  * @param aNextFrame is the first textFrame after the baseText's textFrame.
+  *
+  * @param aBaseDimensions is the dimension of baseText.
+  *
+  * @param aCanBreakBefore is false when it is not possible to break before
+  * the baseText (e.g., when this is the first word on the line).
+  */
   nsTextDimensions ComputeTotalWordDimensions(nsPresContext* aPresContext,
                                 nsILineBreaker* aLineBreaker,
                                 nsLineLayout& aLineLayout,
@@ -818,6 +835,19 @@ public:
                                 PRUint32   aWordBufSize,
                                 PRBool     aCanBreakBefore);
 
+ /**
+  * @param aNextFrame is the textFrame following the current fragment.
+  *
+  * @param aMoreSize plays a double role. The process should continue
+  * normally when it is zero. But when it returns -1, it means that there is
+  * no more fragment of interest and the look-ahead should be stopped. When
+  * it returns a positive value, it means that the current buffer (aWordBuf 
+  * of size aWordBufSize) is not big enough to accumulate the current fragment. 
+  * The returned positive value is the shortfall. 
+  *
+  * @param aWordBufLen is the accumulated length of the fragments that have
+  * been accounted for so far.
+  */
   nsTextDimensions ComputeWordFragmentDimensions(nsPresContext* aPresContext,
                                    nsILineBreaker* aLineBreaker,
                                    nsLineLayout& aLineLayout,
@@ -825,7 +855,7 @@ public:
                                    nsIFrame* aNextFrame,
                                    nsIContent* aContent,
                                    nsITextContent* aText,
-                                   PRBool* aStop,
+                                   PRInt32* aMoreSize,
                                    const PRUnichar* aWordBuf,
                                    PRUint32 &aWordBufLen,
                                    PRUint32 aWordBufSize,
@@ -6206,20 +6236,19 @@ nsTextFrame::ComputeTotalWordDimensions(
 
     nsCOMPtr<nsITextContent> tc(do_QueryInterface(content));
     if (tc) {
-      PRBool stop = PR_FALSE;
+      PRInt32 moreSize = 0;
       nsTextDimensions moreDimensions;
       moreDimensions = ComputeWordFragmentDimensions(aPresContext,
                                                      aLineBreaker,
                                                      aLineLayout,
                                                      aReflowState,
                                                      aNextFrame, content, tc,
-                                                     &stop,
+                                                     &moreSize,
                                                      newWordBuf,
                                                      aWordLen,
                                                      newWordBufSize,
                                                      aCanBreakBefore);
-      if (moreDimensions.width < 0) {
-        PRUint32 moreSize = -moreDimensions.width;
+      if (moreSize > 0) {
         //Oh, wordBuf is too small, we have to grow it
         newWordBufSize += moreSize;
         if (newWordBuf != aWordBuf) {
@@ -6237,13 +6266,13 @@ nsTextFrame::ComputeTotalWordDimensions(
           moreDimensions =
             ComputeWordFragmentDimensions(aPresContext, aLineBreaker,
                                           aLineLayout, aReflowState,
-                                          aNextFrame, content, tc, &stop,
+                                          aNextFrame, content, tc, &moreSize,
                                           newWordBuf, aWordLen, newWordBufSize,
                                           aCanBreakBefore);
-          NS_ASSERTION((moreDimensions.width >= 0),
-                       "ComputeWordFragmentWidth is returning negative");
+          NS_ASSERTION((moreSize <= 0),
+                       "ComputeWordFragmentDimensions is asking more buffer");
         } else {
-          stop = PR_TRUE;
+          moreSize = -1;
           moreDimensions.Clear();
         }  
       }
@@ -6253,7 +6282,7 @@ nsTextFrame::ComputeTotalWordDimensions(
       printf("  moreWidth=%d (addedWidth=%d) stop=%c\n", moreDimensions.width,
              addedDimensions.width, stop?'T':'F');
 #endif
-      if (stop) {
+      if (moreSize == -1) {
         goto done;
       }
     }
@@ -6287,7 +6316,7 @@ nsTextFrame::ComputeWordFragmentDimensio
                                       nsIFrame* aNextFrame,
                                       nsIContent* aContent,
                                       nsITextContent* aText,
-                                      PRBool* aStop,
+                                      PRInt32* aMoreSize,
                                       const PRUnichar* aWordBuf,
                                       PRUint32& aRunningWordLen,
                                       PRUint32 aWordBufSize,
@@ -6307,6 +6336,7 @@ nsTextFrame::ComputeWordFragmentDimensio
     wordLen = -1;
   }
 #endif // IBMBIDI
+  *aMoreSize = 0;
   PRUnichar* bp = tx.GetNextWord(PR_TRUE, &wordLen, &contentLen, &isWhitespace, &wasTransformed);
   if (!bp) {
     //empty text node, but we need to continue lookahead measurement
@@ -6318,17 +6348,18 @@ nsTextFrame::ComputeWordFragmentDimensio
 
   if (isWhitespace) {
     // Don't bother measuring nothing
-    *aStop = PR_TRUE;
+    *aMoreSize = -1; // flag that we should stop now
     return dimensions; // 0
   }
 
-  // We need to adjust the length by look at the two pieces together
-  // but if we have to grow aWordBuf, ask caller do it by return a negative value of size
+  // We need to adjust the length by looking at the two pieces together. But if
+  // we have to grow aWordBuf, ask the caller to do it by returning the shortfall
   if ((wordLen + aRunningWordLen) > aWordBufSize) {
-    dimensions.width = aWordBufSize - wordLen - aRunningWordLen; 
-    return dimensions;
+    *aMoreSize = wordLen + aRunningWordLen - aWordBufSize; 
+    return dimensions; // 0
   }
-  *aStop = contentLen < tx.GetContentLength();
+  if (contentLen < tx.GetContentLength())
+    *aMoreSize = -1;
 
   // Convert any spaces in the current word back to nbsp's. This keeps
   // the breaking logic happy.
@@ -6352,14 +6383,14 @@ nsTextFrame::ComputeWordFragmentDimensio
               wordLen = breakP - aRunningWordLen; 
               if(wordLen < 0)
                   wordLen = 0;
-              *aStop = PR_TRUE;
+              *aMoreSize = -1;
             } 
         }
       
       // if we don't stop, we need to extend the buf so the next one can
       // see this part otherwise, it does not matter since we will stop
       // anyway
-      if(! *aStop) 
+      if (*aMoreSize != -1)
         aRunningWordLen += wordLen;
     }
   }
@@ -6370,11 +6401,11 @@ nsTextFrame::ComputeWordFragmentDimensio
     nsresult lres = aLineBreaker->BreakInBetween(aWordBuf, aRunningWordLen, bp, wordLen, &canBreak);
     if (NS_SUCCEEDED(lres) && canBreak) {
       wordLen = 0;
-      *aStop = PR_TRUE;
+      *aMoreSize = -1;
     }
   }
 
-  if((*aStop) && (wordLen == 0))
+  if ((*aMoreSize == -1) && (wordLen == 0))
     return dimensions; // 0;
 
   nsStyleContext* sc = aNextFrame->GetStyleContext();
@@ -6411,7 +6442,7 @@ nsTextFrame::ComputeWordFragmentDimensio
     return dimensions;
   }
 
-  *aStop = PR_TRUE;
+  *aMoreSize = -1;
   return dimensions; // 0
 }
 
diff -uprN --exclude=CVS mozilla/layout/mathml/base/src/nsMathMLChar.cpp mozilla.new/layout/mathml/base/src/nsMathMLChar.cpp
--- mozilla/layout/mathml/base/src/nsMathMLChar.cpp	2005-10-24 05:25:21.000000000 +0200
+++ mozilla.new/layout/mathml/base/src/nsMathMLChar.cpp	2006-02-24 11:16:42.000000000 +0100
@@ -63,7 +63,7 @@
 #include "prprf.h"         // For PR_snprintf()
 
 #include "nsIDOMWindow.h"
-#include "nsIDialogParamBlock.h"
+#include "nsINonBlockingAlertService.h"
 #include "nsIWindowWatcher.h"
 #include "nsIStringBundle.h"
 #include "nsDoubleHashtable.h"
@@ -168,30 +168,15 @@ AlertMissingFonts(nsString& aMissingFont
   if (!wwatch)
     return;
 
-  nsCOMPtr<nsIDialogParamBlock> paramBlock(do_CreateInstance(NS_DIALOGPARAMBLOCK_CONTRACTID));
-  if (!paramBlock)
-    return;
-
-  // copied from nsICommonDialogs.idl which curiously isn't part of the build
-  // (mozilla/xpfe/appshell/public/nsICommonDialogs.idl)
-  enum {eMsg=0, eCheckboxMsg=1, eIconClass=2, eTitleMessage=3, eEditfield1Msg=4,
-        eEditfield2Msg=5, eEditfield1Value=6, eEditfield2Value=7, eButton0Text=8,
-        eButton1Text=9, eButton2Text=10, eButton3Text=11,eDialogTitle=12};
-  enum {eButtonPressed=0, eCheckboxState=1, eNumberButtons=2, eNumberEditfields=3,
-        eEditField1Password=4};
-
-  paramBlock->SetInt(eNumberButtons, 1);
-  paramBlock->SetString(eIconClass, NS_LITERAL_STRING("alert-icon").get());
-  paramBlock->SetString(eDialogTitle, title.get());
-  paramBlock->SetString(eMsg, message.get());
-
   nsCOMPtr<nsIDOMWindow> parent;
   wwatch->GetActiveWindow(getter_AddRefs(parent));
+  nsresult rv;
+  nsCOMPtr<nsINonBlockingAlertService> prompter =
+    do_GetService("@mozilla.org/embedcomp/nbalert-service;1", &rv);
 
-  nsCOMPtr<nsIDOMWindow> dialog;
-  wwatch->OpenWindow(parent, "chrome://global/content/commonDialog.xul", "_blank",
-                     "dependent,centerscreen,chrome,titlebar", paramBlock,
-                     getter_AddRefs(dialog));
+  if (prompter && parent) {
+    prompter->ShowNonBlockingAlert(parent, title.get(), message.get());
+  }
 }
 
 // helper to trim off comments from data in a MathFont Property File
diff -uprN --exclude=CVS mozilla/layout/mathml/base/src/nsMathMLContainerFrame.cpp mozilla.new/layout/mathml/base/src/nsMathMLContainerFrame.cpp
--- mozilla/layout/mathml/base/src/nsMathMLContainerFrame.cpp	2005-09-17 01:35:44.000000000 +0200
+++ mozilla.new/layout/mathml/base/src/nsMathMLContainerFrame.cpp	2006-03-12 20:04:20.000000000 +0100
@@ -694,51 +694,6 @@ nsMathMLContainerFrame::PropagateScriptS
  * =============================================================================
  */
 
-// We use this to wrap non-MathML frames so that foreign elements (e.g.,
-// html:img) can mix better with other surrounding MathML markups.
-// Currently we only wrap nsInlineFrames because problems were observed only
-// in the presence of such frames. By construction, a foreign frame wrapper
-// has one and only one child, and the life of the wrapper is bound to the
-// life of that unique child. Not all child list operations are applicable
-// with a wrapper. One must either use the parent (or the unique child)
-// for such operations (@see nsMathMLForeignFrameWrapper).
-nsresult
-nsMathMLContainerFrame::WrapForeignFrames()
-{
-  nsIFrame* next = mFrames.FirstChild();
-  nsPresContext* presContext = GetPresContext();
-  nsFrameManager *frameManager = presContext->FrameManager();
-
-  while (next) {
-    nsIFrame* child = next;
-    next = next->GetNextSibling();
-    nsInlineFrame* inlineFrame;
-    child->QueryInterface(kInlineFrameCID, (void**)&inlineFrame);
-    if (inlineFrame) {
-      // create a new wrapper frame to wrap this child
-      nsIFrame* wrapper;
-      nsresult rv = NS_NewMathMLForeignFrameWrapper(presContext->PresShell(),
-						    &wrapper);
-      if (NS_FAILED(rv)) return rv;
-      nsRefPtr<nsStyleContext> newStyleContext;
-      newStyleContext = presContext->StyleSet()->
-	ResolvePseudoStyleFor(mContent,
-			      nsCSSAnonBoxes::mozAnonymousBlock,
-			      mStyleContext);
-      rv = wrapper->Init(presContext, mContent, this, newStyleContext, nsnull);
-      if (NS_FAILED(rv)) {
-        wrapper->Destroy(presContext);
-        return rv;
-      }
-      mFrames.ReplaceFrame(this, child, wrapper, PR_FALSE);
-      child->SetParent(wrapper);
-      child->SetNextSibling(nsnull);
-      frameManager->ReParentStyleContext(child, newStyleContext);
-      wrapper->SetInitialChildList(presContext, nsnull, child);
-    }
-  }
-  return NS_OK;
-}
 
 NS_IMETHODIMP
 nsMathMLContainerFrame::Paint(nsPresContext*      aPresContext,
@@ -813,22 +768,8 @@ nsMathMLContainerFrame::SetInitialChildL
                                             nsIAtom*        aListName,
                                             nsIFrame*       aChildList)
 {
-  // First, let the base class do its job
-  nsresult rv = nsHTMLContainerFrame::SetInitialChildList(aPresContext, aListName, aChildList);
-
-  // Next, since we are an inline frame, and since we are a container, we have to
-  // be very careful with the way we treat our children. Things look okay when
-  // all of our children are only MathML frames. But there are problems if one of
-  // our children happens to be an nsInlineFrame, e.g., from generated content such
-  // as :before { content: open-quote } or :after { content: close-quote }
-  // The code asserts during reflow (in nsLineLayout::BeginSpan)
-  // Also there are problems when our children are hybrid, e.g., from html markups.
-  // In short, the nsInlineFrame class expects a number of *invariants* that are not
-  // met when we mix things.
-
-  // So wrap foreign children in nsMathMLForeignFrameWrapper frames
-  WrapForeignFrames();
-  return rv;
+  // let the base class do its job
+  return nsHTMLContainerFrame::SetInitialChildList(aPresContext, aListName, aChildList);
 
   // ...We will build our automatic MathML data once the entire <math>...</math>
   // tree is constructed.
@@ -864,10 +805,17 @@ nsMathMLContainerFrame::RebuildAutomatic
 /* static */ nsresult
 nsMathMLContainerFrame::ReLayoutChildren(nsIFrame* aParentFrame)
 {
+  if (!aParentFrame)
+    return NS_OK;
+
   // walk-up to the first frame that is a MathML frame, stop if we reach <math>
   PRInt32 parentScriptLevel = 0;
   nsIFrame* frame = aParentFrame;
-  while (frame) {
+  while (1) {
+     nsIFrame* parent = frame->GetParent();
+     if (!parent || !parent->GetContent())
+       break;
+
     // stop if it is a MathML frame
     nsIMathMLFrame* mathMLFrame;
     frame->QueryInterface(NS_GET_IID(nsIMathMLFrame), (void**)&mathMLFrame);
@@ -877,22 +825,20 @@ nsMathMLContainerFrame::ReLayoutChildren
       parentScriptLevel = parentData.scriptLevel;
       break;
     }
+
     // stop if we reach the root <math> tag
     nsIContent* content = frame->GetContent();
     NS_ASSERTION(content, "dangling frame without a content node");
     if (!content)
-      return NS_ERROR_FAILURE;
-
-    if (content->Tag() == nsMathMLAtoms::math) {
       break;
-    }
+    if (content->Tag() == nsMathMLAtoms::math)
+      break;
+
     // mark the frame dirty, and continue to climb up
     frame->AddStateBits(NS_FRAME_IS_DIRTY | NS_FRAME_HAS_DIRTY_CHILDREN);
-    frame = frame->GetParent();
+
+    frame = parent;
   }
-  NS_ASSERTION(frame, "bad MathML markup - could not find the top <math> element");
-  if (!frame)
-    return NS_OK;
 
   // re-sync the presentation data and embellishment data of our children
   RebuildAutomaticDataForChildren(frame);
@@ -924,10 +870,7 @@ nsMathMLContainerFrame::ReLayoutChildren
 nsresult
 nsMathMLContainerFrame::ChildListChanged(PRInt32 aModType)
 {
-  if (aModType != nsIDOMMutationEvent::REMOVAL) {
-    // wrap any new foreign child that may have crept in
-    WrapForeignFrames();
-  }
+  mState |= NS_FRAME_IS_DIRTY | NS_FRAME_HAS_DIRTY_CHILDREN;
 
   // If this is an embellished frame we need to rebuild the
   // embellished hierarchy by walking-up to the parent of the
@@ -936,6 +879,7 @@ nsMathMLContainerFrame::ChildListChanged
   if (mEmbellishData.coreFrame) {
     nsEmbellishData embellishData;
     for (frame = mParent; frame; frame = frame->GetParent()) {
+      frame->AddStateBits(NS_FRAME_IS_DIRTY | NS_FRAME_HAS_DIRTY_CHILDREN);
       GetEmbellishDataFrom(frame, embellishData);
       if (embellishData.coreFrame != mEmbellishData.coreFrame)
         break;
@@ -1044,6 +988,74 @@ nsMathMLContainerFrame::ReflowDirtyChild
   return NS_OK;
 }
 
+nsresult 
+nsMathMLContainerFrame::ReflowChild(nsIFrame*                aChildFrame,
+                                    nsPresContext*           aPresContext,
+                                    nsHTMLReflowMetrics&     aDesiredSize,
+                                    const nsHTMLReflowState& aReflowState,
+                                    nsReflowStatus&          aStatus)
+{
+  aDesiredSize.width = aDesiredSize.height = 0;
+  aDesiredSize.ascent = aDesiredSize.descent = 0;
+  aDesiredSize.mBoundingMetrics.Clear();
+  aDesiredSize.mFlags |= NS_REFLOW_CALC_BOUNDING_METRICS;
+
+  // Having foreign/hybrid children, e.g., from html markups, is not defined by
+  // the MathML spec. But it can happen in practice, e.g., <html:img> allows us
+  // to do some cool demos... or we may have a child that is an nsInlineFrame
+  // from a generated content such as :before { content: open-quote } or 
+  // :after { content: close-quote }. Unfortunately, the other frames out-there
+  // may expect their own invariants that are not met when we mix things.
+  // Hence we do not claim their support, but we will nevertheless attempt to keep
+  // them in the flow, if we can get their desired size. We observed that most
+  // frames may be reflowed generically, but nsInlineFrames need extra care.
+
+  nsInlineFrame* inlineFrame;
+  aChildFrame->QueryInterface(kInlineFrameCID, (void**)&inlineFrame);
+  if (!inlineFrame)
+    return nsHTMLContainerFrame::
+           ReflowChild(aChildFrame, aPresContext, aDesiredSize, aReflowState,
+                       0, 0, NS_FRAME_NO_MOVE_FRAME, aStatus);
+
+  // extra care for an nsInlineFrame
+  return ReflowForeignChild(aChildFrame, aPresContext, aDesiredSize, aReflowState, aStatus);                       
+}
+
+nsresult 
+nsMathMLContainerFrame::ReflowForeignChild(nsIFrame*                aChildFrame,
+                                           nsPresContext*           aPresContext,
+                                           nsHTMLReflowMetrics&     aDesiredSize,
+                                           const nsHTMLReflowState& aReflowState,
+                                           nsReflowStatus&          aStatus)
+{
+  // don't bother trying to span words as if they were non-breaking beyond this point
+  if (aReflowState.mLineLayout)
+    aReflowState.mLineLayout->ForgetWordFrames();
+
+  // provide a local, self-contained linelayout where to reflow the nsInlineFrame
+  nsSize availSize(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
+  nsLineLayout ll(aPresContext, aReflowState.mSpaceManager, aReflowState.parentReflowState,
+                  aDesiredSize.mComputeMEW);
+  ll.BeginLineReflow(0, 0, availSize.width, availSize.height, PR_FALSE, PR_FALSE);
+  PRBool pushedFrame;
+  ll.ReflowFrame(aChildFrame, aStatus, &aDesiredSize, pushedFrame);
+  NS_ASSERTION(!pushedFrame, "unexpected");
+  ll.EndLineReflow();
+
+  // make up the bounding metrics from the reflow metrics.
+  aDesiredSize.mBoundingMetrics.ascent = aDesiredSize.ascent;
+  aDesiredSize.mBoundingMetrics.descent = aDesiredSize.descent;
+  aDesiredSize.mBoundingMetrics.width = aDesiredSize.width;
+  aDesiredSize.mBoundingMetrics.rightBearing = aDesiredSize.width;
+
+  // Note: MathML's vertical & horizontal alignments happen much later in 
+  // Place(), which is ultimately called from within FinalizeReflow().
+
+  aStatus = NS_FRAME_COMPLETE;
+  NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
+  return NS_OK;
+}
+
 NS_IMETHODIMP
 nsMathMLContainerFrame::Reflow(nsPresContext*          aPresContext,
                                nsHTMLReflowMetrics&     aDesiredSize,
@@ -1074,8 +1086,10 @@ printf("\n");
                       aDesiredSize.mFlags | NS_REFLOW_CALC_BOUNDING_METRICS);
   nsIFrame* childFrame = mFrames.FirstChild();
   while (childFrame) {
+    nsReflowReason reason = (childFrame->GetStateBits() & NS_FRAME_FIRST_REFLOW)
+      ? eReflowReason_Initial : aReflowState.reason;
     nsHTMLReflowState childReflowState(aPresContext, aReflowState,
-                                       childFrame, availSize);
+                                       childFrame, availSize, reason);
     rv = ReflowChild(childFrame, aPresContext, childDesiredSize,
                      childReflowState, childStatus);
     //NS_ASSERTION(NS_FRAME_IS_COMPLETE(childStatus), "bad status");
@@ -1167,6 +1181,12 @@ nsMathMLContainerFrame::GetType() const
   return nsMathMLAtoms::ordinaryMathMLFrame;
 }
 
+PRBool
+nsMathMLContainerFrame::IsFrameOfType(PRUint32 aFlags) const
+{
+  return !(aFlags & ~nsIFrame::eMathML);
+}
+
 enum eMathMLFrameType {
   eMathMLFrameType_UNKNOWN = -1,
   eMathMLFrameType_Ordinary,
diff -uprN --exclude=CVS mozilla/layout/mathml/base/src/nsMathMLContainerFrame.h mozilla.new/layout/mathml/base/src/nsMathMLContainerFrame.h
--- mozilla/layout/mathml/base/src/nsMathMLContainerFrame.h	2005-09-17 01:35:44.000000000 +0200
+++ mozilla.new/layout/mathml/base/src/nsMathMLContainerFrame.h	2006-03-03 07:14:51.000000000 +0100
@@ -116,6 +116,7 @@ public:
   // Overloaded nsHTMLContainerFrame methods -- see documentation in nsIFrame.h
 
   virtual nsIAtom* GetType() const;
+  virtual PRBool IsFrameOfType(PRUint32 aFlags) const;
 
   NS_IMETHOD
   Init(nsPresContext*  aPresContext,
@@ -205,11 +206,6 @@ public:
   virtual nsresult
   ChildListChanged(PRInt32 aModType);
 
-  // helper to wrap non-MathML frames so that foreign elements (e.g., html:img)
-  // can mix better with other surrounding MathML markups
-  virtual nsresult
-  WrapForeignFrames();
-
   // helper to get the preferred size that a container frame should use to fire
   // the stretch on its stretchy child frames.
   virtual void
@@ -236,11 +232,14 @@ public:
               nsPresContext*          aPresContext,
               nsHTMLReflowMetrics&     aDesiredSize,
               const nsHTMLReflowState& aReflowState,
-              nsReflowStatus&          aStatus)
-  {
-    return nsHTMLContainerFrame::ReflowChild(aKidFrame, aPresContext, aDesiredSize, aReflowState,
-                                             0, 0, NS_FRAME_NO_MOVE_FRAME, aStatus);
-  }
+              nsReflowStatus&          aStatus);
+
+  nsresult 
+  ReflowForeignChild(nsIFrame*                aKidFrame,
+                     nsPresContext*           aPresContext,
+                     nsHTMLReflowMetrics&     aDesiredSize,
+                     const nsHTMLReflowState& aReflowState,
+                     nsReflowStatus&          aStatus);
 
   // helper to add the inter-spacing when <math> is the immediate parent.
   // Since we don't (yet) handle the root <math> element ourselves, we need to
diff -uprN --exclude=CVS mozilla/layout/mathml/base/src/nsMathMLmactionFrame.cpp mozilla.new/layout/mathml/base/src/nsMathMLmactionFrame.cpp
--- mozilla/layout/mathml/base/src/nsMathMLmactionFrame.cpp	2005-09-16 02:11:51.000000000 +0200
+++ mozilla.new/layout/mathml/base/src/nsMathMLmactionFrame.cpp	2006-03-03 07:14:51.000000000 +0100
@@ -310,7 +310,9 @@ nsMathMLmactionFrame::Reflow(nsPresConte
   nsIFrame* childFrame = GetSelectedFrame();
   if (childFrame) {
     nsReflowReason reason = aReflowState.reason;
-    if (mWasRestyled) {
+    if (childFrame->GetStateBits() & NS_FRAME_FIRST_REFLOW)
+      reason = eReflowReason_Initial;
+    else if (mWasRestyled) {
       mWasRestyled = PR_FALSE;
       // If we have just been restyled, make sure to reflow our
       // selected child with a StyleChange reflow reason so that
diff -uprN --exclude=CVS mozilla/layout/mathml/base/src/nsMathMLmfencedFrame.cpp mozilla.new/layout/mathml/base/src/nsMathMLmfencedFrame.cpp
--- mozilla/layout/mathml/base/src/nsMathMLmfencedFrame.cpp	2005-09-17 01:35:44.000000000 +0200
+++ mozilla.new/layout/mathml/base/src/nsMathMLmfencedFrame.cpp	2006-03-03 07:14:51.000000000 +0100
@@ -320,8 +320,10 @@ nsMathMLmfencedFrame::doReflow(nsPresCon
     fm->GetMaxDescent(aDesiredSize.descent);
   }
   while (childFrame) {
+    nsReflowReason reason = (childFrame->GetStateBits() & NS_FRAME_FIRST_REFLOW)
+      ? eReflowReason_Initial : aReflowState.reason;
     nsHTMLReflowState childReflowState(aPresContext, aReflowState,
-                                       childFrame, availSize);
+                                       childFrame, availSize, reason);
     rv = mathMLFrame->ReflowChild(childFrame, aPresContext, childDesiredSize,
                                   childReflowState, childStatus);
     //NS_ASSERTION(NS_FRAME_IS_COMPLETE(childStatus), "bad status");
diff -uprN --exclude=CVS mozilla/layout/mathml/base/src/nsMathMLmrootFrame.cpp mozilla.new/layout/mathml/base/src/nsMathMLmrootFrame.cpp
--- mozilla/layout/mathml/base/src/nsMathMLmrootFrame.cpp	2005-02-07 02:57:50.000000000 +0100
+++ mozilla.new/layout/mathml/base/src/nsMathMLmrootFrame.cpp	2006-03-03 07:14:51.000000000 +0100
@@ -206,8 +206,10 @@ nsMathMLmrootFrame::Reflow(nsPresContext
   nsHTMLReflowMetrics indexSize(nsnull);
   nsIFrame* childFrame = mFrames.FirstChild();
   while (childFrame) {
+    nsReflowReason reason = (childFrame->GetStateBits() & NS_FRAME_FIRST_REFLOW)
+      ? eReflowReason_Initial : aReflowState.reason;
     nsHTMLReflowState childReflowState(aPresContext, aReflowState,
-                                       childFrame, availSize);
+                                       childFrame, availSize, reason);
     rv = ReflowChild(childFrame, aPresContext,
                      childDesiredSize, childReflowState, childStatus);
     //NS_ASSERTION(NS_FRAME_IS_COMPLETE(childStatus), "bad status");
diff -uprN --exclude=CVS mozilla/layout/mathml/base/src/nsMathMLmtableFrame.cpp mozilla.new/layout/mathml/base/src/nsMathMLmtableFrame.cpp
--- mozilla/layout/mathml/base/src/nsMathMLmtableFrame.cpp	2005-09-16 02:11:52.000000000 +0200
+++ mozilla.new/layout/mathml/base/src/nsMathMLmtableFrame.cpp	2006-03-03 07:14:51.000000000 +0100
@@ -584,6 +584,12 @@ nsMathMLmtableOuterFrame::Reflow(nsPresC
   return rv;
 }
 
+PRBool
+nsMathMLmtableOuterFrame::IsFrameOfType(PRUint32 aFlags) const
+{
+  return !(aFlags & ~nsIFrame::eMathML);
+}
+
 // --------
 // implementation of nsMathMLmtdFrame
 
@@ -644,6 +650,12 @@ nsMathMLmtdFrame::GetColSpan()
   return colspan;
 }
 
+PRBool
+nsMathMLmtdFrame::IsFrameOfType(PRUint32 aFlags) const
+{
+  return !(aFlags & ~nsIFrame::eMathML);
+}
+
 // --------
 // implementation of nsMathMLmtdInnerFrame
 
@@ -707,3 +719,10 @@ nsMathMLmtdInnerFrame::Reflow(nsPresCont
   // ...
   return rv;
 }
+
+PRBool
+nsMathMLmtdInnerFrame::IsFrameOfType(PRUint32 aFlags) const
+{
+  return !(aFlags & ~nsIFrame::eMathML);
+}
+
diff -uprN --exclude=CVS mozilla/layout/mathml/base/src/nsMathMLmtableFrame.h mozilla.new/layout/mathml/base/src/nsMathMLmtableFrame.h
--- mozilla/layout/mathml/base/src/nsMathMLmtableFrame.h	2005-02-07 02:57:50.000000000 +0100
+++ mozilla.new/layout/mathml/base/src/nsMathMLmtableFrame.h	2006-03-03 07:14:51.000000000 +0100
@@ -92,6 +92,8 @@ public:
          const nsHTMLReflowState& aReflowState,
          nsReflowStatus&          aStatus);
 
+  virtual PRBool IsFrameOfType(PRUint32 aFlags) const;
+
 protected:
   nsMathMLmtableOuterFrame();
   virtual ~nsMathMLmtableOuterFrame();
@@ -116,6 +118,7 @@ public:
   // overloaded nsTableCellFrame methods
   virtual PRInt32 GetRowSpan();
   virtual PRInt32 GetColSpan();
+  virtual PRBool IsFrameOfType(PRUint32 aFlags) const;
 
 protected:
   nsMathMLmtdFrame();
@@ -166,6 +169,7 @@ public:
          nsHTMLReflowMetrics&     aDesiredSize,
          const nsHTMLReflowState& aReflowState,
          nsReflowStatus&          aStatus);
+  virtual PRBool IsFrameOfType(PRUint32 aFlags) const;
 
 protected:
   nsMathMLmtdInnerFrame();
diff -uprN --exclude=CVS mozilla/layout/mathml/base/src/nsMathMLTokenFrame.cpp mozilla.new/layout/mathml/base/src/nsMathMLTokenFrame.cpp
--- mozilla/layout/mathml/base/src/nsMathMLTokenFrame.cpp	2005-09-16 02:11:51.000000000 +0200
+++ mozilla.new/layout/mathml/base/src/nsMathMLTokenFrame.cpp	2006-03-03 07:14:51.000000000 +0100
@@ -180,8 +180,10 @@ printf("\n");
   PRInt32 count = 0;
   nsIFrame* childFrame = GetFirstChild(nsnull);
   while (childFrame) {
+    nsReflowReason reason = (childFrame->GetStateBits() & NS_FRAME_FIRST_REFLOW)
+      ? eReflowReason_Initial : aReflowState.reason;
     nsHTMLReflowState childReflowState(aPresContext, aReflowState,
-                                       childFrame, availSize);
+                                       childFrame, availSize, reason);
     rv = ReflowChild(childFrame, aPresContext, childDesiredSize,
                      childReflowState, aStatus);
     //NS_ASSERTION(NS_FRAME_IS_COMPLETE(aStatus), "bad status");
diff -uprN --exclude=CVS mozilla/layout/printing/nsPrintEngine.cpp mozilla.new/layout/printing/nsPrintEngine.cpp
--- mozilla/layout/printing/nsPrintEngine.cpp	2006-01-11 23:05:52.000000000 +0100
+++ mozilla.new/layout/printing/nsPrintEngine.cpp	2006-02-24 11:16:42.000000000 +0100
@@ -2513,46 +2513,6 @@ nsPrintEngine::ReflowDocList(nsPrintObje
   return NS_OK;
 }
 
-PR_STATIC_CALLBACK(void *)
-HandleBarrierEvent(PLEvent *aEvent)
-{
-  PRBool *b = NS_STATIC_CAST(PRBool *, PL_GetEventOwner(aEvent));
-  *b = PR_TRUE;
-  return nsnull;
-}
-
-PR_STATIC_CALLBACK(void)
-DestroyBarrierEvent(PLEvent *aEvent)
-{
-}
-
-static void
-FlushEventQueue()
-{
-  PRBool hitBarrier = PR_FALSE;
-  nsCOMPtr<nsIEventQueue> eventQ;
-  nsresult rv = NS_GetMainEventQ(getter_AddRefs(eventQ));
-  if (NS_FAILED(rv))
-    return;
-
-  PLEvent evt;
-
-  PL_InitEvent(&evt, &hitBarrier, HandleBarrierEvent, DestroyBarrierEvent);
-
-  if (NS_FAILED(eventQ->PostEvent(&evt)))
-    return;
-
-  while (!hitBarrier) {
-    PLEvent *next;
-    eventQ->GetEvent(&next);
-    if (!next) {
-      NS_ERROR("barrier event not found!");
-      return;
-    }
-    eventQ->HandleEvent(next);
-  }
-}
-
 //-------------------------------------------------------
 // Reflow a nsPrintObject
 nsresult
@@ -2767,7 +2727,6 @@ nsPrintEngine::ReflowPrintObject(nsPrint
 
   aPO->mPresContext->SetPageDim(adjRect);
   rv = aPO->mPresShell->InitialReflow(width, height);
-  FlushEventQueue();
   if (NS_SUCCEEDED(rv)) {
     // Transfer Selection Ranges to the new Print PresShell
     nsCOMPtr<nsISelection> selection;
diff -uprN --exclude=CVS mozilla/layout/style/forms.css mozilla.new/layout/style/forms.css
--- mozilla/layout/style/forms.css	2006-01-09 06:48:55.000000000 +0100
+++ mozilla.new/layout/style/forms.css	2006-02-24 11:16:42.000000000 +0100
@@ -681,4 +681,14 @@ input[type="file"] > input[type="button"
   margin: 0px 0px 2px 5px !important;
 }
 
+/* make sure disabled images have transparent background */
+input[type="image"][disabled] {
+  background-color: transparent;
+}
+
+/* avoid flickering size when file selector buttons with large text are activated */
+input[type="file"] > input[type="button"]:active:hover {
+  font-size: inherit;
+}
+
 #endif
diff -uprN --exclude=CVS mozilla/layout/style/nsDOMCSSValueList.cpp mozilla.new/layout/style/nsDOMCSSValueList.cpp
--- mozilla/layout/style/nsDOMCSSValueList.cpp	2004-12-08 20:39:47.000000000 +0100
+++ mozilla.new/layout/style/nsDOMCSSValueList.cpp	2006-03-03 07:14:51.000000000 +0100
@@ -57,6 +57,7 @@ NS_IMPL_RELEASE(nsDOMCSSValueList)
 NS_INTERFACE_MAP_BEGIN(nsDOMCSSValueList)
   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSValueList)
   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSValue)
+  NS_INTERFACE_MAP_ENTRY(nsISupports)
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(CSSValueList)
 NS_INTERFACE_MAP_END
 
diff -uprN --exclude=CVS mozilla/layout/svg/base/src/nsSVGDefsFrame.cpp mozilla.new/layout/svg/base/src/nsSVGDefsFrame.cpp
--- mozilla/layout/svg/base/src/nsSVGDefsFrame.cpp	2005-08-09 15:53:01.000000000 +0200
+++ mozilla.new/layout/svg/base/src/nsSVGDefsFrame.cpp	2006-03-03 07:14:58.000000000 +0100
@@ -205,6 +205,12 @@ nsSVGDefsFrame::GetType() const
   return nsLayoutAtoms::svgDefsFrame;
 }
 
+PRBool
+nsSVGDefsFrame::IsFrameOfType(PRUint32 aFlags) const
+{
+  return !(aFlags & ~nsIFrame::eSVG);
+}
+
 //----------------------------------------------------------------------
 // nsISVGValueObserver methods:
 
diff -uprN --exclude=CVS mozilla/layout/svg/base/src/nsSVGDefsFrame.h mozilla.new/layout/svg/base/src/nsSVGDefsFrame.h
--- mozilla/layout/svg/base/src/nsSVGDefsFrame.h	2005-04-19 05:48:09.000000000 +0200
+++ mozilla.new/layout/svg/base/src/nsSVGDefsFrame.h	2006-03-03 07:14:58.000000000 +0100
@@ -90,6 +90,7 @@ public:
    * @see nsLayoutAtoms::svgDefsFrame
    */
   virtual nsIAtom* GetType() const;
+  virtual PRBool IsFrameOfType(PRUint32 aFlags) const;
 
 #ifdef DEBUG
   NS_IMETHOD GetFrameName(nsAString& aResult) const
diff -uprN --exclude=CVS mozilla/layout/svg/base/src/nsSVGForeignObjectFrame.cpp mozilla.new/layout/svg/base/src/nsSVGForeignObjectFrame.cpp
--- mozilla/layout/svg/base/src/nsSVGForeignObjectFrame.cpp	2005-04-19 05:48:09.000000000 +0200
+++ mozilla.new/layout/svg/base/src/nsSVGForeignObjectFrame.cpp	2006-03-03 07:14:58.000000000 +0100
@@ -120,6 +120,7 @@ public:
   // frametypes, particularly code looking at block and area
   // also handles foreignObject before we return our own frametype
   // virtual nsIAtom* GetType() const;
+  virtual PRBool IsFrameOfType(PRUint32 aFlags) const;
 
 #ifdef DEBUG
   NS_IMETHOD GetFrameName(nsAString& aResult) const
@@ -442,6 +443,12 @@ nsSVGForeignObjectFrame::ReplaceFrame(ns
 //   return nsLayoutAtoms::svgForeignObjectFrame;
 // }
 
+PRBool
+nsSVGForeignObjectFrame::IsFrameOfType(PRUint32 aFlags) const
+{
+  return !(aFlags & ~(nsIFrame::eSVG | nsIFrame::eSVGForeignObject));
+}
+
 //----------------------------------------------------------------------
 // nsISVGValueObserver methods:
 
diff -uprN --exclude=CVS mozilla/layout/svg/base/src/nsSVGGenericContainerFrame.cpp mozilla.new/layout/svg/base/src/nsSVGGenericContainerFrame.cpp
--- mozilla/layout/svg/base/src/nsSVGGenericContainerFrame.cpp	2005-08-09 15:53:02.000000000 +0200
+++ mozilla.new/layout/svg/base/src/nsSVGGenericContainerFrame.cpp	2006-03-03 07:14:58.000000000 +0100
@@ -192,6 +192,11 @@ nsSVGGenericContainerFrame::GetType() co
   return nsLayoutAtoms::svgGenericContainerFrame;
 }
 
+PRBool
+nsSVGGenericContainerFrame::IsFrameOfType(PRUint32 aFlags) const
+{
+  return !(aFlags & ~nsIFrame::eSVG);
+}
 
 //----------------------------------------------------------------------
 // nsISVGChildFrame methods
diff -uprN --exclude=CVS mozilla/layout/svg/base/src/nsSVGGenericContainerFrame.h mozilla.new/layout/svg/base/src/nsSVGGenericContainerFrame.h
--- mozilla/layout/svg/base/src/nsSVGGenericContainerFrame.h	2005-04-19 05:48:09.000000000 +0200
+++ mozilla.new/layout/svg/base/src/nsSVGGenericContainerFrame.h	2006-03-03 07:14:58.000000000 +0100
@@ -95,6 +95,7 @@ public:
    * @see nsLayoutAtoms::svgGenericContainerFrame
    */
   virtual nsIAtom* GetType() const;
+  virtual PRBool IsFrameOfType(PRUint32 aFlags) const;
 
 #ifdef DEBUG
   NS_IMETHOD GetFrameName(nsAString& aResult) const
diff -uprN --exclude=CVS mozilla/layout/svg/base/src/nsSVGGlyphFrame.cpp mozilla.new/layout/svg/base/src/nsSVGGlyphFrame.cpp
--- mozilla/layout/svg/base/src/nsSVGGlyphFrame.cpp	2005-10-03 22:38:01.000000000 +0200
+++ mozilla.new/layout/svg/base/src/nsSVGGlyphFrame.cpp	2006-03-03 07:14:59.000000000 +0100
@@ -115,6 +115,7 @@ public:
    * @see nsLayoutAtoms::svgGlyphFrame
    */
   virtual nsIAtom* GetType() const;
+  virtual PRBool IsFrameOfType(PRUint32 aFlags) const;
 
 #ifdef DEBUG
   NS_IMETHOD GetFrameName(nsAString& aResult) const
@@ -401,6 +402,12 @@ nsSVGGlyphFrame::GetType() const
   return nsLayoutAtoms::svgGlyphFrame;
 }
 
+PRBool
+nsSVGGlyphFrame::IsFrameOfType(PRUint32 aFlags) const
+{
+  return !(aFlags & ~nsIFrame::eSVG);
+}
+
 //----------------------------------------------------------------------
 // nsISVGValueObserver methods:
 
diff -uprN --exclude=CVS mozilla/layout/svg/base/src/nsSVGGradientFrame.cpp mozilla.new/layout/svg/base/src/nsSVGGradientFrame.cpp
--- mozilla/layout/svg/base/src/nsSVGGradientFrame.cpp	2005-10-04 00:38:28.000000000 +0200
+++ mozilla.new/layout/svg/base/src/nsSVGGradientFrame.cpp	2006-02-24 11:16:42.000000000 +0100
@@ -621,6 +621,10 @@ nsSVGGradientFrame::PrivateGetSpreadMeth
 NS_IMETHODIMP
 nsSVGGradientFrame::GetNextGradient(nsISVGGradient * *aNextGrad, PRUint32 aType) {
   PRUint32 nextType;
+  if (!mNextGrad) {
+    *aNextGrad = nsnull;
+    return NS_ERROR_FAILURE;
+  }
   mNextGrad->GetGradientType(&nextType);
   if (nextType == aType) {
     *aNextGrad = mNextGrad;
diff -uprN --exclude=CVS mozilla/layout/svg/base/src/nsSVGInnerSVGFrame.cpp mozilla.new/layout/svg/base/src/nsSVGInnerSVGFrame.cpp
--- mozilla/layout/svg/base/src/nsSVGInnerSVGFrame.cpp	2005-08-09 15:53:02.000000000 +0200
+++ mozilla.new/layout/svg/base/src/nsSVGInnerSVGFrame.cpp	2006-03-03 07:14:59.000000000 +0100
@@ -105,6 +105,7 @@ public:
    * @see nsLayoutAtoms::svgInnerSVGFrame
    */
   virtual nsIAtom* GetType() const;
+  virtual PRBool IsFrameOfType(PRUint32 aFlags) const;
 
 #ifdef DEBUG
   NS_IMETHOD GetFrameName(nsAString& aResult) const
@@ -347,6 +348,12 @@ nsSVGInnerSVGFrame::GetType() const
   return nsLayoutAtoms::svgInnerSVGFrame;
 }
 
+PRBool
+nsSVGInnerSVGFrame::IsFrameOfType(PRUint32 aFlags) const
+{
+  return !(aFlags & ~nsIFrame::eSVG);
+}
+
 //----------------------------------------------------------------------
 // nsISVGChildFrame methods
 
diff -uprN --exclude=CVS mozilla/layout/svg/base/src/nsSVGOuterSVGFrame.cpp mozilla.new/layout/svg/base/src/nsSVGOuterSVGFrame.cpp
--- mozilla/layout/svg/base/src/nsSVGOuterSVGFrame.cpp	2005-09-05 22:41:47.000000000 +0200
+++ mozilla.new/layout/svg/base/src/nsSVGOuterSVGFrame.cpp	2006-03-03 07:14:59.000000000 +0100
@@ -223,6 +223,7 @@ public:
    * @see nsLayoutAtoms::svgOuterSVGFrame
    */
   virtual nsIAtom* GetType() const;
+  virtual PRBool IsFrameOfType(PRUint32 aFlags) const;
 
 #ifdef DEBUG
   NS_IMETHOD GetFrameName(nsAString& aResult) const
@@ -870,6 +871,12 @@ nsSVGOuterSVGFrame::GetType() const
   return nsLayoutAtoms::svgOuterSVGFrame;
 }
 
+PRBool
+nsSVGOuterSVGFrame::IsFrameOfType(PRUint32 aFlags) const
+{
+  return !(aFlags & ~nsIFrame::eSVG);
+}
+
 //----------------------------------------------------------------------
 // nsISVGValueObserver methods:
 
diff -uprN --exclude=CVS mozilla/layout/svg/base/src/nsSVGPathGeometryFrame.cpp mozilla.new/layout/svg/base/src/nsSVGPathGeometryFrame.cpp
--- mozilla/layout/svg/base/src/nsSVGPathGeometryFrame.cpp	2005-10-03 22:38:01.000000000 +0200
+++ mozilla.new/layout/svg/base/src/nsSVGPathGeometryFrame.cpp	2006-03-03 07:14:59.000000000 +0100
@@ -181,6 +181,12 @@ nsSVGPathGeometryFrame::GetType() const
   return nsLayoutAtoms::svgPathGeometryFrame;
 }
 
+PRBool
+nsSVGPathGeometryFrame::IsFrameOfType(PRUint32 aFlags) const
+{
+  return !(aFlags & ~nsIFrame::eSVG);
+}
+
 //----------------------------------------------------------------------
 // nsISVGChildFrame methods
 
diff -uprN --exclude=CVS mozilla/layout/svg/base/src/nsSVGPathGeometryFrame.h mozilla.new/layout/svg/base/src/nsSVGPathGeometryFrame.h
--- mozilla/layout/svg/base/src/nsSVGPathGeometryFrame.h	2005-09-27 21:58:56.000000000 +0200
+++ mozilla.new/layout/svg/base/src/nsSVGPathGeometryFrame.h	2006-03-03 07:14:59.000000000 +0100
@@ -94,6 +94,7 @@ public:
    * @see nsLayoutAtoms::svgPathGeometryFrame
    */
   virtual nsIAtom* GetType() const;
+  virtual PRBool IsFrameOfType(PRUint32 aFlags) const;
 
 #ifdef DEBUG
   NS_IMETHOD GetFrameName(nsAString& aResult) const
diff -uprN --exclude=CVS mozilla/layout/svg/base/src/nsSVGStopFrame.cpp mozilla.new/layout/svg/base/src/nsSVGStopFrame.cpp
--- mozilla/layout/svg/base/src/nsSVGStopFrame.cpp	2005-08-09 17:45:34.000000000 +0200
+++ mozilla.new/layout/svg/base/src/nsSVGStopFrame.cpp	2006-03-03 07:14:59.000000000 +0100
@@ -68,6 +68,7 @@ class nsSVGStopFrame : public nsSVGStopF
    * @see nsLayoutAtoms::svgStopFrame
    */
   virtual nsIAtom* GetType() const;
+  virtual PRBool IsFrameOfType(PRUint32 aFlags) const;
 
 #ifdef DEBUG
   NS_IMETHOD GetFrameName(nsAString& aResult) const
@@ -134,6 +135,12 @@ nsSVGStopFrame::GetType() const
   return nsLayoutAtoms::svgStopFrame;
 }
 
+PRBool
+nsSVGStopFrame::IsFrameOfType(PRUint32 aFlags) const
+{
+  return !(aFlags & ~nsIFrame::eSVG);
+}
+
 NS_IMETHODIMP
 nsSVGStopFrame::Init(nsPresContext*  aPresContext,
                      nsIContent*     aContent,
diff -uprN --exclude=CVS mozilla/layout/svg/base/src/nsSVGTextFrame.cpp mozilla.new/layout/svg/base/src/nsSVGTextFrame.cpp
--- mozilla/layout/svg/base/src/nsSVGTextFrame.cpp	2005-10-23 23:10:50.000000000 +0200
+++ mozilla.new/layout/svg/base/src/nsSVGTextFrame.cpp	2006-03-03 07:14:59.000000000 +0100
@@ -121,6 +121,7 @@ public:
    * @see nsLayoutAtoms::svgTextFrame
    */
   virtual nsIAtom* GetType() const;
+  virtual PRBool IsFrameOfType(PRUint32 aFlags) const;
 
 #ifdef DEBUG
   NS_IMETHOD GetFrameName(nsAString& aResult) const
@@ -360,6 +361,12 @@ nsSVGTextFrame::GetType() const
   return nsLayoutAtoms::svgTextFrame;
 }
 
+PRBool
+nsSVGTextFrame::IsFrameOfType(PRUint32 aFlags) const
+{
+  return !(aFlags & ~nsIFrame::eSVG);
+}
+
 NS_IMETHODIMP
 nsSVGTextFrame::AppendFrames(nsIAtom*        aListName,
                              nsIFrame*       aFrameList)
diff -uprN --exclude=CVS mozilla/layout/svg/base/src/nsSVGTSpanFrame.cpp mozilla.new/layout/svg/base/src/nsSVGTSpanFrame.cpp
--- mozilla/layout/svg/base/src/nsSVGTSpanFrame.cpp	2005-10-03 23:10:32.000000000 +0200
+++ mozilla.new/layout/svg/base/src/nsSVGTSpanFrame.cpp	2006-03-03 07:14:59.000000000 +0100
@@ -110,6 +110,7 @@ public:
    * @see nsLayoutAtoms::svgTSpanFrame
    */
   virtual nsIAtom* GetType() const;
+  virtual PRBool IsFrameOfType(PRUint32 aFlags) const;
 
 #ifdef DEBUG
   NS_IMETHOD GetFrameName(nsAString& aResult) const
@@ -268,6 +269,12 @@ nsSVGTSpanFrame::GetType() const
   return nsLayoutAtoms::svgTSpanFrame;
 }
 
+PRBool
+nsSVGTSpanFrame::IsFrameOfType(PRUint32 aFlags) const
+{
+  return !(aFlags & ~nsIFrame::eSVG);
+}
+
 //----------------------------------------------------------------------
 // nsISupports methods
 
diff -uprN --exclude=CVS mozilla/layout/tables/nsCellMap.cpp mozilla.new/layout/tables/nsCellMap.cpp
--- mozilla/layout/tables/nsCellMap.cpp	2005-09-28 19:46:52.000000000 +0200
+++ mozilla.new/layout/tables/nsCellMap.cpp	2006-03-03 07:14:59.000000000 +0100
@@ -2110,8 +2110,24 @@ void nsCellMap::RemoveCell(nsTableCellMa
 void nsCellMap::Dump(PRBool aIsBorderCollapse) const
 {
   printf("\n  ***** START GROUP CELL MAP DUMP ***** %p\n", this);
+  nsTableRowGroupFrame* rg = GetRowGroup();
+  const nsStyleDisplay* display = rg->GetStyleDisplay();
+  switch (display->mDisplay) {
+  case NS_STYLE_DISPLAY_TABLE_HEADER_GROUP:
+    printf("  thead ");
+    break;
+  case NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP:
+    printf("  tfoot ");
+    break;
+  case NS_STYLE_DISPLAY_TABLE_ROW_GROUP:
+    printf("  tbody ");
+    break;
+  default:
+    printf("HUH? wrong display type on rowgroup");
+  }
   PRInt32 mapRowCount = mRows.Count();
-  printf("  mapRowCount=%d tableRowCount=%d \n", mapRowCount, mRowCount);
+  printf("mapRowCount=%d tableRowCount=%d\n", mapRowCount, mRowCount);
+  
 
   PRInt32 rowIndex, colIndex;
   for (rowIndex = 0; rowIndex < mapRowCount; rowIndex++) {
diff -uprN --exclude=CVS mozilla/layout/tables/nsCellMap.h mozilla.new/layout/tables/nsCellMap.h
--- mozilla/layout/tables/nsCellMap.h	2004-12-08 20:39:53.000000000 +0100
+++ mozilla.new/layout/tables/nsCellMap.h	2006-03-03 07:14:59.000000000 +0100
@@ -203,6 +203,10 @@ protected:
   friend class nsCellMap;
   friend class BCMapCellIterator;
   friend class BCMapBorderIterator;
+/** Insert a row group cellmap after aPrevMap, if aPrefMap is null insert it
+  * at the beginning, the ordering of the cellmap corresponds to the ordering of
+  * rowgroups once OrderRowGroups has been called
+  */
   void InsertGroupCellMap(nsCellMap* aPrevMap,
                           nsCellMap& aNewMap);
   void DeleteRightBottomBorders();
diff -uprN --exclude=CVS mozilla/layout/tables/nsTableFrame.cpp mozilla.new/layout/tables/nsTableFrame.cpp
--- mozilla/layout/tables/nsTableFrame.cpp	2006-01-09 06:48:55.000000000 +0100
+++ mozilla.new/layout/tables/nsTableFrame.cpp	2006-03-03 07:14:59.000000000 +0100
@@ -1271,46 +1271,54 @@ void
 nsTableFrame::InsertRowGroups(nsIFrame* aFirstRowGroupFrame,
                               nsIFrame* aLastRowGroupFrame)
 {
+#ifdef DEBUG_TABLE_CELLMAP
+  printf("insertRowGroupsBefore");
+  Dump(PR_TRUE, PR_FALSE, PR_TRUE);
+#endif
   nsTableCellMap* cellMap = GetCellMap();
   if (cellMap) {
     nsAutoVoidArray orderedRowGroups;
     PRUint32 numRowGroups;
     OrderRowGroups(orderedRowGroups, numRowGroups);
-
     nsAutoVoidArray rows;
-    for (nsIFrame* kidFrame = aFirstRowGroupFrame; kidFrame;
-         kidFrame = kidFrame->GetNextSibling()) {
-      nsTableRowGroupFrame* rgFrame = GetRowGroupFrame(kidFrame);
-      if (rgFrame) {
-        // get the prior row group in display order
-        PRUint32 rgIndex;
-        for (rgIndex = 0; rgIndex < numRowGroups; rgIndex++) {
-          if (GetRowGroupFrame((nsIFrame*)orderedRowGroups.ElementAt(rgIndex)) == rgFrame) {
-            break;
+    // Loop over the rowgroups and check if some of them are new, if they are
+    // insert cellmaps in the order that is predefined by OrderRowGroups,
+    for (PRUint32 rgIndex = 0; rgIndex < numRowGroups; rgIndex++) {
+      nsIFrame* kidFrame = aFirstRowGroupFrame;
+      while (kidFrame) {
+        nsTableRowGroupFrame* rgFrame = GetRowGroupFrame(kidFrame);
+
+        if (GetRowGroupFrame((nsIFrame*)orderedRowGroups.ElementAt(rgIndex)) == rgFrame) {
+          nsTableRowGroupFrame* priorRG = (0 == rgIndex)
+            ? nsnull : GetRowGroupFrame((nsIFrame*)orderedRowGroups.ElementAt(rgIndex - 1)); 
+          // create and add the cell map for the row group
+          cellMap->InsertGroupCellMap(*rgFrame, priorRG);
+          // collect the new row frames in an array and add them to the table
+          PRInt32 numRows = CollectRows(kidFrame, rows);
+          if (numRows > 0) {
+            PRInt32 rowIndex = 0;
+            if (priorRG) {
+              PRInt32 priorNumRows = priorRG->GetRowCount();
+              rowIndex = priorRG->GetStartRowIndex() + priorNumRows;
+            }
+            InsertRows(*rgFrame, rows, rowIndex, PR_TRUE);
+            rows.Clear();
           }
+          break;
         }
-        nsTableRowGroupFrame* priorRG = (0 == rgIndex) 
-          ? nsnull : GetRowGroupFrame((nsIFrame*)orderedRowGroups.ElementAt(rgIndex - 1));
-          
-        // create and add the cell map for the row group
-        cellMap->InsertGroupCellMap(*rgFrame, priorRG);
-        // collect the new row frames in an array and add them to the table
-        PRInt32 numRows = CollectRows(kidFrame, rows);
-        if (numRows > 0) {
-          PRInt32 rowIndex = 0;
-          if (priorRG) {
-            PRInt32 priorNumRows = priorRG->GetRowCount();
-            rowIndex = priorRG->GetStartRowIndex() + priorNumRows;
+        else {
+          if (kidFrame == aLastRowGroupFrame) {
+            break;
           }
-          InsertRows(*rgFrame, rows, rowIndex, PR_TRUE);
-          rows.Clear();
+          kidFrame = kidFrame->GetNextSibling();
         }
       }
-      if (kidFrame == aLastRowGroupFrame) {
-        break;
-      }
     }
   }
+#ifdef DEBUG_TABLE_CELLMAP
+  printf("insertRowGroupsAfter");
+  Dump(PR_TRUE, PR_FALSE, PR_TRUE);
+#endif
 }
 
 
diff -uprN --exclude=CVS mozilla/layout/xul/base/public/nsIListBoxObject.idl mozilla.new/layout/xul/base/public/nsIListBoxObject.idl
--- mozilla/layout/xul/base/public/nsIListBoxObject.idl	2004-04-18 16:30:36.000000000 +0200
+++ mozilla.new/layout/xul/base/public/nsIListBoxObject.idl	2006-02-14 10:01:28.000000000 +0100
@@ -44,6 +44,8 @@ interface nsIDOMElement;
 [scriptable, uuid(FDE7C970-0B4E-49f4-B1EB-974AE6C96336)]
 interface nsIListBoxObject : nsISupports
 {
+  // listboxBody is always null.  It's only here to avoid changing the
+  // interface.
   readonly attribute nsIListBoxObject listboxBody;
 
   long getRowCount();
diff -uprN --exclude=CVS mozilla/layout/xul/base/src/nsBoxFrame.cpp mozilla.new/layout/xul/base/src/nsBoxFrame.cpp
--- mozilla/layout/xul/base/src/nsBoxFrame.cpp	2005-08-23 00:06:56.000000000 +0200
+++ mozilla.new/layout/xul/base/src/nsBoxFrame.cpp	2006-02-24 11:16:43.000000000 +0100
@@ -1351,8 +1351,12 @@ nsBoxFrame::AttributeChanged(nsIContent*
     
     nsIBox* parent;
     GetParentBox(&parent);
-    parent->RelayoutChildAtOrdinal(state, this);
-    parent->MarkDirty(state);
+    // If our parent is not a box, there's not much we can do... but in that
+    // case our ordinal doesn't matter anyway, so that's ok.
+    if (parent) {
+      parent->RelayoutChildAtOrdinal(state, this);
+      parent->MarkDirty(state);
+    }
   }
   // If the accesskey changed, register for the new value
   // The old value has been unregistered in nsXULElement::SetAttr
diff -uprN --exclude=CVS mozilla/layout/xul/base/src/nsBoxObject.cpp mozilla.new/layout/xul/base/src/nsBoxObject.cpp
--- mozilla/layout/xul/base/src/nsBoxObject.cpp	2005-08-24 23:08:53.000000000 +0200
+++ mozilla.new/layout/xul/base/src/nsBoxObject.cpp	2006-03-12 20:04:20.000000000 +0100
@@ -135,7 +135,7 @@ NS_IMETHODIMP
 nsBoxObject::Init(nsIContent* aContent, nsIPresShell* aShell)
 {
   mContent = aContent;
-  mPresShell = aShell;
+  mPresShell = do_GetWeakReference(aShell);
   return NS_OK;
 }
 
@@ -144,7 +144,7 @@ nsBoxObject::SetDocument(nsIDocument* aD
 {
   mPresState = nsnull;
   if (aDocument) {
-    mPresShell = aDocument->GetShellAt(0);
+    mPresShell = do_GetWeakReference(aDocument->GetShellAt(0));
   }
   else {
     mPresShell = nsnull;
@@ -164,13 +164,26 @@ nsIFrame*
 nsBoxObject::GetFrame()
 {
   nsIFrame* frame = nsnull;
-  if (mPresShell) {
-    mPresShell->FlushPendingNotifications(Flush_Frames);
-    mPresShell->GetPrimaryFrameFor(mContent, &frame);
+  nsCOMPtr<nsIPresShell> shell = GetPresShell();
+  if (shell) {
+    shell->FlushPendingNotifications(Flush_Frames);
+    shell->GetPrimaryFrameFor(mContent, &frame);
   }
   return frame;
 }
 
+already_AddRefed<nsIPresShell>
+nsBoxObject::GetPresShell()
+{
+  if (!mPresShell) {
+    return nsnull;
+  }
+
+  nsIPresShell* shell = nsnull;
+  CallQueryReferent(mPresShell.get(), &shell);
+  return shell;
+}
+
 nsresult 
 nsBoxObject::GetOffsetRect(nsRect& aRect)
 {
@@ -405,8 +418,23 @@ nsBoxObject::GetPropertyAsSupports(const
 NS_IMETHODIMP
 nsBoxObject::SetPropertyAsSupports(const PRUnichar* aPropertyName, nsISupports* aValue)
 {
-  if (!mPresState)
+#ifdef DEBUG
+  if (aValue) {
+    nsIFrame* frame;
+    CallQueryInterface(aValue, &frame);
+    NS_ASSERTION(!frame,
+                 "Calling SetPropertyAsSupports on a frame.  Prepare to crash "
+                 "and be exploited any time some random website decides to "
+                 "exploit you");
+  }
+#endif
+
+  NS_ENSURE_ARG(aPropertyName && *aPropertyName);
+  
+  if (!mPresState) {
     NS_NewPresState(getter_Transfers(mPresState));
+    NS_ENSURE_TRUE(mPresState, NS_ERROR_OUT_OF_MEMORY);
+  }
 
   nsDependentString propertyName(aPropertyName);
   return mPresState->SetStatePropertyAsSupports(propertyName, aValue);
@@ -415,6 +443,8 @@ nsBoxObject::SetPropertyAsSupports(const
 NS_IMETHODIMP
 nsBoxObject::GetProperty(const PRUnichar* aPropertyName, PRUnichar** aResult)
 {
+  NS_ENSURE_ARG(aPropertyName && *aPropertyName);
+  
   if (!mPresState) {
     *aResult = nsnull;
     return NS_OK;
@@ -537,10 +567,6 @@ nsBoxObject::GetDocShell(nsIDocShell** a
 {
   *aResult = nsnull;
 
-  if (!mPresShell) {
-    return NS_OK;
-  }
-
   nsIFrame *frame = GetFrame();
 
   if (frame) {
@@ -558,8 +584,14 @@ nsBoxObject::GetDocShell(nsIDocShell** a
   // No nsIFrameFrame available for mContent, try if there's a mapping
   // between mContent's document to mContent's subdocument.
 
-  nsIDocument *sub_doc =
-    mPresShell->GetDocument()->GetSubDocumentFor(mContent);
+  // XXXbz sXBL/XBL2 issue -- ownerDocument or currentDocument?
+  nsIDocument *doc = mContent->GetDocument();
+
+  if (!doc) {
+    return NS_OK;
+  }
+  
+  nsIDocument *sub_doc = doc->GetSubDocumentFor(mContent);
 
   if (!sub_doc) {
     return NS_OK;
diff -uprN --exclude=CVS mozilla/layout/xul/base/src/nsBoxObject.h mozilla.new/layout/xul/base/src/nsBoxObject.h
--- mozilla/layout/xul/base/src/nsBoxObject.h	2005-02-18 10:22:33.000000000 +0100
+++ mozilla.new/layout/xul/base/src/nsBoxObject.h	2006-03-12 20:04:20.000000000 +0100
@@ -41,6 +41,8 @@
 #include "nsPresState.h"
 #include "nsPoint.h"
 #include "nsAutoPtr.h"
+#include "nsIWeakReference.h"
+#include "nsIWeakReferenceUtils.h"
 
 class nsIBoxLayoutManager;
 class nsIBoxPaintManager;
@@ -63,6 +65,7 @@ public:
   NS_IMETHOD InvalidatePresentationStuff();
 
   virtual nsIFrame* GetFrame();
+  already_AddRefed<nsIPresShell> GetPresShell();
   nsresult GetOffsetRect(nsRect& aRect);
   nsresult GetScreenPosition(nsIntPoint& aPoint);
 
@@ -81,5 +84,5 @@ protected:
   nsAutoPtr<nsPresState> mPresState; // [OWNER]
 
   nsIContent* mContent; // [WEAK]
-  nsIPresShell* mPresShell; // [WEAK]
+  nsWeakPtr mPresShell;
 };
diff -uprN --exclude=CVS mozilla/layout/xul/base/src/nsListBoxBodyFrame.cpp mozilla.new/layout/xul/base/src/nsListBoxBodyFrame.cpp
--- mozilla/layout/xul/base/src/nsListBoxBodyFrame.cpp	2005-04-03 23:19:37.000000000 +0200
+++ mozilla.new/layout/xul/base/src/nsListBoxBodyFrame.cpp	2006-02-24 11:16:43.000000000 +0100
@@ -71,6 +71,7 @@
 #include "nsPIBoxObject.h"
 #include "nsINodeInfo.h"
 #include "nsLayoutUtils.h"
+#include "nsPIListBoxObject.h"
 
 /////////////// nsListScrollSmoother //////////////////
 
@@ -284,10 +285,9 @@ nsListBoxBodyFrame::Destroy(nsPresContex
       nsCOMPtr<nsIBoxObject> box;
       nsdoc->GetBoxObjectFor(e, getter_AddRefs(box));
 
-      nsCOMPtr<nsPIBoxObject> pibox(do_QueryInterface(box));
-
-      if (pibox) {
-        pibox->InvalidatePresentationStuff();
+      nsCOMPtr<nsPIListBoxObject> piBox = do_QueryInterface(box);
+      if (piBox) {
+        piBox->ClearCachedListBoxBody();
       }
 
       break;
@@ -1316,6 +1316,9 @@ nsListBoxBodyFrame::OnContentInserted(ns
 void
 nsListBoxBodyFrame::OnContentRemoved(nsPresContext* aPresContext, nsIFrame* aChildFrame, PRInt32 aIndex)
 {
+  NS_ASSERTION(!aChildFrame || aChildFrame->GetParent() == this,
+               "Removing frame that's not our child... Not good");
+  
   if (mRowCount >= 0)
     --mRowCount;
 
@@ -1433,7 +1436,12 @@ nsListBoxBodyFrame::RemoveChildFrame(nsB
 {
   mFrameConstructor->RemoveMappingsForFrameSubtree(aFrame, nsnull);
 
-  mFrames.RemoveFrame(aFrame);
+#ifdef DEBUG
+  PRBool removed =
+#endif
+    mFrames.RemoveFrame(aFrame);
+  NS_ASSERTION(removed,
+               "Going to destroy a frame we didn't remove.  Prepare to crash");
   if (mLayoutManager)
     mLayoutManager->ChildrenRemoved(this, aState, aFrame);
   aFrame->Destroy(mPresContext);
diff -uprN --exclude=CVS mozilla/layout/xul/base/src/nsListBoxObject.cpp mozilla.new/layout/xul/base/src/nsListBoxObject.cpp
--- mozilla/layout/xul/base/src/nsListBoxObject.cpp	2005-04-03 23:02:46.000000000 +0200
+++ mozilla.new/layout/xul/base/src/nsListBoxObject.cpp	2006-03-12 20:04:20.000000000 +0100
@@ -38,7 +38,7 @@
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsCOMPtr.h"
-#include "nsIListBoxObject.h"
+#include "nsPIListBoxObject.h"
 #include "nsBoxObject.h"
 #include "nsIFrame.h"
 #include "nsIDocument.h"
@@ -48,41 +48,30 @@
 #include "nsXULAtoms.h"
 #include "nsIScrollableFrame.h"
 
-class nsListBoxObject : public nsIListBoxObject, public nsBoxObject
+class nsListBoxObject : public nsPIListBoxObject, public nsBoxObject
 {
 public:
-  NS_DECL_ISUPPORTS
+  NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_NSILISTBOXOBJECT
 
+  // nsPIListBoxObject
+  virtual void ClearCachedListBoxBody();
+  virtual nsIListBoxObject* GetListBoxBody();
+
   nsListBoxObject();
   virtual ~nsListBoxObject();
 
-  nsIListBoxObject* GetListBoxBody();
-
   NS_IMETHOD InvalidatePresentationStuff();
   
 protected:
+  nsIListBoxObject* mListBoxBody;
 };
 
-NS_IMPL_ADDREF(nsListBoxObject)
-NS_IMPL_RELEASE(nsListBoxObject)
-
-NS_IMETHODIMP 
-nsListBoxObject::QueryInterface(REFNSIID iid, void** aResult)
-{
-  if (!aResult)
-    return NS_ERROR_NULL_POINTER;
-  
-  if (iid.Equals(NS_GET_IID(nsIListBoxObject))) {
-    *aResult = (nsIListBoxObject*)this;
-    NS_ADDREF(this);
-    return NS_OK;
-  }
+NS_IMPL_ISUPPORTS_INHERITED2(nsListBoxObject, nsBoxObject, nsIListBoxObject,
+                             nsPIListBoxObject)
 
-  return nsBoxObject::QueryInterface(iid, aResult);
-}
-  
 nsListBoxObject::nsListBoxObject()
+  : mListBoxBody(nsnull)
 {
 }
 
@@ -97,8 +86,7 @@ nsListBoxObject::~nsListBoxObject()
 NS_IMETHODIMP
 nsListBoxObject::GetListboxBody(nsIListBoxObject * *aListboxBody)
 {
-  *aListboxBody = GetListBoxBody();
-  NS_IF_ADDREF(*aListboxBody);
+  *aListboxBody = nsnull;
   return NS_OK;
 }
 
@@ -175,6 +163,12 @@ nsListBoxObject::GetIndexOfItem(nsIDOMEl
   return NS_OK;
 }
 
+void
+nsListBoxObject::ClearCachedListBoxBody()
+{
+  mListBoxBody = nsnull;
+}
+
 //////////////////////
 
 static void
@@ -206,26 +200,25 @@ FindBodyContent(nsIContent* aParent, nsI
 nsIListBoxObject*
 nsListBoxObject::GetListBoxBody()
 {
-  NS_NAMED_LITERAL_STRING(listboxbody, "listboxbody");
-
-  nsCOMPtr<nsISupports> supp;
-  GetPropertyAsSupports(listboxbody.get(), getter_AddRefs(supp));
-
-  if (supp) {
-    nsCOMPtr<nsIListBoxObject> body(do_QueryInterface(supp));
-    return body;
+  if (mListBoxBody) {
+    return mListBoxBody;
   }
 
   nsIFrame* frame = GetFrame();
   if (!frame)
     return nsnull;
 
+  nsCOMPtr<nsIPresShell> shell = GetPresShell();
+  if (!shell) {
+    return nsnull;
+  }
+
   // Iterate over our content model children looking for the body.
   nsCOMPtr<nsIContent> content;
   FindBodyContent(frame->GetContent(), getter_AddRefs(content));
 
   // this frame will be a nsGFXScrollFrame
-  mPresShell->GetPrimaryFrameFor(content, &frame);
+  shell->GetPrimaryFrameFor(content, &frame);
   if (!frame)
      return nsnull;
   nsIScrollableFrame* scrollFrame;
@@ -239,16 +232,14 @@ nsListBoxObject::GetListBoxBody()
      return nsnull;
 
   // It's a frame. Refcounts are irrelevant.
-  nsCOMPtr<nsIListBoxObject> body;
-  yeahBaby->QueryInterface(NS_GET_IID(nsIListBoxObject), getter_AddRefs(body));
-  SetPropertyAsSupports(listboxbody.get(), body);
-  return body;
+  CallQueryInterface(yeahBaby, &mListBoxBody);
+  return mListBoxBody;
 }
 
 NS_IMETHODIMP
 nsListBoxObject::InvalidatePresentationStuff()
 {
-  SetPropertyAsSupports(NS_LITERAL_STRING("listboxbody").get(), nsnull);
+  ClearCachedListBoxBody();
 
   return nsBoxObject::InvalidatePresentationStuff();
 }
diff -uprN --exclude=CVS mozilla/layout/xul/base/src/nsMenuPopupFrame.cpp mozilla.new/layout/xul/base/src/nsMenuPopupFrame.cpp
--- mozilla/layout/xul/base/src/nsMenuPopupFrame.cpp	2005-09-28 20:49:14.000000000 +0200
+++ mozilla.new/layout/xul/base/src/nsMenuPopupFrame.cpp	2006-02-24 11:16:43.000000000 +0100
@@ -1,4 +1,5 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=2 sw=2 et tw=78: */
 /* ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
@@ -480,10 +481,11 @@ nsMenuPopupFrame::AdjustClientXYForNeste
   // nsXULPopupListener).
 
   nsCOMPtr<nsIDOMNode> targetNode;
+  nsCOMPtr<nsIDOMXULDocument2> doc = do_QueryInterface(inPopupDoc);
   if (mContent->Tag() == nsXULAtoms::tooltip)
-    inPopupDoc->GetTooltipNode(getter_AddRefs(targetNode));
+    doc->TrustedGetTooltipNode(getter_AddRefs(targetNode));
   else
-    inPopupDoc->GetPopupNode(getter_AddRefs(targetNode));
+    doc->TrustedGetPopupNode(getter_AddRefs(targetNode));
 
   //NS_WARN_IF_FALSE(targetNode, "no popup/tooltip node on document!");
   nsCOMPtr<nsIContent> targetAsContent ( do_QueryInterface(targetNode) );
diff -uprN --exclude=CVS mozilla/layout/xul/base/src/nsPIListBoxObject.h mozilla.new/layout/xul/base/src/nsPIListBoxObject.h
--- mozilla/layout/xul/base/src/nsPIListBoxObject.h	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/layout/xul/base/src/nsPIListBoxObject.h	2006-02-03 02:46:01.000000000 +0100
@@ -0,0 +1,63 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is Mozilla.org.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *     Boris Zbarsky <bzbarsky@mit.edu> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsPIListBoxObject_h__
+#define nsPIListBoxObject_h__
+
+#define NS_PILISTBOXOBJECT_IID \
+{ 0x294e0820, 0x5c40, 0x42a8, \
+ { 0xb3, 0x2f, 0x6d, 0xcf, 0x05, 0xfb, 0xe1, 0xf3 } }
+
+#include "nsIListBoxObject.h"
+
+class nsPIListBoxObject : public nsIListBoxObject {
+ public:
+  NS_DEFINE_STATIC_IID_ACCESSOR(NS_PILISTBOXOBJECT_IID)
+
+  /**
+   * Clear the cached list box body frame from this box object.  This should be
+   * called when the frame in question is destroyed.
+  */
+  virtual void ClearCachedListBoxBody() = 0;
+
+  /*
+   * Get the list box body.  This will search for it as needed.
+   */
+  virtual nsIListBoxObject* GetListBoxBody() = 0;
+};
+
+#endif // nsPIListBoxObject_h__
diff -uprN --exclude=CVS mozilla/layout/xul/base/src/nsPopupBoxObject.cpp mozilla.new/layout/xul/base/src/nsPopupBoxObject.cpp
--- mozilla/layout/xul/base/src/nsPopupBoxObject.cpp	2004-09-02 05:08:51.000000000 +0200
+++ mozilla.new/layout/xul/base/src/nsPopupBoxObject.cpp	2006-03-12 20:04:20.000000000 +0100
@@ -103,8 +103,13 @@ nsPopupBoxObject::HidePopup()
   nsIFrame* ourFrame = GetFrame();
   if (!ourFrame)
     return NS_OK;
+
+  nsCOMPtr<nsIPresShell> shell = GetPresShell();
+  if (!shell) {
+    return NS_OK;
+  }
   
-  nsIFrame* rootFrame = mPresShell->FrameManager()->GetRootFrame();
+  nsIFrame* rootFrame = shell->FrameManager()->GetRootFrame();
   if (!rootFrame)
     return NS_OK;
 
@@ -138,7 +143,12 @@ nsPopupBoxObject::ShowPopup(nsIDOMElemen
                             const PRUnichar *aPopupType, const PRUnichar *anAnchorAlignment, 
                             const PRUnichar *aPopupAlignment)
 {
-  nsIFrame* rootFrame = mPresShell->FrameManager()->GetRootFrame();
+  nsCOMPtr<nsIPresShell> shell = GetPresShell();
+  if (!shell) {
+    return NS_OK;
+  }
+  
+  nsIFrame* rootFrame = shell->FrameManager()->GetRootFrame();
   if (!rootFrame)
     return NS_OK;
 
diff -uprN --exclude=CVS mozilla/layout/xul/base/src/nsScrollBoxObject.cpp mozilla.new/layout/xul/base/src/nsScrollBoxObject.cpp
--- mozilla/layout/xul/base/src/nsScrollBoxObject.cpp	2005-04-26 13:26:31.000000000 +0200
+++ mozilla.new/layout/xul/base/src/nsScrollBoxObject.cpp	2006-03-12 20:04:20.000000000 +0100
@@ -89,8 +89,13 @@ NS_IMETHODIMP nsScrollBoxObject::ScrollT
   nsIScrollableView* scrollableView = GetScrollableView();
   if (!scrollableView)
     return NS_ERROR_FAILURE;
+
+  nsCOMPtr<nsIPresShell> shell = GetPresShell();
+  if (!shell) {
+    return NS_ERROR_UNEXPECTED;
+  }
   
-  float pixelsToTwips = mPresShell->GetPresContext()->PixelsToTwips();
+  float pixelsToTwips = shell->GetPresContext()->PixelsToTwips();
 
   return scrollableView->ScrollTo(NSToIntRound(x * pixelsToTwips),
                                   NSToIntRound(y * pixelsToTwips),
@@ -239,8 +244,13 @@ NS_IMETHODIMP nsScrollBoxObject::ScrollT
     if (!scrollableView)
        return NS_ERROR_FAILURE;
 
+    nsCOMPtr<nsIPresShell> shell = GetPresShell();
+    if (!shell) {
+      return NS_ERROR_UNEXPECTED;
+    }
+    
     // prepare for twips
-    float pixelsToTwips = mPresShell->GetPresContext()->PixelsToTwips();
+    float pixelsToTwips = shell->GetPresContext()->PixelsToTwips();
     
     nsIFrame* scrolledBox = GetScrolledBox(this);
     if (!scrolledBox)
@@ -307,7 +317,12 @@ NS_IMETHODIMP nsScrollBoxObject::GetPosi
   if (NS_FAILED(rv))
     return rv;
 
-  float twipsToPixels = mPresShell->GetPresContext()->TwipsToPixels();
+  nsCOMPtr<nsIPresShell> shell = GetPresShell();
+  if (!shell) {
+    return NS_ERROR_UNEXPECTED;
+  }
+
+  float twipsToPixels = shell->GetPresContext()->TwipsToPixels();
 
   *x = NSToIntRound(xc * twipsToPixels);
   *y = NSToIntRound(yc * twipsToPixels);
@@ -329,9 +344,14 @@ NS_IMETHODIMP nsScrollBoxObject::EnsureE
     if (!scrollableView)
        return NS_ERROR_FAILURE;
 
+    nsCOMPtr<nsIPresShell> shell = GetPresShell();
+    if (!shell) {
+      return NS_ERROR_UNEXPECTED;
+    }
+
     // prepare for twips
     float pixelsToTwips = 0.0;
-    pixelsToTwips = mPresShell->GetPresContext()->PixelsToTwips();
+    pixelsToTwips = shell->GetPresContext()->PixelsToTwips();
     
     nsIFrame* scrolledBox = GetScrolledBox(this);
     if (!scrolledBox)
diff -uprN --exclude=CVS mozilla/layout/xul/base/src/nsXULTooltipListener.cpp mozilla.new/layout/xul/base/src/nsXULTooltipListener.cpp
--- mozilla/layout/xul/base/src/nsXULTooltipListener.cpp	2005-07-20 09:15:38.000000000 +0200
+++ mozilla.new/layout/xul/base/src/nsXULTooltipListener.cpp	2006-02-24 11:16:43.000000000 +0100
@@ -143,11 +143,11 @@ nsXULTooltipListener::MouseOut(nsIDOMEve
     nsCOMPtr<nsIDOMNode> targetNode(do_QueryInterface(eventTarget));
 
     // which node is our tooltip on?
-    nsCOMPtr<nsIDOMXULDocument> xulDoc(do_QueryInterface(mCurrentTooltip->GetDocument()));
+    nsCOMPtr<nsIDOMXULDocument2> xulDoc(do_QueryInterface(mCurrentTooltip->GetDocument()));
     if (!xulDoc)     // remotely possible someone could have 
       return NS_OK;  // removed tooltip from dom while it was open
     nsCOMPtr<nsIDOMNode> tooltipNode;
-    xulDoc->GetTooltipNode (getter_AddRefs(tooltipNode));
+    xulDoc->TrustedGetTooltipNode (getter_AddRefs(tooltipNode));
 
     // if they're the same, the mouse left the node the tooltip appeared on,
     // close the tooltip.
diff -uprN --exclude=CVS mozilla/layout/xul/base/src/tree/src/nsPITreeBoxObject.h mozilla.new/layout/xul/base/src/tree/src/nsPITreeBoxObject.h
--- mozilla/layout/xul/base/src/tree/src/nsPITreeBoxObject.h	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/layout/xul/base/src/tree/src/nsPITreeBoxObject.h	2006-02-03 02:46:01.000000000 +0100
@@ -0,0 +1,58 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is Mozilla.org.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *     Boris Zbarsky <bzbarsky@mit.edu> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsPITreeBoxObject_h__
+#define nsPITreeBoxObject_h__
+
+#define NS_PITREEBOXOBJECT_IID \
+{ 0xafcd2a82, 0xc484, 0x4f86, \
+ { 0x83, 0x77, 0xd9, 0xb8, 0x59, 0x31, 0xef, 0xf0 } }
+
+#include "nsITreeBoxObject.h"
+
+class nsPITreeBoxObject : public nsITreeBoxObject {
+ public:
+  NS_DEFINE_STATIC_IID_ACCESSOR(NS_PITREEBOXOBJECT_IID)
+
+  /**
+   * Clear the cached tree body frame from this box object.  This should be
+   * called when the frame in question is destroyed.
+  */
+  virtual void ClearCachedTreeBody() = 0;
+};
+
+#endif // nsPITreeBoxObject_h__
diff -uprN --exclude=CVS mozilla/layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp mozilla.new/layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp
--- mozilla/layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp	2005-09-14 00:50:22.000000000 +0200
+++ mozilla.new/layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp	2006-02-14 10:01:28.000000000 +0100
@@ -156,7 +156,7 @@ NS_INTERFACE_MAP_END_INHERITING(nsLeafBo
 
 // Constructor
 nsTreeBodyFrame::nsTreeBodyFrame(nsIPresShell* aPresShell)
-:nsLeafBoxFrame(aPresShell), mPresContext(nsnull), mTreeBoxObject(nsnull), mImageCache(nsnull),
+:nsLeafBoxFrame(aPresShell), mPresContext(nsnull), mImageCache(nsnull),
  mScrollbar(nsnull), mTopRowIndex(0), mRowHeight(0), mIndentation(0), mStringWidth(-1),
  mFocused(PR_FALSE), mHasFixedRowCount(PR_FALSE),
  mVerticalOverflow(PR_FALSE), mReflowCallbackPosted(PR_FALSE),
@@ -348,8 +348,7 @@ nsTreeBodyFrame::Destroy(nsPresContext* 
     }
 
     // Always null out the cached tree body frame.
-    nsAutoString treeBody(NS_LITERAL_STRING("treebody"));
-    box->RemoveProperty(treeBody.get());
+    mTreeBoxObject->ClearCachedTreeBody();
 
     mTreeBoxObject = nsnull; // Drop our ref here.
   }
@@ -395,12 +394,14 @@ nsTreeBodyFrame::EnsureView()
     nsCOMPtr<nsIBoxObject> box = do_QueryInterface(mTreeBoxObject);
     if (box) {
       nsCOMPtr<nsISupports> suppView;
-      box->GetPropertyAsSupports(NS_LITERAL_STRING("view").get(), getter_AddRefs(suppView));
+      box->GetPropertyAsSupports(NS_LITERAL_STRING("view").get(),
+                                 getter_AddRefs(suppView));
       nsCOMPtr<nsITreeView> treeView(do_QueryInterface(suppView));
 
       if (treeView) {
         nsXPIDLString rowStr;
-        box->GetProperty(NS_LITERAL_STRING("topRow").get(), getter_Copies(rowStr));
+        box->GetProperty(NS_LITERAL_STRING("topRow").get(),
+                         getter_Copies(rowStr));
         nsAutoString rowStr2(rowStr);
         PRInt32 error;
         PRInt32 rowIndex = rowStr2.ToInteger(&error);
@@ -514,7 +515,7 @@ NS_IMETHODIMP nsTreeBodyFrame::SetView(n
   EnsureBoxObject();
   nsCOMPtr<nsIBoxObject> box = do_QueryInterface(mTreeBoxObject);
   
-  nsAutoString view(NS_LITERAL_STRING("view"));
+  NS_NAMED_LITERAL_STRING(view, "view");
   
   if (mView) {
     nsCOMPtr<nsITreeSelection> sel;
diff -uprN --exclude=CVS mozilla/layout/xul/base/src/tree/src/nsTreeBodyFrame.h mozilla.new/layout/xul/base/src/tree/src/nsTreeBodyFrame.h
--- mozilla/layout/xul/base/src/tree/src/nsTreeBodyFrame.h	2005-04-18 07:22:35.000000000 +0200
+++ mozilla.new/layout/xul/base/src/tree/src/nsTreeBodyFrame.h	2006-02-14 10:01:28.000000000 +0100
@@ -40,7 +40,7 @@
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsLeafBoxFrame.h"
-#include "nsITreeBoxObject.h"
+#include "nsPITreeBoxObject.h"
 #include "nsITreeView.h"
 #include "nsICSSPseudoComparator.h"
 #include "nsIScrollbarMediator.h"
@@ -313,7 +313,7 @@ protected: // Data Members
   nsPresContext* mPresContext;
 
   // The cached box object parent.
-  nsCOMPtr<nsITreeBoxObject> mTreeBoxObject;
+  nsCOMPtr<nsPITreeBoxObject> mTreeBoxObject;
 
   // Cached column information.
   nsRefPtr<nsTreeColumns> mColumns;
diff -uprN --exclude=CVS mozilla/layout/xul/base/src/tree/src/nsTreeBoxObject.cpp mozilla.new/layout/xul/base/src/tree/src/nsTreeBoxObject.cpp
--- mozilla/layout/xul/base/src/tree/src/nsTreeBoxObject.cpp	2004-08-01 01:15:17.000000000 +0200
+++ mozilla.new/layout/xul/base/src/tree/src/nsTreeBoxObject.cpp	2006-03-12 20:04:20.000000000 +0100
@@ -39,7 +39,7 @@
 #include "nsCOMPtr.h"
 #include "nsPresContext.h"
 #include "nsIPresShell.h"
-#include "nsITreeBoxObject.h"
+#include "nsPITreeBoxObject.h"
 #include "nsITreeView.h"
 #include "nsITreeSelection.h"
 #include "nsBoxObject.h"
@@ -49,7 +49,7 @@
 #include "nsXULAtoms.h"
 #include "nsChildIterator.h"
 
-class nsTreeBoxObject : public nsITreeBoxObject, public nsBoxObject
+class nsTreeBoxObject : public nsPITreeBoxObject, public nsBoxObject
 {
 public:
   NS_DECL_ISUPPORTS_INHERITED
@@ -64,10 +64,17 @@ public:
   NS_IMETHOD Init(nsIContent* aContent, nsIPresShell* aPresShell);
   NS_IMETHOD SetDocument(nsIDocument* aDocument);
   NS_IMETHOD InvalidatePresentationStuff();
+
+  // nsPITreeBoxObject
+  virtual void ClearCachedTreeBody();  
+
+protected:
+  nsITreeBoxObject* mTreeBody;
 };
 
 /* Implementation file */
-NS_IMPL_ISUPPORTS_INHERITED1(nsTreeBoxObject, nsBoxObject, nsITreeBoxObject)
+NS_IMPL_ISUPPORTS_INHERITED2(nsTreeBoxObject, nsBoxObject, nsITreeBoxObject,
+                             nsPITreeBoxObject)
 
 
 NS_IMETHODIMP
@@ -96,13 +103,14 @@ nsTreeBoxObject::SetDocument(nsIDocument
 NS_IMETHODIMP
 nsTreeBoxObject::InvalidatePresentationStuff()
 {
-  SetPropertyAsSupports(NS_LITERAL_STRING("treebody").get(), nsnull);
+  ClearCachedTreeBody();
   SetPropertyAsSupports(NS_LITERAL_STRING("view").get(), nsnull);
 
   return nsBoxObject::InvalidatePresentationStuff();
 }
   
 nsTreeBoxObject::nsTreeBoxObject()
+  : mTreeBody(nsnull)
 {
 }
 
@@ -140,15 +148,11 @@ static void FindBodyElement(nsIContent* 
   }
 }
 
-inline nsITreeBoxObject*
+nsITreeBoxObject*
 nsTreeBoxObject::GetTreeBody()
 {
-  nsCOMPtr<nsISupports> supp;
-  GetPropertyAsSupports(NS_LITERAL_STRING("treebody").get(), getter_AddRefs(supp));
-
-  if (supp) {
-    nsCOMPtr<nsITreeBoxObject> body(do_QueryInterface(supp));
-    return body;
+  if (mTreeBody) {
+    return mTreeBody;
   }
 
   nsIFrame* frame = GetFrame();
@@ -159,15 +163,18 @@ nsTreeBoxObject::GetTreeBody()
   nsCOMPtr<nsIContent> content;
   FindBodyElement(frame->GetContent(), getter_AddRefs(content));
 
-  mPresShell->GetPrimaryFrameFor(content, &frame);
+  nsCOMPtr<nsIPresShell> shell = GetPresShell();
+  if (!shell) {
+    return nsnull;
+  }
+
+  shell->GetPrimaryFrameFor(content, &frame);
   if (!frame)
      return nsnull;
 
   // It's a frame. Refcounts are irrelevant.
-  nsCOMPtr<nsITreeBoxObject> body;
-  frame->QueryInterface(NS_GET_IID(nsITreeBoxObject), getter_AddRefs(body));
-  SetPropertyAsSupports(NS_LITERAL_STRING("treebody").get(), body);
-  return body;
+  CallQueryInterface(frame, &mTreeBody);
+  return mTreeBody;
 }
 
 NS_IMETHODIMP nsTreeBoxObject::GetView(nsITreeView * *aView)
@@ -410,6 +417,12 @@ NS_IMETHODIMP nsTreeBoxObject::ClearStyl
   return NS_OK;
 }
 
+void
+nsTreeBoxObject::ClearCachedTreeBody()
+{
+  mTreeBody = nsnull;
+}    
+
 // Creation Routine ///////////////////////////////////////////////////////////////////////
 
 nsresult
diff -uprN --exclude=CVS mozilla/mailnews/addrbook/src/nsDirPrefs.cpp mozilla.new/mailnews/addrbook/src/nsDirPrefs.cpp
--- mozilla/mailnews/addrbook/src/nsDirPrefs.cpp	2005-03-23 19:05:49.000000000 +0100
+++ mozilla.new/mailnews/addrbook/src/nsDirPrefs.cpp	2006-02-24 11:16:49.000000000 +0100
@@ -2693,6 +2693,14 @@ char *DIR_CreateServerPrefName (DIR_Serv
         leafName = nsCRT::strdup(name);
 	else
 		leafName = dir_ConvertDescriptionToPrefName (server);
+
+  if (!leafName || !*leafName)
+  {
+    // we need to handle this in case the description has no alphanumeric chars
+    // it's very common for cjk users
+    leafName = nsCRT::strdup("_nonascii");
+  }
+
 	if (leafName)
 	{
 		PRInt32 uniqueIDCnt = 0;
@@ -2723,6 +2731,13 @@ char *DIR_CreateServerPrefName (DIR_Serv
             NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(prefCount, children);
 		} /* while we don't have a unique name */
 
+    // fallback to "user_directory_N" form if we failed to verify
+    if (!isUnique && prefName)
+    {
+      PR_smprintf_free(prefName);
+      prefName = nsnull;
+    }
+
 		PR_Free(leafName);
 
 	} /* if leafName */
diff -uprN --exclude=CVS mozilla/mailnews/base/prefs/resources/content/am-addressing.js mozilla.new/mailnews/base/prefs/resources/content/am-addressing.js
--- mozilla/mailnews/base/prefs/resources/content/am-addressing.js	2004-11-10 22:40:59.000000000 +0100
+++ mozilla.new/mailnews/base/prefs/resources/content/am-addressing.js	2006-02-14 10:01:38.000000000 +0100
@@ -55,16 +55,16 @@ function enabling()
 
   // If the default per-identity directory preferences are locked 
   // disable the corresponding elements.
-  if (gPrefInt.prefIsLocked("mail.identity." + gIdentity.key + ".overrideGlobal_Pref")) {
+  if (gIdentity && gPrefInt.prefIsLocked("mail.identity." + gIdentity.key + ".overrideGlobal_Pref")) {
     document.getElementById("useGlobalPref").setAttribute("disabled", "true");
     document.getElementById("directories").setAttribute("disabled", "true");
   }
   else
   {
-	document.getElementById("useGlobalPref").removeAttribute("disabled");
+    document.getElementById("useGlobalPref").removeAttribute("disabled");
     document.getElementById("directories").removeAttribute("disabled");
   }
-  if (gPrefInt.prefIsLocked("mail.identity." + gIdentity.key + ".directoryServer")) {
+  if (gIdentity && gPrefInt.prefIsLocked("mail.identity." + gIdentity.key + ".directoryServer")) {
     document.getElementById("directoriesList").setAttribute("disabled", "true");
     document.getElementById("directoriesListPopup").setAttribute("disabled", "true");
   }
diff -uprN --exclude=CVS mozilla/mailnews/base/resources/content/mailWindowOverlay.js mozilla.new/mailnews/base/resources/content/mailWindowOverlay.js
--- mozilla/mailnews/base/resources/content/mailWindowOverlay.js	2006-01-09 06:49:05.000000000 +0100
+++ mozilla.new/mailnews/base/resources/content/mailWindowOverlay.js	2006-02-14 10:01:38.000000000 +0100
@@ -2253,7 +2253,7 @@ function OnMsgLoaded(aUrl)
     var markReadOnADelay = gPrefBranch.getBoolPref("mailnews.mark_message_read.delay");
     if (msgHdr && !msgHdr.isRead)
     {
-      var wintype = document.firstChild.getAttribute('windowtype');
+      var wintype = document.documentElement.getAttribute('windowtype');
       if (markReadOnADelay && wintype == "mail:3pane") // only use the timer if viewing using the 3-pane preview pane and the user has set the pref
         gMarkViewedMessageAsReadTimer = setTimeout(MarkCurrentMessageAsRead, gPrefBranch.getIntPref("mailnews.mark_message_read.delay.interval") * 1000);
       else
diff -uprN --exclude=CVS mozilla/mailnews/base/resources/content/msgMail3PaneWindow.js mozilla.new/mailnews/base/resources/content/msgMail3PaneWindow.js
--- mozilla/mailnews/base/resources/content/msgMail3PaneWindow.js	2006-01-23 08:55:19.000000000 +0100
+++ mozilla.new/mailnews/base/resources/content/msgMail3PaneWindow.js	2006-02-14 10:01:38.000000000 +0100
@@ -823,11 +823,11 @@ function loadStartFolder(initialUri)
 
         var startFolder = startFolderResource.QueryInterface(Components.interfaces.nsIMsgFolder);
 
-        // Perform biff on the server to check for new mail, except for imap
-        // or a pop3 account that is deferred or deferred to,
+        // Perform biff on the server to check for new mail, except for 
+        // a pop3 account that is deferred or deferred to,
         // or the case where initialUri is non-null (non-startup)
         if (!initialUri && isLoginAtStartUpEnabled && gLoadStartFolder
-            && defaultServer.type != "imap" && !defaultServer.isDeferredTo &&
+            && !defaultServer.isDeferredTo &&
             defaultServer.rootFolder == defaultServer.rootMsgFolder)
           defaultServer.PerformBiff(msgWindow);        
 
diff -uprN --exclude=CVS mozilla/mailnews/base/resources/content/phishingDetector.js mozilla.new/mailnews/base/resources/content/phishingDetector.js
--- mozilla/mailnews/base/resources/content/phishingDetector.js	2006-01-09 06:49:06.000000000 +0100
+++ mozilla.new/mailnews/base/resources/content/phishingDetector.js	2006-02-24 11:16:49.000000000 +0100
@@ -76,7 +76,7 @@ function isMsgEmailScam(aUrl)
   {
     var forms = msgDocument.getElementsByTagName("form");
     for (index = 0; index < forms.length && !isEmailScam; index++)
-      isEmailScam = !/^addbook:/.test(forms[index].action);
+      isEmailScam = forms[index].action != "" && !/^addbook:/.test(forms[index].action);
   }
 
   // we'll add more checks here as our detector matures....
@@ -135,6 +135,11 @@ function isPhishingURL(aLinkNode, aSilen
 function misMatchedHostWithLinkText(aLinkNode, aHrefURL, aLinkTextURL)
 {
   var linkNodeText = gatherTextUnder(aLinkNode);
+
+  // gatherTextUnder puts a space between each piece of text it gathers,
+  // so strip the spaces out (see bug 326082 for details).
+  linkNodeText = linkNodeText.replace(/ /g, "");
+
   // only worry about http and https urls
   if (linkNodeText)
   {
diff -uprN --exclude=CVS mozilla/mailnews/base/search/src/nsMsgFilterService.cpp mozilla.new/mailnews/base/search/src/nsMsgFilterService.cpp
--- mozilla/mailnews/base/search/src/nsMsgFilterService.cpp	2005-08-10 20:59:17.000000000 +0200
+++ mozilla.new/mailnews/base/search/src/nsMsgFilterService.cpp	2006-02-14 10:01:38.000000000 +0100
@@ -139,11 +139,15 @@ NS_IMETHODIMP nsMsgFilterService::CloseF
 /* save without deleting */
 NS_IMETHODIMP	nsMsgFilterService::SaveFilterList(nsIMsgFilterList *filterList, nsIFileSpec *filterFile)
 {
-	nsresult ret = NS_OK;
+  NS_ENSURE_ARG_POINTER(filterFile);
+  NS_ENSURE_ARG_POINTER(filterList);
+
+  nsresult ret = NS_OK;
   nsCOMPtr <nsIFileSpec> tmpFiltersFile;
   nsCOMPtr <nsIFileSpec> realFiltersFile;
   nsCOMPtr <nsIFileSpec> parentDir;
 
+
   nsSpecialSystemDirectory tmpFile(nsSpecialSystemDirectory::OS_TemporaryDirectory);
   tmpFile += "tmprules.dat";
 
diff -uprN --exclude=CVS mozilla/mailnews/base/src/nsMessenger.cpp mozilla.new/mailnews/base/src/nsMessenger.cpp
--- mozilla/mailnews/base/src/nsMessenger.cpp	2005-10-04 05:10:45.000000000 +0200
+++ mozilla.new/mailnews/base/src/nsMessenger.cpp	2006-02-14 10:01:38.000000000 +0100
@@ -902,6 +902,8 @@ nsMessenger::SaveAllAttachments(PRUint32
                                 const char **displayNameArray,
                                 const char **messageUriArray)
 {
+  if (!count)
+    return NS_ERROR_INVALID_ARG;
   return SaveAllAttachments(count, contentTypeArray, urlArray, displayNameArray, messageUriArray, PR_FALSE);
 }
 
diff -uprN --exclude=CVS mozilla/mailnews/base/src/nsMsgContentPolicy.cpp mozilla.new/mailnews/base/src/nsMsgContentPolicy.cpp
--- mozilla/mailnews/base/src/nsMsgContentPolicy.cpp	2005-10-24 07:41:40.000000000 +0200
+++ mozilla.new/mailnews/base/src/nsMsgContentPolicy.cpp	2006-03-03 07:15:39.000000000 +0100
@@ -350,7 +350,7 @@ nsMsgContentPolicy::ShouldLoad(PRUint32 
         // now we need to call out the msg sink informing it that this message has remote content      
         nsCOMPtr<nsIMsgWindow> msgWindow;
         rv = mailnewsUrl->GetMsgWindow(getter_AddRefs(msgWindow)); // it's not an error for the msg window to be null
-        NS_ENSURE_TRUE(msgWindow, NS_ERROR_FAILURE);
+        NS_ENSURE_TRUE(msgWindow, NS_OK);
 
         nsCOMPtr<nsIMsgHeaderSink> msgHdrSink;
         rv = msgWindow->GetMsgHeaderSink(getter_AddRefs(msgHdrSink));
diff -uprN --exclude=CVS mozilla/mailnews/base/src/nsMsgDBView.cpp mozilla.new/mailnews/base/src/nsMsgDBView.cpp
--- mozilla/mailnews/base/src/nsMsgDBView.cpp	2005-10-14 02:42:20.000000000 +0200
+++ mozilla.new/mailnews/base/src/nsMsgDBView.cpp	2006-02-14 10:01:38.000000000 +0100
@@ -4062,6 +4062,7 @@ nsresult nsMsgDBView::ExpandByIndex(nsMs
     return NS_MSG_MESSAGE_NOT_FOUND;
   }
   rv = GetThreadContainingMsgHdr(msgHdr, getter_AddRefs(pThread));
+  NS_ENSURE_SUCCESS(rv, rv);
   m_flags[index] = flags;
   NoteChange(index, 1, nsMsgViewNotificationCode::changed);
   if (m_viewFlags & nsMsgViewFlagsType::kUnreadOnly)
@@ -4348,12 +4349,6 @@ nsresult	nsMsgDBView::AddHdr(nsIMsgDBHdr
   {
     // if unreadonly, level is 0 because we must be the only msg in the thread.
     PRInt32 levelToAdd = 0;
-#if 0 
-    if (!(m_viewFlags & nsMsgViewFlagsType::kUnreadOnly)) 
-    {
-      levelToAdd = FindLevelInThread(msgHdr, insertIndex);
-    }
-#endif
     
     if (m_sortOrder == nsMsgViewSortOrder::ascending)
     {
@@ -4382,12 +4377,6 @@ nsresult	nsMsgDBView::AddHdr(nsIMsgDBHdr
     m_keys.InsertAt(insertIndex, msgKey);
     m_flags.InsertAt(insertIndex, flags);
     PRInt32 level = 0; 
-#if 0 
-    if (m_viewFlags & nsMsgViewFlagsType::kThreadedDisplay)
-    {
-      level = FindLevelInThread(msgHdr, insertIndex);
-    }
-#endif
     m_levels.InsertAt(insertIndex, level);
     
     // the call to NoteChange() has to happen after we add the key
@@ -4501,11 +4490,9 @@ nsresult nsMsgDBView::ListIdsInThread(ns
       msgHdr->GetFlags(&msgFlags);
       AdjustReadFlag(msgHdr, &msgFlags);
       m_keys.InsertAt(viewIndex, msgKey);
-      // ### TODO - how about hasChildren flag?
       m_flags.InsertAt(viewIndex, msgFlags & ~MSG_VIEW_FLAGS);
-      // ### TODO this is going to be tricky - might use enumerators
-      PRInt32 level = FindLevelInThread(msgHdr, startOfThreadViewIndex, viewIndex);
-      m_levels.InsertAt(viewIndex, level); 
+      // here, we're either flat, or we're grouped - in either case, level is 1
+      m_levels.InsertAt(viewIndex, 1);
       // turn off thread or elided bit if they got turned on (maybe from new only view?)
       if (i > 0)	
         msgHdr->AndFlags(~(MSG_VIEW_FLAG_ISTHREAD | MSG_FLAG_ELIDED), &newFlags);
diff -uprN --exclude=CVS mozilla/mailnews/base/util/nsMsgIdentity.cpp mozilla.new/mailnews/base/util/nsMsgIdentity.cpp
--- mozilla/mailnews/base/util/nsMsgIdentity.cpp	2005-05-08 00:36:17.000000000 +0200
+++ mozilla.new/mailnews/base/util/nsMsgIdentity.cpp	2006-02-24 11:16:50.000000000 +0100
@@ -618,6 +618,13 @@ nsMsgIdentity::getFolderPref(const char 
       if (NS_SUCCEEDED(rv))
         return msgFolder->GetURI(retval);
     }
+    else // if the server doesn't exist, fall back to the default pref.
+    {
+      PR_FREEIF(*retval);	// free the empty string
+      rv = getDefaultCharPref(prefname, retval);
+      if (NS_SUCCEEDED(rv) && *retval)
+        rv = setFolderPref(prefname, (const char *)*retval);
+    }
   }
   return rv;
 }
diff -uprN --exclude=CVS mozilla/mailnews/base/util/nsMsgUtils.cpp mozilla.new/mailnews/base/util/nsMsgUtils.cpp
--- mozilla/mailnews/base/util/nsMsgUtils.cpp	2005-10-04 05:10:45.000000000 +0200
+++ mozilla.new/mailnews/base/util/nsMsgUtils.cpp	2006-02-14 10:01:38.000000000 +0100
@@ -668,10 +668,10 @@ nsresult EscapeFromSpaceLine(nsIFileSpec
       // Found a line so check if it's a qualified "From " line.
       if (IsAFromSpaceLine(start, pChar))
         rv = pDst->Write(">", 1, &written);
-
-      rv = pDst->Write(start, pChar-start+2, &written);
+      PRInt32 lineTerminatorCount = (*(pChar + 1) == nsCRT::LF) ? 2 : 1;
+      rv = pDst->Write(start, pChar - start + lineTerminatorCount, &written);
       NS_ENSURE_SUCCESS(rv,rv);
-      pChar += 2;
+      pChar += lineTerminatorCount;
       start = pChar;
     }
     else if (start < end)
diff -uprN --exclude=CVS mozilla/mailnews/compose/src/nsMsgCompose.cpp mozilla.new/mailnews/compose/src/nsMsgCompose.cpp
--- mozilla/mailnews/compose/src/nsMsgCompose.cpp	2005-12-01 00:44:46.000000000 +0100
+++ mozilla.new/mailnews/compose/src/nsMsgCompose.cpp	2006-02-14 10:01:38.000000000 +0100
@@ -403,10 +403,10 @@ nsresult nsMsgCompose::TagEmbeddedObject
 
   // first, convert the rdf original msg uri into a url that represents the message...
   nsCOMPtr <nsIMsgMessageService> msgService;
-  rv = GetMessageServiceFromURI(mQuoteURI.get(), getter_AddRefs(msgService));
+  rv = GetMessageServiceFromURI(mOriginalMsgURI.get(), getter_AddRefs(msgService));
   if (NS_SUCCEEDED(rv))
   {
-    rv = msgService->GetUrlForUri(mQuoteURI.get(), getter_AddRefs(originalUrl), nsnull);
+    rv = msgService->GetUrlForUri(mOriginalMsgURI.get(), getter_AddRefs(originalUrl), nsnull);
     if (NS_SUCCEEDED(rv) && originalUrl)
     {
       originalUrl->GetScheme(originalScheme);
@@ -1742,8 +1742,6 @@ nsresult nsMsgCompose::CreateMessage(con
 
             // Setup quoting callbacks for later...
             mWhatHolder = 1;
-            mQuoteURI = originalMsgURI;
-
             break;
           }
         case nsIMsgCompType::ForwardAsAttachment:
@@ -3420,7 +3418,7 @@ nsMsgCompose::BuildQuotedMessageAndSigna
 
   // We will fire off the quote operation and wait for it to
   // finish before we actually do anything with Ender...
-  return QuoteOriginalMessage(mQuoteURI.get(), mWhatHolder);
+  return QuoteOriginalMessage(mOriginalMsgURI.get(), mWhatHolder);
 }
 
 //
diff -uprN --exclude=CVS mozilla/mailnews/compose/src/nsMsgCompose.h mozilla.new/mailnews/compose/src/nsMsgCompose.h
--- mozilla/mailnews/compose/src/nsMsgCompose.h	2005-10-18 18:34:41.000000000 +0200
+++ mozilla.new/mailnews/compose/src/nsMsgCompose.h	2006-02-14 10:01:38.000000000 +0100
@@ -91,7 +91,6 @@ private:
                                                      nsIDOMNode * object);
   nsresult                      TagEmbeddedObjects(nsIEditorMailSupport *aMailEditor);
 
-  nsCString                     mQuoteURI;
   nsCString                     mQuoteCharset;
   nsCString                     mOriginalMsgURI; // used so we can mark message disposition flags after we send the message
 
diff -uprN --exclude=CVS mozilla/mailnews/compose/src/nsMsgComposeService.cpp mozilla.new/mailnews/compose/src/nsMsgComposeService.cpp
--- mozilla/mailnews/compose/src/nsMsgComposeService.cpp	2005-10-04 05:10:46.000000000 +0200
+++ mozilla.new/mailnews/compose/src/nsMsgComposeService.cpp	2006-02-14 10:01:38.000000000 +0100
@@ -1380,9 +1380,14 @@ nsMsgComposeService::Handle(nsICommandLi
   rv = aCmdLine->GetLength(&count);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  if (count >= found) {
+  if (count > found + 1) {
     aCmdLine->GetArgument(found + 1, uristr);
-    if (StringBeginsWith(uristr, NS_LITERAL_STRING("mailto:"))) {
+    if (StringBeginsWith(uristr, NS_LITERAL_STRING("mailto:"))  ||
+	StringBeginsWith(uristr, NS_LITERAL_STRING("to="))  ||
+	StringBeginsWith(uristr, NS_LITERAL_STRING("cc="))  ||
+	StringBeginsWith(uristr, NS_LITERAL_STRING("subject="))  ||
+	StringBeginsWith(uristr, NS_LITERAL_STRING("body="))  ||
+	StringBeginsWith(uristr, NS_LITERAL_STRING("attachment="))) {
       end++;
       // mailto: URIs are frequently passed with spaces in them. They should be
       // escaped with %20, but we hack around broken clients. See bug 231032.
diff -uprN --exclude=CVS mozilla/mailnews/compose/src/nsMsgCompUtils.cpp mozilla.new/mailnews/compose/src/nsMsgCompUtils.cpp
--- mozilla/mailnews/compose/src/nsMsgCompUtils.cpp	2005-07-20 13:49:42.000000000 +0200
+++ mozilla.new/mailnews/compose/src/nsMsgCompUtils.cpp	2006-02-14 10:01:38.000000000 +0100
@@ -1307,10 +1307,7 @@ RFC2231ParmFolding(const char *parmName,
         foldedParm = PL_strdup(parmName);
       }
       else {
-        if (needEscape)
-          NS_MsgSACat(&foldedParm, "\r\n ");
-        else
-          NS_MsgSACat(&foldedParm, ";\r\n ");
+        NS_MsgSACat(&foldedParm, ";\r\n ");
         NS_MsgSACat(&foldedParm, parmName);
       }
       PR_snprintf(digits, sizeof(digits), "*%d", counter);
diff -uprN --exclude=CVS mozilla/mailnews/compose/src/nsSmtpService.cpp mozilla.new/mailnews/compose/src/nsSmtpService.cpp
--- mozilla/mailnews/compose/src/nsSmtpService.cpp	2005-07-26 23:23:43.000000000 +0200
+++ mozilla.new/mailnews/compose/src/nsSmtpService.cpp	2006-02-24 11:16:50.000000000 +0100
@@ -345,6 +345,7 @@ NS_IMETHODIMP nsSmtpService::NewURI(cons
 
 NS_IMETHODIMP nsSmtpService::NewChannel(nsIURI *aURI, nsIChannel **_retval)
 {
+  NS_ENSURE_ARG_POINTER(aURI);
   // create an empty pipe for use with the input stream channel.
   nsCOMPtr<nsIInputStream> pipeIn;
   nsCOMPtr<nsIOutputStream> pipeOut;
diff -uprN --exclude=CVS mozilla/mailnews/extensions/smime/resources/content/msgReadSMIMEOverlay.js mozilla.new/mailnews/extensions/smime/resources/content/msgReadSMIMEOverlay.js
--- mozilla/mailnews/extensions/smime/resources/content/msgReadSMIMEOverlay.js	2002-05-29 06:44:47.000000000 +0200
+++ mozilla.new/mailnews/extensions/smime/resources/content/msgReadSMIMEOverlay.js	2006-02-14 10:01:38.000000000 +0100
@@ -119,7 +119,7 @@ var SecurityController =
     {
       case "cmd_viewSecurityStatus":
       {
-        if (document.firstChild.getAttribute('windowtype') == "mail:messageWindow")
+        if (document.documentElement.getAttribute('windowtype') == "mail:messageWindow")
         {
           return ( gCurrentMessageUri != null);
         }
diff -uprN --exclude=CVS mozilla/mailnews/local/src/nsMailboxService.cpp mozilla.new/mailnews/local/src/nsMailboxService.cpp
--- mozilla/mailnews/local/src/nsMailboxService.cpp	2005-11-01 17:49:22.000000000 +0100
+++ mozilla.new/mailnews/local/src/nsMailboxService.cpp	2006-02-24 11:16:51.000000000 +0100
@@ -558,6 +558,7 @@ NS_IMETHODIMP nsMailboxService::NewURI(c
 
 NS_IMETHODIMP nsMailboxService::NewChannel(nsIURI *aURI, nsIChannel **_retval)
 {
+  NS_ENSURE_ARG_POINTER(aURI);
   nsresult rv = NS_OK;
   nsMailboxProtocol * protocol = new nsMailboxProtocol(aURI);
   if (protocol)
diff -uprN --exclude=CVS mozilla/mailnews/local/src/nsMailboxUrl.cpp mozilla.new/mailnews/local/src/nsMailboxUrl.cpp
--- mozilla/mailnews/local/src/nsMailboxUrl.cpp	2005-06-01 21:04:20.000000000 +0200
+++ mozilla.new/mailnews/local/src/nsMailboxUrl.cpp	2006-03-03 07:15:42.000000000 +0100
@@ -277,7 +277,7 @@ NS_IMETHODIMP nsMailboxUrl::GetUri(char 
 nsresult nsMailboxUrl::GetMsgHdrForKey(nsMsgKey  msgKey, nsIMsgDBHdr ** aMsgHdr)
 {
   nsresult rv = NS_OK;
-  if (aMsgHdr)
+  if (aMsgHdr && m_filePath)
   {
     nsCOMPtr<nsIMsgDatabase> mailDBFactory;
     nsCOMPtr<nsIMsgDatabase> mailDB;
diff -uprN --exclude=CVS mozilla/mailnews/local/src/nsPop3Service.cpp mozilla.new/mailnews/local/src/nsPop3Service.cpp
--- mozilla/mailnews/local/src/nsPop3Service.cpp	2005-08-03 00:32:21.000000000 +0200
+++ mozilla.new/mailnews/local/src/nsPop3Service.cpp	2006-02-24 11:16:51.000000000 +0100
@@ -415,6 +415,7 @@ NS_IMETHODIMP nsPop3Service::NewURI(cons
 
 NS_IMETHODIMP nsPop3Service::NewChannel(nsIURI *aURI, nsIChannel **_retval)
 {
+  NS_ENSURE_ARG_POINTER(aURI);
   nsresult rv = NS_OK;
   nsPop3Protocol * protocol = new nsPop3Protocol(aURI);
   if (protocol)
diff -uprN --exclude=CVS mozilla/mailnews/mailnews.js mozilla.new/mailnews/mailnews.js
--- mozilla/mailnews/mailnews.js	2006-01-09 06:49:05.000000000 +0100
+++ mozilla.new/mailnews/mailnews.js	2006-02-24 11:16:49.000000000 +0100
@@ -277,7 +277,7 @@ pref("ldap_2.servers.history.isOffline",
 // default mapping of addressbook properties to ldap attributes
 pref("ldap_2.servers.default.attrmap.FirstName", "givenName");
 pref("ldap_2.servers.default.attrmap.LastName", "sn,surname");
-pref("ldap_2.servers.default.attrmap.DisplayName", "displayName,cn,commonname");
+pref("ldap_2.servers.default.attrmap.DisplayName", "cn,commonname");
 pref("ldap_2.servers.default.attrmap.NickName", "mozillaNickname,xmozillanickname");
 pref("ldap_2.servers.default.attrmap.PrimaryEmail", "mail");
 pref("ldap_2.servers.default.attrmap.SecondEmail", "mozillaSecondEmail,xmozillasecondemail");
diff -uprN --exclude=CVS mozilla/mailnews/mime/src/mimecryp.cpp mozilla.new/mailnews/mime/src/mimecryp.cpp
--- mozilla/mailnews/mime/src/mimecryp.cpp	2004-01-04 08:57:16.000000000 +0100
+++ mozilla.new/mailnews/mime/src/mimecryp.cpp	2006-02-14 10:01:39.000000000 +0100
@@ -118,7 +118,17 @@ MimeEncrypted_parse_begin (MimeObject *o
   else if (!nsCRT::strcasecmp(obj->encoding, ENCODING_BASE64))
 	fn = &MimeB64DecoderInit;
   else if (!nsCRT::strcasecmp(obj->encoding, ENCODING_QUOTED_PRINTABLE))
-	fn = &MimeQPDecoderInit;
+  {
+    enc->decoder_data =
+	  MimeQPDecoderInit (/* The (int (*) ...) cast is to turn the `void' argument
+		     into `MimeObject'. */
+		  ((nsresult (*) (const char *, PRInt32, void *))
+		   ((MimeEncryptedClass *)obj->clazz)->parse_decoded_buffer),
+		  obj);
+
+    if (!enc->decoder_data)
+	  return MIME_OUT_OF_MEMORY;
+  }
   else if (!nsCRT::strcasecmp(obj->encoding, ENCODING_UUENCODE) ||
 		   !nsCRT::strcasecmp(obj->encoding, ENCODING_UUENCODE2) ||
 		   !nsCRT::strcasecmp(obj->encoding, ENCODING_UUENCODE3) ||
diff -uprN --exclude=CVS mozilla/mailnews/mime/src/mimedrft.cpp mozilla.new/mailnews/mime/src/mimedrft.cpp
--- mozilla/mailnews/mime/src/mimedrft.cpp	2005-07-20 13:49:43.000000000 +0200
+++ mozilla.new/mailnews/mime/src/mimedrft.cpp	2006-02-14 10:01:39.000000000 +0100
@@ -1964,7 +1964,13 @@ mime_decompose_file_init_fn ( void *stre
     else if (!nsCRT::strcasecmp(newAttachment->encoding, ENCODING_BASE64))
       fn = &MimeB64DecoderInit;
     else if (!nsCRT::strcasecmp(newAttachment->encoding, ENCODING_QUOTED_PRINTABLE))
-      fn = &MimeQPDecoderInit;
+    {
+      mdd->decoder_data = MimeQPDecoderInit (/* The (nsresult (*) ...) cast is to turn the `void' argument into `MimeObject'. */
+                              ((nsresult (*) (const char *, PRInt32, void *))
+                              dummy_file_write), mdd->tmpFileStream);
+      if (!mdd->decoder_data)
+        return MIME_OUT_OF_MEMORY;
+    }
     else if (!nsCRT::strcasecmp(newAttachment->encoding, ENCODING_UUENCODE) ||
              !nsCRT::strcasecmp(newAttachment->encoding, ENCODING_UUENCODE2) ||
              !nsCRT::strcasecmp(newAttachment->encoding, ENCODING_UUENCODE3) ||
diff -uprN --exclude=CVS mozilla/mailnews/mime/src/mimeenc.cpp mozilla.new/mailnews/mime/src/mimeenc.cpp
--- mozilla/mailnews/mime/src/mimeenc.cpp	2004-05-14 10:14:44.000000000 +0200
+++ mozilla.new/mailnews/mime/src/mimeenc.cpp	2006-02-14 10:01:39.000000000 +0100
@@ -42,6 +42,7 @@
 #include "plstr.h"
 #include "prlog.h"
 #include "prprf.h"
+#include "mimeobj.h"
 
 typedef enum mime_encoding {
   mime_Base64, mime_QuotedPrintable, mime_uuencode, mime_yencode
@@ -63,6 +64,7 @@ struct MimeDecoderData {
   char *line_buffer;
   int line_buffer_size;
 
+  MimeObject *objectToDecode; // might be null, only used for QP currently
   /* Where to write the decoded data */
   nsresult (*write_buffer) (const char *buf, PRInt32 size, void *closure);
   void *closure;
@@ -176,7 +178,9 @@ mime_decode_qp_buffer (MimeDecoderData *
 			  continue;
 			}
 		  /* treat null bytes as spaces per bug 243199 comment 7 */
-		  *out++ = c ? (char) c : ' ';
+		  *out++ = c || (data->objectToDecode && 
+                      data->objectToDecode->options->format_out != nsMimeOutput::nsMimeMessageBodyDisplay)
+                    ? (char) c : ' ';
 		}
 	  else
 		{
@@ -797,9 +801,12 @@ MimeB64DecoderInit (nsresult (*output_fn
 
 MimeDecoderData *
 MimeQPDecoderInit (nsresult (*output_fn) (const char *, PRInt32, void *),
-				   void *closure)
+				   void *closure, MimeObject *object)
 {
-  return mime_decoder_init (mime_QuotedPrintable, output_fn, closure);
+  MimeDecoderData *retData = mime_decoder_init (mime_QuotedPrintable, output_fn, closure);
+  if (retData)
+    retData->objectToDecode = object;
+  return retData;
 }
 
 MimeDecoderData *
diff -uprN --exclude=CVS mozilla/mailnews/mime/src/mimeleaf.cpp mozilla.new/mailnews/mime/src/mimeleaf.cpp
--- mozilla/mailnews/mime/src/mimeleaf.cpp	2005-06-03 12:26:24.000000000 +0200
+++ mozilla.new/mailnews/mime/src/mimeleaf.cpp	2006-02-14 10:01:39.000000000 +0100
@@ -124,7 +124,10 @@ MimeLeaf_parse_begin (MimeObject *obj)
   else if (!nsCRT::strcasecmp(obj->encoding, ENCODING_BASE64))
 	fn = &MimeB64DecoderInit;
   else if (!nsCRT::strcasecmp(obj->encoding, ENCODING_QUOTED_PRINTABLE))
-	fn = &MimeQPDecoderInit;
+	leaf->decoder_data = 
+          MimeQPDecoderInit(((nsresult (*) (const char *, PRInt32, void *))
+                        ((MimeLeafClass *)obj->clazz)->parse_decoded_buffer),
+                        obj, obj);
   else if (!nsCRT::strcasecmp(obj->encoding, ENCODING_UUENCODE) ||
 		   !nsCRT::strcasecmp(obj->encoding, ENCODING_UUENCODE2) ||
 		   !nsCRT::strcasecmp(obj->encoding, ENCODING_UUENCODE3) ||
diff -uprN --exclude=CVS mozilla/mailnews/mime/src/mimemsig.cpp mozilla.new/mailnews/mime/src/mimemsig.cpp
--- mozilla/mailnews/mime/src/mimemsig.cpp	2004-04-17 20:33:13.000000000 +0200
+++ mozilla.new/mailnews/mime/src/mimemsig.cpp	2006-02-14 10:01:39.000000000 +0100
@@ -395,7 +395,15 @@ MimeMultipartSigned_parse_line (char *li
     else if (!nsCRT::strcasecmp(encoding.get(), ENCODING_BASE64))
       fn = &MimeB64DecoderInit;
     else if (!nsCRT::strcasecmp(encoding.get(), ENCODING_QUOTED_PRINTABLE))
-      fn = &MimeQPDecoderInit;
+    {
+      sig->sig_decoder_data =
+	MimeQPDecoderInit (((nsresult (*) (const char *, PRInt32, void *))
+		 (((MimeMultipartSignedClass *) obj->clazz)
+		      ->crypto_signature_hash)),
+		sig->crypto_closure);
+      if (!sig->sig_decoder_data)
+	return MIME_OUT_OF_MEMORY;
+    }
     else if (!nsCRT::strcasecmp(encoding.get(), ENCODING_UUENCODE) ||
              !nsCRT::strcasecmp(encoding.get(), ENCODING_UUENCODE2) ||
              !nsCRT::strcasecmp(encoding.get(), ENCODING_UUENCODE3) ||
diff -uprN --exclude=CVS mozilla/mailnews/mime/src/modmimee.h mozilla.new/mailnews/mime/src/modmimee.h
--- mozilla/mailnews/mime/src/modmimee.h	2004-04-17 20:33:13.000000000 +0200
+++ mozilla.new/mailnews/mime/src/modmimee.h	2006-02-14 10:01:39.000000000 +0100
@@ -56,17 +56,17 @@
 typedef struct MimeDecoderData MimeDecoderData;
 typedef struct MimeEncoderData MimeEncoderData;
 
+struct MimeObject;
+
 
 /* functions for creating that opaque data.
  */
-MimeDecoderData *MimeB64DecoderInit(nsresult (*output_fn) (const char *buf,
-													  PRInt32 size,
-													  void *closure),
-									void *closure);
-MimeDecoderData *MimeQPDecoderInit (nsresult (*output_fn) (const char *buf,
-													  PRInt32 size,
-													  void *closure),
+MimeDecoderData *MimeB64DecoderInit(nsresult (*output_fn) (const char *buf,PRInt32 size, void *closure),
 									void *closure);
+
+MimeDecoderData *MimeQPDecoderInit (nsresult (*output_fn) (const char *buf, PRInt32 size, void *closure),
+									void *closure, MimeObject *object = nsnull);
+
 MimeDecoderData *MimeUUDecoderInit (nsresult (*output_fn) (const char *buf,
 													  PRInt32 size,
 													  void *closure),
diff -uprN --exclude=CVS mozilla/mailnews/news/src/nsNntpService.cpp mozilla.new/mailnews/news/src/nsNntpService.cpp
--- mozilla/mailnews/news/src/nsNntpService.cpp	2005-07-20 13:49:44.000000000 +0200
+++ mozilla.new/mailnews/news/src/nsNntpService.cpp	2006-02-24 11:16:51.000000000 +0100
@@ -24,7 +24,7 @@
  *   Scott MacGregor <mscott@netscape.com>
  *   Pierre Phaneuf <pp@ludusdesign.com>
  *   Hkan Waara <hwaara@chello.se>
- *   David Bienvenu < bienvenu@nventure.com>
+ *   David Bienvenu <bienvenu@nventure.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
@@ -1416,11 +1416,12 @@ NS_IMETHODIMP nsNntpService::NewURI(cons
 
 NS_IMETHODIMP nsNntpService::NewChannel(nsIURI *aURI, nsIChannel **_retval)
 {
+  NS_ENSURE_ARG_POINTER(aURI);
   nsresult rv = NS_OK;
   nsCOMPtr <nsINNTPProtocol> nntpProtocol;
   rv = GetProtocolForUri(aURI, nsnull, getter_AddRefs(nntpProtocol));
   if (NS_SUCCEEDED(rv))
-	  rv = nntpProtocol->Initialize(aURI, nsnull);
+    rv = nntpProtocol->Initialize(aURI, nsnull);
   if (NS_FAILED(rv)) return rv;
 
   return CallQueryInterface(nntpProtocol, _retval);
diff -uprN --exclude=CVS mozilla/Makefile.in mozilla.new/Makefile.in
--- mozilla/Makefile.in	2006-01-09 06:48:35.000000000 +0100
+++ mozilla.new/Makefile.in	2006-02-24 11:16:26.000000000 +0100
@@ -430,6 +430,11 @@ tier_99_dirs += \
 	$(NULL)
 endif
 
+# This should be built last, after all IDL files in the tree have been processed
+ifdef MOZ_JAVAXPCOM
+tier_99_dirs += extensions/java/xpcom/interfaces
+endif
+
 else
 
 # Standalone build
diff -uprN --exclude=CVS mozilla/modules/libpr0n/decoders/gif/GIF2.cpp mozilla.new/modules/libpr0n/decoders/gif/GIF2.cpp
--- mozilla/modules/libpr0n/decoders/gif/GIF2.cpp	2005-03-10 14:31:26.000000000 +0100
+++ mozilla.new/modules/libpr0n/decoders/gif/GIF2.cpp	2006-03-04 21:31:06.000000000 +0100
@@ -408,7 +408,7 @@ PRBool GIFInit(gif_struct* gs, void* aCl
     return PR_FALSE;
 
   // Clear out the structure, excluding the arrays
-  memset(gs, 0, offsetof(gif_struct, prefix));
+  memset(gs, 0, sizeof(gif_struct));
   gs->clientptr = aClientData;
 
   gs->state = gif_init;
diff -uprN --exclude=CVS mozilla/modules/libpr0n/decoders/icon/nsIconProtocolHandler.cpp mozilla.new/modules/libpr0n/decoders/icon/nsIconProtocolHandler.cpp
--- mozilla/modules/libpr0n/decoders/icon/nsIconProtocolHandler.cpp	2005-03-24 19:17:15.000000000 +0100
+++ mozilla.new/modules/libpr0n/decoders/icon/nsIconProtocolHandler.cpp	2006-02-24 11:15:49.000000000 +0100
@@ -106,6 +106,7 @@ NS_IMETHODIMP nsIconProtocolHandler::New
 
 NS_IMETHODIMP nsIconProtocolHandler::NewChannel(nsIURI* url, nsIChannel* *result)
 {
+  NS_ENSURE_ARG_POINTER(url);
   nsIconChannel* channel = new nsIconChannel;
   if (!channel)
     return NS_ERROR_OUT_OF_MEMORY;
diff -uprN --exclude=CVS mozilla/modules/libpr0n/decoders/icon/nsIconURI.cpp mozilla.new/modules/libpr0n/decoders/icon/nsIconURI.cpp
--- mozilla/modules/libpr0n/decoders/icon/nsIconURI.cpp	2005-02-05 00:22:57.000000000 +0100
+++ mozilla.new/modules/libpr0n/decoders/icon/nsIconURI.cpp	2006-03-03 07:11:15.000000000 +0100
@@ -434,13 +434,13 @@ nsMozIconURI::SchemeIs(const char *i_Sch
 NS_IMETHODIMP
 nsMozIconURI::Clone(nsIURI **result)
 {
-  return NS_OK;
+  return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP
 nsMozIconURI::Resolve(const nsACString &relativePath, nsACString &result)
 {
-  return NS_OK;
+  return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP
diff -uprN --exclude=CVS mozilla/modules/libpref/src/init/all.js mozilla.new/modules/libpref/src/init/all.js
--- mozilla/modules/libpref/src/init/all.js	2006-01-11 23:04:49.000000000 +0100
+++ mozilla.new/modules/libpref/src/init/all.js	2006-02-14 10:01:22.000000000 +0100
@@ -270,19 +270,30 @@ pref("capability.policy.default.Navigato
 
 pref("capability.policy.default.Window.blur.get", "allAccess");
 pref("capability.policy.default.Window.close.get", "allAccess");
-pref("capability.policy.default.Window.closed", "allAccess");
+pref("capability.policy.default.Window.closed.get", "allAccess");
 pref("capability.policy.default.Window.Components", "allAccess");
-pref("capability.policy.default.Window.document", "allAccess");
+pref("capability.policy.default.Window.document.get", "allAccess");
 pref("capability.policy.default.Window.focus.get", "allAccess");
-pref("capability.policy.default.Window.frames", "allAccess");
-pref("capability.policy.default.Window.history", "allAccess");
-pref("capability.policy.default.Window.length", "allAccess");
+pref("capability.policy.default.Window.frames.get", "allAccess");
+pref("capability.policy.default.Window.history.get", "allAccess");
+pref("capability.policy.default.Window.length.get", "allAccess");
 pref("capability.policy.default.Window.location", "allAccess");
-pref("capability.policy.default.Window.opener", "allAccess");
-pref("capability.policy.default.Window.parent", "allAccess");
-pref("capability.policy.default.Window.self", "allAccess");
-pref("capability.policy.default.Window.top", "allAccess");
-pref("capability.policy.default.Window.window", "allAccess");
+pref("capability.policy.default.Window.opener.get", "allAccess");
+pref("capability.policy.default.Window.parent.get", "allAccess");
+pref("capability.policy.default.Window.self.get", "allAccess");
+pref("capability.policy.default.Window.top.get", "allAccess");
+pref("capability.policy.default.Window.window.get", "allAccess");
+
+pref("capability.policy.default.XULControllers.commandDispatcher", "noAccess");
+pref("capability.policy.default.XULControllers.getControllerForCommand", "noAccess");
+pref("capability.policy.default.XULControllers.insertControllerAt", "noAccess");
+pref("capability.policy.default.XULControllers.removeControllerAt", "noAccess");
+pref("capability.policy.default.XULControllers.getControllerAt", "noAccess");
+pref("capability.policy.default.XULControllers.appendController", "noAccess");
+pref("capability.policy.default.XULControllers.removeController", "noAccess");
+pref("capability.policy.default.XULControllers.getControllerId", "noAccess");
+pref("capability.policy.default.XULControllers.getControllerById", "noAccess");
+pref("capability.policy.default.XULControllers.getControllerCount", "noAccess");
 
 // Restrictions on the DOM for mail/news - see bugs 66938 and 84545
 pref("capability.policy.mailnews.sites", "mailbox: imap: news:");
diff -uprN --exclude=CVS mozilla/modules/plugin/base/src/ns4xPlugin.cpp mozilla.new/modules/plugin/base/src/ns4xPlugin.cpp
--- mozilla/modules/plugin/base/src/ns4xPlugin.cpp	2006-01-09 06:48:47.000000000 +0100
+++ mozilla.new/modules/plugin/base/src/ns4xPlugin.cpp	2006-02-24 11:16:36.000000000 +0100
@@ -195,7 +195,28 @@ PR_BEGIN_EXTERN_C
 
 PR_END_EXTERN_C
 
-#if defined(XP_MACOSX) && defined(__POWERPC__)
+#if defined(XP_MACOSX) && defined(__i386__)
+
+// BROKEN_PLUGIN_HACK works around bugs in the version of the Macromedia
+// Flash Player plugin that is supplied with the initial consumer shipment
+// of Mac OS X for x86-based Macs.  The plugin is broken in at least
+// 10.4.4/x86 and 10.4.5/x86.
+#define BROKEN_PLUGIN_HACK
+
+// brokenPlugin is defined in the scope in which TV2FP is used.  It is
+// true when this ns4xPlugin object has loaded a plugin that contains the
+// bugs being worked around.
+//
+// The broken plugin returns entry points that are pointers to function
+// pointers, instead of just returning the function pointers.  These must
+// be dereferenced, or Mozilla will crash upon attempting to call an address
+// that doesn't contain code.  TV2FP is a convenient place to handle this,
+// since the macro is already present everywhere it's needed, and is otherwise
+// unused on x86.
+#define TV2FP(f) (brokenPlugin && f ? *(void**)f : (void*)f)
+#define FP2TV(f) (f)
+
+#elif defined(XP_MACOSX) && defined(__POWERPC__)
 
 #define TV2FP(tvp) _TV2FP((void *)tvp)
 
@@ -424,6 +445,56 @@ ns4xPlugin::ns4xPlugin(NPPluginFuncs* ca
 
   fShutdownEntry = (NP_PLUGINSHUTDOWN)PR_FindSymbol(aLibrary, "NP_Shutdown");
 #elif defined(XP_MACOSX)
+#ifdef BROKEN_PLUGIN_HACK
+#warning BROKEN_PLUGIN_HACK is in use, enjoy your Flash movies!
+  // This is a private NSPR struct.  Define it here because it's necessary
+  // to restrict the hack to plugins that need it, and the only way to do
+  // that is to examine the bundle that was loaded.  I feel comfortable doing
+  // this because BROKEN_PLUGIN_HACK is a hack anyway, and it's not intended
+  // to be long-lived.
+  struct myPRLibrary {
+    char*                     name;
+    PRLibrary*                next;
+    int                       refCount;
+    const PRStaticLinkTable*  staticTable;
+    CFragConnectionID         connection;
+    CFBundleRef               bundle;
+    Ptr                       main;
+    CFMutableDictionaryRef    wrappers;
+    const struct mach_header* image;
+  };
+
+  // brokenPlugin indicates whether the plugin needs to be worked around
+  // because it doesn't adhere to the API used on x86.
+  PRBool brokenPlugin = PR_FALSE;
+
+  // Identify the broken plugin by a variety of attributes.
+  // Further inspection will be done before applying any workarounds.
+  struct myPRLibrary *prLibrary = (struct myPRLibrary*) aLibrary;
+
+  if (prLibrary->name && prLibrary->bundle) {
+    CFStringRef bundleIdentifier = ::CFBundleGetIdentifier(prLibrary->bundle);
+    CFStringRef bundleShortVersion =
+      (CFStringRef) ::CFBundleGetValueForInfoDictionaryKey(prLibrary->bundle,
+                      CFSTR("CFBundleShortVersionString"));
+
+    if (!strcmp(prLibrary->name,
+                "/Library/Internet Plug-Ins/Flash Player.plugin") &&
+        ::CFBundleGetVersionNumber(prLibrary->bundle) == 0x1018011 &&
+        bundleIdentifier &&
+        ::CFStringCompare(bundleIdentifier,
+                          CFSTR("com.macromedia.Flash Player.plugin"),
+                          0) == kCFCompareEqualTo &&
+        bundleShortVersion &&
+        ::CFStringCompare(bundleShortVersion,
+                          CFSTR("8.0.17"),
+                          0) == kCFCompareEqualTo) {
+      // Macromedia Flash Player plugin, version 8.0.17, bundle version 1.0.1f17
+      brokenPlugin = PR_TRUE;
+    }
+  }
+#endif /* BROKEN_PLUGIN_HACK */
+
   // call into the entry point
   NP_MAIN pfnMain = (NP_MAIN) PR_FindSymbol(aLibrary, "main");
 
@@ -443,6 +514,92 @@ ns4xPlugin::ns4xPlugin(NPPluginFuncs* ca
                                                 &pfnShutdown),
                           aLibrary, nsnull);
 
+#ifdef BROKEN_PLUGIN_HACK
+  // The broken plugin has wrapped NPN callback function pointers in PPC
+  // TVector glue as though they were pointers to CFM TVectors.  When the
+  // x86 attempts to execute the PPC glue, it will of course fail.
+  //
+  // What's done here is a bit unorthodox.  I'm going to locate the
+  // TVector glue that the plugin created from ns4xPlugin::CALLBACKS by
+  // peeking into its symbol table, then I'm going to dissect the PPC
+  // machine code to get the target addresses and produce x86 machine code.
+  // The x86 code overwrites the PPC code in the plugin's jump table.
+  // The replacement code is of course executable.  I know I can do this,
+  // because the broken plugin builds its table of TVector glue based on
+  // what the sample NPAPI plugin does.
+  //
+  // Watch this.
+  if (brokenPlugin) {
+    PRUint32 glueFixed = 0;
+
+    // Locate the table that the plugin filled with TVector glue.
+    PRUint8* pluginsGlueTable = (PRUint8*)
+      ::CFBundleGetDataPointerForName(prLibrary->bundle,
+                                      CFSTR("gNetscapeFuncsGlueTable"));
+
+    if (pluginsGlueTable) {
+      // The table contains 40 entries.  Each entry is TVector glue of 6
+      // 4-byte words (24 bytes total).  See gPluginFuncsGlueTable in
+      // mozilla/modules/plugin/samples/default/mac/npmac.cpp .  That table
+      // accomodates 23 entries, inspection in the debugger teaches that the
+      // broken plugin's table is 40 entries long.
+      for (PRUint32 i = 0 ; i < 40 ; i++) {
+        PRUint32* gluePPC = (PRUint32*) (pluginsGlueTable + 24 * i);
+
+        // Only translate entries that are actually stored as TVector glue.
+        // There are other ways to write the glue for PPC, but this is the
+        // de facto standard, and it's what the broken plugin uses.  The
+        // PPC code means:
+        //   lis   r12,        hi16(address) ; pointer to tvector embedded
+        //   ori   r12,   r12, lo16(address) ;   as immediate params in glue
+        //   lwz    r0, 0(r12)               ; get pc from tvector
+        //   lwz    r2, 4(r12)               ; get rtoc from tvector
+        //   mtctr  r0
+        //   bctr                            ; jump to new pc
+        if ( (*gluePPC    & 0xffff0000) == 0x3d800000 &&
+            (*(gluePPC+1) & 0xffff0000) == 0x618c0000 &&
+             *(gluePPC+2)               == 0x800c0000 &&
+             *(gluePPC+3)               == 0x804c0004 &&
+             *(gluePPC+4)               == 0x7c0903a6 &&
+             *(gluePPC+5)               == 0x4e800420) {
+          // Determine the actual address of the function by stripping the
+          // TVector glue.  |address| is a usable function pointer.  Making
+          // it a pointer to an 8-bit quantity keeps the math below simple.
+          PRUint8* address = (PRUint8*) ((*gluePPC) << 16 |
+                                         *(gluePPC+1) & 0xffff);
+
+          // Build an x86 JMP instruction to jump to the desired function,
+          // and replace the TVector glue with it.  Opcode 0xe9 is a
+          // jump relative to the next instruction.  Total instruction length
+          // is 5 bytes (in 32-bit operand-size mode).  If base is address
+          // 0xfece5 and the target function is at address 0xc0ffee, then
+          // the instruction placed at base, byte for byte, should be:
+          //   0xfece5: 0xe9 0x04 0x13 0xb1 0x00: jmp 0xc0ffee
+          PRUint8* glueX86 = (PRUint8*) gluePPC;
+          *glueX86 = 0xe9;
+
+          PRInt32* offset = (PRInt32*) (glueX86+1);
+          *offset = (address - (glueX86 + 5));
+
+          // PPC TVector glue is big compared to the x86 JMP.  Clean up the
+          // rest of the space in the table entry.  Opcode 0x90 is NOP,
+          // instruction length 1 byte.  This permits clean disassembly of
+          // the entire memory region corresponding to the table.
+          memset(glueX86+5, 0x90, 19);
+
+          glueFixed++;
+        }
+      }
+    }
+
+    if (!glueFixed) {
+      // This plugin wasn't broken after all.  Avoid applying the callback
+      // dereferencing workarounds (TV2FP).
+      brokenPlugin = PR_FALSE;
+    }
+  }
+#endif /* BROKEN_PLUGIN_HACK */
+
   NPP_PLUGIN_LOG(PLUGIN_LOG_BASIC,
                  ("NPP MainEntryProc called: return=%d\n",error));
 
diff -uprN --exclude=CVS mozilla/modules/plugin/samples/default/mac/DefaultPlugin.pbproj/project.pbxproj mozilla.new/modules/plugin/samples/default/mac/DefaultPlugin.pbproj/project.pbxproj
--- mozilla/modules/plugin/samples/default/mac/DefaultPlugin.pbproj/project.pbxproj	2003-04-05 00:47:00.000000000 +0200
+++ mozilla.new/modules/plugin/samples/default/mac/DefaultPlugin.pbproj/project.pbxproj	2006-02-24 11:16:36.000000000 +0100
@@ -349,7 +349,7 @@
 		};
 		F5E0C34D036A12DF01A96660 = {
 			isa = PBXFileReference;
-			path = _NullPlugin.rsrc;
+			path = NullPlugin.rsrc;
 			refType = 2;
 		};
 		F5E0C34E036A12DF01A96660 = {
diff -uprN --exclude=CVS mozilla/modules/plugin/samples/default/mac/DefaultPlugin.xcode/project.pbxproj mozilla.new/modules/plugin/samples/default/mac/DefaultPlugin.xcode/project.pbxproj
--- mozilla/modules/plugin/samples/default/mac/DefaultPlugin.xcode/project.pbxproj	2005-06-01 20:53:30.000000000 +0200
+++ mozilla.new/modules/plugin/samples/default/mac/DefaultPlugin.xcode/project.pbxproj	2006-02-24 11:16:36.000000000 +0100
@@ -343,7 +343,7 @@
 		F5E0C34D036A12DF01A96660 = {
 			isa = PBXFileReference;
 			lastKnownFileType = file;
-			path = _NullPlugin.rsrc;
+			path = NullPlugin.rsrc;
 			refType = 2;
 			sourceTree = SOURCE_ROOT;
 		};
diff -uprN --exclude=CVS mozilla/modules/plugin/samples/default/mac/Makefile.in mozilla.new/modules/plugin/samples/default/mac/Makefile.in
--- mozilla/modules/plugin/samples/default/mac/Makefile.in	2005-06-20 21:24:51.000000000 +0200
+++ mozilla.new/modules/plugin/samples/default/mac/Makefile.in	2006-02-24 11:16:36.000000000 +0100
@@ -76,10 +76,6 @@ PACKAGE_FILE = npnul.pkg
 
 unexport CC CXX
 
-# decodes resource files from AppleSingle to Resource Manager format.
-ASDECODE = $(DIST)/bin/asdecode
-RESOURCE_FILES = _NullPlugin.rsrc
-
 # for objdir builds, copy the project, and symlink the sources
 ABS_topsrcdir   := $(shell cd $(topsrcdir); pwd)
 ifneq ($(ABS_topsrcdir),$(MOZ_BUILD_ROOT))
@@ -90,6 +86,7 @@ export::
 	ln -fs $(srcdir)/NullPlugin.cpp
 	ln -fs $(srcdir)/npmac.cpp
 	ln -fs $(srcdir)/Info-*.plist .
+	ln -fs $(srcdir)/NullPlugin.rsrc
 endif
 
 libs install:: install-plugin
@@ -97,15 +94,9 @@ libs install:: install-plugin
 install-plugin: build-plugin
 	$(INSTALL) "$(XCODE_PRODUCT_DIR)/Default Plugin.plugin" $(DIST)/bin/plugins
 
-resources: $(RESOURCE_FILES)
-
-build-plugin: resources
+build-plugin:
 	$(PBBUILD) $(PROJECT_ARG) -target $(TARGET) -buildstyle $(BUILDSTYLE) $(PBBUILD_ARG)
 	echo -n NSPLMOSS > "$(XCODE_PRODUCT_DIR)/Default Plugin.plugin/Contents/PkgInfo"
 
-_%.rsrc: %.rsrc
-	$(ASDECODE) $< $@
-
 clean clobber distclean::
-	rm -f $(RESOURCE_FILES)
 	rm -rf build
Dateien mozilla/modules/plugin/samples/default/mac/NullPlugin.rsrc und mozilla.new/modules/plugin/samples/default/mac/NullPlugin.rsrc sind verschieden.
diff -uprN --exclude=CVS mozilla/netwerk/base/src/nsStandardURL.cpp mozilla.new/netwerk/base/src/nsStandardURL.cpp
--- mozilla/netwerk/base/src/nsStandardURL.cpp	2005-10-17 22:12:58.000000000 +0200
+++ mozilla.new/netwerk/base/src/nsStandardURL.cpp	2006-02-24 11:16:36.000000000 +0100
@@ -864,10 +864,24 @@ nsStandardURL::ACEtoDisplayIDN(const nsC
 /* static */ nsresult
 nsStandardURL::UTF8toDisplayIDN(const nsCSubstring &host, nsCString &result)
 {
-    if (gShowPunycode || !IsInWhitelist(host))
+    // We have to normalize the hostname before testing against the domain
+    // whitelist.  See bug 315411.
+
+    nsCAutoString temp;
+    if (gShowPunycode || NS_FAILED(gIDN->Normalize(host, temp)))
         return gIDN->ConvertUTF8toACE(host, result);
 
-    return gIDN->Normalize(host, result);
+    PRBool isACE = PR_FALSE;
+    gIDN->IsACE(temp, &isACE);
+
+    // If host is converted to ACE by the normalizer, then the host may contain
+    // unsafe characters.  See bug 283016, bug 301694, and bug 309311.
+ 
+    if (!isACE && !IsInWhitelist(temp))
+        return gIDN->ConvertUTF8toACE(temp, result);
+
+    result = temp;
+    return NS_OK;
 }
 
 /* static */ PRBool
@@ -876,6 +890,8 @@ nsStandardURL::IsInWhitelist(const nsCSu
     PRInt32 pos; 
     PRBool safe;
 
+    // XXX This code uses strings inefficiently.
+
     if (gIDNWhitelistPrefBranch && 
         (pos = nsCAutoString(host).RFind(".")) != kNotFound &&
         NS_SUCCEEDED(gIDNWhitelistPrefBranch->
@@ -2423,7 +2439,6 @@ nsStandardURL::GetFile(nsIFile **result)
     if (NS_FAILED(rv))
         return rv;
 
-
 #if defined(PR_LOGGING)
     if (LOG_ENABLED()) {
         nsCAutoString path;
diff -uprN --exclude=CVS mozilla/netwerk/cache/src/nsDiskCacheMap.h mozilla.new/netwerk/cache/src/nsDiskCacheMap.h
--- mozilla/netwerk/cache/src/nsDiskCacheMap.h	2005-06-29 22:47:45.000000000 +0200
+++ mozilla.new/netwerk/cache/src/nsDiskCacheMap.h	2006-02-24 11:16:36.000000000 +0100
@@ -358,6 +358,14 @@ struct nsDiskCacheHeader {
         mEntryCount  = ::PR_htonl(mEntryCount);
         mIsDirty     = ::PR_htonl(mIsDirty);
         mRecordCount = ::PR_htonl(mRecordCount);
+
+#ifdef XP_MACOSX
+        // Mac-only on the 1.8.0 branch, see bug 325765
+        for (PRUint32 i = 0; i < kBuckets ; i++) {
+            mEvictionRank[i] = ::PR_htonl(mEvictionRank[i]);
+            mBucketUsage[i]  = ::PR_htonl(mBucketUsage[i]);
+        }
+#endif
 #endif
     }
     
@@ -369,6 +377,14 @@ struct nsDiskCacheHeader {
         mEntryCount  = ::PR_ntohl(mEntryCount);
         mIsDirty     = ::PR_ntohl(mIsDirty);
         mRecordCount = ::PR_ntohl(mRecordCount);
+
+#ifdef XP_MACOSX
+        // Mac-only on the 1.8.0 branch, see bug 325765
+        for (PRUint32 i = 0; i < kBuckets ; i++) {
+            mEvictionRank[i] = ::PR_ntohl(mEvictionRank[i]);
+            mBucketUsage[i]  = ::PR_ntohl(mBucketUsage[i]);
+        }
+#endif
 #endif
     }
 };
diff -uprN --exclude=CVS mozilla/netwerk/cookie/public/nsICookieManager2.idl mozilla.new/netwerk/cookie/public/nsICookieManager2.idl
--- mozilla/netwerk/cookie/public/nsICookieManager2.idl	2003-10-30 03:50:11.000000000 +0100
+++ mozilla.new/netwerk/cookie/public/nsICookieManager2.idl	2006-02-24 11:16:36.000000000 +0100
@@ -68,7 +68,6 @@ interface nsICookieManager2 : nsICookieM
    *        expiration date, in seconds since the epoch. only relevant if
    *        aIsSession is false.
    */
-  [noscript]
   void add(in AUTF8String aDomain,
            in AUTF8String aPath,
            in ACString    aName,
diff -uprN --exclude=CVS mozilla/netwerk/protocol/about/src/nsAboutBlank.cpp mozilla.new/netwerk/protocol/about/src/nsAboutBlank.cpp
--- mozilla/netwerk/protocol/about/src/nsAboutBlank.cpp	2005-09-01 21:34:24.000000000 +0200
+++ mozilla.new/netwerk/protocol/about/src/nsAboutBlank.cpp	2006-02-24 11:16:36.000000000 +0100
@@ -49,6 +49,7 @@ static const char kBlankPage[] = "<!DOCT
 NS_IMETHODIMP
 nsAboutBlank::NewChannel(nsIURI *aURI, nsIChannel **result)
 {
+    NS_ENSURE_ARG_POINTER(aURI);
     nsresult rv;
     nsIChannel* channel;
 
diff -uprN --exclude=CVS mozilla/netwerk/protocol/about/src/nsAboutBloat.cpp mozilla.new/netwerk/protocol/about/src/nsAboutBloat.cpp
--- mozilla/netwerk/protocol/about/src/nsAboutBloat.cpp	2005-09-01 21:34:24.000000000 +0200
+++ mozilla.new/netwerk/protocol/about/src/nsAboutBloat.cpp	2006-02-24 11:16:36.000000000 +0100
@@ -60,6 +60,7 @@ NS_IMPL_ISUPPORTS1(nsAboutBloat, nsIAbou
 NS_IMETHODIMP
 nsAboutBloat::NewChannel(nsIURI *aURI, nsIChannel **result)
 {
+    NS_ENSURE_ARG_POINTER(aURI);
     nsresult rv;
     nsCAutoString path;
     rv = aURI->GetPath(path);
diff -uprN --exclude=CVS mozilla/netwerk/protocol/about/src/nsAboutCache.cpp mozilla.new/netwerk/protocol/about/src/nsAboutCache.cpp
--- mozilla/netwerk/protocol/about/src/nsAboutCache.cpp	2005-09-01 21:34:25.000000000 +0200
+++ mozilla.new/netwerk/protocol/about/src/nsAboutCache.cpp	2006-02-24 11:16:36.000000000 +0100
@@ -75,6 +75,7 @@ NS_IMPL_ISUPPORTS2(nsAboutCache, nsIAbou
 NS_IMETHODIMP
 nsAboutCache::NewChannel(nsIURI *aURI, nsIChannel **result)
 {
+    NS_ENSURE_ARG_POINTER(aURI);
     nsresult rv;
     PRUint32 bytesWritten;
 
diff -uprN --exclude=CVS mozilla/netwerk/protocol/about/src/nsAboutCacheEntry.cpp mozilla.new/netwerk/protocol/about/src/nsAboutCacheEntry.cpp
--- mozilla/netwerk/protocol/about/src/nsAboutCacheEntry.cpp	2005-09-01 21:34:25.000000000 +0200
+++ mozilla.new/netwerk/protocol/about/src/nsAboutCacheEntry.cpp	2006-02-24 11:16:36.000000000 +0100
@@ -64,6 +64,7 @@ NS_IMPL_ISUPPORTS4(nsAboutCacheEntry,
 NS_IMETHODIMP
 nsAboutCacheEntry::NewChannel(nsIURI *aURI, nsIChannel **result)
 {
+    NS_ENSURE_ARG_POINTER(aURI);
     nsresult rv;
 
     nsCOMPtr<nsIChannel> chan;
diff -uprN --exclude=CVS mozilla/netwerk/protocol/about/src/nsAboutProtocolHandler.cpp mozilla.new/netwerk/protocol/about/src/nsAboutProtocolHandler.cpp
--- mozilla/netwerk/protocol/about/src/nsAboutProtocolHandler.cpp	2005-09-14 06:18:36.000000000 +0200
+++ mozilla.new/netwerk/protocol/about/src/nsAboutProtocolHandler.cpp	2006-02-24 11:16:36.000000000 +0100
@@ -135,6 +135,7 @@ nsAboutProtocolHandler::NewURI(const nsA
 NS_IMETHODIMP
 nsAboutProtocolHandler::NewChannel(nsIURI* uri, nsIChannel* *result)
 {
+    NS_ENSURE_ARG_POINTER(uri);
     // about:what you ask?
     nsresult rv;
     nsCAutoString contractID;
diff -uprN --exclude=CVS mozilla/netwerk/protocol/about/src/nsAboutRedirector.cpp mozilla.new/netwerk/protocol/about/src/nsAboutRedirector.cpp
--- mozilla/netwerk/protocol/about/src/nsAboutRedirector.cpp	2005-09-14 06:18:36.000000000 +0200
+++ mozilla.new/netwerk/protocol/about/src/nsAboutRedirector.cpp	2006-02-24 11:16:36.000000000 +0100
@@ -76,7 +76,7 @@ static const int kRedirTotal = NS_ARRAY_
 NS_IMETHODIMP
 nsAboutRedirector::NewChannel(nsIURI *aURI, nsIChannel **result)
 {
-    NS_ASSERTION(aURI, "must not be null");
+    NS_ENSURE_ARG_POINTER(aURI);
     NS_ASSERTION(result, "must not be null");
 
     nsresult rv;
diff -uprN --exclude=CVS mozilla/netwerk/protocol/data/src/nsDataChannel.cpp mozilla.new/netwerk/protocol/data/src/nsDataChannel.cpp
--- mozilla/netwerk/protocol/data/src/nsDataChannel.cpp	2005-08-13 21:34:01.000000000 +0200
+++ mozilla.new/netwerk/protocol/data/src/nsDataChannel.cpp	2006-02-24 11:16:36.000000000 +0100
@@ -180,8 +180,8 @@ nsDataChannel::ParseData() {
     if (lBase64) {
         *base64 = ';';
         PRInt32 resultLen = 0;
-        if (dataBuffer[dataLen-1] == '=') {
-            if (dataBuffer[dataLen-2] == '=')
+        if (dataLen >= 1 && dataBuffer[dataLen-1] == '=') {
+            if (dataLen >= 2 && dataBuffer[dataLen-2] == '=')
                 resultLen = dataLen-2;
             else
                 resultLen = dataLen-1;
diff -uprN --exclude=CVS mozilla/netwerk/protocol/data/src/nsDataHandler.cpp mozilla.new/netwerk/protocol/data/src/nsDataHandler.cpp
--- mozilla/netwerk/protocol/data/src/nsDataHandler.cpp	2004-12-04 11:19:27.000000000 +0100
+++ mozilla.new/netwerk/protocol/data/src/nsDataHandler.cpp	2006-02-24 11:16:36.000000000 +0100
@@ -117,6 +117,7 @@ nsDataHandler::NewURI(const nsACString &
 NS_IMETHODIMP
 nsDataHandler::NewChannel(nsIURI* url, nsIChannel* *result)
 {
+    NS_ENSURE_ARG_POINTER(url);
     nsresult rv;
     
     nsDataChannel* channel;
diff -uprN --exclude=CVS mozilla/netwerk/protocol/ftp/src/nsFtpProtocolHandler.cpp mozilla.new/netwerk/protocol/ftp/src/nsFtpProtocolHandler.cpp
--- mozilla/netwerk/protocol/ftp/src/nsFtpProtocolHandler.cpp	2005-02-25 21:46:29.000000000 +0100
+++ mozilla.new/netwerk/protocol/ftp/src/nsFtpProtocolHandler.cpp	2006-02-24 11:16:36.000000000 +0100
@@ -213,6 +213,7 @@ nsFtpProtocolHandler::NewChannel(nsIURI*
 NS_IMETHODIMP
 nsFtpProtocolHandler::NewProxiedChannel(nsIURI* url, nsIProxyInfo* proxyInfo, nsIChannel* *result)
 {
+    NS_ENSURE_ARG_POINTER(url);
     nsFTPChannel *channel = new nsFTPChannel();
     if (!channel)
         return NS_ERROR_OUT_OF_MEMORY;
diff -uprN --exclude=CVS mozilla/netwerk/protocol/gopher/src/nsGopherHandler.cpp mozilla.new/netwerk/protocol/gopher/src/nsGopherHandler.cpp
--- mozilla/netwerk/protocol/gopher/src/nsGopherHandler.cpp	2004-12-04 11:19:27.000000000 +0100
+++ mozilla.new/netwerk/protocol/gopher/src/nsGopherHandler.cpp	2006-02-24 11:16:36.000000000 +0100
@@ -131,6 +131,7 @@ NS_IMETHODIMP
 nsGopherHandler::NewProxiedChannel(nsIURI* url, nsIProxyInfo* proxyInfo,
                                    nsIChannel* *result)
 {
+    NS_ENSURE_ARG_POINTER(url);
     nsGopherChannel *chan = new nsGopherChannel();
     if (!chan)
         return NS_ERROR_OUT_OF_MEMORY;
diff -uprN --exclude=CVS mozilla/netwerk/protocol/http/src/nsHttpChannel.cpp mozilla.new/netwerk/protocol/http/src/nsHttpChannel.cpp
--- mozilla/netwerk/protocol/http/src/nsHttpChannel.cpp	2005-10-22 20:23:59.000000000 +0200
+++ mozilla.new/netwerk/protocol/http/src/nsHttpChannel.cpp	2006-02-24 11:16:36.000000000 +0100
@@ -2765,8 +2765,20 @@ nsHttpChannel::PromptForIdentity(const c
     {
         NS_NAMED_LITERAL_STRING(proxyText, "EnterUserPasswordForProxy");
         NS_NAMED_LITERAL_STRING(originText, "EnterUserPasswordForRealm");
-        const PRUnichar *text = proxyAuth ? proxyText.get() : originText.get();
- 
+
+        const PRUnichar *text;
+        if (proxyAuth) {
+            text = proxyText.get();
+        } else {
+            text = originText.get();
+
+            // prepend "scheme://"
+            nsAutoString schemeU; 
+            CopyASCIItoUTF16(scheme, schemeU);
+            schemeU.AppendLiteral("://");
+            displayHost.Insert(schemeU, 0);
+        }
+
         const PRUnichar *strings[] = { realmU.get(), displayHost.get() };
 
         rv = bundle->FormatStringFromName(text, strings, 2,
diff -uprN --exclude=CVS mozilla/netwerk/protocol/http/src/nsHttpTransaction.cpp mozilla.new/netwerk/protocol/http/src/nsHttpTransaction.cpp
--- mozilla/netwerk/protocol/http/src/nsHttpTransaction.cpp	2005-10-22 03:03:14.000000000 +0200
+++ mozilla.new/netwerk/protocol/http/src/nsHttpTransaction.cpp	2006-02-24 11:16:36.000000000 +0100
@@ -44,8 +44,10 @@
 #include "nsHttpRequestHead.h"
 #include "nsHttpResponseHead.h"
 #include "nsHttpChunkedDecoder.h"
+#include "nsNetSegmentUtils.h"
 #include "nsTransportUtils.h"
 #include "nsIOService.h"
+#include "nsNetUtil.h"
 #include "nsAutoLock.h"
 #include "pratom.h"
 #include "plevent.h"
@@ -236,7 +238,12 @@ nsHttpTransaction::Init(PRUint8 caps,
         rv = multi->AppendStream(requestBody);
         if (NS_FAILED(rv)) return rv;
 
-        mRequestStream = multi;
+        // wrap the multiplexed input stream with a buffered input stream, so
+        // that we write data in the largest chunks possible.  this is actually
+        // necessary to workaround some common server bugs (see bug 137155).
+        rv = NS_NewBufferedInputStream(getter_AddRefs(mRequestStream), multi,
+                                       NET_DEFAULT_SEGMENT_SIZE);
+        if (NS_FAILED(rv)) return rv;
     }
     else
         mRequestStream = headers;
diff -uprN --exclude=CVS mozilla/netwerk/protocol/keyword/src/nsKeywordProtocolHandler.cpp mozilla.new/netwerk/protocol/keyword/src/nsKeywordProtocolHandler.cpp
--- mozilla/netwerk/protocol/keyword/src/nsKeywordProtocolHandler.cpp	2004-12-04 11:19:28.000000000 +0100
+++ mozilla.new/netwerk/protocol/keyword/src/nsKeywordProtocolHandler.cpp	2006-02-24 11:16:36.000000000 +0100
@@ -164,6 +164,7 @@ nsKeywordProtocolHandler::NewURI(const n
 NS_IMETHODIMP
 nsKeywordProtocolHandler::NewChannel(nsIURI* uri, nsIChannel* *result)
 {
+    NS_ENSURE_ARG_POINTER(uri);
     nsresult rv;
     nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);
     if (NS_FAILED(rv)) return rv;
diff -uprN --exclude=CVS mozilla/netwerk/protocol/res/src/nsResProtocolHandler.cpp mozilla.new/netwerk/protocol/res/src/nsResProtocolHandler.cpp
--- mozilla/netwerk/protocol/res/src/nsResProtocolHandler.cpp	2004-12-04 11:19:28.000000000 +0100
+++ mozilla.new/netwerk/protocol/res/src/nsResProtocolHandler.cpp	2006-02-24 11:16:36.000000000 +0100
@@ -236,6 +236,7 @@ nsResProtocolHandler::NewURI(const nsACS
 NS_IMETHODIMP
 nsResProtocolHandler::NewChannel(nsIURI* uri, nsIChannel* *result)
 {
+    NS_ENSURE_ARG_POINTER(uri);
     nsresult rv;
     nsCAutoString spec;
 
diff -uprN --exclude=CVS mozilla/netwerk/protocol/viewsource/src/nsViewSourceHandler.cpp mozilla.new/netwerk/protocol/viewsource/src/nsViewSourceHandler.cpp
--- mozilla/netwerk/protocol/viewsource/src/nsViewSourceHandler.cpp	2004-07-02 01:45:34.000000000 +0200
+++ mozilla.new/netwerk/protocol/viewsource/src/nsViewSourceHandler.cpp	2006-02-24 11:16:36.000000000 +0100
@@ -115,6 +115,7 @@ nsViewSourceHandler::NewURI(const nsACSt
 NS_IMETHODIMP
 nsViewSourceHandler::NewChannel(nsIURI* uri, nsIChannel* *result)
 {
+    NS_ENSURE_ARG_POINTER(uri);
     nsViewSourceChannel *channel = new nsViewSourceChannel();
     if (!channel)
         return NS_ERROR_OUT_OF_MEMORY;
diff -uprN --exclude=CVS mozilla/nsprpub/config/autoconf.mk.in mozilla.new/nsprpub/config/autoconf.mk.in
--- mozilla/nsprpub/config/autoconf.mk.in	2006-01-09 06:47:18.000000000 +0100
+++ mozilla.new/nsprpub/config/autoconf.mk.in	2006-02-24 11:15:17.000000000 +0100
@@ -88,6 +88,7 @@ RESOLVE_LINK_SYMBOLS = @RESOLVE_LINK_SYM
 
 HOST_CC		= @HOST_CC@
 HOST_CFLAGS	= @HOST_CFLAGS@
+HOST_LDFLAGS	= @HOST_LDFLAGS@
 
 DEFINES		= @DEFINES@ @DEFS@
 
diff -uprN --exclude=CVS mozilla/nsprpub/config/rules.mk mozilla.new/nsprpub/config/rules.mk
--- mozilla/nsprpub/config/rules.mk	2005-04-14 00:57:55.000000000 +0200
+++ mozilla.new/nsprpub/config/rules.mk	2006-02-24 11:15:17.000000000 +0100
@@ -87,6 +87,7 @@ CC=$(HOST_CC)
 CCC=$(HOST_CXX)
 CFLAGS=$(HOST_CFLAGS)
 CXXFLAGS=$(HOST_CXXFLAGS)
+LDFLAGS=$(HOST_LDFLAGS)
 endif
 endif
 endif
diff -uprN --exclude=CVS mozilla/nsprpub/configure mozilla.new/nsprpub/configure
--- mozilla/nsprpub/configure	2006-01-11 23:01:55.000000000 +0100
+++ mozilla.new/nsprpub/configure	2006-02-24 11:15:17.000000000 +0100
@@ -1185,12 +1185,21 @@ rm -f conftest*
     CFLAGS=$_SAVE_CFLAGS
     LDFLAGS=$_SAVE_LDFLAGS
 
+    case "$build:$target" in 
+      powerpc-apple-darwin8*:i?86-apple-darwin*)
+                                                _SAVE_CFLAGS=$CFLAGS 
+        _SAVE_CXXFLAGS=$CXXLAGS
+        CFLAGS="-isysroot /Developer/SDKs/MacOSX10.4u.sdk $CFLAGS"
+        CXXFLAGS="-isysroot /Developer/SDKs/MacOSX10.4u.sdk $CXXFLAGS"
+        ;;        
+    esac            
+
     for ac_prog in $CC "${target_alias}-gcc" "${target}-gcc"
 do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1194: checking for $ac_word" >&5
+echo "configure:1203: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1224,7 +1233,7 @@ test -n "$CC" || CC="echo"
     # Extract the first word of "gcc", so it can be a program name with args.
 set dummy gcc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1228: checking for $ac_word" >&5
+echo "configure:1237: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1254,7 +1263,7 @@ if test -z "$CC"; then
   # Extract the first word of "cc", so it can be a program name with args.
 set dummy cc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1258: checking for $ac_word" >&5
+echo "configure:1267: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1305,7 +1314,7 @@ fi
       # Extract the first word of "cl", so it can be a program name with args.
 set dummy cl; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1309: checking for $ac_word" >&5
+echo "configure:1318: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1337,7 +1346,7 @@ fi
 fi
 
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
-echo "configure:1341: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
+echo "configure:1350: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
 
 ac_ext=c
 # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
@@ -1348,12 +1357,12 @@ cross_compiling=$ac_cv_prog_cc_cross
 
 cat > conftest.$ac_ext << EOF
 
-#line 1352 "configure"
+#line 1361 "configure"
 #include "confdefs.h"
 
 main(){return(0);}
 EOF
-if { (eval echo configure:1357: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1366: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   ac_cv_prog_cc_works=yes
   # If we can't run a trivial program, we are probably using a cross compiler.
   if (./conftest; exit) 2>/dev/null; then
@@ -1379,12 +1388,12 @@ if test $ac_cv_prog_cc_works = no; then
   { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
 fi
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
-echo "configure:1383: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "configure:1392: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
 echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
 cross_compiling=$ac_cv_prog_cc_cross
 
 echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
-echo "configure:1388: checking whether we are using GNU C" >&5
+echo "configure:1397: checking whether we are using GNU C" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1393,7 +1402,7 @@ else
   yes;
 #endif
 EOF
-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1397: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1406: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
   ac_cv_prog_gcc=yes
 else
   ac_cv_prog_gcc=no
@@ -1412,7 +1421,7 @@ ac_test_CFLAGS="${CFLAGS+set}"
 ac_save_CFLAGS="$CFLAGS"
 CFLAGS=
 echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
-echo "configure:1416: checking whether ${CC-cc} accepts -g" >&5
+echo "configure:1425: checking whether ${CC-cc} accepts -g" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1448,7 +1457,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1452: checking for $ac_word" >&5
+echo "configure:1461: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CXX'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1484,7 +1493,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1488: checking for $ac_word" >&5
+echo "configure:1497: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CXX'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1516,7 +1525,7 @@ test -n "$CXX" || CXX="gcc"
 
 
 echo $ac_n "checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) works""... $ac_c" 1>&6
-echo "configure:1520: checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) works" >&5
+echo "configure:1529: checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) works" >&5
 
 ac_ext=C
 # CXXFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
@@ -1527,12 +1536,12 @@ cross_compiling=$ac_cv_prog_cxx_cross
 
 cat > conftest.$ac_ext << EOF
 
-#line 1531 "configure"
+#line 1540 "configure"
 #include "confdefs.h"
 
 int main(){return(0);}
 EOF
-if { (eval echo configure:1536: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1545: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   ac_cv_prog_cxx_works=yes
   # If we can't run a trivial program, we are probably using a cross compiler.
   if (./conftest; exit) 2>/dev/null; then
@@ -1558,12 +1567,12 @@ if test $ac_cv_prog_cxx_works = no; then
   { echo "configure: error: installation or configuration problem: C++ compiler cannot create executables." 1>&2; exit 1; }
 fi
 echo $ac_n "checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
-echo "configure:1562: checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "configure:1571: checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) is a cross-compiler" >&5
 echo "$ac_t""$ac_cv_prog_cxx_cross" 1>&6
 cross_compiling=$ac_cv_prog_cxx_cross
 
 echo $ac_n "checking whether we are using GNU C++""... $ac_c" 1>&6
-echo "configure:1567: checking whether we are using GNU C++" >&5
+echo "configure:1576: checking whether we are using GNU C++" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gxx'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1572,7 +1581,7 @@ else
   yes;
 #endif
 EOF
-if { ac_try='${CXX-g++} -E conftest.C'; { (eval echo configure:1576: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+if { ac_try='${CXX-g++} -E conftest.C'; { (eval echo configure:1585: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
   ac_cv_prog_gxx=yes
 else
   ac_cv_prog_gxx=no
@@ -1591,7 +1600,7 @@ ac_test_CXXFLAGS="${CXXFLAGS+set}"
 ac_save_CXXFLAGS="$CXXFLAGS"
 CXXFLAGS=
 echo $ac_n "checking whether ${CXX-g++} accepts -g""... $ac_c" 1>&6
-echo "configure:1595: checking whether ${CXX-g++} accepts -g" >&5
+echo "configure:1604: checking whether ${CXX-g++} accepts -g" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_cxx_g'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1622,12 +1631,20 @@ else
   fi
 fi
 
+
+    case "$build:$target" in
+      powerpc-apple-darwin8*:i?86-apple-darwin*)
+                                CFLAGS=$_SAVE_CFLAGS
+        CXXFLAGS=$_SAVE_CXXFLAGS
+        ;;
+    esac
+
     for ac_prog in $RANLIB "${target_alias}-ranlib" "${target}-ranlib"
 do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1631: checking for $ac_word" >&5
+echo "configure:1648: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1662,7 +1679,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1666: checking for $ac_word" >&5
+echo "configure:1683: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_AR'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1697,7 +1714,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1701: checking for $ac_word" >&5
+echo "configure:1718: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_AS'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1732,7 +1749,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1736: checking for $ac_word" >&5
+echo "configure:1753: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_LD'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1767,7 +1784,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1771: checking for $ac_word" >&5
+echo "configure:1788: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_STRIP'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1802,7 +1819,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1806: checking for $ac_word" >&5
+echo "configure:1823: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_WINDRES'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1839,7 +1856,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1843: checking for $ac_word" >&5
+echo "configure:1860: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CXX'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1871,7 +1888,7 @@ test -n "$CXX" || CXX="gcc"
 
 
 echo $ac_n "checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) works""... $ac_c" 1>&6
-echo "configure:1875: checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) works" >&5
+echo "configure:1892: checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) works" >&5
 
 ac_ext=C
 # CXXFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
@@ -1882,12 +1899,12 @@ cross_compiling=$ac_cv_prog_cxx_cross
 
 cat > conftest.$ac_ext << EOF
 
-#line 1886 "configure"
+#line 1903 "configure"
 #include "confdefs.h"
 
 int main(){return(0);}
 EOF
-if { (eval echo configure:1891: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1908: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   ac_cv_prog_cxx_works=yes
   # If we can't run a trivial program, we are probably using a cross compiler.
   if (./conftest; exit) 2>/dev/null; then
@@ -1913,12 +1930,12 @@ if test $ac_cv_prog_cxx_works = no; then
   { echo "configure: error: installation or configuration problem: C++ compiler cannot create executables." 1>&2; exit 1; }
 fi
 echo $ac_n "checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
-echo "configure:1917: checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "configure:1934: checking whether the C++ compiler ($CXX $CXXFLAGS $LDFLAGS) is a cross-compiler" >&5
 echo "$ac_t""$ac_cv_prog_cxx_cross" 1>&6
 cross_compiling=$ac_cv_prog_cxx_cross
 
 echo $ac_n "checking whether we are using GNU C++""... $ac_c" 1>&6
-echo "configure:1922: checking whether we are using GNU C++" >&5
+echo "configure:1939: checking whether we are using GNU C++" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gxx'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1927,7 +1944,7 @@ else
   yes;
 #endif
 EOF
-if { ac_try='${CXX-g++} -E conftest.C'; { (eval echo configure:1931: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+if { ac_try='${CXX-g++} -E conftest.C'; { (eval echo configure:1948: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
   ac_cv_prog_gxx=yes
 else
   ac_cv_prog_gxx=no
@@ -1946,7 +1963,7 @@ ac_test_CXXFLAGS="${CXXFLAGS+set}"
 ac_save_CXXFLAGS="$CXXFLAGS"
 CXXFLAGS=
 echo $ac_n "checking whether ${CXX-g++} accepts -g""... $ac_c" 1>&6
-echo "configure:1950: checking whether ${CXX-g++} accepts -g" >&5
+echo "configure:1967: checking whether ${CXX-g++} accepts -g" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_cxx_g'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1983,7 +2000,7 @@ fi
         # Extract the first word of "gcc", so it can be a program name with args.
 set dummy gcc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1987: checking for $ac_word" >&5
+echo "configure:2004: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2013,7 +2030,7 @@ if test -z "$CC"; then
   # Extract the first word of "cc", so it can be a program name with args.
 set dummy cc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2017: checking for $ac_word" >&5
+echo "configure:2034: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2064,7 +2081,7 @@ fi
       # Extract the first word of "cl", so it can be a program name with args.
 set dummy cl; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2068: checking for $ac_word" >&5
+echo "configure:2085: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2096,7 +2113,7 @@ fi
 fi
 
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
-echo "configure:2100: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
+echo "configure:2117: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
 
 ac_ext=c
 # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
@@ -2107,12 +2124,12 @@ cross_compiling=$ac_cv_prog_cc_cross
 
 cat > conftest.$ac_ext << EOF
 
-#line 2111 "configure"
+#line 2128 "configure"
 #include "confdefs.h"
 
 main(){return(0);}
 EOF
-if { (eval echo configure:2116: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2133: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   ac_cv_prog_cc_works=yes
   # If we can't run a trivial program, we are probably using a cross compiler.
   if (./conftest; exit) 2>/dev/null; then
@@ -2138,12 +2155,12 @@ if test $ac_cv_prog_cc_works = no; then
   { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
 fi
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
-echo "configure:2142: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "configure:2159: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
 echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
 cross_compiling=$ac_cv_prog_cc_cross
 
 echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
-echo "configure:2147: checking whether we are using GNU C" >&5
+echo "configure:2164: checking whether we are using GNU C" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2152,7 +2169,7 @@ else
   yes;
 #endif
 EOF
-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:2156: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:2173: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
   ac_cv_prog_gcc=yes
 else
   ac_cv_prog_gcc=no
@@ -2171,7 +2188,7 @@ ac_test_CFLAGS="${CFLAGS+set}"
 ac_save_CFLAGS="$CFLAGS"
 CFLAGS=
 echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
-echo "configure:2175: checking whether ${CC-cc} accepts -g" >&5
+echo "configure:2192: checking whether ${CC-cc} accepts -g" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2204,7 +2221,7 @@ fi
 
     fi
     echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
-echo "configure:2208: checking how to run the C preprocessor" >&5
+echo "configure:2225: checking how to run the C preprocessor" >&5
 # On Suns, sometimes $CPP names a directory.
 if test -n "$CPP" && test -d "$CPP"; then
   CPP=
@@ -2219,13 +2236,13 @@ else
   # On the NeXT, cc -E runs the code through the compiler's parser,
   # not just through cpp.
   cat > conftest.$ac_ext <<EOF
-#line 2223 "configure"
+#line 2240 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2229: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2246: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   :
@@ -2236,13 +2253,13 @@ else
   rm -rf conftest*
   CPP="${CC-cc} -E -traditional-cpp"
   cat > conftest.$ac_ext <<EOF
-#line 2240 "configure"
+#line 2257 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2246: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2263: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   :
@@ -2253,13 +2270,13 @@ else
   rm -rf conftest*
   CPP="${CC-cc} -nologo -E"
   cat > conftest.$ac_ext <<EOF
-#line 2257 "configure"
+#line 2274 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2263: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2280: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   :
@@ -2286,7 +2303,7 @@ echo "$ac_t""$CPP" 1>&6
     # Extract the first word of "ranlib", so it can be a program name with args.
 set dummy ranlib; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2290: checking for $ac_word" >&5
+echo "configure:2307: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2318,7 +2335,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2322: checking for $ac_word" >&5
+echo "configure:2339: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_AS'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2359,7 +2376,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2363: checking for $ac_word" >&5
+echo "configure:2380: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_AR'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2400,7 +2417,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2404: checking for $ac_word" >&5
+echo "configure:2421: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_LD'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2441,7 +2458,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2445: checking for $ac_word" >&5
+echo "configure:2462: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_STRIP'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2482,7 +2499,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2486: checking for $ac_word" >&5
+echo "configure:2503: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_WINDRES'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2537,6 +2554,12 @@ if test "`echo | $AS -v 2>&1 | grep -c G
 fi
 rm -f a.out
 
+case "$build:$target" in
+    i?86-apple-darwin*:powerpc-apple-darwin*)
+                                cross_compiling=yes
+        ;;
+esac
+
 if test "$cross_compiling"  = "yes"; then
     CROSS_COMPILE=1
 else
@@ -2544,7 +2567,7 @@ else
 fi
 
 echo $ac_n "checking for gcc -pipe support""... $ac_c" 1>&6
-echo "configure:2548: checking for gcc -pipe support" >&5
+echo "configure:2571: checking for gcc -pipe support" >&5
 if test -n "$GNU_CC" && test -n "$GNU_CXX" && test -n "$GNU_AS"; then
     echo '#include <stdio.h>' > dummy-hello.c
     echo 'int main() { printf("Hello World\n"); return 0; }' >> dummy-hello.c
@@ -2559,14 +2582,14 @@ if test -n "$GNU_CC" && test -n "$GNU_CX
         _SAVE_CFLAGS=$CFLAGS
         CFLAGS="$CFLAGS -pipe"
         cat > conftest.$ac_ext <<EOF
-#line 2563 "configure"
+#line 2586 "configure"
 #include "confdefs.h"
  #include <stdio.h> 
 int main() {
 printf("Hello World\n");
 ; return 0; }
 EOF
-if { (eval echo configure:2570: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2593: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   _res_gcc_pipe="yes"
 else
@@ -2593,7 +2616,7 @@ fi
 
 if test "$GNU_CC"; then
     echo $ac_n "checking for visibility(hidden) attribute""... $ac_c" 1>&6
-echo "configure:2597: checking for visibility(hidden) attribute" >&5
+echo "configure:2620: checking for visibility(hidden) attribute" >&5
 if eval "test \"`echo '$''{'ac_cv_visibility_hidden'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2617,7 +2640,7 @@ echo "$ac_t""$ac_cv_visibility_hidden" 1
 EOF
 
         echo $ac_n "checking for visibility pragma support""... $ac_c" 1>&6
-echo "configure:2621: checking for visibility pragma support" >&5
+echo "configure:2644: checking for visibility pragma support" >&5
 if eval "test \"`echo '$''{'ac_cv_visibility_pragma'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2670,7 +2693,7 @@ do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:2674: checking for $ac_word" >&5
+echo "configure:2697: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_PERL'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2730,6 +2753,7 @@ if test -n "$CROSS_COMPILE"; then
         linux*)       OS_ARCH=Linux ;;
         solaris*)     OS_ARCH=SunOS OS_RELEASE=5 ;;
         mingw*)       OS_ARCH=WINNT ;;
+        darwin*)      OS_ARCH=Darwin ;;
     esac
 else
     OS_ARCH=`uname -s | sed -e 's|/|_|g'`
@@ -2916,17 +2940,17 @@ EOF
     DSO_LDOPTS='-brtl -bnortllib -bM:SRE -bnoentry -bexpall -blibpath:/usr/lib:/lib'
     ac_safe=`echo "sys/atomic_op.h" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for sys/atomic_op.h""... $ac_c" 1>&6
-echo "configure:2920: checking for sys/atomic_op.h" >&5
+echo "configure:2944: checking for sys/atomic_op.h" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2925 "configure"
+#line 2949 "configure"
 #include "confdefs.h"
 #include <sys/atomic_op.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2930: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2954: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -3083,7 +3107,7 @@ EOF
         _DEBUG_FLAGS='-gdwarf-2 -O0'
         MKSHLIB='$(CCC) $(DSO_LDOPTS) -o $@'
         echo $ac_n "checking for gethostbyaddr in -lbind""... $ac_c" 1>&6
-echo "configure:3087: checking for gethostbyaddr in -lbind" >&5
+echo "configure:3111: checking for gethostbyaddr in -lbind" >&5
 ac_lib_var=`echo bind'_'gethostbyaddr | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -3091,7 +3115,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lbind  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3095 "configure"
+#line 3119 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3102,7 +3126,7 @@ int main() {
 gethostbyaddr()
 ; return 0; }
 EOF
-if { (eval echo configure:3106: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3130: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3305,7 +3329,7 @@ EOF
     DSO_LDOPTS='-dynamiclib -compatibility_version 1 -current_version 1 -all_load -install_name @executable_path/$@ -headerpad_max_install_names'
     # Use the standard preprocessor (cpp)
     CFLAGS="$CFLAGS -no-cpp-precomp"
-    MKSHLIB='$(CC) -arch $(CPU_ARCH) $(DSO_LDOPTS) -o $@'
+    MKSHLIB='$(CC) $(DSO_LDOPTS) -o $@'
     STRIP="$STRIP -x -S"
     DLL_SUFFIX=dylib
     USE_PTHREADS=1
@@ -3364,6 +3388,11 @@ tools are selected during the Xcode/Deve
                 LDFLAGS="${MACOS_SDK_LIBS} $LDFLAGS"
                 DSO_LDOPTS="${MACOS_SDK_LIBS} $DSO_LDOPTS"
                 export NEXT_ROOT=$MACOS_SDK_DIR
+
+                if test -n "$CROSS_COMPILE" ; then
+                                                                                HOST_CC="NEXT_ROOT= $HOST_CC"
+                    HOST_CXX="NEXT_ROOT= $HOST_CXX"
+                fi
             else
                                                 CFLAGS="$CFLAGS -isysroot ${MACOS_SDK_DIR}"
 
@@ -4363,17 +4392,17 @@ EOF
         _OPTIMIZE_FLAGS="$_OPTIMIZE_FLAGS -Olimit 4000"
         ac_safe=`echo "machine/builtins.h" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for machine/builtins.h""... $ac_c" 1>&6
-echo "configure:4367: checking for machine/builtins.h" >&5
+echo "configure:4396: checking for machine/builtins.h" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4372 "configure"
+#line 4401 "configure"
 #include "confdefs.h"
 #include <machine/builtins.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:4377: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:4406: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -4935,7 +4964,7 @@ case $target in
     ;;
 *)
     echo $ac_n "checking for dlopen in -ldl""... $ac_c" 1>&6
-echo "configure:4939: checking for dlopen in -ldl" >&5
+echo "configure:4968: checking for dlopen in -ldl" >&5
 ac_lib_var=`echo dl'_'dlopen | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -4943,7 +4972,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-ldl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 4947 "configure"
+#line 4976 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -4954,7 +4983,7 @@ int main() {
 dlopen()
 ; return 0; }
 EOF
-if { (eval echo configure:4958: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4987: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -4971,17 +5000,17 @@ if eval "test \"`echo '$ac_cv_lib_'$ac_l
   echo "$ac_t""yes" 1>&6
   ac_safe=`echo "dlfcn.h" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for dlfcn.h""... $ac_c" 1>&6
-echo "configure:4975: checking for dlfcn.h" >&5
+echo "configure:5004: checking for dlfcn.h" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4980 "configure"
+#line 5009 "configure"
 #include "confdefs.h"
 #include <dlfcn.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:4985: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:5014: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -5014,13 +5043,13 @@ esac
 
 if test $ac_cv_prog_gcc = yes; then
     echo $ac_n "checking whether ${CC-cc} needs -traditional""... $ac_c" 1>&6
-echo "configure:5018: checking whether ${CC-cc} needs -traditional" >&5
+echo "configure:5047: checking whether ${CC-cc} needs -traditional" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gcc_traditional'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
     ac_pattern="Autoconf.*'x'"
   cat > conftest.$ac_ext <<EOF
-#line 5024 "configure"
+#line 5053 "configure"
 #include "confdefs.h"
 #include <sgtty.h>
 Autoconf TIOCGETP
@@ -5038,7 +5067,7 @@ rm -f conftest*
 
   if test $ac_cv_prog_gcc_traditional = no; then
     cat > conftest.$ac_ext <<EOF
-#line 5042 "configure"
+#line 5071 "configure"
 #include "confdefs.h"
 #include <termio.h>
 Autoconf TCGETA
@@ -5062,12 +5091,12 @@ fi
 for ac_func in lchown strerror
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:5066: checking for $ac_func" >&5
+echo "configure:5095: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 5071 "configure"
+#line 5100 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -5090,7 +5119,7 @@ $ac_func();
 
 ; return 0; }
 EOF
-if { (eval echo configure:5094: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:5123: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -5131,7 +5160,7 @@ hpux*)
 if test -z "$GNU_CC"; then
 
     echo $ac_n "checking for +Olit support""... $ac_c" 1>&6
-echo "configure:5135: checking for +Olit support" >&5
+echo "configure:5164: checking for +Olit support" >&5
 if eval "test \"`echo '$''{'ac_cv_hpux_usable_olit_option'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -5170,7 +5199,7 @@ darwin*)
 *)
     
 echo $ac_n "checking for pthread_create in -lpthreads""... $ac_c" 1>&6
-echo "configure:5174: checking for pthread_create in -lpthreads" >&5
+echo "configure:5203: checking for pthread_create in -lpthreads" >&5
 echo "
     #include <pthread.h> 
     void *foo(void *v) { return v; } 
@@ -5192,7 +5221,7 @@ echo "
         echo "$ac_t""no" 1>&6
         
 echo $ac_n "checking for pthread_create in -lpthread""... $ac_c" 1>&6
-echo "configure:5196: checking for pthread_create in -lpthread" >&5
+echo "configure:5225: checking for pthread_create in -lpthread" >&5
 echo "
     #include <pthread.h> 
     void *foo(void *v) { return v; } 
@@ -5214,7 +5243,7 @@ echo "
         echo "$ac_t""no" 1>&6
         
 echo $ac_n "checking for pthread_create in -lc_r""... $ac_c" 1>&6
-echo "configure:5218: checking for pthread_create in -lc_r" >&5
+echo "configure:5247: checking for pthread_create in -lc_r" >&5
 echo "
     #include <pthread.h> 
     void *foo(void *v) { return v; } 
@@ -5236,7 +5265,7 @@ echo "
         echo "$ac_t""no" 1>&6
         
 echo $ac_n "checking for pthread_create in -lc""... $ac_c" 1>&6
-echo "configure:5240: checking for pthread_create in -lc" >&5
+echo "configure:5269: checking for pthread_create in -lc" >&5
 echo "
     #include <pthread.h> 
     void *foo(void *v) { return v; } 
@@ -5390,7 +5419,7 @@ if test -n "$USE_PTHREADS"; then
       rm -f conftest*
    ac_cv_have_dash_pthread=no
    echo $ac_n "checking whether ${CC-cc} accepts -pthread""... $ac_c" 1>&6
-echo "configure:5394: checking whether ${CC-cc} accepts -pthread" >&5
+echo "configure:5423: checking whether ${CC-cc} accepts -pthread" >&5
    echo 'int main() { return 0; }' | cat > conftest.c
    ${CC-cc} -pthread -o conftest conftest.c > conftest.out 2>&1
    if test $? -eq 0; then
@@ -5413,7 +5442,7 @@ echo "configure:5394: checking whether $
 			    ac_cv_have_dash_pthreads=no
     if test "$ac_cv_have_dash_pthread" = "no"; then
 	    echo $ac_n "checking whether ${CC-cc} accepts -pthreads""... $ac_c" 1>&6
-echo "configure:5417: checking whether ${CC-cc} accepts -pthreads" >&5
+echo "configure:5446: checking whether ${CC-cc} accepts -pthreads" >&5
     	echo 'int main() { return 0; }' | cat > conftest.c
 	    ${CC-cc} -pthreads -o conftest conftest.c > conftest.out 2>&1
     	if test $? -eq 0; then
@@ -5831,6 +5860,7 @@ esac
 
 
 
+
 MAKEFILES="
 Makefile 
 config/Makefile
@@ -6058,6 +6088,7 @@ s%@PERL@%$PERL%g
 s%@SHELL_OVERRIDE@%$SHELL_OVERRIDE%g
 s%@MOZILLA_CLIENT@%$MOZILLA_CLIENT%g
 s%@HOST_CFLAGS@%$HOST_CFLAGS%g
+s%@HOST_LDFLAGS@%$HOST_LDFLAGS%g
 s%@GNU_CC@%$GNU_CC%g
 s%@GCC_USE_GNU_LD@%$GCC_USE_GNU_LD%g
 s%@MSC_VER@%$MSC_VER%g
diff -uprN --exclude=CVS mozilla/nsprpub/configure.in mozilla.new/nsprpub/configure.in
--- mozilla/nsprpub/configure.in	2006-01-11 23:01:56.000000000 +0100
+++ mozilla.new/nsprpub/configure.in	2006-02-24 11:15:17.000000000 +0100
@@ -412,12 +412,37 @@ if test "$target" != "$host"; then
     CFLAGS=$_SAVE_CFLAGS
     LDFLAGS=$_SAVE_LDFLAGS
 
+    case "$build:$target" in 
+      powerpc-apple-darwin8*:i?86-apple-darwin*)
+        dnl The Darwin cross compiler doesn't necessarily point itself at a
+        dnl root that has libraries for the proper architecture, it defaults
+        dnl to the system root.  The libraries in the system root on current
+        dnl versions of PPC OS X 10.4 aren't fat, so these target compiler
+        dnl checks will fail.  Fake a working SDK in that case.
+        _SAVE_CFLAGS=$CFLAGS 
+        _SAVE_CXXFLAGS=$CXXLAGS
+        CFLAGS="-isysroot /Developer/SDKs/MacOSX10.4u.sdk $CFLAGS"
+        CXXFLAGS="-isysroot /Developer/SDKs/MacOSX10.4u.sdk $CXXFLAGS"
+        ;;        
+    esac            
+
     AC_CHECK_PROGS(CC, $CC "${target_alias}-gcc" "${target}-gcc", echo)
     unset ac_cv_prog_CC
     AC_PROG_CC
     AC_CHECK_PROGS(CXX, $CXX "${target_alias}-g++" "${target}-g++", echo)
     unset ac_cv_prog_CXX
     AC_PROG_CXX
+
+    case "$build:$target" in
+      powerpc-apple-darwin8*:i?86-apple-darwin*)
+        dnl Revert the changes made above.  From this point on, the target
+        dnl compiler will never be used without applying the SDK to CFLAGS
+        dnl (see --with-macos-sdk below).
+        CFLAGS=$_SAVE_CFLAGS
+        CXXFLAGS=$_SAVE_CXXFLAGS
+        ;;
+    esac
+
     AC_CHECK_PROGS(RANLIB, $RANLIB "${target_alias}-ranlib" "${target}-ranlib", echo)
     AC_CHECK_PROGS(AR, $AR "${target_alias}-ar" "${target}-ar", echo)
     AC_CHECK_PROGS(AS, $AS "${target_alias}-as" "${target}-as", echo)
@@ -458,6 +483,15 @@ if test "`echo | $AS -v 2>&1 | grep -c G
 fi
 rm -f a.out
 
+case "$build:$target" in
+    i?86-apple-darwin*:powerpc-apple-darwin*)
+        dnl cross_compiling will have erroneously been set to "no" in this
+        dnl case, because the x86 build host is able to run ppc code in a
+        dnl translated environment, making a cross compiler appear native.
+        cross_compiling=yes
+        ;;
+esac
+
 if test "$cross_compiling"  = "yes"; then
     CROSS_COMPILE=1
 else
@@ -591,6 +625,7 @@ if test -n "$CROSS_COMPILE"; then
         linux*)       OS_ARCH=Linux ;;
         solaris*)     OS_ARCH=SunOS OS_RELEASE=5 ;;
         mingw*)       OS_ARCH=WINNT ;;
+        darwin*)      OS_ARCH=Darwin ;;
     esac
 else
     OS_ARCH=`uname -s | sed -e 's|/|_|g'`
@@ -943,7 +978,7 @@ case "$target" in
     DSO_LDOPTS='-dynamiclib -compatibility_version 1 -current_version 1 -all_load -install_name @executable_path/$@ -headerpad_max_install_names'
     # Use the standard preprocessor (cpp)
     CFLAGS="$CFLAGS -no-cpp-precomp"
-    MKSHLIB='$(CC) -arch $(CPU_ARCH) $(DSO_LDOPTS) -o $@'
+    MKSHLIB='$(CC) $(DSO_LDOPTS) -o $@'
     STRIP="$STRIP -x -S"
     DLL_SUFFIX=dylib
     USE_PTHREADS=1
@@ -1020,6 +1055,14 @@ tools are selected during the Xcode/Deve
                 LDFLAGS="${MACOS_SDK_LIBS} $LDFLAGS"
                 DSO_LDOPTS="${MACOS_SDK_LIBS} $DSO_LDOPTS"
                 export NEXT_ROOT=$MACOS_SDK_DIR
+
+                if test -n "$CROSS_COMPILE" ; then
+                    dnl NEXT_ROOT will be in the environment, but it
+                    dnl shouldn't be set for the build host.  HOST_CXX is
+                    dnl presently unused.
+                    HOST_CC="NEXT_ROOT= $HOST_CC"
+                    HOST_CXX="NEXT_ROOT= $HOST_CXX"
+                fi
             else
                 dnl gcc >= 4.0 uses different paths than above, but knows
                 dnl how to find them itself.
@@ -2619,6 +2662,7 @@ AC_SUBST(CPPFLAGS)
 AC_SUBST(HOST_CC)
 AC_SUBST(HOST_CFLAGS)
 AC_SUBST(LDFLAGS)
+AC_SUBST(HOST_LDFLAGS)
 AC_SUBST(GNU_CC)
 AC_SUBST(GCC_USE_GNU_LD)
 AC_SUBST(MSC_VER)
diff -uprN --exclude=CVS mozilla/nsprpub/pr/include/md/_darwin.cfg mozilla.new/nsprpub/pr/include/md/_darwin.cfg
--- mozilla/nsprpub/pr/include/md/_darwin.cfg	2004-04-28 02:33:44.000000000 +0200
+++ mozilla.new/nsprpub/pr/include/md/_darwin.cfg	2006-02-24 11:15:17.000000000 +0100
@@ -94,6 +94,7 @@
 #define PR_ALIGN_OF_FLOAT   4
 #define PR_ALIGN_OF_DOUBLE  4
 #define PR_ALIGN_OF_POINTER 4
+#define PR_ALIGN_OF_WORD    4
 
 #ifndef NO_NSPR_10_SUPPORT
 
diff -uprN --exclude=CVS mozilla/nsprpub/pr/src/Makefile.in mozilla.new/nsprpub/pr/src/Makefile.in
--- mozilla/nsprpub/pr/src/Makefile.in	2005-06-01 16:26:29.000000000 +0200
+++ mozilla.new/nsprpub/pr/src/Makefile.in	2006-02-14 09:59:41.000000000 +0100
@@ -198,9 +198,9 @@ endif
 
 ifeq ($(OS_ARCH),WINNT)
 ifdef NS_USE_GCC
-OS_LIBS		= -ladvapi32 -lwsock32
+OS_LIBS		= -ladvapi32 -lwsock32 -lwinmm
 else
-OS_LIBS		= advapi32.lib wsock32.lib
+OS_LIBS		= advapi32.lib wsock32.lib winmm.lib
 endif
 endif
 
diff -uprN --exclude=CVS mozilla/nsprpub/pr/src/md/windows/ntinrval.c mozilla.new/nsprpub/pr/src/md/windows/ntinrval.c
--- mozilla/nsprpub/pr/src/md/windows/ntinrval.c	2004-04-28 02:34:06.000000000 +0200
+++ mozilla.new/nsprpub/pr/src/md/windows/ntinrval.c	2006-02-14 09:59:42.000000000 +0100
@@ -42,83 +42,19 @@
 
 #include "primpl.h"
 
-#if defined(WIN16)
-#include <win/compobj.h>
-#define QueryPerformanceFrequency(x)   FALSE
-#define QueryPerformanceCounter(x)     FALSE
-#endif
-
-static PRIntn _nt_bitShift = 0;
-static PRInt32 _nt_ticksPerSec = -1;
-
 void
 _PR_MD_INTERVAL_INIT()
 {
-    LARGE_INTEGER count;
-
-    if (QueryPerformanceFrequency(&count)) {
-        /*
-         * HighPart is signed (LONG).  Assert that its sign bit is 0
-         * because we will be right shifting it.  LowPart is unsigned
-         * (DWORD).
-         */
-        PR_ASSERT(count.HighPart >= 0);
-        while(count.HighPart) {
-            count.LowPart = (count.HighPart << 31) + (count.LowPart >> 1);
-            count.HighPart >>= 1;
-            _nt_bitShift++;
-        }
-        while(count.LowPart > PR_INTERVAL_MAX) {
-            count.LowPart >>= 1;
-            _nt_bitShift++;
-        }
-
-        /*
-         * We can't use the performance counter if after
-         * normalization we are left with fewer than 32 bits.
-         */
-        if (_nt_bitShift <= 32) {
-            _nt_ticksPerSec = count.LowPart;
-            PR_ASSERT(_nt_ticksPerSec > PR_INTERVAL_MIN);
-            return;
-        }
-    }
-    _nt_ticksPerSec = -1;
 }
 
 PRIntervalTime 
 _PR_MD_GET_INTERVAL()
 {
-    LARGE_INTEGER count;
-
-   /* Sadly; nspr requires the interval to range from 1000 ticks per second
-    * to only 100000 ticks per second; QueryPerformanceCounter is too high
-    * resolution...
-    */
-    if (_nt_ticksPerSec != -1) {
-        (void)QueryPerformanceCounter(&count);
-        PR_ASSERT(_nt_bitShift <= 32);
-        if (_nt_bitShift == 32) {
-            return (PRUint32)count.HighPart;
-        } else {
-            return (PRUint32)((count.HighPart << (32 - _nt_bitShift))
-                    + (count.LowPart >> _nt_bitShift));
-        }
-    } else
-#if defined(__MINGW32__)
-        return time();
-#elif defined(WIN16)
-        return clock();        /* milliseconds since application start */
-#else
-        return GetTickCount();  /* milliseconds since system start */
-#endif
+    return timeGetTime();  /* milliseconds since system start */
 }
 
 PRIntervalTime 
 _PR_MD_INTERVAL_PER_SEC()
 {
-    if (_nt_ticksPerSec != -1)
-        return _nt_ticksPerSec;
-    else
-        return 1000;
+    return 1000;
 }
diff -uprN --exclude=CVS mozilla/nsprpub/pr/src/md/windows/ntio.c mozilla.new/nsprpub/pr/src/md/windows/ntio.c
--- mozilla/nsprpub/pr/src/md/windows/ntio.c	2004-04-28 02:34:06.000000000 +0200
+++ mozilla.new/nsprpub/pr/src/md/windows/ntio.c	2006-02-24 11:15:18.000000000 +0100
@@ -20,6 +20,7 @@
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
+ *   Masayuki Nakano <masayuki@d-toybox.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -108,6 +109,8 @@ static const PRTime _pr_filetime_offset 
 static const PRTime _pr_filetime_offset = 116444736000000000i64;
 #endif
 
+static PRBool IsPrevCharSlash(const char *str, const char *current);
+
 #define _NEED_351_FILE_LOCKING_HACK
 #ifdef _NEED_351_FILE_LOCKING_HACK
 #define _PR_LOCAL_FILE 1
@@ -2769,7 +2772,7 @@ _PR_MD_OPEN_DIR(_MDDir *d, const char *n
      * If 'name' ends in a slash or backslash, do not append
      * another backslash.
      */
-    if (filename[len - 1] == '/' || filename[len - 1] == '\\') {
+    if (IsPrevCharSlash(filename, filename + len)) {
         len--;
     }
     strcpy(&filename[len], "\\*.*");
@@ -2907,7 +2910,7 @@ _PR_MD_STAT(const char *fn, struct stat 
 
         int len = strlen(fn);
         if (len > 0 && len <= _MAX_PATH
-                && (fn[len - 1] == '\\' || fn[len - 1] == '/')) {
+                && IsPrevCharSlash(fn, fn + len)) {
             char newfn[_MAX_PATH + 1];
 
             strcpy(newfn, fn);
@@ -2924,6 +2927,17 @@ _PR_MD_STAT(const char *fn, struct stat 
 
 #define _PR_IS_SLASH(ch) ((ch) == '/' || (ch) == '\\')
 
+static PRBool
+IsPrevCharSlash(const char *str, const char *current)
+{
+    const char *prev;
+
+    if (str >= current)
+        return PR_FALSE;
+    prev = _mbsdec(str, current);
+    return (prev == current - 1) && _PR_IS_SLASH(*prev);
+}
+
 /*
  * IsRootDirectory --
  *
@@ -2970,7 +2984,7 @@ IsRootDirectory(char *fn, size_t buflen)
 
         /* look for the next slash */
         do {
-            p++;
+            p = _mbsinc(p);
         } while (*p != '\0' && !_PR_IS_SLASH(*p));
         if (*p == '\0') {
             return PR_FALSE;
@@ -2984,7 +2998,7 @@ IsRootDirectory(char *fn, size_t buflen)
 
         /* look for the final slash */
         do {
-            p++;
+            p = _mbsinc(p);
         } while (*p != '\0' && !_PR_IS_SLASH(*p));
         if (_PR_IS_SLASH(*p) && p[1] != '\0') {
             return PR_FALSE;
@@ -3074,7 +3088,7 @@ _PR_MD_GETFILEINFO64(const char *fn, PRF
             info->creationTime = 0;
             return 0;
         }
-        if (!_PR_IS_SLASH(pathbuf[len - 1])) {
+        if (!IsPrevCharSlash(pathbuf, pathbuf + len)) {
             _PR_MD_MAP_OPENDIR_ERROR(GetLastError());
             return -1;
         } else {
diff -uprN --exclude=CVS mozilla/nsprpub/pr/src/md/windows/w95io.c mozilla.new/nsprpub/pr/src/md/windows/w95io.c
--- mozilla/nsprpub/pr/src/md/windows/w95io.c	2004-04-28 02:34:06.000000000 +0200
+++ mozilla.new/nsprpub/pr/src/md/windows/w95io.c	2006-02-24 11:15:18.000000000 +0100
@@ -20,6 +20,7 @@
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
+ *   Masayuki Nakano <masayuki@d-toybox.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -84,6 +85,8 @@ static const PRTime _pr_filetime_offset 
 static void InitUnicodeSupport(void);
 #endif
 
+static PRBool IsPrevCharSlash(const char *str, const char *current);
+
 void
 _PR_MD_INIT_IO()
 {
@@ -516,7 +519,7 @@ _PR_MD_OPEN_DIR(_MDDir *d, const char *n
      * If 'name' ends in a slash or backslash, do not append
      * another backslash.
      */
-    if (filename[len - 1] == '/' || filename[len - 1] == '\\') {
+    if (IsPrevCharSlash(filename, filename + len)) {
         len--;
     }
     strcpy(&filename[len], "\\*.*");
@@ -654,7 +657,7 @@ _PR_MD_STAT(const char *fn, struct stat 
 
         int len = strlen(fn);
         if (len > 0 && len <= _MAX_PATH
-                && (fn[len - 1] == '\\' || fn[len - 1] == '/')) {
+                && IsPrevCharSlash(fn, fn + len)) {
             char newfn[_MAX_PATH + 1];
 
             strcpy(newfn, fn);
@@ -671,6 +674,17 @@ _PR_MD_STAT(const char *fn, struct stat 
 
 #define _PR_IS_SLASH(ch) ((ch) == '/' || (ch) == '\\')
 
+static PRBool
+IsPrevCharSlash(const char *str, const char *current)
+{
+    const char *prev;
+
+    if (str >= current)
+        return PR_FALSE;
+    prev = _mbsdec(str, current);
+    return (prev == current - 1) && _PR_IS_SLASH(*prev);
+}
+
 /*
  * IsRootDirectory --
  *
@@ -717,7 +731,7 @@ IsRootDirectory(char *fn, size_t buflen)
 
         /* look for the next slash */
         do {
-            p++;
+            p = _mbsinc(p);
         } while (*p != '\0' && !_PR_IS_SLASH(*p));
         if (*p == '\0') {
             return PR_FALSE;
@@ -731,7 +745,7 @@ IsRootDirectory(char *fn, size_t buflen)
 
         /* look for the final slash */
         do {
-            p++;
+            p = _mbsinc(p);
         } while (*p != '\0' && !_PR_IS_SLASH(*p));
         if (_PR_IS_SLASH(*p) && p[1] != '\0') {
             return PR_FALSE;
@@ -821,7 +835,7 @@ _PR_MD_GETFILEINFO64(const char *fn, PRF
             info->creationTime = 0;
             return 0;
         }
-        if (!_PR_IS_SLASH(pathbuf[len - 1])) {
+        if (!IsPrevCharSlash(pathbuf, pathbuf + len)) {
             _PR_MD_MAP_OPENDIR_ERROR(GetLastError());
             return -1;
         } else {
diff -uprN --exclude=CVS mozilla/parser/expat/lib/internal.h mozilla.new/parser/expat/lib/internal.h
--- mozilla/parser/expat/lib/internal.h	2005-07-22 00:14:59.000000000 +0200
+++ mozilla.new/parser/expat/lib/internal.h	2006-02-24 11:16:41.000000000 +0100
@@ -20,7 +20,7 @@
          and therefore subject to change.
 */
 
-#if defined(__GNUC__) && defined(__i386__) && !defined(XP_MACOSX)
+#if defined(__GNUC__) && defined(__i386__)
 /* We'll use this version by default only where we know it helps.
 
    regparm() generates warnings on Solaris boxes.   See SF bug #692878.
diff -uprN --exclude=CVS mozilla/parser/htmlparser/src/CNavDTD.cpp mozilla.new/parser/htmlparser/src/CNavDTD.cpp
--- mozilla/parser/htmlparser/src/CNavDTD.cpp	2005-09-13 19:15:18.000000000 +0200
+++ mozilla.new/parser/htmlparser/src/CNavDTD.cpp	2006-03-12 20:04:18.000000000 +0100
@@ -2028,7 +2028,11 @@ nsresult CNavDTD::HandleSavedTokens(PRIn
               // EndContext(). Ex: <center><table><a></center>.
               // In the Ex. above </center> should not close <center> above table.
               // Doing so will cause the current context to get closed prematurely. 
-              PRInt32 theIndex=mBodyContext->LastOf(theTag);
+              eHTMLTags closed = FindAutoCloseTargetForEndTag(theTag, *mBodyContext,
+                                                              mDTDMode);
+              PRInt32 theIndex = closed != eHTMLTag_unknown
+                                 ? mBodyContext->LastOf(closed)
+                                 : kNotFound;
               
               if(theIndex!=kNotFound && theIndex<=mBodyContext->mContextTopIndex) {
                 IF_FREE(theToken, mTokenAllocator);
diff -uprN --exclude=CVS mozilla/plugin/oji/JEP/JavaEmbeddingPlugin.bundle/Contents/Info.plist mozilla.new/plugin/oji/JEP/JavaEmbeddingPlugin.bundle/Contents/Info.plist
--- mozilla/plugin/oji/JEP/JavaEmbeddingPlugin.bundle/Contents/Info.plist	2006-01-09 06:48:48.000000000 +0100
+++ mozilla.new/plugin/oji/JEP/JavaEmbeddingPlugin.bundle/Contents/Info.plist	2006-02-24 11:16:36.000000000 +0100
@@ -7,7 +7,7 @@
 	<key>CFBundleExecutable</key>
 	<string>JavaEmbeddingPlugin</string>
 	<key>CFBundleGetInfoString</key>
-	<string>Java Embedding Plugin 0.9.5+b, Copyright (c) 2005 Steven Michaud</string>
+	<string>Java Embedding Plugin 0.9.5+c, Copyright (c) 2006 Steven Michaud</string>
 	<key>CFBundleInfoDictionaryVersion</key>
 	<string>6.0</string>
 	<key>CFBundleName</key>
@@ -15,11 +15,11 @@
 	<key>CFBundlePackageType</key>
 	<string>BNDL</string>
 	<key>CFBundleShortVersionString</key>
-	<string>0.9.5+b</string>
+	<string>0.9.5+c</string>
 	<key>CFBundleSignature</key>
 	<string>????</string>
 	<key>CFBundleVersion</key>
-	<string>0.9.5+b</string>
+	<string>0.9.5+c</string>
 	<key>NSJavaNeeded</key>
 	<string>YES</string>
 	<key>NSJavaPath</key>
Dateien mozilla/plugin/oji/JEP/JavaEmbeddingPlugin.bundle/Contents/MacOS/JavaEmbeddingPlugin und mozilla.new/plugin/oji/JEP/JavaEmbeddingPlugin.bundle/Contents/MacOS/JavaEmbeddingPlugin sind verschieden.
diff -uprN --exclude=CVS mozilla/plugin/oji/JEP/JavaEmbeddingPlugin.bundle/Contents/pbdevelopment.plist mozilla.new/plugin/oji/JEP/JavaEmbeddingPlugin.bundle/Contents/pbdevelopment.plist
--- mozilla/plugin/oji/JEP/JavaEmbeddingPlugin.bundle/Contents/pbdevelopment.plist	2006-01-09 06:48:48.000000000 +0100
+++ mozilla.new/plugin/oji/JEP/JavaEmbeddingPlugin.bundle/Contents/pbdevelopment.plist	2006-02-24 11:16:36.000000000 +0100
@@ -3,6 +3,6 @@
 <plist version="1.0">
 <dict>
 	<key>PBXProjectSourcePath</key>
-	<string>/Volumes/Storage2/Developer/JavaEmbeddingPlugin/Project/JavaEmbeddingPlugin0.9.5+b/JavaEmbeddingPlugin.pbproj</string>
+	<string>/Volumes/Storage2/Developer/JavaEmbeddingPlugin/Project/JavaEmbeddingPlugin0.9.5+c/JavaEmbeddingPlugin.pbproj</string>
 </dict>
 </plist>
Dateien mozilla/plugin/oji/JEP/JavaEmbeddingPlugin.bundle/Contents/Resources/English.lproj/InfoPlist.strings und mozilla.new/plugin/oji/JEP/JavaEmbeddingPlugin.bundle/Contents/Resources/English.lproj/InfoPlist.strings sind verschieden.
Dateien mozilla/plugin/oji/JEP/JavaEmbeddingPlugin.bundle/Contents/Resources/Java/JavaEmbeddingPlugin.jar und mozilla.new/plugin/oji/JEP/JavaEmbeddingPlugin.bundle/Contents/Resources/Java/JavaEmbeddingPlugin.jar sind verschieden.
diff -uprN --exclude=CVS mozilla/plugin/oji/JEP/MRJPlugin.plugin/Contents/Info.plist mozilla.new/plugin/oji/JEP/MRJPlugin.plugin/Contents/Info.plist
--- mozilla/plugin/oji/JEP/MRJPlugin.plugin/Contents/Info.plist	2006-01-09 06:48:49.000000000 +0100
+++ mozilla.new/plugin/oji/JEP/MRJPlugin.plugin/Contents/Info.plist	2006-02-24 11:16:37.000000000 +0100
@@ -7,7 +7,7 @@
 	<key>CFBundleExecutable</key>
 	<string>MRJPlugin</string>
 	<key>CFBundleGetInfoString</key>
-	<string>MRJ Plugin 1.0-JEP-0.9.5+b, Copyright (c) 2002 The Mozilla Organization</string>
+	<string>MRJ Plugin 1.0-JEP-0.9.5+c, Copyright (c) 2002 The Mozilla Organization</string>
 	<key>CFBundleIdentifier</key>
 	<string>com.netscape.MRJPlugin</string>
 	<key>CFBundleInfoDictionaryVersion</key>
@@ -17,11 +17,11 @@
 	<key>CFBundlePackageType</key>
 	<string>NSPL</string>
 	<key>CFBundleShortVersionString</key>
-	<string>1.0-JEP-0.9.5+b</string>
+	<string>1.0-JEP-0.9.5+c</string>
 	<key>CFBundleSignature</key>
 	<string>MOSS</string>
 	<key>CFBundleVersion</key>
-	<string>1.0-JEP-0.9.5+b</string>
+	<string>1.0-JEP-0.9.5+c</string>
 	<key>CSResourcesFileMapped</key>
 	<true/>
 </dict>
Dateien mozilla/plugin/oji/JEP/MRJPlugin.plugin/Contents/MacOS/MRJPlugin und mozilla.new/plugin/oji/JEP/MRJPlugin.plugin/Contents/MacOS/MRJPlugin sind verschieden.
Dateien mozilla/plugin/oji/JEP/MRJPlugin.plugin/Contents/MacOS/MRJPlugin.jar und mozilla.new/plugin/oji/JEP/MRJPlugin.plugin/Contents/MacOS/MRJPlugin.jar sind verschieden.
Dateien mozilla/plugin/oji/JEP/MRJPlugin.plugin/Contents/Resources/English.lproj/InfoPlist.strings und mozilla.new/plugin/oji/JEP/MRJPlugin.plugin/Contents/Resources/English.lproj/InfoPlist.strings sind verschieden.
Dateien mozilla/plugin/oji/JEP/MRJPlugin.plugin/Contents/Resources/MRJPlugin.rsrc und mozilla.new/plugin/oji/JEP/MRJPlugin.plugin/Contents/Resources/MRJPlugin.rsrc sind verschieden.
diff -uprN --exclude=CVS mozilla/plugin/oji/MRJCarbon/plugin/MRJPlugin.pbproj/project.pbxproj mozilla.new/plugin/oji/MRJCarbon/plugin/MRJPlugin.pbproj/project.pbxproj
--- mozilla/plugin/oji/MRJCarbon/plugin/MRJPlugin.pbproj/project.pbxproj	2003-06-11 07:11:30.000000000 +0200
+++ mozilla.new/plugin/oji/MRJCarbon/plugin/MRJPlugin.pbproj/project.pbxproj	2006-02-24 11:16:39.000000000 +0100
@@ -406,14 +406,14 @@
 		};
 		F59D146D02AC308301000104 = {
 			isa = PBXFileReference;
-			name = _Dialogs.rsrc;
-			path = Resources/_Dialogs.rsrc;
+			name = Dialogs.rsrc;
+			path = Resources/Dialogs.rsrc;
 			refType = 2;
 		};
 		F59D146E02AC308301000104 = {
 			isa = PBXFileReference;
-			name = _Strings.rsrc;
-			path = Resources/_Strings.rsrc;
+			name = Strings.rsrc;
+			path = Resources/Strings.rsrc;
 			refType = 2;
 		};
 		F59D146F02AC308301000104 = {
Dateien mozilla/plugin/oji/MRJCarbon/plugin/Resources/Dialogs.rsrc und mozilla.new/plugin/oji/MRJCarbon/plugin/Resources/Dialogs.rsrc sind verschieden.
diff -uprN --exclude=CVS mozilla/plugin/oji/MRJCarbon/plugin/Resources/Makefile mozilla.new/plugin/oji/MRJCarbon/plugin/Resources/Makefile
--- mozilla/plugin/oji/MRJCarbon/plugin/Resources/Makefile	2003-06-11 07:11:33.000000000 +0200
+++ mozilla.new/plugin/oji/MRJCarbon/plugin/Resources/Makefile	2006-02-24 11:16:39.000000000 +0100
@@ -1,15 +1,3 @@
-# decodes resource files from AppleSingle to Resource Manager format.
-
-ASDECODE = ../../../../../dist/bin/asdecode
-RESOURCE_FILES = _Dialogs.rsrc _Strings.rsrc
-
-all:  $(RESOURCE_FILES)
-
-_Dialogs.rsrc:  Dialogs.rsrc
-	$(ASDECODE) Dialogs.rsrc _Dialogs.rsrc
-
-_Strings.rsrc:  Strings.rsrc
-	$(ASDECODE) Strings.rsrc _Strings.rsrc
-
-clean:
-	rm -f $(RESOURCE_FILES)
+all:
+	@echo These .rsrc files are now distributed as resources in data forks.
+	@echo No further processing is necessary.
Dateien mozilla/plugin/oji/MRJCarbon/plugin/Resources/Strings.rsrc und mozilla.new/plugin/oji/MRJCarbon/plugin/Resources/Strings.rsrc sind verschieden.
Dateien mozilla/plugin/oji/MRJCarbon/plugin/Resources/Version.rsrc und mozilla.new/plugin/oji/MRJCarbon/plugin/Resources/Version.rsrc sind verschieden.
diff -uprN --exclude=CVS mozilla/rdf/base/src/nsRDFXMLSerializer.cpp mozilla.new/rdf/base/src/nsRDFXMLSerializer.cpp
--- mozilla/rdf/base/src/nsRDFXMLSerializer.cpp	2005-07-01 10:22:17.000000000 +0200
+++ mozilla.new/rdf/base/src/nsRDFXMLSerializer.cpp	2006-02-24 11:16:39.000000000 +0100
@@ -180,10 +180,7 @@ nsRDFXMLSerializer::AddNameSpace(nsIAtom
     if (!prefix) {
         // Make up a prefix, we don't want default namespaces, so
         // that we can use QNames for elements and attributes alike.
-        nsCAutoString pref;
-        pref.AssignLiteral("NS");
-        pref.AppendInt(++mPrefixID, 10);
-        prefix = do_GetAtom(pref);
+        prefix = EnsureNewPrefix();
     }
     mNameSpaces.Put(aURI, prefix);
     return NS_OK;
@@ -220,6 +217,28 @@ rdf_BlockingWrite(nsIOutputStream* strea
     return rdf_BlockingWrite(stream, utf8.get(), utf8.Length());
 }
 
+already_AddRefed<nsIAtom>
+nsRDFXMLSerializer::EnsureNewPrefix()
+{
+    nsCAutoString qname;
+    nsCOMPtr<nsIAtom> prefix;
+    PRBool isNewPrefix;
+    do {
+        isNewPrefix = PR_TRUE;
+        qname.AssignLiteral("NS");
+        qname.AppendInt(++mPrefixID, 10);
+        prefix = do_GetAtom(qname);
+        nsNameSpaceMap::const_iterator iter = mNameSpaces.first();
+        while (iter != mNameSpaces.last() && isNewPrefix) {
+            isNewPrefix = (iter->mPrefix != prefix);
+            ++iter;
+        } 
+    } while (!isNewPrefix);
+    nsIAtom* outPrefix = nsnull;
+    prefix.swap(outPrefix);
+    return outPrefix;
+}
+
 // This converts a property resource (like
 // "http://www.w3.org/TR/WD-rdf-syntax#Description") into a QName
 // ("RDF:Description"), and registers the namespace, if it's made up.
@@ -253,12 +272,9 @@ nsRDFXMLSerializer::RegisterQName(nsIRDF
 
     // Take whatever is to the right of the '#' or '/' and call it the
     // local name, make up a prefix.
-    qname.AssignLiteral("NS");
-    qname.AppendInt(++mPrefixID, 10);
-    {
-        nsCOMPtr<nsIAtom> prefix = do_GetAtom(qname);
-        mNameSpaces.Put(StringHead(uri, i+1), prefix);
-    }
+    nsCOMPtr<nsIAtom> prefix = EnsureNewPrefix();
+    mNameSpaces.Put(StringHead(uri, i+1), prefix);
+    prefix->ToUTF8String(qname);
     qname.Append(':');
     qname += StringTail(uri, uri.Length() - (i + 1));
 
diff -uprN --exclude=CVS mozilla/rdf/base/src/nsRDFXMLSerializer.h mozilla.new/rdf/base/src/nsRDFXMLSerializer.h
--- mozilla/rdf/base/src/nsRDFXMLSerializer.h	2005-06-24 09:49:43.000000000 +0200
+++ mozilla.new/rdf/base/src/nsRDFXMLSerializer.h	2006-02-24 11:16:39.000000000 +0100
@@ -79,6 +79,8 @@ protected:
     RegisterQName(nsIRDFResource* aResource);
     nsresult
     GetQName(nsIRDFResource* aResource, nsCString& aQName);
+    already_AddRefed<nsIAtom>
+    EnsureNewPrefix();
 
     nsresult
     SerializeInlineAssertion(nsIOutputStream* aStream,
diff -uprN --exclude=CVS mozilla/security/coreconf/Darwin.mk mozilla.new/security/coreconf/Darwin.mk
--- mozilla/security/coreconf/Darwin.mk	2006-01-09 06:47:32.000000000 +0100
+++ mozilla.new/security/coreconf/Darwin.mk	2006-03-03 07:10:28.000000000 +0100
@@ -43,12 +43,16 @@ CC		= cc
 CCC		= c++
 RANLIB		= ranlib
 
-ifeq (86,$(findstring 86,$(OS_TEST)))
+ifndef CPU_ARCH
+# When cross-compiling, CPU_ARCH should already be defined as the target
+# architecture, set to powerpc or i386.
+CPU_ARCH	:= $(shell uname -p)
+endif
+
+ifeq (,$(filter-out i%86,$(CPU_ARCH)))
 OS_REL_CFLAGS	= -Di386
-CPU_ARCH	= i386
 else
 OS_REL_CFLAGS	= -Dppc
-CPU_ARCH	= ppc
 endif
 
 ifneq (,$(MACOS_SDK_DIR))
@@ -59,13 +63,13 @@ ifneq (,$(MACOS_SDK_DIR))
 
     ifeq (,$(filter-out 2 3,$(GCC_VERSION_MAJOR)))
         # GCC <= 3
-	DARWIN_SDK_FRAMEWORKS = -F$(MACOS_SDK_DIR)/System/Library/Frameworks
+        DARWIN_SDK_FRAMEWORKS = -F$(MACOS_SDK_DIR)/System/Library/Frameworks
         ifneq (,$(shell find $(MACOS_SDK_DIR)/Library/Frameworks -maxdepth 0))
             DARWIN_SDK_FRAMEWORKS += -F$(MACOS_SDK_DIR)/Library/Frameworks
         endif
         DARWIN_SDK_CFLAGS = -nostdinc -isystem $(MACOS_SDK_DIR)/usr/include/gcc/darwin/$(GCC_VERSION) -isystem $(MACOS_SDK_DIR)/usr/include $(DARWIN_SDK_FRAMEWORKS)
         DARWIN_SDK_LDFLAGS = -L$(MACOS_SDK_DIR)/usr/lib/gcc/darwin -L$(MACOS_SDK_DIR)/usr/lib/gcc/darwin/$(GCC_VERSION_FULL) -L$(MACOS_SDK_DIR)/usr/lib
-        DARWIN_SDK_DSOFLAGS = $(DARWIN_SDK_LDFLAGS) $(DARWIN_SDK_FRAMEWORKS)
+        DARWIN_SDK_SHLIBFLAGS = $(DARWIN_SDK_LDFLAGS) $(DARWIN_SDK_FRAMEWORKS)
         NEXT_ROOT = $(MACOS_SDK_DIR)
         export NEXT_ROOT
     else
@@ -75,12 +79,12 @@ ifneq (,$(MACOS_SDK_DIR))
             # gcc > 4.0.0 passes -syslibroot to ld based on -isysroot.
             # Don't add -isysroot to DARWIN_SDK_LDFLAGS, because the programs
             # that are linked with those flags also get DARWIN_SDK_CFLAGS.
-            DARWIN_SDK_DSOFLAGS = -isysroot $(MACOS_SDK_DIR)
+            DARWIN_SDK_SHLIBFLAGS = -isysroot $(MACOS_SDK_DIR)
         else
             # gcc 4.0.0 doesn't pass -syslibroot to ld, it needs to be
             # explicit.
             DARWIN_SDK_LDFLAGS = -Wl,-syslibroot,$(MACOS_SDK_DIR)
-            DARWIN_SDK_DSOFLAGS = $(DARWIN_SDK_LDFLAGS)
+            DARWIN_SDK_SHLIBFLAGS = $(DARWIN_SDK_LDFLAGS)
         endif
     endif
 
@@ -105,10 +109,11 @@ endif
 
 ARCH		= darwin
 
+DSO_CFLAGS	= -fPIC
 # May override this with -bundle to create a loadable module.
-DSO_LDOPTS	= -dynamiclib -compatibility_version 1 -current_version 1 -install_name @executable_path/$(notdir $@) -headerpad_max_install_names $(DARWIN_SDK_DSOFLAGS)
+DSO_LDOPTS	= -dynamiclib -compatibility_version 1 -current_version 1 -install_name @executable_path/$(notdir $@) -headerpad_max_install_names
 
-MKSHLIB		= $(CC) -arch $(CPU_ARCH) $(DSO_LDOPTS)
+MKSHLIB		= $(CC) $(DSO_LDOPTS) $(DARWIN_SDK_SHLIBFLAGS)
 DLL_SUFFIX	= dylib
 PROCESS_MAP_FILE = grep -v ';+' $(LIBRARY_NAME).def | grep -v ';-' | \
                 sed -e 's; DATA ;;' -e 's,;;,,' -e 's,;.*,,' -e 's,^,_,' > $@
diff -uprN --exclude=CVS mozilla/security/manager/ssl/src/nsCrypto.cpp mozilla.new/security/manager/ssl/src/nsCrypto.cpp
--- mozilla/security/manager/ssl/src/nsCrypto.cpp	2005-07-28 20:15:20.000000000 +0200
+++ mozilla.new/security/manager/ssl/src/nsCrypto.cpp	2006-03-04 21:31:09.000000000 +0100
@@ -69,6 +69,7 @@
 #include "nsIDOMCryptoDialogs.h"
 #include "nsIFormSigningDialog.h"
 #include "nsIProxyObjectManager.h"
+#include "nsIJSContextStack.h"
 #include "jsapi.h"
 #include "jsdbgapi.h"
 #include <ctype.h>
@@ -243,7 +244,7 @@ nsCrypto::~nsCrypto()
 NS_IMETHODIMP
 nsCrypto::SetEnableSmartCardEvents(PRBool aEnable)
 {
-  nsresult rv;
+  nsresult rv = NS_OK;
 
   // this has the side effect of starting the nssComponent (and initializing
   // NSS) even if it isn't already going. Starting the nssComponent is a 
@@ -1773,15 +1774,23 @@ nsCryptoRunnable::Run()
   if (NS_FAILED(rv))
     return NS_ERROR_FAILURE;
 
+  // make sure the right context is on the stack. must not return w/out popping
+  nsCOMPtr<nsIJSContextStack> stack(do_GetService("@mozilla.org/js/xpc/ContextStack;1"));
+  if (!stack || NS_FAILED(stack->Push(cx))) {
+    return NS_ERROR_FAILURE;
+  }
+
   jsval retval;
   if (JS_EvaluateScriptForPrincipals(cx, m_args->m_scope, principals,
                                      m_args->m_jsCallback, 
                                      strlen(m_args->m_jsCallback),
                                      nsnull, 0,
                                      &retval) != JS_TRUE) {
-    return NS_ERROR_FAILURE;
+    rv = NS_ERROR_FAILURE;
   }
-  return NS_OK;
+
+  stack->Pop(nsnull);
+  return rv;
 }
 
 //Quick helper function to check if a newly issued cert
@@ -2522,7 +2531,8 @@ nsPkcs11::~nsPkcs11()
 PRBool
 confirm_user(const PRUnichar *message)
 {
-  PRBool confirmation = PR_FALSE;
+  PRInt32 buttonPressed = 1; // If the user exits by clicking the close box, assume No (button 1)
+
   nsCOMPtr<nsIWindowWatcher> wwatch(do_GetService(NS_WINDOWWATCHER_CONTRACTID));
   nsCOMPtr<nsIPrompt> prompter;
   if (wwatch)
@@ -2531,11 +2541,16 @@ confirm_user(const PRUnichar *message)
   if (prompter) {
     nsPSMUITracker tracker;
     if (!tracker.isUIForbidden()) {
-      prompter->Confirm(0, message, &confirmation);
+      prompter->ConfirmEx(0, message,
+                          (nsIPrompt::BUTTON_DELAY_ENABLE) +
+                          (nsIPrompt::BUTTON_POS_1_DEFAULT) +
+                          (nsIPrompt::BUTTON_TITLE_OK * nsIPrompt::BUTTON_POS_0) +
+                          (nsIPrompt::BUTTON_TITLE_CANCEL * nsIPrompt::BUTTON_POS_1),
+                          nsnull, nsnull, nsnull, nsnull, nsnull, &buttonPressed);
     }
   }
 
-  return confirmation;
+  return (buttonPressed == 0);
 }
 
 //Delete a PKCS11 module from the user's profile.
diff -uprN --exclude=CVS mozilla/toolkit/components/autocomplete/public/nsIAutoCompleteResultTypes.idl mozilla.new/toolkit/components/autocomplete/public/nsIAutoCompleteResultTypes.idl
--- mozilla/toolkit/components/autocomplete/public/nsIAutoCompleteResultTypes.idl	2005-02-01 18:06:59.000000000 +0100
+++ mozilla.new/toolkit/components/autocomplete/public/nsIAutoCompleteResultTypes.idl	2006-03-12 20:03:26.000000000 +0100
@@ -81,3 +81,10 @@ interface nsIAutoCompleteMdbResult : nsI
 
   long getIntRowValue(in nsIMdbRow row, in mdb_column col);
 };
+
+/* noscript */
+[uuid(148C9DC5-0FBB-408B-80FE-544F6A85B433)]
+interface nsIAutoCompleteMdbResult2 : nsIAutoCompleteMdbResult
+{
+  attribute boolean reverseByteOrder;
+};
diff -uprN --exclude=CVS mozilla/toolkit/components/autocomplete/src/nsAutoCompleteMdbResult.cpp mozilla.new/toolkit/components/autocomplete/src/nsAutoCompleteMdbResult.cpp
--- mozilla/toolkit/components/autocomplete/src/nsAutoCompleteMdbResult.cpp	2005-02-01 18:07:00.000000000 +0100
+++ mozilla.new/toolkit/components/autocomplete/src/nsAutoCompleteMdbResult.cpp	2006-03-12 20:03:26.000000000 +0100
@@ -39,10 +39,20 @@
 #include "nsCOMPtr.h"
 #include "nsCRT.h"
 
+static void SwapBytes(PRUnichar* aDest, const PRUnichar* aSrc, PRUint32 aLen)
+{
+  for(PRUint32 i = 0; i < aLen; i++)
+  {
+    PRUnichar aChar = *aSrc++;
+    *aDest++ = (0xff & (aChar >> 8)) | (aChar << 8);
+  }
+}
+
 NS_INTERFACE_MAP_BEGIN(nsAutoCompleteMdbResult)
   NS_INTERFACE_MAP_ENTRY(nsIAutoCompleteResult)
   NS_INTERFACE_MAP_ENTRY(nsIAutoCompleteBaseResult)
   NS_INTERFACE_MAP_ENTRY(nsIAutoCompleteMdbResult)
+  NS_INTERFACE_MAP_ENTRY(nsIAutoCompleteMdbResult2)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIAutoCompleteResult)
 NS_INTERFACE_MAP_END
 
@@ -51,7 +61,8 @@ NS_IMPL_RELEASE(nsAutoCompleteMdbResult)
 
 nsAutoCompleteMdbResult::nsAutoCompleteMdbResult() :
   mDefaultIndex(-1),
-  mSearchResult(nsIAutoCompleteResult::RESULT_IGNORED)
+  mSearchResult(nsIAutoCompleteResult::RESULT_IGNORED),
+  mReverseByteOrder(PR_FALSE)
 {
 }
 
@@ -245,9 +256,21 @@ nsAutoCompleteMdbResult::GetRowValue(nsI
     return NS_OK;
   
   switch (yarn.mYarn_Form) {
-    case 0: // unicode
-      aValue.Assign((const PRUnichar *)yarn.mYarn_Buf, yarn.mYarn_Fill/sizeof(PRUnichar));
+    case 0: { // unicode
+      PRUint32 len = yarn.mYarn_Fill / sizeof(PRUnichar);
+      if (mReverseByteOrder) {
+        // The mdb file is other-endian, byte-swap the result
+        PRUnichar *swapval = new PRUnichar[len];
+        if (!swapval)
+          return NS_ERROR_OUT_OF_MEMORY;
+        SwapBytes(swapval, (const PRUnichar *)yarn.mYarn_Buf, len);
+        aValue.Assign(swapval, len);
+        delete swapval;
+      }
+      else
+        aValue.Assign((const PRUnichar *)yarn.mYarn_Buf, len);
       break;
+    }
     case 1: // utf 8
       aValue.Assign(NS_ConvertUTF8toUCS2((const char*)yarn.mYarn_Buf, yarn.mYarn_Fill));
       break;
@@ -295,3 +318,20 @@ nsAutoCompleteMdbResult::GetIntRowValue(
   
   return NS_OK;
 }
+
+////////////////////////////////////////////////////////////////////////
+//// nsIAutoCompleteMdbResult2
+
+NS_IMETHODIMP
+nsAutoCompleteMdbResult::GetReverseByteOrder(PRBool *aReverseByteOrder)
+{
+  *aReverseByteOrder = mReverseByteOrder;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsAutoCompleteMdbResult::SetReverseByteOrder(PRBool aReverseByteOrder)
+{
+  mReverseByteOrder = aReverseByteOrder;
+  return NS_OK;
+}
diff -uprN --exclude=CVS mozilla/toolkit/components/autocomplete/src/nsAutoCompleteMdbResult.h mozilla.new/toolkit/components/autocomplete/src/nsAutoCompleteMdbResult.h
--- mozilla/toolkit/components/autocomplete/src/nsAutoCompleteMdbResult.h	2005-02-01 18:07:00.000000000 +0100
+++ mozilla.new/toolkit/components/autocomplete/src/nsAutoCompleteMdbResult.h	2006-03-12 20:03:26.000000000 +0100
@@ -44,7 +44,7 @@
 #include "nsArray.h"
 #include "mdb.h"
 
-class nsAutoCompleteMdbResult : public nsIAutoCompleteMdbResult
+class nsAutoCompleteMdbResult : public nsIAutoCompleteMdbResult2
 {
 public:
   NS_DECL_ISUPPORTS
@@ -55,6 +55,7 @@ public:
 
   NS_DECL_NSIAUTOCOMPLETEBASERESULT
   NS_DECL_NSIAUTOCOMPLETEMDBRESULT
+  NS_DECL_NSIAUTOCOMPLETEMDBRESULT2
 
 protected:
   nsCOMArray<nsIMdbRow> mResults;
@@ -71,6 +72,8 @@ protected:
   PRInt16   mValueType;
   mdb_scope mCommentToken;
   PRInt16   mCommentType;
+
+  PRPackedBool mReverseByteOrder;
 };
 
 #endif // __nsAutoCompleteResultBase__
diff -uprN --exclude=CVS mozilla/toolkit/components/history/src/nsGlobalHistory.cpp mozilla.new/toolkit/components/history/src/nsGlobalHistory.cpp
--- mozilla/toolkit/components/history/src/nsGlobalHistory.cpp	2006-01-09 06:48:17.000000000 +0100
+++ mozilla.new/toolkit/components/history/src/nsGlobalHistory.cpp	2006-03-12 20:03:28.000000000 +0100
@@ -4203,7 +4203,7 @@ nsGlobalHistory::StartSearch(const nsASt
 
   NS_ENSURE_SUCCESS(OpenDB(), NS_ERROR_FAILURE);
   
-  nsCOMPtr<nsIAutoCompleteMdbResult> result;
+  nsCOMPtr<nsIAutoCompleteMdbResult2> result;
   if (aSearchString.IsEmpty()) {
     AutoCompleteTypedSearch(getter_AddRefs(result));
   } else {
@@ -4222,7 +4222,7 @@ nsGlobalHistory::StartSearch(const nsASt
     
     // perform the actual search here
     nsresult rv = AutoCompleteSearch(filtered, &exclude,
-                                     NS_STATIC_CAST(nsIAutoCompleteMdbResult *,
+                                     NS_STATIC_CAST(nsIAutoCompleteMdbResult2 *,
                                                     aPreviousResult),
                                      getter_AddRefs(result));
     NS_ENSURE_SUCCESS(rv, rv);
@@ -4246,7 +4246,7 @@ nsGlobalHistory::StopSearch()
 //
 
 nsresult
-nsGlobalHistory::AutoCompleteTypedSearch(nsIAutoCompleteMdbResult **aResult)
+nsGlobalHistory::AutoCompleteTypedSearch(nsIAutoCompleteMdbResult2 **aResult)
 {
   mdb_count count;
   mdb_err err = mTable->GetCount(mEnv, &count);
@@ -4257,15 +4257,16 @@ nsGlobalHistory::AutoCompleteTypedSearch
   NS_ENSURE_TRUE(!err, NS_ERROR_FAILURE);
 
   nsresult rv;
-  nsCOMPtr<nsIAutoCompleteMdbResult> result = do_CreateInstance("@mozilla.org/autocomplete/mdb-result;1", &rv);
+  nsCOMPtr<nsIAutoCompleteMdbResult2> result = do_CreateInstance("@mozilla.org/autocomplete/mdb-result;1", &rv);
   NS_ENSURE_SUCCESS(rv, rv);
   result->Init(mEnv, mTable);
-  result->SetTokens(kToken_URLColumn, nsIAutoCompleteMdbResult::kCharType, kToken_NameColumn, nsIAutoCompleteMdbResult::kUnicharType);
+  result->SetTokens(kToken_URLColumn, nsIAutoCompleteMdbResult2::kCharType, kToken_NameColumn, nsIAutoCompleteMdbResult2::kUnicharType);
+  result->SetReverseByteOrder(mReverseByteOrder);
 
-  nsIMdbRow *row = nsnull;
+  nsCOMPtr<nsIMdbRow> row;
   mdb_pos pos;
   do {
-    rowCursor->PrevRow(mEnv, &row, &pos);
+    rowCursor->PrevRow(mEnv, getter_AddRefs(row), &pos);
     if (!row) break;
     
     if (HasCell(mEnv, row, kToken_TypedColumn)) {
@@ -4293,8 +4294,8 @@ nsGlobalHistory::AutoCompleteTypedSearch
 nsresult
 nsGlobalHistory::AutoCompleteSearch(const nsAString &aSearchString,
                                     AutocompleteExclude *aExclude,
-                                    nsIAutoCompleteMdbResult *aPrevResult,
-                                    nsIAutoCompleteMdbResult **aResult)
+                                    nsIAutoCompleteMdbResult2 *aPrevResult,
+                                    nsIAutoCompleteMdbResult2 **aResult)
 {
   // determine if we can skip searching the whole history and only search
   // through the previous search results
@@ -4325,10 +4326,11 @@ nsGlobalHistory::AutoCompleteSearch(cons
         
     // Create and initialize a new result object
     nsresult rv = NS_OK;
-    nsCOMPtr<nsIAutoCompleteMdbResult> result = do_CreateInstance("@mozilla.org/autocomplete/mdb-result;1", &rv);
+    nsCOMPtr<nsIAutoCompleteMdbResult2> result = do_CreateInstance("@mozilla.org/autocomplete/mdb-result;1", &rv);
     NS_ENSURE_SUCCESS(rv, rv);
     result->Init(mEnv, mTable);
-    result->SetTokens(kToken_URLColumn, nsIAutoCompleteMdbResult::kCharType, kToken_NameColumn, nsIAutoCompleteMdbResult::kUnicharType);
+    result->SetTokens(kToken_URLColumn, nsIAutoCompleteMdbResult2::kCharType, kToken_NameColumn, nsIAutoCompleteMdbResult2::kUnicharType);
+    result->SetReverseByteOrder(mReverseByteOrder);
     result->SetSearchString(aSearchString);
 
     // Get a cursor to iterate through all rows in the database
diff -uprN --exclude=CVS mozilla/toolkit/components/history/src/nsGlobalHistory.h mozilla.new/toolkit/components/history/src/nsGlobalHistory.h
--- mozilla/toolkit/components/history/src/nsGlobalHistory.h	2005-08-10 22:21:44.000000000 +0200
+++ mozilla.new/toolkit/components/history/src/nsGlobalHistory.h	2006-03-12 20:03:28.000000000 +0100
@@ -213,11 +213,11 @@ protected:
   nsStringArray mIgnoreSchemes;
   nsStringArray mIgnoreHostnames;
   
-  nsresult AutoCompleteTypedSearch(nsIAutoCompleteMdbResult **aResult);
+  nsresult AutoCompleteTypedSearch(nsIAutoCompleteMdbResult2 **aResult);
   nsresult AutoCompleteSearch(const nsAString& aSearchString,
                               AutocompleteExclude* aExclude,
-                              nsIAutoCompleteMdbResult* aPrevResult,
-                              nsIAutoCompleteMdbResult** aResult);
+                              nsIAutoCompleteMdbResult2* aPrevResult,
+                              nsIAutoCompleteMdbResult2** aResult);
   void AutoCompleteCutPrefix(nsAString& aURL, AutocompleteExclude* aExclude);
   void AutoCompleteGetExcludeInfo(const nsAString& aURL, AutocompleteExclude* aExclude);
   nsString AutoCompletePrefilter(const nsAString& aSearchString);
diff -uprN --exclude=CVS mozilla/toolkit/components/satchel/src/nsFormFillController.cpp mozilla.new/toolkit/components/satchel/src/nsFormFillController.cpp
--- mozilla/toolkit/components/satchel/src/nsFormFillController.cpp	2005-06-16 01:52:43.000000000 +0200
+++ mozilla.new/toolkit/components/satchel/src/nsFormFillController.cpp	2006-03-12 20:03:28.000000000 +0100
@@ -486,14 +486,14 @@ nsFormFillController::StartSearch(const 
                                   nsIAutoCompleteResult *aPreviousResult, nsIAutoCompleteObserver *aListener)
 {
   nsCOMPtr<nsIAutoCompleteResult> result;
-  nsCOMPtr<nsIAutoCompleteMdbResult> mdbResult = do_QueryInterface(aPreviousResult);
+  nsCOMPtr<nsIAutoCompleteMdbResult2> mdbResult = do_QueryInterface(aPreviousResult);
 
   nsPasswordManager* passMgr = nsPasswordManager::GetInstance();
   if (!passMgr)
     return NS_ERROR_OUT_OF_MEMORY;
 
   // Only hand off a previous result to the password manager if it's
-  // a password manager result (i.e. not an nsIAutoCompleteMdbResult).
+  // a password manager result (i.e. not an nsIAutoCompleteMdbResult2).
 
   if (!passMgr->AutoCompleteSearch(aSearchString,
                                    mdbResult ? nsnull : aPreviousResult,
diff -uprN --exclude=CVS mozilla/toolkit/components/satchel/src/nsFormHistory.cpp mozilla.new/toolkit/components/satchel/src/nsFormHistory.cpp
--- mozilla/toolkit/components/satchel/src/nsFormHistory.cpp	2005-06-19 20:09:51.000000000 +0200
+++ mozilla.new/toolkit/components/satchel/src/nsFormHistory.cpp	2006-03-12 20:03:28.000000000 +0100
@@ -61,6 +61,15 @@
 #include "nsVoidArray.h"
 #include "nsCOMArray.h"
 
+static void SwapBytes(PRUnichar* aDest, const PRUnichar* aSrc, PRUint32 aLen)
+{
+  for(PRUint32 i = 0; i < aLen; i++)
+  {
+    PRUnichar aChar = *aSrc++;
+    *aDest++ = (0xff & (aChar >> 8)) | (aChar << 8);
+  }
+}
+
 #define PREF_FORMFILL_BRANCH "browser.formfill."
 #define PREF_FORMFILL_ENABLE "enable"
 
@@ -86,7 +95,8 @@ PRBool nsFormHistory::gPrefsInitialized 
 nsFormHistory::nsFormHistory() :
   mEnv(nsnull),
   mStore(nsnull),
-  mTable(nsnull)
+  mTable(nsnull),
+  mReverseByteOrder(PR_FALSE)
 {
 }
 
@@ -263,6 +273,9 @@ NS_IMETHODIMP
 nsFormHistory::RemoveAllEntries()
 {
   nsresult rv = RemoveEntriesInternal(nsnull);
+
+  if (NS_SUCCEEDED(rv))
+    rv = InitByteOrder(PR_TRUE);
   
   rv |= Flush();
   
@@ -424,18 +437,23 @@ nsFormHistory::OpenDatabase()
   historyFile->GetNativePath(filePath);
   PRBool exists = PR_TRUE;
   historyFile->Exists(&exists);
+
+  PRBool createdNew = PR_FALSE;
   
   if (!exists || NS_FAILED(rv = OpenExistingFile(filePath.get()))) {
     // If the file doesn't exist, or we fail trying to open it,
     // then make sure it is deleted and then create an empty database file
     historyFile->Remove(PR_FALSE);
     rv = CreateNewFile(filePath.get());
+    createdNew = PR_TRUE;
   }
   NS_ENSURE_SUCCESS(rv, rv);
 
   // Get the initial size of the file, needed later for Commit
   historyFile->GetFileSize(&mFileSizeOnDisk);
 
+  rv = InitByteOrder(createdNew);
+
   /* // TESTING: Add a row to the database
   nsAutoString foopy;
   foopy.AssignWithConversion("foopy");
@@ -460,7 +478,7 @@ nsFormHistory::OpenDatabase()
     printf("ROW: %s - %s\n", ToNewCString(name), ToNewCString(value));
   } */
 
-  return NS_OK;
+  return rv;
 }
 
 nsresult
@@ -499,6 +517,10 @@ nsFormHistory::OpenExistingFile(const ch
     return NS_ERROR_FAILURE;
   }
 
+  err = mTable->GetMetaRow(mEnv, &oid, nsnull, getter_AddRefs(mMetaRow));
+  if (err)
+    NS_WARNING("Could not get meta row");
+
   if (NS_FAILED(thumbErr))
     err = thumbErr;
 
@@ -526,6 +548,13 @@ nsFormHistory::CreateNewFile(const char 
   err = mStore->NewTable(mEnv, kToken_RowScope, kToken_Kind, PR_TRUE, nsnull, &mTable);
   NS_ENSURE_TRUE(!err && mTable, NS_ERROR_FAILURE);
 
+  mdbOid oid = {kToken_RowScope, 1};
+  err = mTable->GetMetaRow(mEnv, &oid, nsnull, getter_AddRefs(mMetaRow));
+  if (err) {
+    NS_WARNING("Could not get meta row");
+    return NS_ERROR_FAILURE;
+  }
+
    // oldTable will only be set if we detected a corrupt db, and are 
    // trying to restore data from it.
   if (oldTable)
@@ -547,6 +576,8 @@ nsFormHistory::CloseDatabase()
 {
   Flush();
 
+  mMetaRow = nsnull;
+
   if (mTable)
     mTable->Release();
 
@@ -583,6 +614,9 @@ nsFormHistory::CreateTokens()
   err = mStore->StringToToken(mEnv, "Name", &kToken_NameColumn);
   if (err != 0) return NS_ERROR_FAILURE;
 
+  err = mStore->StringToToken(mEnv, "ByteOrder", &kToken_ByteOrder);
+  if (err != 0) return NS_ERROR_FAILURE;
+
   return NS_OK;
 }
 
@@ -641,7 +675,7 @@ nsFormHistory::CopyRowsFromTable(nsIMdbT
     rowId.mOid_Id = mdb_id(-1);
 
     nsCOMPtr<nsIMdbRow> newRow;
-    mdb_err err = mTable->NewRow(mEnv, &rowId, getter_AddRefs(newRow));
+    mTable->NewRow(mEnv, &rowId, getter_AddRefs(newRow));
     newRow->SetRow(mEnv, row);
     mTable->AddRow(mEnv, newRow);
   } while (row);
@@ -683,9 +717,23 @@ nsresult
 nsFormHistory::SetRowValue(nsIMdbRow *aRow, mdb_column aCol, const nsAString &aValue)
 {
   PRInt32 len = aValue.Length() * sizeof(PRUnichar);
+  PRUnichar *swapval = nsnull;
+  mdbYarn yarn = {nsnull, len, len, 0, 0, nsnull};
+  const nsPromiseFlatString& buffer = PromiseFlatString(aValue);
+
+  if (mReverseByteOrder) {
+    swapval = new PRUnichar[aValue.Length()];
+    if (!swapval)
+      return NS_ERROR_OUT_OF_MEMORY;
+    SwapBytes(swapval, buffer.get(), aValue.Length());
+    yarn.mYarn_Buf = swapval;
+  }
+  else
+    yarn.mYarn_Buf = (void*)buffer.get();
 
-  mdbYarn yarn = {(void *)ToNewUnicode(aValue), len, len, 0, 0, nsnull};
   mdb_err err = aRow->AddColumn(mEnv, aCol, &yarn);
+
+  delete swapval;
   
   return err ? NS_ERROR_FAILURE : NS_OK;
 }
@@ -703,9 +751,20 @@ nsFormHistory::GetRowValue(nsIMdbRow *aR
     return NS_OK;
   
   switch (yarn.mYarn_Form) {
-    case 0: // unicode
-      aValue.Assign((const PRUnichar *)yarn.mYarn_Buf, yarn.mYarn_Fill/sizeof(PRUnichar));
+    case 0: { // unicode
+      PRUint32 len = yarn.mYarn_Fill / sizeof(PRUnichar);
+      if (mReverseByteOrder) {
+        PRUnichar *swapval = new PRUnichar[len];
+        if (!swapval)
+          return NS_ERROR_OUT_OF_MEMORY;
+        SwapBytes(swapval, (const PRUnichar*)yarn.mYarn_Buf, len);
+        aValue.Assign(swapval, len);
+        delete swapval;
+      }
+      else
+        aValue.Assign((const PRUnichar *)yarn.mYarn_Buf, len);
       break;
+    }
     default:
       return NS_ERROR_UNEXPECTED;
   }
@@ -716,7 +775,7 @@ nsFormHistory::GetRowValue(nsIMdbRow *aR
 nsresult
 nsFormHistory::AutoCompleteSearch(const nsAString &aInputName,
                                   const nsAString &aInputValue,
-                                  nsIAutoCompleteMdbResult *aPrevResult,
+                                  nsIAutoCompleteMdbResult2 *aPrevResult,
                                   nsIAutoCompleteResult **aResult)
 {
   if (!FormHistoryEnabled())
@@ -725,7 +784,7 @@ nsFormHistory::AutoCompleteSearch(const 
   nsresult rv = OpenDatabase(); // lazily ensure that the database is open
   NS_ENSURE_SUCCESS(rv, rv);
 
-  nsCOMPtr<nsIAutoCompleteMdbResult> result;
+  nsCOMPtr<nsIAutoCompleteMdbResult2> result;
   
   if (aPrevResult) {
     result = aPrevResult;
@@ -744,7 +803,8 @@ nsFormHistory::AutoCompleteSearch(const 
 
     result->SetSearchString(aInputValue);
     result->Init(mEnv, mTable);
-    result->SetTokens(kToken_ValueColumn, nsIAutoCompleteMdbResult::kUnicharType, nsnull, nsIAutoCompleteMdbResult::kUnicharType);
+    result->SetTokens(kToken_ValueColumn, nsIAutoCompleteMdbResult2::kUnicharType, nsnull, nsIAutoCompleteMdbResult2::kUnicharType);
+    result->SetReverseByteOrder(mReverseByteOrder);
 
     // Get a cursor to iterate through all rows in the database
     nsCOMPtr<nsIMdbTableRowCursor> rowCursor;
@@ -941,3 +1001,74 @@ nsFormHistory::RemoveEntriesInternal(con
   return (err == 0) ? NS_OK : NS_ERROR_FAILURE;
 
 }
+
+nsresult
+nsFormHistory::InitByteOrder(PRBool aForce)
+{
+  // bigEndian and littleEndian are endianness markers that are stored in
+  // the formhistory db as UTF-16.  Define them to be strings easily
+  // recognized in either endianness.
+  nsAutoString bigEndianByteOrder((PRUnichar*)"BBBB");
+  nsAutoString littleEndianByteOrder((PRUnichar*)"llll");
+#ifdef IS_BIG_ENDIAN
+  nsAutoString nativeByteOrder(bigEndianByteOrder);
+#else
+  nsAutoString nativeByteOrder(littleEndianByteOrder);
+#endif
+
+  nsAutoString fileByteOrder;
+  nsresult rv = NS_OK;
+
+  if (!aForce)
+    rv = GetByteOrder(fileByteOrder);
+
+  if (aForce || NS_FAILED(rv) ||
+      !(fileByteOrder.Equals(bigEndianByteOrder) ||
+        fileByteOrder.Equals(littleEndianByteOrder))) {
+#if defined(XP_MACOSX) && defined(IS_LITTLE_ENDIAN)
+    // The formhistory db did not carry endiannes information until the
+    // initial x86 Mac release.  There are a lot of users out there who
+    // will be switching from ppc versions to x86, and their unmarked
+    // formhistory files are big-endian.  On x86 Macs, unless aForce is set
+    // (indicating formhistory reset or a brand-new db), use big-endian byte
+    // ordering and turn swapping on.
+    if (aForce) {
+      mReverseByteOrder = PR_FALSE;
+      rv = SaveByteOrder(nativeByteOrder);
+    }
+    else {
+      mReverseByteOrder = PR_TRUE;
+      rv = SaveByteOrder(bigEndianByteOrder);
+    }
+#else
+    mReverseByteOrder = PR_FALSE;
+    rv = SaveByteOrder(nativeByteOrder);
+#endif
+  }
+  else
+    mReverseByteOrder = !fileByteOrder.Equals(nativeByteOrder);
+
+  return rv;
+}
+
+nsresult
+nsFormHistory::GetByteOrder(nsAString& aByteOrder)
+{
+  NS_ENSURE_SUCCESS(OpenDatabase(), NS_ERROR_FAILURE);
+
+  mdb_err err = GetRowValue(mMetaRow, kToken_ByteOrder, aByteOrder);
+  NS_ENSURE_FALSE(err, NS_ERROR_FAILURE);
+
+  return NS_OK;
+}
+
+nsresult
+nsFormHistory::SaveByteOrder(const nsAString& aByteOrder)
+{
+  NS_ENSURE_SUCCESS(OpenDatabase(), NS_ERROR_FAILURE);
+
+  mdb_err err = SetRowValue(mMetaRow, kToken_ByteOrder, aByteOrder);
+  NS_ENSURE_FALSE(err, NS_ERROR_FAILURE);
+
+  return NS_OK;
+}
diff -uprN --exclude=CVS mozilla/toolkit/components/satchel/src/nsFormHistory.h mozilla.new/toolkit/components/satchel/src/nsFormHistory.h
--- mozilla/toolkit/components/satchel/src/nsFormHistory.h	2005-02-01 18:07:04.000000000 +0100
+++ mozilla.new/toolkit/components/satchel/src/nsFormHistory.h	2006-03-12 20:03:28.000000000 +0100
@@ -69,7 +69,7 @@ public:
   static void ReleaseInstance(void);
 
   nsresult AutoCompleteSearch(const nsAString &aInputName, const nsAString &aInputValue,
-                              nsIAutoCompleteMdbResult *aPrevResult, nsIAutoCompleteResult **aNewResult);
+                              nsIAutoCompleteMdbResult2 *aPrevResult, nsIAutoCompleteResult **aNewResult);
 
   static mdb_column kToken_ValueColumn;
   static mdb_column kToken_NameColumn;
@@ -98,6 +98,10 @@ protected:
 
   nsresult RemoveEntriesInternal(const nsAString *aName);
 
+  nsresult InitByteOrder(PRBool aForce);
+  nsresult GetByteOrder(nsAString& aByteOrder);
+  nsresult SaveByteOrder(const nsAString& aByteOrder);
+
   static PRBool FormHistoryEnabled();
 
   static nsFormHistory *gFormHistory;
@@ -111,10 +115,13 @@ protected:
   nsIMdbStore* mStore;
   nsIMdbTable* mTable;
   PRInt64 mFileSizeOnDisk;
+  nsCOMPtr<nsIMdbRow> mMetaRow;
+  PRPackedBool mReverseByteOrder;
   
   // database tokens
   mdb_scope kToken_RowScope;
   mdb_kind kToken_Kind;
+  mdb_column kToken_ByteOrder;
 };
 
 #endif // __nsFormHistory__
diff -uprN --exclude=CVS mozilla/toolkit/components/typeaheadfind/src/nsTypeAheadFind.cpp mozilla.new/toolkit/components/typeaheadfind/src/nsTypeAheadFind.cpp
--- mozilla/toolkit/components/typeaheadfind/src/nsTypeAheadFind.cpp	2005-09-28 16:41:36.000000000 +0200
+++ mozilla.new/toolkit/components/typeaheadfind/src/nsTypeAheadFind.cpp	2006-02-24 11:15:58.000000000 +0100
@@ -299,7 +299,7 @@ nsTypeAheadFind::FindItNow(nsIPresShell 
       return NS_ERROR_FAILURE;
   }
 
-  nsPresContext* presContext = presShell->GetPresContext();
+  nsRefPtr<nsPresContext> presContext = presShell->GetPresContext();
 
   if (!presContext)
     return NS_ERROR_FAILURE;
@@ -351,7 +351,7 @@ nsTypeAheadFind::FindItNow(nsIPresShell 
                                     aIsFirstVisiblePreferred, 
                                     !aIsFirstVisiblePreferred || mStartFindRange,
                                     getter_AddRefs(presShell),
-                                    &presContext))) {
+                                    getter_AddRefs(presContext)))) {
     return NS_ERROR_FAILURE;
   }
 
@@ -497,7 +497,7 @@ nsTypeAheadFind::FindItNow(nsIPresShell 
                                         aIsRepeatingSameChar,
                                         aIsFirstVisiblePreferred, PR_FALSE,
                                         getter_AddRefs(presShell),
-                                        &presContext))) {
+                                        getter_AddRefs(presContext)))) {
         continue;
       }
 
@@ -582,8 +582,8 @@ nsTypeAheadFind::GetSearchContainers(nsI
   nsCOMPtr<nsIPresShell> presShell;
   docShell->GetPresShell(getter_AddRefs(presShell));
 
-  nsPresContext* presContext;
-  docShell->GetPresContext(&presContext);
+  nsRefPtr<nsPresContext> presContext;
+  docShell->GetPresContext(getter_AddRefs(presContext));
 
   if (!presShell || !presContext)
     return NS_ERROR_FAILURE;
diff -uprN --exclude=CVS mozilla/toolkit/content/widgets/tabbrowser.xml mozilla.new/toolkit/content/widgets/tabbrowser.xml
--- mozilla/toolkit/content/widgets/tabbrowser.xml	2005-10-23 20:45:50.000000000 +0200
+++ mozilla.new/toolkit/content/widgets/tabbrowser.xml	2006-02-24 11:15:58.000000000 +0100
@@ -650,10 +650,15 @@
                 this.mCurrentBrowser.focusedElement = document.commandDispatcher.focusedElement;
               }
 
-              if (this.mCurrentBrowser.focusedElement) {
+              if (this.mCurrentBrowser.focusedElement instanceof NSHTMLElement || 
+                  this.mCurrentBrowser.focusedElement instanceof XULElement) {
                 // Clear focus outline before we draw on top of it
                 this.mCurrentBrowser.focusedElement.blur();
               }
+              else {
+                // non-HTML/XUL elements have no blur method, see bug 323805
+                this.mCurrentBrowser.focusedElement = null;
+              }
               this.mCurrentBrowser.setAttribute("type", "content");
             }
             
@@ -745,7 +750,12 @@
 
             function setFocus(element) {
               document.commandDispatcher.suppressFocusScroll = true;
-              element.focus();
+
+              if (element instanceof Window ||
+                  element instanceof NSHTMLElement || 
+                  element instanceof XULElement) {
+                element.focus();
+              }
               document.commandDispatcher.suppressFocusScroll = false;
             }
 
@@ -2032,7 +2042,6 @@
         <![CDATA[
           this.mCurrentBrowser = this.mPanelContainer.childNodes[0].firstChild.nextSibling;
           this.mCurrentTab = this.mTabContainer.firstChild;
-          this.mTabBox.handleCtrlTab = !/Mac/.test(navigator.platform);
           document.addEventListener("keypress", this._keyEventHandler, false);
 
           var uniqueId = "panel" + Date.now();
diff -uprN --exclude=CVS mozilla/toolkit/library/Makefile.in mozilla.new/toolkit/library/Makefile.in
--- mozilla/toolkit/library/Makefile.in	2006-01-09 06:48:18.000000000 +0100
+++ mozilla.new/toolkit/library/Makefile.in	2006-02-24 11:15:58.000000000 +0100
@@ -85,7 +85,12 @@ CPPSRCS += dlldeps-zlib.cpp
 DEFINES += -DZLIB_INTERNAL
 endif
 
-LOCAL_INCLUDES += -I$(topsrcdir)/widget/src/windows
+LOCAL_INCLUDES += \
+	-I$(topsrcdir)/widget/src/windows \
+	-I$(topsrcdir)/widget/src/build \
+	$(NULL)
+
+RESFILE = xulrunner.res
 endif
 
 ifeq ($(OS_ARCH),WINNT)
diff -uprN --exclude=CVS mozilla/toolkit/library/xulrunner.rc mozilla.new/toolkit/library/xulrunner.rc
--- mozilla/toolkit/library/xulrunner.rc	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/toolkit/library/xulrunner.rc	2006-02-17 20:50:53.000000000 +0100
@@ -0,0 +1 @@
+#include "widget.rc"
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/downloads/content/downloads.js mozilla.new/toolkit/mozapps/downloads/content/downloads.js
--- mozilla/toolkit/mozapps/downloads/content/downloads.js	2005-09-06 18:10:35.000000000 +0200
+++ mozilla.new/toolkit/mozapps/downloads/content/downloads.js	2006-02-24 11:15:58.000000000 +0100
@@ -24,6 +24,7 @@
 #   Ben Goodger <ben@bengoodger.com> (v2.0)
 #   Dan Mosedale <dmose@mozilla.org>
 #   Fredrik Holmqvist <thesuckiestemail@yahoo.se>
+#   Josh Aas <josh@mozilla.com>
 #
 # Alternatively, the contents of this file may be used under the terms of
 # either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -59,7 +60,11 @@ var gActiveDownloads  = [];
 // opened by the xpinstall manager prevents the window from being closed after
 // each download completes (because xpinstall downloads are done sequentially, 
 // not concurrently) 
-var gCanAutoClose     = true;
+var gCanAutoClose   = true;
+
+// If the user has interacted with the window in a significant way, we should
+// not auto-close the window. Tough UI decisions about what is "significant."
+var gUserInteracted = false;
 
 ///////////////////////////////////////////////////////////////////////////////
 // Utility Functions 
@@ -182,14 +187,12 @@ function autoClose(aDownload)
     // For the moment, just use the simple heuristic that if this window was
     // opened by the download process, rather than by the user, it should auto-close
     // if the pref is set that way. If the user opened it themselves, it should
-    // not close until they explicitly close it. 
-    // We may like to revisit this in a bit more detail later, perhaps we want
-    // to keep it up if the user messes with it in a significant way.
+    // not close until they explicitly close it.
     var pref = Components.classes["@mozilla.org/preferences-service;1"]
                         .getService(Components.interfaces.nsIPrefBranch);
     var autoClose = pref.getBoolPref(PREF_BDM_CLOSEWHENDONE)
     if (autoClose && (!window.opener || window.opener.location.href == window.location.href) &&
-        gCanAutoClose)
+        gCanAutoClose && !gUserInteracted)
       gCloseDownloadManager();
   }
 }
@@ -422,6 +425,7 @@ function onDownloadOpenWith(aEvent)
 
 function onDownloadProperties(aEvent)
 {
+  gUserInteracted = true;
   window.openDialog("chrome://mozapps/content/downloads/downloadProperties.xul",
                     "_blank", "modal,centerscreen,chrome,resizable=no", aEvent.target.id);
 }
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/extensions/src/Makefile.in mozilla.new/toolkit/mozapps/extensions/src/Makefile.in
--- mozilla/toolkit/mozapps/extensions/src/Makefile.in	2005-06-08 00:20:34.000000000 +0200
+++ mozilla.new/toolkit/mozapps/extensions/src/Makefile.in	2006-02-24 11:15:58.000000000 +0100
@@ -48,11 +48,6 @@ EXTRA_COMPONENTS = nsExtensionManager.js
 
 include $(topsrcdir)/config/rules.mk
 
-DEFINES += -DOS_TARGET=\"$(OS_TARGET)\"
-ifdef TARGET_XPCOM_ABI
-DEFINES += -DTARGET_XPCOM_ABI=\"$(TARGET_XPCOM_ABI)\"
-endif
-
 nsExtensionManager.js: nsExtensionManager.js.in
 	$(PERL) $(MOZILLA_DIR)/config/preprocessor.pl $(DEFINES) $(ACDEFINES) $^ > $@ 
 
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/extensions/src/nsExtensionManager.js.in mozilla.new/toolkit/mozapps/extensions/src/nsExtensionManager.js.in
--- mozilla/toolkit/mozapps/extensions/src/nsExtensionManager.js.in	2005-10-21 03:27:44.000000000 +0200
+++ mozilla.new/toolkit/mozapps/extensions/src/nsExtensionManager.js.in	2006-02-24 11:15:58.000000000 +0100
@@ -84,16 +84,7 @@ const FILE_INSTALL_MANIFEST           = 
 const FILE_CONTENTS_MANIFEST          = "contents.rdf";
 const FILE_CHROME_MANIFEST            = "chrome.manifest";
 
-#expand const OS_TARGET               = __OS_TARGET__;
-
-#ifdef TARGET_XPCOM_ABI
-#expand const TARGET_XPCOM_ABI        = __TARGET_XPCOM_ABI__;
-#else
-// Provide a default for TARGET_XPCOM_ABI. It won't be compared to an item's metadata
-// (i.e. install.rdf can't specify e.g. WINNT_unknownABI as targetPlatform),
-// but it will be displayed in error messages and transmitted to update URLs.
-const TARGET_XPCOM_ABI                = "unknownABI";
-#endif
+const UNKNOWN_XPCOM_ABI               = "unknownABI";
 
 const FILE_LOGFILE                    = "extensionmanager.log";
 
@@ -162,6 +153,8 @@ var gApp  = null;
 var gPref = null;
 var gRDF  = null;
 var gOS   = null;
+var gXPCOMABI             = null;
+var gOSTarget             = null;
 var gConsole              = null;
 var gInstallManifestRoot  = null;
 var gVersionChecker       = null;
@@ -915,7 +908,13 @@ function DirectoryInstallLocation(name, 
       throw new Error("location must be a directoy!");
   }
   else {
-    location.create(Components.interfaces.nsIFile.DIRECTORY_TYPE, 0775);
+    try {
+      location.create(nsILocalFile.DIRECTORY_TYPE, 0775);
+    }
+    catch (e) {
+      LOG("DirectoryInstallLocation: failed to create location " + 
+          " directory = " + location.path + ", exception = " + e + "\n");
+    }
   }
 
   this._location = location;
@@ -1266,8 +1265,10 @@ WinRegInstallLocation.prototype = {
                           .createInstance(nsILocalFile);
       dir.initWithPath(key.readStringValue(id));
 
-      this._IDToDirMap[id] = dir;
-      this._DirToIDMap[dir.path] = id;
+      if (dir.exists() && dir.isDirectory()) {
+        this._IDToDirMap[id] = dir;
+        this._DirToIDMap[dir.path] = id;
+      }
     }
   },
 
@@ -2186,6 +2187,16 @@ function ExtensionManager() {
   gApp = Components.classes["@mozilla.org/xre/app-info;1"]
                    .getService(Components.interfaces.nsIXULAppInfo)
                    .QueryInterface(Components.interfaces.nsIXULRuntime);
+  gOSTarget = gApp.OS;
+  try {
+    gXPCOMABI = gApp.XPCOMABI;
+  } catch (ex) {
+    // Provide a default for gXPCOMABI. It won't be compared to an
+    // item's metadata (i.e. install.rdf can't specify e.g. WINNT_unknownABI
+    // as targetPlatform), but it will be displayed in error messages and
+    // transmitted to update URLs.
+    gXPCOMABI = UNKNOWN_XPCOM_ABI;
+  }
   gPref = Components.classes["@mozilla.org/preferences-service;1"]
                     .getService(Components.interfaces.nsIPrefBranch2);
   gLoggingEnabled = getPref("getBoolPref", PREF_EM_LOGGING_ENABLED, false);
@@ -3578,18 +3589,16 @@ ExtensionManager.prototype = {
         var tokens = targetPlatform.split("_");
         var os = tokens[0];
         var abi = (tokens.length > 1) ? tokens[1] : null;
-        if (os == OS_TARGET) {
+        if (os == gOSTarget) {
           foundMatchingOS = true;
           // The presence of any ABI part after our OS means ABI is important.
           if (abi != null) {
             requireABICompatibility = true;
-// If we don't know our ABI, we can't be compatible - skip the equality check.
-#ifdef TARGET_XPCOM_ABI
-            if (abi == TARGET_XPCOM_ABI) {
+            // If we don't know our ABI, we can't be compatible
+            if (abi == gXPCOMABI && abi != UNKNOWN_XPCOM_ABI) {
               foundMatchingOSAndABI = true;
               break;
             }
-#endif
           }
         }
       }
@@ -4063,7 +4072,7 @@ ExtensionManager.prototype = {
                   "invalidVersionMessage", [installData.name, installData.version]);
       break;
     case INSTALLERROR_INCOMPATIBLE_PLATFORM:
-      const osABI = OS_TARGET + "_" + TARGET_XPCOM_ABI;
+      const osABI = gOSTarget + "_" + gXPCOMABI;
       LOG("Incompatible Platform: Item: \"" + installData.id + "\" is not " + 
           "compatible with '" + osABI + "'.");
       var bundle = BundleManager.getBundle(URI_EXTENSIONS_PROPERTIES);
@@ -5249,8 +5258,8 @@ RDFItemUpdater.prototype = {
     dsURI = dsURI.replace(/%APP_ID%/g, this._updater._appID);
     dsURI = dsURI.replace(/%APP_VERSION%/g, this._updater._appVersion);
     dsURI = dsURI.replace(/%REQ_VERSION%/g, 1);
-    dsURI = dsURI.replace(/%APP_OS%/g, OS_TARGET);
-    dsURI = dsURI.replace(/%APP_ABI%/g, TARGET_XPCOM_ABI);
+    dsURI = dsURI.replace(/%APP_OS%/g, gOSTarget);
+    dsURI = dsURI.replace(/%APP_ABI%/g, gXPCOMABI);
     
     // escape() does not properly encode + symbols in any embedded FVF strings.
     dsURI = dsURI.replace(/\+/g, "%2B");
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/installer/CFGParser.pm mozilla.new/toolkit/mozapps/installer/CFGParser.pm
--- mozilla/toolkit/mozapps/installer/CFGParser.pm	2005-08-30 22:15:36.000000000 +0200
+++ mozilla.new/toolkit/mozapps/installer/CFGParser.pm	2006-02-24 11:15:58.000000000 +0100
@@ -81,12 +81,6 @@ sub ParseInstallerCfg
       elsif ($prop eq "FileInstallerEXE") {
         $ENV{WIZ_fileInstallerExe} = $value;
       }
-      elsif ($prop eq "FileUninstall") {
-        $ENV{WIZ_fileUninstall} = $value;
-      }
-      elsif ($prop eq "FileUninstallZIP") {
-        $ENV{WIZ_fileUninstallZip} = $value;
-      }
       elsif ($prop eq "FileMainEXE") {
         $ENV{WIZ_fileMainExe} = $value;
       }
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/installer/makeall.pl mozilla.new/toolkit/mozapps/installer/makeall.pl
--- mozilla/toolkit/mozapps/installer/makeall.pl	2005-08-30 22:15:38.000000000 +0200
+++ mozilla.new/toolkit/mozapps/installer/makeall.pl	2006-02-24 11:15:58.000000000 +0100
@@ -90,8 +90,6 @@ $seiFileNameGeneric       = "nsinstall".
 $seiFileNameSpecific      = $ENV{WIZ_fileInstallerExe};
 $seiStubRootName          = $ENV{WIZ_fileNetStubRootName};
 $seiFileNameSpecificStub  = "$seiStubRootName".$exe_suffix;
-$seuFileNameSpecific      = $ENV{WIZ_fileUninstall};
-$seuzFileNameSpecific     = $ENV{WIZ_fileUninstallZip};
 
 if(defined($ENV{DEBUG_INSTALLER_BUILD}))
 {
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/installer/makecfgini.pl mozilla.new/toolkit/mozapps/installer/makecfgini.pl
--- mozilla/toolkit/mozapps/installer/makecfgini.pl	2005-06-01 16:20:35.000000000 +0200
+++ mozilla.new/toolkit/mozapps/installer/makecfgini.pl	2006-02-24 11:15:58.000000000 +0100
@@ -109,8 +109,6 @@ $nameProduct      = $ENV{WIZ_nameProduct
 $shortNameProduct = $ENV{WIZ_shortNameProduct};
 $nameProductInternal = $ENV{WIZ_nameProductInternal};
 $fileMainExe      = $ENV{WIZ_fileMainExe};
-$fileUninstall    = $ENV{WIZ_fileUninstall};
-$fileUninstallZip = $ENV{WIZ_fileUninstallZip};
 $greBuildID       = $ENV{WIZ_greBuildID};
 $greFileVersion   = $ENV{WIZ_greFileVersion};
 $greUniqueID      = $ENV{WIZ_greUniqueID};
@@ -157,26 +155,19 @@ while($line = <fpInIt>)
         chop($componentName);
       }
 
-      if($componentName =~ /\$UninstallFileZip\$/i)
+      $installSize = OutputInstallSize("$inStagePath/$componentName");
+
+      # special oji consideration here.  Since it's an installer that 
+      # seamonkey installer will be calling, the disk space allocation
+      # needs to be adjusted by an expansion factor of 3.62.
+      if($componentName =~ /oji/i)
       {
-        $installSize = OutputInstallSizeArchive("$inXpiPath/$fileUninstallZip") * 2;
+        $installSize = int($installSize * 3.62);
       }
-      else
-      {
-        $installSize = OutputInstallSize("$inStagePath/$componentName");
 
-        # special oji consideration here.  Since it's an installer that 
-        # seamonkey installer will be calling, the disk space allocation
-        # needs to be adjusted by an expansion factor of 3.62.
-        if($componentName =~ /oji/i)
-        {
-          $installSize = int($installSize * 3.62);
-        }
-
-        if($componentName =~ /gre/i)
-        {
-          $installSize = int($installSize * 4.48);
-        }
+      if($componentName =~ /gre/i)
+      {
+        $installSize = int($installSize * 4.48);
       }
     }
 
@@ -208,7 +199,6 @@ while($line = <fpInIt>)
       else {
         chop($componentName);
       }
-      $componentName      =~ s/\$UninstallFileZip\$/$fileUninstallZip/gi;
       $installSizeArchive = OutputInstallSizeArchive("$inXpiPath/$componentName");
     }
 
@@ -252,8 +242,6 @@ while($line = <fpInIt>)
     $line =~ s/\$ProductNameInternal\$/$nameProductInternal/gi;
     $line =~ s/\$ProductShortName\$/$shortNameProduct/gi;
     $line =~ s/\$MainExeFile\$/$fileMainExe/gi;
-    $line =~ s/\$UninstallFile\$/$fileUninstall/gi;
-    $line =~ s/\$UninstallFileZip\$/$fileUninstallZip/gi;
     $line =~ s/\$GreBuildID\$/$greBuildID/gi;
     $line =~ s/\$GreFileVersion\$/$greFileVersion/gi;
     $line =~ s/\$GreUniqueID\$/$greUniqueID/gi;
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/installer/makejs.pl mozilla.new/toolkit/mozapps/installer/makejs.pl
--- mozilla/toolkit/mozapps/installer/makejs.pl	2005-02-01 18:07:16.000000000 +0100
+++ mozilla.new/toolkit/mozapps/installer/makejs.pl	2006-02-24 11:15:58.000000000 +0100
@@ -85,7 +85,6 @@ $nameProduct      = $ENV{WIZ_nameProduct
 $nameProductInternal = $ENV{WIZ_nameProductInternal};
 $shortNameProduct = $ENV{WIZ_shortNameProduct};
 $fileMainExe      = $ENV{WIZ_fileMainExe};
-$fileUninstall    = $ENV{WIZ_fileUninstall};
 $greBuildID       = $ENV{WIZ_greBuildID};
 $greFileVersion   = $ENV{WIZ_greFileVersion};
 $greUniqueID      = $ENV{WIZ_greUniqueID};
@@ -141,7 +140,6 @@ while($line = <fpInTemplate>)
     $line =~ s/\$ProductShortName\$/$shortNameProduct/i;
     $line =~ s/\$ProductNameInternal\$/$nameProductInternal/gi;
     $line =~ s/\$MainExeFile\$/$fileMainExe/i;
-    $line =~ s/\$UninstallFile\$/$fileUninstall/i;
     $line =~ s/\$GreBuildID\$/$greBuildID/gi;
     $line =~ s/\$GreFileVersion\$/$greFileVersion/gi;
     $line =~ s/\$GreUniqueID\$/$greUniqueID/gi;
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/installer/packager.mk mozilla.new/toolkit/mozapps/installer/packager.mk
--- mozilla/toolkit/mozapps/installer/packager.mk	2005-10-12 15:41:43.000000000 +0200
+++ mozilla.new/toolkit/mozapps/installer/packager.mk	2006-02-24 11:15:58.000000000 +0100
@@ -101,6 +101,7 @@ else
 _APPNAME	= $(MOZ_APP_DISPLAYNAME).app
 endif
 endif
+_BINPATH	= /$(_APPNAME)/Contents/MacOS
 PKG_SUFFIX	= .dmg
 PKG_DMG_FLAGS	=
 ifneq (,$(MOZ_PKG_MAC_DSSTORE))
@@ -119,8 +120,11 @@ ifneq (,$(MOZ_PKG_MAC_EXTRA))
 PKG_DMG_FLAGS += $(MOZ_PKG_MAC_EXTRA)
 endif
 _ABS_TOPSRCDIR = $(shell cd $(topsrcdir) && pwd)
+ifdef UNIVERSAL_BINARY
+STAGEPATH = universal/
+endif
 MAKE_PACKAGE	= $(_ABS_TOPSRCDIR)/build/package/mac_osx/pkg-dmg \
-  --source "$(MOZ_PKG_APPNAME)" --target "$(PACKAGE)" \
+  --source "$(STAGEPATH)$(MOZ_PKG_APPNAME)" --target "$(PACKAGE)" \
   --volname "$(MOZ_APP_DISPLAYNAME)" $(PKG_DMG_FLAGS)
 UNMAKE_PACKAGE	= \
   set -ex; \
@@ -155,15 +159,21 @@ endif
 
 # dummy macro if we don't have PSM built
 SIGN_NSS		=
-ifndef CROSS_COMPILE
+ifneq (1_,$(if $(CROSS_COMPILE),1,0)_$(UNIVERSAL_BINARY))
 ifdef MOZ_PSM
 SIGN_NSS		= @echo signing nss libraries;
 
+ifdef UNIVERSAL_BINARY
+NATIVE_ARCH	= $(shell uname -p | sed -e s/powerpc/ppc/)
+NATIVE_DIST	= $(DIST)/../../$(NATIVE_ARCH)/dist
+SIGN_CMD	= $(NATIVE_DIST)/bin/run-mozilla.sh $(NATIVE_DIST)/bin/shlibsign -v -i
+else
 SIGN_CMD	= $(DIST)/bin/run-mozilla.sh $(DIST)/bin/shlibsign -v -i
+endif
 
-SOFTOKN		= $(DIST)/$(MOZ_PKG_APPNAME)/$(DLL_PREFIX)softokn3$(DLL_SUFFIX)
-FREEBL_HYBRID	= $(DIST)/$(MOZ_PKG_APPNAME)/$(DLL_PREFIX)freebl_hybrid_3$(DLL_SUFFIX)
-FREEBL_PURE	= $(DIST)/$(MOZ_PKG_APPNAME)/$(DLL_PREFIX)freebl_pure32_3$(DLL_SUFFIX)
+SOFTOKN		= $(DIST)/$(STAGEPATH)$(MOZ_PKG_APPNAME)$(_BINPATH)/$(DLL_PREFIX)softokn3$(DLL_SUFFIX)
+FREEBL_HYBRID	= $(DIST)/$(STAGEPATH)$(MOZ_PKG_APPNAME)$(_BINPATH)/$(DLL_PREFIX)freebl_hybrid_3$(DLL_SUFFIX)
+FREEBL_PURE	= $(DIST)/$(STAGEPATH)$(MOZ_PKG_APPNAME)$(_BINPATH)/$(DLL_PREFIX)freebl_pure32_3$(DLL_SUFFIX)
 
 SIGN_NSS	+= $(SIGN_CMD) $(SOFTOKN); \
         if test -f $(FREEBL_HYBRID); then $(SIGN_CMD) $(FREEBL_HYBRID); fi; \
@@ -260,14 +270,18 @@ ifdef MOZ_PKG_MANIFEST
 	$(PERL) $(topsrcdir)/xpinstall/packager/xptlink.pl -s $(DIST) -d $(DIST)/xpt -f $(DIST)/$(MOZ_PKG_APPNAME)/components -v
 else # !MOZ_PKG_MANIFEST
 ifeq ($(MOZ_PKG_FORMAT),DMG)
+# If UNIVERSAL_BINARY, the package will be made from an already-prepared
+# STAGEPATH
+ifndef UNIVERSAL_BINARY
 	@cd $(DIST) && rsync -auv --copy-unsafe-links $(_APPNAME) $(MOZ_PKG_APPNAME)
+endif
 else
 	@cd $(DIST)/bin && tar $(TAR_CREATE_FLAGS) - * | (cd ../$(MOZ_PKG_APPNAME); tar -xf -)
 endif # DMG
 endif # MOZ_PKG_MANIFEST
 ifndef PKG_SKIP_STRIP
 	@echo "Stripping package directory..."
-	@cd $(DIST)/$(MOZ_PKG_APPNAME); find . ! -type d \
+	@cd $(DIST)/$(STAGEPATH)$(MOZ_PKG_APPNAME); find . ! -type d \
 			! -name "*.js" \
 			! -name "*.xpt" \
 			! -name "*.gif" \
@@ -293,16 +307,11 @@ ifndef PKG_SKIP_STRIP
 	$(SIGN_NSS)
 endif
 	@echo "Removing unpackaged files..."
-ifeq ($(MOZ_PKG_FORMAT),DMG)
-	cd $(DIST)/$(MOZ_PKG_APPNAME)/$(_APPNAME)/Contents/MacOS; rm -rf $(NO_PKG_FILES)
-ifdef MOZ_PKG_REMOVALS
-	$(SYSINSTALL) $(MOZ_PKG_REMOVALS_GEN) $(DIST)/$(MOZ_PKG_APPNAME)/$(_APPNAME)/Contents/MacOS
-endif # MOZ_PKG_REMOVALS
-else
-	cd $(DIST)/$(MOZ_PKG_APPNAME); rm -rf $(NO_PKG_FILES)
+ifdef NO_PKG_FILES
+	cd $(DIST)/$(STAGEPATH)$(MOZ_PKG_APPNAME)$(_BINPATH); rm -rf $(NO_PKG_FILES)
+endif
 ifdef MOZ_PKG_REMOVALS
-	$(SYSINSTALL) $(MOZ_PKG_REMOVALS_GEN) $(DIST)/$(MOZ_PKG_APPNAME)
+	$(SYSINSTALL) $(MOZ_PKG_REMOVALS_GEN) $(DIST)/$(STAGEPATH)$(MOZ_PKG_APPNAME)$(_BINPATH)
 endif # MOZ_PKG_REMOVALS
-endif
 	@echo "Compressing..."
 	cd $(DIST); $(MAKE_PACKAGE)
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/installer/windows/install_sub.pl mozilla.new/toolkit/mozapps/installer/windows/install_sub.pl
--- mozilla/toolkit/mozapps/installer/windows/install_sub.pl	2004-11-30 23:54:02.000000000 +0100
+++ mozilla.new/toolkit/mozapps/installer/windows/install_sub.pl	2006-02-24 11:15:58.000000000 +0100
@@ -11,9 +11,6 @@ $exe_suffix = '.exe';
 
 sub BuildPlatformInstaller
 {
-  print "Making uninstaller...\n";
-  MakeUninstall() && die;
-
   # copy the lean installer to stub\ dir
   print "\n****************************\n";
   print "*                          *\n";
@@ -211,55 +208,6 @@ sub BuildPlatformInstaller
   return 0;
 }
 
-sub MakeUninstall
-{
-  chdir($inConfigFiles);
-  if(MakeUninstallIniFile())
-  {
-    return(1);
-  }
-
-  # Copy the uninstall files to the dist uninstall directory.
-  copy("uninstall.ini", "$gDirDistInstall") ||
-    die "copy uninstall.ini $gDirDistInstall: $!\n";
-  copy("uninstall.ini", "$gDirDistInstall/uninstall") ||
-    die "copy uninstall.ini $gDirDistInstall/uninstall: $!\n";
-  copy("$gDirDistInstall/uninstall.exe", "$gDirDistInstall/uninstall") ||
-    die "copy $gDirDistInstall/uninstall.exe $gDirDistInstall/uninstall: $!\n";
-
-  # build the self-extracting .exe (uninstaller) file.
-  print "\nbuilding self-extracting uninstaller ($seuFileNameSpecific)...\n";
-  copy("$gDirDistInstall/$seiFileNameGeneric", "$gDirDistInstall/$seuFileNameSpecific") ||
-    die "copy $gDirDistInstall/$seiFileNameGeneric $gDirDistInstall/$seuFileNameSpecific: $!\n";
-
-  $origCwd = cwd();
-  chdir($gDirDistInstall);
-
-  if(system("./nsztool.exe $seuFileNameSpecific uninstall/*.*"))
-  {
-    print "\n Error: ./nsztool.exe $seuFileNameSpecific uninstall/*.*\n";
-    return(1);
-  }
-
-  chdir($origCwd);
-
-  MakeExeZip($gDirDistInstall, $seuFileNameSpecific, $seuzFileNameSpecific);
-  unlink <$gDirDistInstall/$seuFileNameSpecific>;
-  return(0);
-}
-
-sub MakeUninstallIniFile
-{
-  # Make config.ini file
-  chdir($inConfigFiles);
-  if(system("perl $gDirPackager/windows/makeuninstallini.pl uninstall.it $gDefaultProductVersion"))
-  {
-    print "\n Error: perl $gDirPackager/windows/makeuninstallini.pl uninstall.it $gDefaultProductVersion\n";
-    return(1);
-  }
-  return(0);
-}
-
 sub MakeExeZip
 {
   my($aSrcDir, $aExeFile, $aZipFile) = @_;
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/installer/windows/wizard/Makefile.in mozilla.new/toolkit/mozapps/installer/windows/wizard/Makefile.in
--- mozilla/toolkit/mozapps/installer/windows/wizard/Makefile.in	2005-02-01 18:07:27.000000000 +0100
+++ mozilla.new/toolkit/mozapps/installer/windows/wizard/Makefile.in	2006-02-24 11:15:58.000000000 +0100
@@ -42,7 +42,7 @@ VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
-DIRS	= uninstall setuprsc setup
+DIRS	= setuprsc setup
 
 include $(topsrcdir)/config/rules.mk
 
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/installer/windows/wizard/setup/dialogs.c mozilla.new/toolkit/mozapps/installer/windows/wizard/setup/dialogs.c
--- mozilla/toolkit/mozapps/installer/windows/wizard/setup/dialogs.c	2005-10-19 02:10:44.000000000 +0200
+++ mozilla.new/toolkit/mozapps/installer/windows/wizard/setup/dialogs.c	2006-02-24 11:15:58.000000000 +0100
@@ -268,7 +268,6 @@ void InitSequence(HINSTANCE hInstance)
         RefreshIcons();
 
       UnsetSetupState(); // clear setup state
-      ClearWinRegUninstallFileDeletion();
       if (!gbIgnoreProgramFolderX)
         ProcessProgramFolderShowCmd();
 
@@ -2189,7 +2188,6 @@ LRESULT CALLBACK DlgProcInstallSuccessfu
           RefreshIcons();
 
         UnsetSetupState(); // clear setup state
-        ClearWinRegUninstallFileDeletion();
         if (!gbIgnoreProgramFolderX)
           ProcessProgramFolderShowCmd();
 
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/installer/windows/wizard/setup/extra.c mozilla.new/toolkit/mozapps/installer/windows/wizard/setup/extra.c
--- mozilla/toolkit/mozapps/installer/windows/wizard/setup/extra.c	2005-05-21 00:42:47.000000000 +0200
+++ mozilla.new/toolkit/mozapps/installer/windows/wizard/setup/extra.c	2006-02-24 11:15:59.000000000 +0100
@@ -640,51 +640,6 @@ void RemoveDelayedDeleteFileEntries(cons
   free(pathToMatch);
 }
 
-
-/* Looks for and removes the uninstaller from the Windows Registry
- * that is set to delete the uninstaller at the next restart of
- * Windows.  This key is set/created when the user does the following:
- *
- * 1) Runs the uninstaller from the previous version of the product.
- * 2) User does not reboot the OS and starts the installation of
- *    the next version of the product.
- *
- * This functions prevents the uninstaller from being deleted on a
- * system reboot after the user performs 2).
- */
-void ClearWinRegUninstallFileDeletion(void)
-{
-  char  szLCUninstallFilenameLongBuf[MAX_BUF];
-  char  szLCUninstallFilenameShortBuf[MAX_BUF];
-  char  szWinInitFile[MAX_BUF];
-  char  szTempInitFile[MAX_BUF];
-  char  szWinDir[MAX_BUF];
-
-  if(!GetWindowsDirectory(szWinDir, sizeof(szWinDir)))
-    return;
-
-  wsprintf(szLCUninstallFilenameLongBuf, "%s\\%s", szWinDir, sgProduct.szUninstallFilename);
-  GetShortPathName(szLCUninstallFilenameLongBuf, szLCUninstallFilenameShortBuf, sizeof(szLCUninstallFilenameShortBuf));
-
-  if(gSystemInfo.dwOSType & OS_NT)
-  {
-    RemoveDelayedDeleteFileEntries(szLCUninstallFilenameShortBuf);
-  }
-  else
-  {
-    /* OS type is win9x */
-    wsprintf(szWinInitFile, "%s\\wininit.ini", szWinDir);
-    wsprintf(szTempInitFile, "%s\\wininit.moz", szWinDir);
-    if(FileExists(szWinInitFile))
-    {
-      if(UpdateFile(szWinInitFile, szTempInitFile, szLCUninstallFilenameLongBuf))
-        CopyFile(szTempInitFile, szWinInitFile, FALSE);
-
-      DeleteFile(szTempInitFile);
-    }
-  }
-}
-
 HRESULT Initialize(HINSTANCE hInstance)
 {
   char szBuf[MAX_BUF];
@@ -3941,8 +3896,6 @@ HRESULT InitSetupGeneral()
     return(1);
   if((sgProduct.szProductNamePrevious         = NS_GlobalAlloc(MAX_BUF)) == NULL)
     return(1);
-  if((sgProduct.szUninstallFilename           = NS_GlobalAlloc(MAX_BUF)) == NULL)
-    return(1);
   if((sgProduct.szUserAgent                   = NS_GlobalAlloc(MAX_BUF)) == NULL)
     return(1);
   if((sgProduct.szProgramFolderName           = NS_GlobalAlloc(MAX_BUF)) == NULL)
@@ -3981,7 +3934,6 @@ void DeInitSetupGeneral()
   FreeMemory(&(sgProduct.szProductName));
   FreeMemory(&(sgProduct.szProductNameInternal));
   FreeMemory(&(sgProduct.szProductNamePrevious));
-  FreeMemory(&(sgProduct.szUninstallFilename));
   FreeMemory(&(sgProduct.szUserAgent));
   FreeMemory(&(sgProduct.szProgramFolderName));
   FreeMemory(&(sgProduct.szProgramFolderPath));
@@ -7276,7 +7228,6 @@ HRESULT ParseConfigIni(LPSTR lpszCmdLine
     lstrcpy(sgProduct.szProductNameInternal, sgProduct.szProductName);
  
   GetConfigIniProfileString("General", "Product Name Previous", "", sgProduct.szProductNamePrevious, MAX_BUF);
-  GetConfigIniProfileString("General", "Uninstall Filename", "", sgProduct.szUninstallFilename, MAX_BUF);
   GetConfigIniProfileString("General", "User Agent",   "", sgProduct.szUserAgent,   MAX_BUF);
   GetConfigIniProfileString("General", "Sub Path",     "", sgProduct.szSubPath,     MAX_BUF);
   GetConfigIniProfileString("General", "Program Name", "", sgProduct.szProgramName, MAX_BUF);
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/installer/windows/wizard/setup/extra.h mozilla.new/toolkit/mozapps/installer/windows/wizard/setup/extra.h
--- mozilla/toolkit/mozapps/installer/windows/wizard/setup/extra.h	2005-04-15 16:49:51.000000000 +0200
+++ mozilla.new/toolkit/mozapps/installer/windows/wizard/setup/extra.h	2006-02-24 11:15:59.000000000 +0100
@@ -202,7 +202,6 @@ void              Delay(DWORD dwSeconds)
 void              UnsetSetupState(void);
 void              SetSetupState(char *szState);
 siCD              *InitWinInitNodes(char *szInFile);
-void              UpdateWininit(LPSTR szUninstallFilename);
 char              *GetSaveInstallerPath(char *szBuf, DWORD dwBufSize);
 void              SaveInstallerFiles(void);
 void              ResetComponentAttributes(char *szFileIni);
@@ -227,7 +226,6 @@ void              RestoreInvisibleFlag(s
 void              RestoreAdditionalFlag(siC *siCNode);
 void              RestoreEnabledFlag(siC *siCNode);
 void              SwapFTPAndHTTP(char *szInUrl, DWORD dwInUrlSize);
-void              ClearWinRegUninstallFileDeletion(void);
 void              RemoveDelayedDeleteFileEntries(const char *aPathToMatch);
 int               AppendToGlobalMessageStream(char *szInfo);
 char              *GetOSTypeString(char *szOSType, DWORD dwOSTypeBufSize);
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/installer/windows/wizard/setup/logging.c mozilla.new/toolkit/mozapps/installer/windows/wizard/setup/logging.c
--- mozilla/toolkit/mozapps/installer/windows/wizard/setup/logging.c	2005-02-01 18:07:27.000000000 +0100
+++ mozilla.new/toolkit/mozapps/installer/windows/wizard/setup/logging.c	2006-02-24 11:15:59.000000000 +0100
@@ -121,11 +121,10 @@ void LogISProductInfo(void)
   }
   UpdateInstallStatusLog(szBuf);
 
-  wsprintf(szBuf, "        Company name: %s\n        Product name (external): %s\n        Product name (internal): %s\n        Uninstall Filename: %s\n        UserAgent: %s\n        Alternate search path: %s\n",
+  wsprintf(szBuf, "        Company name: %s\n        Product name (external): %s\n        Product name (internal): %s\n        UserAgent: %s\n        Alternate search path: %s\n",
            sgProduct.szCompanyName,
            sgProduct.szProductName,
            sgProduct.szProductNameInternal,
-           sgProduct.szUninstallFilename,
            sgProduct.szUserAgent,
            sgProduct.szAlternateArchiveSearchPath);
   UpdateInstallStatusLog(szBuf);
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/installer/windows/wizard/setup/setup.h mozilla.new/toolkit/mozapps/installer/windows/wizard/setup/setup.h
--- mozilla/toolkit/mozapps/installer/windows/wizard/setup/setup.h	2005-08-30 22:15:41.000000000 +0200
+++ mozilla.new/toolkit/mozapps/installer/windows/wizard/setup/setup.h	2006-02-24 11:15:59.000000000 +0100
@@ -541,7 +541,6 @@ typedef struct setupStruct
   LPSTR     szProductName;
   LPSTR     szProductNameInternal;
   LPSTR     szProductNamePrevious;
-  LPSTR     szUninstallFilename;
   LPSTR     szUserAgent;
   LPSTR     szProgramFolderName;
   LPSTR     szProgramFolderPath;
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/installer/windows/wizard/uninstall/dialogs.c mozilla.new/toolkit/mozapps/installer/windows/wizard/uninstall/dialogs.c
--- mozilla/toolkit/mozapps/installer/windows/wizard/uninstall/dialogs.c	2005-02-12 01:05:12.000000000 +0100
+++ mozilla.new/toolkit/mozapps/installer/windows/wizard/uninstall/dialogs.c	2006-02-24 11:15:59.000000000 +0100
@@ -74,7 +74,7 @@ void ParseDefaultsInfo()
   int  iIndex;
   DWORD dwIconsVisible;
 
-  // If szAppPath is a null sting, i.e. we cannot find where the app has been installed:
+  // If szAppPath is a null string, i.e. we cannot find where the app has been installed:
   //   - HIDEICONS will still remove the shortcuts but
   //   - SHOWICONS will do nothing because we won't be able to find the shortcuts to display.
   ParsePath(ugUninstall.szAppPath, szStorageDir, MAX_BUF, PP_PATH_ONLY);
@@ -267,12 +267,12 @@ void ParseAllUninstallLogs()
     lstrcat(szKey, ugUninstall.szUninstallKeyDescription);
     RegDeleteKey(HKEY_LOCAL_MACHINE, szKey);
 
-    /* update Wininit.ini to remove itself at reboot */
-    RemoveUninstaller(ugUninstall.szUninstallFilename);
-
     // Calling SHChangeNotify() will update the file association icons
     // in case they had been reset.
     SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, NULL, NULL);
+
+    // Note completion of the uninstall process.
+    gbUninstallCompleted = TRUE;
   }
 
   /* Broadcast message only if the windows registry keys exist
@@ -489,6 +489,66 @@ LRESULT CALLBACK DlgProcMessage(HWND hDl
   return(0);
 }
 
+// This dialog proc must be used in conjunction with DLG_MESSAGE_CHK.
+LRESULT CALLBACK DlgProcComplete(HWND hDlg, UINT msg, WPARAM wParam, LONG lParam)
+{
+  RECT rDlg;
+  char text[256];
+  LRESULT result = 0;
+
+  switch(msg)
+  {
+    case WM_INITDIALOG:
+      SetWindowText(hDlg, diUninstall.szTitle);
+
+      GetPrivateProfileString("Dialog Uninstall", "OK", "",
+                              text, sizeof(text), szFileIniUninstall);
+      SetDlgItemText(hDlg, IDOK, text);
+
+      GetPrivateProfileString("Messages", "MSG_UNINSTALL_COMPLETE", "",
+                              text, sizeof(text), szFileIniUninstall);
+      SetDlgItemText(hDlg, IDC_MESSAGE, text);
+
+      GetPrivateProfileString("Messages", "MSG_UNINSTALL_SURVEY", "",
+                              text, sizeof(text), szFileIniUninstall);
+      if (text[0]) 
+      {
+        SetDlgItemText(hDlg, IDC_CHECKBOX, text);
+      }
+      else
+      {
+        // Hide the checkbox control if there is not survey text.
+        ShowWindow(GetDlgItem(hDlg, IDC_CHECKBOX), SW_HIDE);
+      }
+
+      if(GetClientRect(hDlg, &rDlg))
+        SetWindowPos(hDlg, HWND_TOP, (dwScreenX/2)-(rDlg.right/2), (dwScreenY/2)-(rDlg.bottom/2), 0, 0, SWP_NOSIZE);
+
+      break;
+
+    case WM_COMMAND:
+      switch(LOWORD(wParam))
+      {
+        case IDOK:
+          if (SendDlgItemMessage(hDlg, IDC_CHECKBOX, BM_GETCHECK, 0, 0) == BST_CHECKED)
+          {
+            EndDialog(hDlg, ID_YES_TO_ALL);
+          }
+          else 
+          {
+            EndDialog(hDlg, IDOK);
+          }            
+          break;
+      }
+      break;
+
+    case WM_CLOSE:
+      EndDialog(hDlg, IDOK);
+      break;
+  }
+  return(0);
+}
+
 void ProcessWindowsMessages()
 {
   MSG msg;
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/installer/windows/wizard/uninstall/dialogs.h mozilla.new/toolkit/mozapps/installer/windows/wizard/uninstall/dialogs.h
--- mozilla/toolkit/mozapps/installer/windows/wizard/uninstall/dialogs.h	2005-02-01 18:07:28.000000000 +0100
+++ mozilla.new/toolkit/mozapps/installer/windows/wizard/uninstall/dialogs.h	2006-02-24 11:15:59.000000000 +0100
@@ -43,6 +43,7 @@
 LRESULT CALLBACK  DlgProcUninstall(HWND hDlg, UINT msg, WPARAM wParam, LONG lParam);
 LRESULT CALLBACK  DlgProcWhatToDo(HWND hDlg, UINT msg, WPARAM wParam, LONG lParam);
 LRESULT CALLBACK  DlgProcMessage(HWND hDlg, UINT msg, WPARAM wParam, LONG lParam);
+LRESULT CALLBACK  DlgProcComplete(HWND hDlg, UINT msg, WPARAM wParam, LONG lParam);
 
 void              ParseAllUninstallLogs();
 void              ParseDefaultsInfo();
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/installer/windows/wizard/uninstall/extern.h mozilla.new/toolkit/mozapps/installer/windows/wizard/uninstall/extern.h
--- mozilla/toolkit/mozapps/installer/windows/wizard/uninstall/extern.h	2005-02-01 18:07:28.000000000 +0100
+++ mozilla.new/toolkit/mozapps/installer/windows/wizard/uninstall/extern.h	2006-02-24 11:15:59.000000000 +0100
@@ -75,4 +75,8 @@ extern BOOL             gbAllowMultipleI
 extern uninstallGen     ugUninstall;
 extern diU              diUninstall;
 
+extern DWORD            dwParentPID;
+
+extern BOOL             gbUninstallCompleted;
+
 #endif
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/installer/windows/wizard/uninstall/extra.c mozilla.new/toolkit/mozapps/installer/windows/wizard/uninstall/extra.c
--- mozilla/toolkit/mozapps/installer/windows/wizard/uninstall/extra.c	2005-02-01 18:07:28.000000000 +0100
+++ mozilla.new/toolkit/mozapps/installer/windows/wizard/uninstall/extra.c	2006-02-24 11:15:59.000000000 +0100
@@ -253,19 +253,10 @@ HRESULT Initialize(HINSTANCE hInstance)
     {
       lstrcpy(szTempDir, szUninstallDir);
     }
-    else
+    else if (!MakeUniquePath(szTempDir))
     {
-      int i;
-      for(i = 1; i <= 100 && (FileExists(szTempDir) != FALSE); i++)
-      {
-        itoa(i, (szTempDir + dwLen), 10);
-      }
-    
-      if (FileExists(szTempDir) != FALSE)
-      {
-        MessageBox(hWndMain, "Cannot create temp directory", NULL, MB_OK | MB_ICONEXCLAMATION);
-        exit(1);
-      }
+      MessageBox(hWndMain, "Cannot create temp directory", NULL, MB_OK | MB_ICONEXCLAMATION);
+      exit(1);
     }
   }
   else
@@ -854,8 +845,6 @@ HRESULT InitUninstallGeneral()
     return(1);
   if((ugUninstall.szUninstallKeyDescription = NS_GlobalAlloc(MAX_BUF)) == NULL)
     return(1);
-  if((ugUninstall.szUninstallFilename       = NS_GlobalAlloc(MAX_BUF)) == NULL)
-    return(1);
   if((ugUninstall.szClientAppID             = NS_GlobalAlloc(MAX_BUF)) == NULL)
     return(1);
   if((ugUninstall.szClientAppPath           = NS_GlobalAlloc(MAX_BUF)) == NULL)
@@ -871,7 +860,6 @@ void DeInitUninstallGeneral()
   FreeMemory(&(ugUninstall.szLogFilename));
   FreeMemory(&(ugUninstall.szDescription));
   FreeMemory(&(ugUninstall.szUninstallKeyDescription));
-  FreeMemory(&(ugUninstall.szUninstallFilename));
   FreeMemory(&(ugUninstall.szUserAgent));
   FreeMemory(&(ugUninstall.szDefaultComponent));
   FreeMemory(&(ugUninstall.szWrKey));
@@ -1023,6 +1011,17 @@ DWORD ParseCommandLine(LPSTR lpszCmdLine
     {
       gbAllowMultipleInstalls = TRUE;    
     }
+    else if(!lstrcmpi(szArgVBuf, "-ppid") || !lstrcmpi(szArgVBuf, "/ppid"))
+    {
+      if((i + 1) < iArgC)
+      {
+        char buf[32];
+        if (GetArgV(lpszCmdLine, ++i, buf, sizeof(buf)))
+        {
+          dwParentPID = (DWORD) atoi(buf);
+        }
+      }
+    }
 
     ++i;
   }
@@ -2068,9 +2067,6 @@ HRESULT ParseUninstallIni()
 
   RemoveBackSlash(ugUninstall.szWrMainKey);
 
-  GetPrivateProfileString("General", "Uninstall Filename", "", ugUninstall.szUninstallFilename, MAX_BUF, szFileIniUninstall);
-
-
   /* Uninstall dialog */
   GetPrivateProfileString("Dialog Uninstall",       "Show Dialog",  "", szShowDialog,                 MAX_BUF, szFileIniUninstall);
   GetPrivateProfileString("Dialog Uninstall",       "Title",        "", diUninstall.szTitle,          MAX_BUF, szFileIniUninstall);
@@ -2581,6 +2577,18 @@ HRESULT FileExists(LPSTR szFile)
   }
 }
 
+BOOL MakeUniquePath(LPSTR szPath)
+{
+  int i, dwLen;
+
+  dwLen = lstrlen(szPath);
+  for(i = 1; i <= 999 && (FileExists(szPath) != FALSE); i++)
+  {
+    itoa(i, (szPath + dwLen), 10);
+  }
+  return !FileExists(szPath);
+}
+
 BOOL WinRegNameExists(HKEY hkRootKey, LPSTR szKey, LPSTR szName)
 {
   HKEY  hkResult;
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/installer/windows/wizard/uninstall/extra.h mozilla.new/toolkit/mozapps/installer/windows/wizard/uninstall/extra.h
--- mozilla/toolkit/mozapps/installer/windows/wizard/uninstall/extra.h	2005-02-01 18:07:28.000000000 +0100
+++ mozilla.new/toolkit/mozapps/installer/windows/wizard/uninstall/extra.h	2006-02-24 11:15:59.000000000 +0100
@@ -91,6 +91,7 @@ void              AppendBackSlash(LPSTR 
 void              RemoveSlash(LPSTR szInput);
 void              AppendSlash(LPSTR szInput, DWORD dwInputSize);
 HRESULT           FileExists(LPSTR szFile);
+BOOL              MakeUniquePath(LPSTR szPath);
 BOOL              IsWin95Debute(void);
 HRESULT           CheckInstances();
 BOOL              GetFileVersion(LPSTR szFile, verBlock *vbVersion);
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/installer/windows/wizard/uninstall/Makefile.in mozilla.new/toolkit/mozapps/installer/windows/wizard/uninstall/Makefile.in
--- mozilla/toolkit/mozapps/installer/windows/wizard/uninstall/Makefile.in	2005-02-01 18:07:28.000000000 +0100
+++ mozilla.new/toolkit/mozapps/installer/windows/wizard/uninstall/Makefile.in	2006-02-24 11:15:59.000000000 +0100
@@ -68,7 +68,7 @@ LOCAL_INCLUDES	= -I$(srcdir)
 ifdef GNU_CC
 OS_LIBS		+= -lshell32 -lversion -lgdi32
 else
-OS_LIBS		+= shell32.lib version.lib
+OS_LIBS		+= shell32.lib version.lib ole32.lib
 endif
 
 NO_DIST_INSTALL	= 1
@@ -76,11 +76,10 @@ NO_DIST_INSTALL	= 1
 include $(topsrcdir)/config/rules.mk
 
 libs:: $(PROGRAM)
-	$(INSTALL) $(PROGRAM) $(DIST)/install
+	$(INSTALL) $(PROGRAM) $(DIST)/bin/uninstall
 
 install:: $(PROGRAM)
-	$(INSTALL) $(PROGRAM) $(DESTDIR)$(mozappdir)/install
+	$(INSTALL) $(PROGRAM) $(DESTDIR)$(mozappdir)/bin/uninstall
 
 clean clobber realclean clobber_all::
-	$(RM) $(DIST)/install/$(PROGRAM)
-
+	$(RM) $(DIST)/bin/uninstall/$(PROGRAM)
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/installer/windows/wizard/uninstall/parser.c mozilla.new/toolkit/mozapps/installer/windows/wizard/uninstall/parser.c
--- mozilla/toolkit/mozapps/installer/windows/wizard/uninstall/parser.c	2005-02-01 18:07:28.000000000 +0100
+++ mozilla.new/toolkit/mozapps/installer/windows/wizard/uninstall/parser.c	2006-02-24 11:15:59.000000000 +0100
@@ -46,69 +46,48 @@
 
 #define KEY_SHARED_DLLS "Software\\Microsoft\\Windows\\CurrentVersion\\SharedDlls"
 
-BOOL DeleteOrDelayUntilReboot(LPSTR szFile)
+BOOL DeleteOnReboot(LPSTR szFile)
 {
-  FILE      *ofp;
-  char      szWinDir[MAX_BUF];
-  char      szWininitFile[MAX_BUF];
-  BOOL      bDelayDelete = FALSE;
-  BOOL      bWriteRenameSection;
-
-  FileDelete(szFile);
-  if(FileExists(szFile))
+  if(ulOSType & OS_NT)
+    MoveFileEx(szFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
+  else
   {
-    bDelayDelete = TRUE;
-    if(ulOSType & OS_NT)
-      MoveFileEx(szFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
-    else
-    {
-      if(GetWindowsDirectory(szWinDir, sizeof(szWinDir)) == 0)
-        return(FALSE);
-
-      lstrcpy(szWininitFile, szWinDir);
-      AppendBackSlash(szWininitFile, sizeof(szWininitFile));
-      lstrcat(szWininitFile, "wininit.ini");
+    char szWinDir[MAX_BUF];
+    char szWininitFile[MAX_BUF];
+    BOOL bWriteRenameSection;
+    FILE *ofp;
+
+    if(GetWindowsDirectory(szWinDir, sizeof(szWinDir)) == 0)
+      return(FALSE);
+
+    lstrcpy(szWininitFile, szWinDir);
+    AppendBackSlash(szWininitFile, sizeof(szWininitFile));
+    lstrcat(szWininitFile, "wininit.ini");
 
-      if(FileExists(szWininitFile) == FALSE)
-        bWriteRenameSection = TRUE;
-      else
-        bWriteRenameSection = FALSE;
+    if(FileExists(szWininitFile) == FALSE)
+      bWriteRenameSection = TRUE;
+    else
+      bWriteRenameSection = FALSE;
 
-      if((ofp = fopen(szWininitFile, "a+")) == NULL)
-        return(FALSE);
+    if((ofp = fopen(szWininitFile, "a+")) == NULL)
+      return(FALSE);
 
-      if(bWriteRenameSection == TRUE)
-        fprintf(ofp, "[RENAME]\n");
+    if(bWriteRenameSection == TRUE)
+      fprintf(ofp, "[RENAME]\n");
 
-      fprintf(ofp, "NUL=%s\n", szFile);
-      fclose(ofp);
-    }
+    fprintf(ofp, "NUL=%s\n", szFile);
+    fclose(ofp);
   }
-  else
-    bDelayDelete = FALSE;
-
-  return(bDelayDelete);
+  return(TRUE);
 }
 
-void RemoveUninstaller(LPSTR szUninstallFilename)
+BOOL DeleteOrDelayUntilReboot(LPSTR szFile)
 {
-  char      szBuf[MAX_BUF];
-  char      szWinDir[MAX_BUF];
-  char      szUninstallFile[MAX_BUF];
-
-  if(SearchForUninstallKeys(szUninstallFilename))
-    /* Found the uninstall file name in the windows registry uninstall
-     * key sections.  We should not try to delete ourselves. */
-    return;
-
-  if(GetWindowsDirectory(szWinDir, sizeof(szWinDir)) == 0)
-    return;
+  FileDelete(szFile);
+  if(FileExists(szFile))
+    return DeleteOnReboot(szFile);
 
-  lstrcpy(szBuf, szWinDir);
-  AppendBackSlash(szBuf, sizeof(szBuf));
-  lstrcat(szBuf, szUninstallFilename);
-  GetShortPathName(szBuf, szUninstallFile, sizeof(szUninstallFile));
-  DeleteOrDelayUntilReboot(szUninstallFile);
+  return(TRUE);
 }
 
 sil *InitSilNodes(char *szInFile)
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/installer/windows/wizard/uninstall/parser.h mozilla.new/toolkit/mozapps/installer/windows/wizard/uninstall/parser.h
--- mozilla/toolkit/mozapps/installer/windows/wizard/uninstall/parser.h	2005-02-01 18:07:28.000000000 +0100
+++ mozilla.new/toolkit/mozapps/installer/windows/wizard/uninstall/parser.h	2006-02-24 11:15:59.000000000 +0100
@@ -50,9 +50,9 @@ HRESULT     ParseForWinRegInfo(LPSTR szS
 void        ParseForUninstallCommand(LPSTR szString, LPSTR szKeyStr, LPSTR szFile, DWORD dwFileBufSize, LPSTR szParam, DWORD dwParamBufSize);
 void        DeleteWinRegKey(HKEY hkRootKey, LPSTR szKey, BOOL bAbsoluteDelete);
 DWORD       GetLogFile(LPSTR szTargetPath, LPSTR szInFilename, LPSTR szOutBuf, DWORD dwOutBufSize);
-void        RemoveUninstaller(LPSTR szUninstallFilename);
 DWORD       DecrementSharedFileCounter(char *file);
 BOOL        DeleteOrDelayUntilReboot(LPSTR szFile);
+BOOL        DeleteOnReboot(LPSTR szFile);
 BOOL        UnregisterServer(char *file);
 int         GetSharedFileCount(char *file);
 BOOL        DetermineUnRegisterServer(sil *silInstallLogHead, LPSTR szFile);
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/installer/windows/wizard/uninstall/resource.h mozilla.new/toolkit/mozapps/installer/windows/wizard/uninstall/resource.h
--- mozilla/toolkit/mozapps/installer/windows/wizard/uninstall/resource.h	2003-10-09 04:02:08.000000000 +0200
+++ mozilla.new/toolkit/mozapps/installer/windows/wizard/uninstall/resource.h	2006-02-24 11:15:59.000000000 +0100
@@ -15,6 +15,7 @@
 #define IDI_SETUP                       105
 #define IDI_UNINSTALL                   105
 #define DLG_MESSAGE                     110
+#define DLG_MESSAGE_CHK                 111
 #define IDC_LIST_PRODUCTS               1000
 #define ID_NO                           1001
 #define IDC_GAUGE_FILE                  1002
@@ -29,6 +30,7 @@
 #define IDC_MESSAGE0                    1042
 #define IDC_MESSAGE1                    1043
 #define IDC_MESSAGE                     1049
+#define IDC_CHECKBOX                    1050
 #define DLG_UNINSTALL                   2008
 #define DLG_EXTRACTING                  2009
 #define DLG_PRODUCT_LIST                2009
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/installer/windows/wizard/uninstall/uninstall.c mozilla.new/toolkit/mozapps/installer/windows/wizard/uninstall/uninstall.c
--- mozilla/toolkit/mozapps/installer/windows/wizard/uninstall/uninstall.c	2005-02-01 18:07:28.000000000 +0100
+++ mozilla.new/toolkit/mozapps/installer/windows/wizard/uninstall/uninstall.c	2006-02-24 11:15:59.000000000 +0100
@@ -22,6 +22,7 @@
  *
  * Contributor(s):
  *   Sean Su <ssu@netscape.com>
+ *   Darin Fisher <darin@meer.net>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -41,6 +42,7 @@
 #include "extra.h"
 #include "dialogs.h"
 #include "ifuncns.h"
+#include "parser.h"
 
 /* global variables */
 HINSTANCE       hInst;
@@ -75,6 +77,155 @@ BOOL            gbAllowMultipleInstalls 
 uninstallGen    ugUninstall;
 diU             diUninstall;
 
+DWORD           dwParentPID = 0;
+
+BOOL            gbUninstallCompleted = FALSE;
+
+/* Copy a file into a directory.  Write the path to the new file
+ * into the result buffer (MAX_PATH in size). */
+static BOOL CopyTo(LPCSTR file, LPCSTR destDir, LPSTR result)
+{
+  char leaf[MAX_BUF_TINY];
+
+  ParsePath(file, leaf, sizeof(leaf), PP_FILENAME_ONLY);
+  lstrcpy(result, destDir);
+  lstrcat(result, "\\");
+  lstrcat(result, leaf);
+
+  return CopyFile(file, result, TRUE);
+}
+
+/* Spawn child process. */
+static BOOL SpawnProcess(LPCSTR exePath, LPCSTR cmdLine)
+{
+  STARTUPINFO si = {sizeof(si), 0};
+  PROCESS_INFORMATION pi = {0};
+
+  BOOL ok = CreateProcess(exePath,
+                          cmdLine,
+                          NULL,  // no special security attributes
+                          NULL,  // no special thread attributes
+                          FALSE, // don't inherit filehandles
+                          0,     // No special process creation flags
+                          NULL,  // inherit my environment
+                          NULL,  // use my current directory
+                          &si,
+                          &pi);
+
+  if (ok) {
+    CloseHandle(pi.hProcess);
+    CloseHandle(pi.hThread);
+  }
+
+  return ok;
+}
+
+/* This function is called to ensure that the running executable is a copy of
+ * the actual uninstaller.  If not, then this function copies the uninstaller
+ * into a temporary directory and invokes the copy of itself.  This is done to
+ * enable the uninstaller to remove itself. */
+static BOOL EnsureRunningAsCopy(LPCSTR cmdLine)
+{
+  char uninstExe[MAX_PATH], uninstIni[MAX_PATH];
+  char tempBuf[MAX_PATH], tempDir[MAX_PATH] = ""; 
+  DWORD n;
+
+  if (dwParentPID != 0)
+  {
+    HANDLE hParent;
+    
+    /* OpenProcess may return NULL if the parent process has already gone away.
+     * If not, then wait for the parent process to exit.  NOTE: The process may
+     * be signaled before it releases the executable image, so we sit in a loop
+     * until OpenProcess returns NULL. */
+    while ((hParent = OpenProcess(SYNCHRONIZE, FALSE, dwParentPID)) != NULL)
+    {
+      DWORD rv = WaitForSingleObject(hParent, 5000);
+      CloseHandle(hParent);
+      if (rv != WAIT_OBJECT_0)
+        return FALSE;
+      Sleep(50);  /* prevent burning CPU while waiting */
+    }
+
+    return TRUE;
+  }
+
+  /* otherwise, copy ourselves to a temp location and execute the copy. */
+
+  /* make unique folder under the Temp folder */
+  n = GetTempPath(sizeof(tempDir)-1, tempDir);
+  if (n == 0 || n > sizeof(tempDir)-1)
+    return FALSE;
+  lstrcat(tempDir, "nstmp");
+  if (!MakeUniquePath(tempDir) || !CreateDirectory(tempDir, NULL))
+    return FALSE;
+
+  if (!GetModuleFileName(hInst, tempBuf, sizeof(tempBuf)))
+    return FALSE;
+
+  /* copy exe file into temp folder */
+  if (!CopyTo(tempBuf, tempDir, uninstExe))
+  {
+    RemoveDirectory(tempDir);
+    return FALSE;
+  }
+
+  /* copy ini file into temp folder */
+  ParsePath(tempBuf, uninstIni, sizeof(uninstIni), PP_PATH_ONLY); 
+  lstrcat(uninstIni, FILE_INI_UNINSTALL);
+
+  if (!CopyTo(uninstIni, tempDir, tempBuf))
+  {
+    DeleteFile(uninstExe);
+    RemoveDirectory(tempDir);
+    return FALSE;
+  }
+
+  /* schedule temp dir and contents to be deleted on reboot */
+  DeleteOnReboot(uninstExe);
+  DeleteOnReboot(tempBuf);
+  DeleteOnReboot(tempDir);
+
+  /* append -ppid command line flag  */
+  _snprintf(tempBuf, sizeof(tempBuf), "\"%s\" %s /ppid %lu",
+            uninstExe, cmdLine, GetCurrentProcessId());
+
+  /* call CreateProcess */
+  SpawnProcess(uninstExe, tempBuf);
+
+  return FALSE;  /* exit this process */
+}
+
+/* Uninstall completed; show some UI... */
+static void OnUninstallComplete()
+{
+  char exePath[MAX_PATH], buf[MAX_PATH];
+
+  if (!(ugUninstall.szProductName && ugUninstall.szProductName[0]) ||
+      !(ugUninstall.szUserAgent && ugUninstall.szUserAgent[0]))
+    return;
+
+  if (DialogBox(hInst, MAKEINTRESOURCE(DLG_MESSAGE_CHK), NULL,
+      DlgProcComplete) != ID_YES_TO_ALL)
+    return;
+
+  /* find iexplore.exe.  we cannot use ShellExecute because the protocol
+   * association (in HKEY_CLASSES_ROOT) may reference the app we just
+   * uninstalled, which is a bug in and of itself. */
+  GetWinReg(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\IE Setup\\Setup", "Path",
+            exePath, sizeof(exePath));
+  if (!exePath[0])
+    return;
+  lstrcat(exePath, "\\iexplore.exe");
+
+  /* launch IE, and point it at the survey URL (whitespace in the product name
+   * or user agent is okay) */
+  _snprintf(buf, sizeof(buf),
+            "\"%s\" \"https://survey.mozilla.com/1/%s/%s/exit.html\"", exePath,
+            ugUninstall.szProductName, ugUninstall.szUserAgent);
+  SpawnProcess(exePath, buf);
+}
+
 int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
 {
   /***********************************************************************/
@@ -92,10 +243,10 @@ int APIENTRY WinMain(HINSTANCE hInstance
   if(!hPrevInstance)
   {
     hInst = GetModuleHandle(NULL);
-    if(InitUninstallGeneral())
-      PostQuitMessage(1);
-    else if(ParseCommandLine(lpszCmdLine))
+    if(InitUninstallGeneral() || ParseCommandLine(lpszCmdLine))
+    {
       PostQuitMessage(1);
+    }
     else if((hwndFW = FindWindow(CLASS_NAME_UNINSTALL_DLG, NULL)) != NULL && !gbAllowMultipleInstalls)
     {
     /* Allow only one instance of setup to run.
@@ -107,7 +258,7 @@ int APIENTRY WinMain(HINSTANCE hInstance
       iRv = WIZ_SETUP_ALREADY_RUNNING;
       PostQuitMessage(1);
     }
-    else if(Initialize(hInst))
+    else if(!EnsureRunningAsCopy(lpszCmdLine) || Initialize(hInst))
     {
       PostQuitMessage(1);
     }
@@ -152,6 +303,11 @@ int APIENTRY WinMain(HINSTANCE hInstance
     }
   }
 
+  if(diUninstall.bShowDialog == TRUE && gbUninstallCompleted)
+  {
+    OnUninstallComplete();
+  }
+
   /* garbage collection */
   DeInitUninstallGeneral();
   if(iRv != WIZ_SETUP_ALREADY_RUNNING)
@@ -160,4 +316,3 @@ int APIENTRY WinMain(HINSTANCE hInstance
 
   return(msg.wParam);
 } /*  End of WinMain */
-
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/installer/windows/wizard/uninstall/uninstall.h mozilla.new/toolkit/mozapps/installer/windows/wizard/uninstall/uninstall.h
--- mozilla/toolkit/mozapps/installer/windows/wizard/uninstall/uninstall.h	2005-08-30 22:15:41.000000000 +0200
+++ mozilla.new/toolkit/mozapps/installer/windows/wizard/uninstall/uninstall.h	2006-02-24 11:15:59.000000000 +0100
@@ -172,7 +172,6 @@ typedef struct uninstallStruct
   LPSTR     szProductName;
   LPSTR     szDescription;
   LPSTR     szUninstallKeyDescription;
-  LPSTR     szUninstallFilename;
   HKEY      hWrMainRoot;
   LPSTR     szWrMainKey;
   HKEY      hWrRoot;
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/installer/windows/wizard/uninstall/uninstall.rc mozilla.new/toolkit/mozapps/installer/windows/wizard/uninstall/uninstall.rc
--- mozilla/toolkit/mozapps/installer/windows/wizard/uninstall/uninstall.rc	2004-02-11 01:56:16.000000000 +0100
+++ mozilla.new/toolkit/mozapps/installer/windows/wizard/uninstall/uninstall.rc	2006-02-24 11:15:59.000000000 +0100
@@ -126,6 +126,15 @@ BEGIN
     CTEXT           "",IDC_MESSAGE,0,0,236,34,SS_CENTERIMAGE
 END
 
+DLG_MESSAGE_CHK DIALOG DISCARDABLE  0, 0, 200, 66
+STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
+FONT 8, "MS Sans Serif"
+BEGIN
+    DEFPUSHBUTTON   "",IDOK,75,45,53,14
+    LTEXT           "",IDC_MESSAGE,11,8,191,8
+    CONTROL         "",IDC_CHECKBOX,"Button",BS_AUTOCHECKBOX|WS_TABSTOP,15,25,191,10
+END
+
 DLG_WHAT_TO_DO DIALOG DISCARDABLE  51, 56, 333, 140
 STYLE DS_MODALFRAME | WS_MINIMIZEBOX | WS_POPUP | WS_VISIBLE | WS_CAPTION | 
     WS_SYSMENU
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/Makefile.in mozilla.new/toolkit/mozapps/Makefile.in
--- mozilla/toolkit/mozapps/Makefile.in	2004-06-19 00:05:29.000000000 +0200
+++ mozilla.new/toolkit/mozapps/Makefile.in	2006-02-24 11:15:58.000000000 +0100
@@ -44,5 +44,12 @@ include $(DEPTH)/config/autoconf.mk
 
 DIRS = downloads extensions update xpinstall
 
-include $(topsrcdir)/config/rules.mk
+# The installer is built during the packaging phase, but the uninstaller needs
+# to be built earlier.
+ifdef MOZ_INSTALLER
+ifeq ($(OS_ARCH),WINNT)
+DIRS += installer/windows/wizard/uninstall
+endif
+endif
 
+include $(topsrcdir)/config/rules.mk
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/update/src/nsPostUpdateWin.js mozilla.new/toolkit/mozapps/update/src/nsPostUpdateWin.js
--- mozilla/toolkit/mozapps/update/src/nsPostUpdateWin.js	2005-11-04 19:45:00.000000000 +0100
+++ mozilla.new/toolkit/mozapps/update/src/nsPostUpdateWin.js	2006-02-24 11:15:59.000000000 +0100
@@ -46,7 +46,6 @@ const URI_BRAND_PROPERTIES     = "chrome
 const URI_UNINSTALL_PROPERTIES = "chrome://branding/content/uninstall.properties";
 
 const KEY_APPDIR          = "XCurProcD";
-const KEY_WINDIR          = "WinD";
 const KEY_COMPONENTS_DIR  = "ComsD";
 const KEY_PLUGINS_DIR     = "APlugns";
 const KEY_EXECUTABLE_FILE = "XREExeF";
@@ -576,6 +575,9 @@ function updateRegistry(rootKey) {
 
   var vendorShortName;
   try {
+    // The Thunderbird vendorShortName is "Mozilla Thunderbird", but we
+    // just want "Thunderbird", so allow it to be overridden in prefs.
+
     var prefs =
       Components.classes["@mozilla.org/preferences-service;1"].
       getService(Components.interfaces.nsIPrefBranch);
@@ -710,9 +712,10 @@ function updateRegistry(rootKey) {
   var uninstallBundle = sbs.createBundle(URI_UNINSTALL_PROPERTIES);
 
   var nameWithVersion = brandFullName + " (" + app.version + ")";
-  var uninstaller = getFile(KEY_WINDIR);
-  uninstaller.append(uninstallBundle.GetStringFromName("fileUninstall"));
-  // XXX copy latest uninstaller to this location
+
+  var uninstaller = getFile(KEY_APPDIR);
+  uninstaller.append("uninstall");
+  uninstaller.append("uninstall.exe");
 
   var uninstallString =
       uninstaller.path + " /ua \"" + versionWithLocale + "\"";
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/update/src/nsUpdateService.js.in mozilla.new/toolkit/mozapps/update/src/nsUpdateService.js.in
--- mozilla/toolkit/mozapps/update/src/nsUpdateService.js.in	2005-11-05 03:01:15.000000000 +0100
+++ mozilla.new/toolkit/mozapps/update/src/nsUpdateService.js.in	2006-02-24 11:15:59.000000000 +0100
@@ -1,3 +1,4 @@
+#if 0
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
@@ -36,6 +37,7 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
+#endif
 
 const PREF_APP_UPDATE_ENABLED             = "app.update.enabled";
 const PREF_APP_UPDATE_AUTO                = "app.update.auto";
@@ -116,6 +118,7 @@ const Node = Components.interfaces.nsIDO
 var gApp        = null;
 var gPref       = null;
 var gOS         = null;
+var gABI        = null;
 var gConsole    = null;
 var gLogEnabled = { };
 
@@ -854,6 +857,24 @@ function UpdateService() {
   gConsole = Components.classes["@mozilla.org/consoleservice;1"]
                        .getService(Components.interfaces.nsIConsoleService);  
 
+  // Not all builds have a known ABI
+  try {
+    gABI = gApp.XPCOMABI;
+  }
+  catch (e) {
+    LOG("UpdateService", "XPCOM ABI unknown: updates are not possible.");
+  }
+
+#ifdef XP_MACOSX
+  // Mac universal build should report a different ABI than either macppc
+  // or mactel.
+  var macutils = Components.classes["@mozilla.org/xpcom/mac-utils;1"]
+                           .getService(Components.interfaces.nsIMacUtils);
+
+  if (macutils.isUniversalBinary)
+    gABI = "Universal-gcc3";
+#endif
+
   // Start the update timer only after a profile has been selected so that the
   // appropriate values for the update check are read from the user's profile.  
   gOS.addObserver(this, "profile-after-change", false);
@@ -1302,6 +1323,11 @@ UpdateService.prototype = {
     var enabled = getPref("getBoolPref", PREF_APP_UPDATE_ENABLED, true);
     if (!enabled && gPref.prefIsLocked(PREF_APP_UPDATE_ENABLED))
       return false;
+
+    // If we don't know the binary platform we're updating, we can't update.
+    if (!gABI)
+      return false;
+
     return true;
   },
   
@@ -1686,7 +1712,7 @@ Checker.prototype = {
     url = url.replace(/%PRODUCT%/g, gApp.name);
     url = url.replace(/%VERSION%/g, gApp.version);
     url = url.replace(/%BUILD_ID%/g, gApp.appBuildID);
-    url = url.replace(/%BUILD_TARGET%/g, gApp.OS + "_" + gApp.XPCOMABI);
+    url = url.replace(/%BUILD_TARGET%/g, gApp.OS + "_" + gABI);
     url = url.replace(/%LOCALE%/g, getLocale());
     url = url.replace(/%CHANNEL%/g, getUpdateChannel());
     url = url.replace(/\+/g, "%2B");
diff -uprN --exclude=CVS mozilla/toolkit/mozapps/update/src/updater/progressui_win.cpp mozilla.new/toolkit/mozapps/update/src/updater/progressui_win.cpp
--- mozilla/toolkit/mozapps/update/src/updater/progressui_win.cpp	2005-10-25 20:26:56.000000000 +0200
+++ mozilla.new/toolkit/mozapps/update/src/updater/progressui_win.cpp	2006-02-14 10:01:03.000000000 +0100
@@ -21,6 +21,7 @@
  *
  * Contributor(s):
  *  Darin Fisher <darin@meer.net>
+ *  Masayuki Nakano <masayuki@d-toybox.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -48,6 +49,7 @@
 
 static float sProgress;  // between 0 and 100
 static BOOL  sQuit = FALSE;
+static HFONT sSystemFont = 0;
 
 static BOOL
 GetStringsFile(char filename[MAX_PATH])
@@ -67,7 +69,7 @@ static void
 UpdateDialog(HWND hDlg)
 {
   int pos = int(sProgress + 0.5f);
-  SendMessage(GetDlgItem(hDlg, IDC_PROGRESS), PBM_SETPOS, pos, 0L);
+  SendDlgItemMessage(hDlg, IDC_PROGRESS, PBM_SETPOS, pos, 0L);
 }
 
 // The code in this function is from MSDN:
@@ -123,13 +125,27 @@ InitDialog(HWND hDlg)
   SetItemText(hDlg, "Title", filename);
   SetItemText(GetDlgItem(hDlg, IDC_INFO), "Info", filename);
 
+  // On Win9x, we need to send WM_SETFONT for l10n builds.  Yes, we shouldn't
+  // use the system font.  For example, if the text has Japanese characters on
+  // Win98-en, then the text may not be displayed correctly.  We should perhaps
+  // support loading a font named in updater.ini; however, even then there are
+  // cases where it might not work properly.
+  if (!sSystemFont) {
+    NONCLIENTMETRICS ncm;
+    memset(&ncm, 0, sizeof(ncm));
+    ncm.cbSize = sizeof(ncm);
+    SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);
+    sSystemFont = CreateFontIndirect(&ncm.lfMessageFont);
+  }
+  if (sSystemFont)
+    SendDlgItemMessage(hDlg, IDC_INFO, WM_SETFONT, (WPARAM)sSystemFont, 0L);
+
   // Set dialog icon
   HICON hIcon = LoadIcon(GetModuleHandle(NULL), MAKEINTRESOURCE(IDI_DIALOG));
   if (hIcon)
     SendMessage(hDlg, WM_SETICON, ICON_BIG, (LPARAM) hIcon);
 
-  SendMessage(GetDlgItem(hDlg, IDC_PROGRESS), PBM_SETRANGE, 0,
-              MAKELPARAM(0, 100));
+  SendDlgItemMessage(hDlg, IDC_PROGRESS, PBM_SETRANGE, 0, MAKELPARAM(0, 100));
 
   CenterDialog(hDlg);  // make dialog appear in the center of the screen
 
@@ -147,10 +163,15 @@ DialogProc(HWND hDlg, UINT message, WPAR
     return TRUE;
 
   case WM_TIMER:
-    if (sQuit)
+    if (sQuit) {
       EndDialog(hDlg, 0);
-    else
+      if (sSystemFont) {
+        DeleteObject(sSystemFont);
+        sSystemFont = 0;
+      }
+    } else {
       UpdateDialog(hDlg);
+    }
     return TRUE;
 
   case WM_COMMAND:
diff -uprN --exclude=CVS mozilla/toolkit/xre/MacLaunchHelper.m mozilla.new/toolkit/xre/MacLaunchHelper.m
--- mozilla/toolkit/xre/MacLaunchHelper.m	2005-02-01 18:07:35.000000000 +0100
+++ mozilla.new/toolkit/xre/MacLaunchHelper.m	2006-03-03 07:11:40.000000000 +0100
@@ -42,6 +42,12 @@
 #include <mach-o/dyld.h>
 #include <sys/utsname.h>
 
+#ifdef __ppc__
+#include <sys/types.h>
+#include <sys/sysctl.h>
+#include <mach/machine.h>
+#endif /* __ppc__ */
+
 @interface TaskMonitor : NSObject
 -(void)prebindFinished:(NSNotification *)aNotification;
 @end
@@ -104,6 +110,31 @@ void LaunchChildMac(int aArgc, char** aA
   NSMutableArray* args = [[NSMutableArray alloc] init];
   NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];
 
+#ifdef __ppc__
+  // It's possible that the app is a universal binary running under Rosetta
+  // translation because the user forced it to.  Relaunching via NSTask would
+  // launch the app natively, which the user apparently doesn't want.
+  // In that case, try to preserve translation.
+
+  // If the sysctl doesn't exist, it's because Rosetta doesn't exist,
+  // so don't try to force translation.  In case of other errors, just assume
+  // that the app is native.
+
+  int isNative = 0;
+  size_t sz = sizeof(isNative);
+
+  if (sysctlbyname("sysctl.proc_native", &isNative, &sz, NULL, 0) == 0 &&
+      !isNative) {
+    // Running translated on ppc.
+
+    cpu_type_t preferredCPU = CPU_TYPE_POWERPC;
+    sysctlbyname("sysctl.proc_exec_affinity", NULL, NULL,
+                 &preferredCPU, sizeof(preferredCPU));
+
+    // Nothing can be done to handle failure, relaunch anyway.
+  }
+#endif /* __ppc__ */
+
   for (i = 1; i < aArgc; ++i) 
     [args addObject: [NSString stringWithCString: aArgv[i]]];
   
diff -uprN --exclude=CVS mozilla/toolkit/xre/nsAppRunner.cpp mozilla.new/toolkit/xre/nsAppRunner.cpp
--- mozilla/toolkit/xre/nsAppRunner.cpp	2005-10-17 21:16:51.000000000 +0200
+++ mozilla.new/toolkit/xre/nsAppRunner.cpp	2006-02-24 11:15:59.000000000 +0100
@@ -1627,7 +1627,8 @@ SelectProfile(nsIProfileLock* *aResult, 
 
 static PRBool
 CheckCompatibility(nsIFile* aProfileDir, const nsCString& aVersion,
-                   nsIFile* aXULRunnerDir, nsIFile* aAppDir)
+                   const nsCString& aOSABI, nsIFile* aXULRunnerDir,
+                   nsIFile* aAppDir)
 {
   nsCOMPtr<nsIFile> file;
   aProfileDir->Clone(getter_AddRefs(file));
@@ -1649,6 +1650,13 @@ CheckCompatibility(nsIFile* aProfileDir,
   if (!aVersion.Equals(buf))
     return PR_FALSE;
 
+  rv = parser.GetString("Compatibility", "LastOSABI", buf);
+  if (NS_FAILED(rv))
+    return PR_FALSE;
+
+  if (!aOSABI.Equals(buf))
+    return PR_FALSE;
+
   rv = parser.GetString("Compatibility", "LastPlatformDir", buf);
   if (NS_FAILED(rv))
     return PR_FALSE;
@@ -1693,7 +1701,8 @@ static void BuildVersion(nsCString &aBuf
 
 static void
 WriteVersion(nsIFile* aProfileDir, const nsCString& aVersion,
-             nsIFile* aXULRunnerDir, nsIFile* aAppDir)
+             const nsCString& aOSABI, nsIFile* aXULRunnerDir,
+             nsIFile* aAppDir)
 {
   nsCOMPtr<nsIFile> file;
   aProfileDir->Clone(getter_AddRefs(file));
@@ -1723,6 +1732,10 @@ WriteVersion(nsIFile* aProfileDir, const
   PR_Write(fd, kHeader, sizeof(kHeader) - 1);
   PR_Write(fd, aVersion.get(), aVersion.Length());
 
+  static const char kOSABIHeader[] = NS_LINEBREAK "LastOSABI=";
+  PR_Write(fd, kOSABIHeader, sizeof(kOSABIHeader) - 1);
+  PR_Write(fd, aOSABI.get(), aOSABI.Length());
+
   static const char kPlatformDirHeader[] = NS_LINEBREAK "LastPlatformDir=";
 
   PR_Write(fd, kPlatformDirHeader, sizeof(kPlatformDirHeader) - 1);
@@ -2083,10 +2096,17 @@ XRE_main(int argc, char* argv[], const n
   nsCAutoString version;
   BuildVersion(version);
 
+#ifdef TARGET_OS_ABI
+    NS_NAMED_LITERAL_CSTRING(osABI, TARGET_OS_ABI);
+#else
+    // No TARGET_XPCOM_ABI, but at least the OS is known
+    NS_NAMED_LITERAL_CSTRING(osABI, OS_TARGET "_UNKNOWN");
+#endif
+
   // Check for version compatibility with the last version of the app this 
   // profile was started with.  The format of the version stamp is defined
   // by the BuildVersion function.
-  PRBool versionOK = CheckCompatibility(profD, version,
+  PRBool versionOK = CheckCompatibility(profD, version, osABI,
                                         dirProvider.GetAppDir(),
                                         gAppData->directory);
 
@@ -2099,7 +2119,7 @@ XRE_main(int argc, char* argv[], const n
   //
   if (gSafeMode) {
     RemoveComponentRegistries(profD, profLD, PR_FALSE);
-    WriteVersion(profD, NS_LITERAL_CSTRING("Safe Mode"),
+    WriteVersion(profD, NS_LITERAL_CSTRING("Safe Mode"), osABI,
                  dirProvider.GetAppDir(), gAppData->directory);
   }
   else if (versionOK) {
@@ -2124,7 +2144,7 @@ XRE_main(int argc, char* argv[], const n
     upgraded = PR_TRUE;
 
     // Write out version
-    WriteVersion(profD, version,
+    WriteVersion(profD, version, osABI,
                  dirProvider.GetAppDir(), gAppData->directory);
   }
 
@@ -2168,6 +2188,24 @@ XRE_main(int argc, char* argv[], const n
       // So we can open and close windows during startup
       appStartup->EnterLastWindowClosingSurvivalArea();
 
+      if (gDoMigration) {
+        nsCOMPtr<nsIFile> file;
+        dirProvider.GetAppDir()->Clone(getter_AddRefs(file));
+        file->AppendNative(NS_LITERAL_CSTRING("override.ini"));
+        nsINIParser parser;
+        nsCOMPtr<nsILocalFile> localFile(do_QueryInterface(file));
+        nsresult rv = parser.Init(localFile);
+        if (NS_SUCCEEDED(rv)) {
+          nsCAutoString buf;
+          rv = parser.GetString("XRE", "EnableProfileMigrator", buf);
+          if (NS_SUCCEEDED(rv)) {
+            if (buf[0] == '0' || buf[0] == 'f' || buf[0] == 'F') {
+              gDoMigration = PR_FALSE;
+            }
+          }
+        }
+      }
+
       // Profile Migration
       if (gAppData->flags & NS_XRE_ENABLE_PROFILE_MIGRATOR && gDoMigration) {
         gDoMigration = PR_FALSE;
diff -uprN --exclude=CVS mozilla/uriloader/prefetch/nsPrefetchService.cpp mozilla.new/uriloader/prefetch/nsPrefetchService.cpp
--- mozilla/uriloader/prefetch/nsPrefetchService.cpp	2005-06-29 22:57:34.000000000 +0200
+++ mozilla.new/uriloader/prefetch/nsPrefetchService.cpp	2006-02-24 11:16:39.000000000 +0100
@@ -237,6 +237,14 @@ nsPrefetchListener::OnChannelRedirect(ns
         return NS_ERROR_ABORT;
     }
 
+    // HTTP request headers are not automatically forwarded to the new channel.
+    nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(aNewChannel);
+    NS_ENSURE_STATE(httpChannel);
+
+    httpChannel->SetRequestHeader(NS_LITERAL_CSTRING("X-Moz"),
+                                  NS_LITERAL_CSTRING("prefetch"), PR_FALSE);
+
+    mService->UpdateCurrentChannel(aNewChannel);
     return NS_OK;
 }
 
diff -uprN --exclude=CVS mozilla/uriloader/prefetch/nsPrefetchService.h mozilla.new/uriloader/prefetch/nsPrefetchService.h
--- mozilla/uriloader/prefetch/nsPrefetchService.h	2005-06-29 22:57:34.000000000 +0200
+++ mozilla.new/uriloader/prefetch/nsPrefetchService.h	2006-02-24 11:16:39.000000000 +0100
@@ -73,6 +73,7 @@ public:
 
     nsresult Init();
     void     ProcessNextURI();
+    void     UpdateCurrentChannel(nsIChannel *c) { mCurrentChannel = c; }
 
 private:
     ~nsPrefetchService();
diff -uprN --exclude=CVS mozilla/view/src/nsViewManager.cpp mozilla.new/view/src/nsViewManager.cpp
--- mozilla/view/src/nsViewManager.cpp	2005-10-15 09:54:38.000000000 +0200
+++ mozilla.new/view/src/nsViewManager.cpp	2006-02-24 11:16:48.000000000 +0100
@@ -4501,6 +4501,33 @@ nsViewManager::SynthesizeMouseMove(PRBoo
   return NS_OK;
 }
 
+/**
+ * Find the first floating view with a widget in a postorder traversal of the
+ * view tree that contains the point. Thus more deeply nested floating views
+ * are preferred over their ancestors, and floating views earlier in the
+ * view hierarchy (i.e., added later) are preferred over their siblings.
+ * This is adequate for finding the "topmost" floating view under a point,
+ * given that floating views don't supporting having a specific z-index.
+ *
+ * We cannot exit early when aPt is outside the view bounds, because floating
+ * views aren't necessarily included in their parent's bounds, so this could
+ * traverse the entire view hierarchy --- use carefully.
+ */
+static nsView* FindFloatingViewContaining(nsView* aView, nsPoint aPt)
+{
+  for (nsView* v = aView->GetFirstChild(); v; v = v->GetNextSibling()) {
+    nsView* r = FindFloatingViewContaining(v, aPt - v->GetOffsetTo(aView));
+    if (r)
+      return r;
+  }
+
+  if (aView->GetFloating() && aView->HasWidget() &&
+      aView->GetDimensions().Contains(aPt) && IsViewVisible(aView))
+    return aView;
+
+  return nsnull;
+}
+
 void
 nsViewManager::ProcessSynthMouseMoveEvent(PRBool aFromScroll)
 {
@@ -4523,14 +4550,29 @@ nsViewManager::ProcessSynthMouseMoveEven
          this, mMouseLocation.x, mMouseLocation.y);
 #endif
 
-  nsMouseEvent event(PR_TRUE, NS_MOUSE_MOVE, mRootView->GetWidget(),
+  nsPoint pt = mMouseLocation;
+  pt.x = NSToCoordRound(mMouseLocation.x*mPixelsToTwips);
+  pt.y = NSToCoordRound(mMouseLocation.y*mPixelsToTwips);
+  // This could be a bit slow (traverses entire view hierarchy)
+  // but it's OK to do it once per synthetic mouse event
+  nsView* view = FindFloatingViewContaining(mRootView, pt);
+  nsPoint offset(0, 0);
+  if (!view) {
+    view = mRootView;
+  } else {
+    offset = view->GetOffsetTo(mRootView);
+    offset.x = NSToIntRound(offset.x*mTwipsToPixels);
+    offset.y = NSToIntRound(offset.y*mTwipsToPixels);
+  }
+  nsMouseEvent event(PR_TRUE, NS_MOUSE_MOVE, view->GetWidget(),
                      nsMouseEvent::eSynthesized);
-  event.point = mMouseLocation;
+
+  event.point = mMouseLocation - offset;
   event.time = PR_IntervalNow();
   // XXX set event.isShift, event.isControl, event.isAlt, event.isMeta ?
 
   nsEventStatus status;
-  DispatchEvent(&event, &status);
+  view->GetViewManager()->DispatchEvent(&event, &status);
 
   if (!aFromScroll)
     mSynthMouseMoveEventQueue = nsnull;
diff -uprN --exclude=CVS mozilla/widget/src/mac/nsMacEventHandler.cpp mozilla.new/widget/src/mac/nsMacEventHandler.cpp
--- mozilla/widget/src/mac/nsMacEventHandler.cpp	2006-01-09 06:48:56.000000000 +0100
+++ mozilla.new/widget/src/mac/nsMacEventHandler.cpp	2006-02-24 11:16:48.000000000 +0100
@@ -2616,7 +2616,7 @@ nsresult nsMacEventHandler::HandleTextEv
 		mIMEPos.x = textEvent.theReply.mCursorPosition.x;
 		mIMEPos.y = textEvent.theReply.mCursorPosition.y +
 		            textEvent.theReply.mCursorPosition.height;
-		focusedWidget->LocalToWindowCoordinate(mIMEPos);
+		mTopLevelWidget->LocalToWindowCoordinate(mIMEPos);
 #ifdef DEBUG_TSM
 		printf("HandleTextEvent reply (%d,%d)\n", mIMEPos.x , mIMEPos.y);
 #endif
diff -uprN --exclude=CVS mozilla/widget/src/mac/nsMacWindow.cpp mozilla.new/widget/src/mac/nsMacWindow.cpp
--- mozilla/widget/src/mac/nsMacWindow.cpp	2006-01-09 06:48:56.000000000 +0100
+++ mozilla.new/widget/src/mac/nsMacWindow.cpp	2006-02-24 11:16:49.000000000 +0100
@@ -213,6 +213,9 @@ nsMacWindow::nsMacWindow() : Inherited()
   , mResizeIsFromUs(PR_FALSE)
   , mShown(PR_FALSE)
   , mMacEventHandler(nsnull)
+#if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_3
+  , mNeedsResize(PR_FALSE)
+#endif
 {
   mMacEventHandler.reset(new nsMacEventHandler(this));
   WIDGET_SET_CLASSNAME("nsMacWindow");  
@@ -572,7 +575,9 @@ nsresult nsMacWindow::StandardCreate(nsI
       // to enable live resizing
       { kEventClassWindow, kEventWindowBoundsChanged },
       // to roll up popups when we're minimized
-      { kEventClassWindow, kEventWindowCollapse },
+      { kEventClassWindow, kEventWindowCollapsing },
+      // to activate when restoring
+      { kEventClassWindow, kEventWindowExpanded },
       // to keep invisible windows off the screen
       { kEventClassWindow, kEventWindowConstrain },
       // to handle update events
@@ -699,14 +704,30 @@ nsMacWindow::WindowEventHandler ( EventH
       break;
 
       // roll up popups when we're minimized
-      case kEventWindowCollapse:
+      case kEventWindowCollapsing:
       {
         if ( gRollupListener && gRollupWidget )
           gRollupListener->Rollup();        
+        nsMacWindow *self = NS_REINTERPRET_CAST(nsMacWindow *, userData);
+        if (self) {
+          gEventDispatchHandler.DispatchGuiEvent(self, NS_DEACTIVATE);
+        }
         retVal = ::CallNextEventHandler(inHandlerChain, inEvent);
       }
       break;
-        
+
+      // Activate when restoring from the minimized state.  This ensures that
+      // the restored window will be able to take focus.
+      case kEventWindowExpanded:
+      {
+        nsMacWindow *self = NS_REINTERPRET_CAST(nsMacWindow *, userData);
+        if (self) {
+          gEventDispatchHandler.DispatchGuiEvent(self, NS_ACTIVATE);
+        }
+        retVal = ::CallNextEventHandler(inHandlerChain, inEvent);
+      }
+      break;
+
       default:
         // do nothing...
         break;
@@ -1412,6 +1433,24 @@ NS_IMETHODIMP nsMacWindow::Resize(PRInt3
 nsresult nsMacWindow::Resize(PRInt32 aWidth, PRInt32 aHeight, PRBool aRepaint, PRBool aFromUI)
 {
   if (mWindowMadeHere) {
+#if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_3
+    if (mInUpdate && nsToolkit::OSXVersion() < MAC_OS_X_VERSION_10_3_HEX) {
+      // Calling SizeWindow in the middle of an update will hang on 10.2,
+      // even if care is taken to break out of the update with EndUpdate.
+      // On 10.2, defer the resize until the update is done.  Update will
+      // call back into Resize with these values after the update is
+      // finished.
+      mResizeTo.width = aWidth;
+      mResizeTo.height = aHeight;
+      mResizeTo.repaint = aRepaint;
+      mResizeTo.fromUI = aFromUI;
+
+      mNeedsResize = PR_TRUE;
+
+      return NS_OK;
+    }
+#endif
+
     Rect windowRect;
     if (::GetWindowBounds(mWindowPtr, kWindowContentRgn, &windowRect)
         != noErr) {
@@ -2037,3 +2076,23 @@ nsresult nsMacWindow::GetDesktopRect(Rec
   // to be cleared.
   return NS_OK;
 }
+
+NS_IMETHODIMP nsMacWindow::Update()
+{
+  nsresult rv = Inherited::Update();
+
+#if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_3
+  if (NS_SUCCEEDED(rv) && mNeedsResize) {
+    // Something wanted to resize this window in the middle of the update
+    // above, and the host OS is 10.2.  The resize would have caused a
+    // hang in SizeWindow, so it was deferred.  Now that the update is
+    // done, it's safe to resize.
+    mNeedsResize = PR_FALSE;
+
+    Resize(mResizeTo.width, mResizeTo.height,
+           mResizeTo.repaint, mResizeTo.fromUI);
+  }
+#endif
+
+  return rv;
+}
diff -uprN --exclude=CVS mozilla/widget/src/mac/nsMacWindow.h mozilla.new/widget/src/mac/nsMacWindow.h
--- mozilla/widget/src/mac/nsMacWindow.h	2005-09-30 23:59:37.000000000 +0200
+++ mozilla.new/widget/src/mac/nsMacWindow.h	2006-02-24 11:16:49.000000000 +0100
@@ -132,6 +132,8 @@ public:
     WindowPtr GetWindowTop(WindowPtr baseWindowRef);
     void UpdateWindowMenubar(WindowPtr parentWindow, PRBool enableFlag);
 
+    NS_IMETHOD              Update();
+
 protected:
   
   void InstallBorderlessDefProc ( WindowPtr inWindow ) ;
@@ -164,6 +166,15 @@ protected:
 	auto_ptr<nsMacEventHandler>     mMacEventHandler;
 	nsIWidget                      *mOffsetParent;
 	
+#if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_3
+	PRPackedBool                    mNeedsResize;
+	struct {
+	  PRInt32      width;
+	  PRInt32      height;
+	  PRPackedBool repaint;
+	  PRPackedBool fromUI;
+	}                               mResizeTo;
+#endif
 };
 
 #endif // MacWindow_h__
diff -uprN --exclude=CVS mozilla/widget/src/os2/nsWindow.cpp mozilla.new/widget/src/os2/nsWindow.cpp
--- mozilla/widget/src/os2/nsWindow.cpp	2005-10-21 00:04:32.000000000 +0200
+++ mozilla.new/widget/src/os2/nsWindow.cpp	2006-02-14 10:01:30.000000000 +0100
@@ -557,6 +557,27 @@ PRBool nsWindow::DispatchAppCommandEvent
 }
 
 //-------------------------------------------------------------------------
+//
+// Dispatch DragDrop (target) event
+//
+//-------------------------------------------------------------------------
+PRBool nsWindow::DispatchDragDropEvent(PRUint32 aMsg)
+{
+  nsMouseEvent event(PR_TRUE, aMsg, this, nsMouseEvent::eReal);
+  InitEvent(event);
+
+  event.isShift   = WinIsKeyDown(VK_SHIFT);
+  event.isControl = WinIsKeyDown(VK_CTRL);
+  event.isAlt     = WinIsKeyDown(VK_ALT) || WinIsKeyDown(VK_ALTGRAF);
+  event.isMeta    = PR_FALSE;
+
+  PRBool result = DispatchWindowEvent(&event);
+  NS_RELEASE(event.widget);
+
+  return result;
+}
+
+//-------------------------------------------------------------------------
 NS_IMETHODIMP nsWindow::CaptureRollupEvents(nsIRollupListener * aListener, 
                                             PRBool aDoCapture, 
                                             PRBool aConsumeRollupEvent)
@@ -3935,10 +3956,10 @@ PRBool nsWindow::OnDragDropMsg(ULONG msg
         mDragStatus = gDragStatus = (dragFlags & DND_DragStatus);
 
         if (dragFlags & DND_DispatchEnterEvent)
-          DispatchStandardEvent(NS_DRAGDROP_ENTER);
+          DispatchDragDropEvent(NS_DRAGDROP_ENTER);
 
         if (dragFlags & DND_DispatchEvent)
-          DispatchStandardEvent(eventType);
+          DispatchDragDropEvent(eventType);
 
         if (dragFlags & DND_GetDragoverResult)
           dragSession->GetDragoverResult(mr);
diff -uprN --exclude=CVS mozilla/widget/src/os2/nsWindow.h mozilla.new/widget/src/os2/nsWindow.h
--- mozilla/widget/src/os2/nsWindow.h	2005-10-04 20:08:05.000000000 +0200
+++ mozilla.new/widget/src/os2/nsWindow.h	2006-02-14 10:01:30.000000000 +0100
@@ -322,6 +322,7 @@ protected:
    virtual PRBool DispatchWindowEvent(nsGUIEvent*event, nsEventStatus &aStatus);
    PRBool  DispatchStandardEvent( PRUint32 aMsg);
    PRBool  DispatchAppCommandEvent(PRUint32 aEventCommand);
+   PRBool  DispatchDragDropEvent(PRUint32 aMsg);
    virtual PRBool DispatchMouseEvent( PRUint32 aEventType, MPARAM mp1, MPARAM mp2);
    virtual PRBool DispatchResizeEvent( PRInt32 aClientX, PRInt32 aClientY);
    void GetNonClientBounds(nsRect &aRect);
diff -uprN --exclude=CVS mozilla/xpcom/base/Makefile.in mozilla.new/xpcom/base/Makefile.in
--- mozilla/xpcom/base/Makefile.in	2005-08-09 15:39:11.000000000 +0200
+++ mozilla.new/xpcom/base/Makefile.in	2006-02-24 11:16:39.000000000 +0100
@@ -70,6 +70,10 @@ CPPSRCS += nsLeakDetector.cpp
 REQUIRES	+= boehm
 endif
 
+ifeq ($(OS_ARCH),Darwin)
+CPPSRCS		+= nsMacUtilsImpl.cpp
+endif
+
 EXPORTS		= \
 		nsAgg.h \
 		nsAutoPtr.h \
@@ -124,6 +128,10 @@ ifdef GC_LEAK_DETECTOR
 XPIDLSRCS       += nsILeakDetector.idl
 endif
 
+ifeq ($(OS_ARCH),Darwin)
+XPIDLSRCS	+= nsIMacUtils.idl
+endif
+
 # we don't want the shared lib, but we want to force the creation of a static lib.
 FORCE_STATIC_LIB = 1
 
diff -uprN --exclude=CVS mozilla/xpcom/base/nscore.h mozilla.new/xpcom/base/nscore.h
--- mozilla/xpcom/base/nscore.h	2005-07-22 00:15:00.000000000 +0200
+++ mozilla.new/xpcom/base/nscore.h	2006-02-24 11:16:39.000000000 +0100
@@ -140,7 +140,7 @@
  *           NS_HIDDEN_(int) NS_FASTCALL func2(char *foo);
  */
 
-#if defined(__i386__) && defined(__GNUC__) && (__GNUC__ >= 3) && !defined(XP_OS2) && !defined(XP_MACOSX)
+#if defined(__i386__) && defined(__GNUC__) && (__GNUC__ >= 3) && !defined(XP_OS2)
 #define NS_FASTCALL __attribute__ ((regparm (3), stdcall))
 #else
 #define NS_FASTCALL
@@ -150,7 +150,7 @@
  * NS_DEFCALL undoes the effect of a global regparm/stdcall setting
  * so that xptcall works correctly.
  */
-#if defined(__i386__) && defined(__GNUC__) && (__GNUC__ >= 3) && !defined(XP_OS2) && !defined(XP_MACOSX)
+#if defined(__i386__) && defined(__GNUC__) && (__GNUC__ >= 3) && !defined(XP_OS2)
 #define NS_DEFCALL __attribute__ ((regparm (0), cdecl))
 #else
 #define NS_DEFCALL
diff -uprN --exclude=CVS mozilla/xpcom/base/nsIMacUtils.idl mozilla.new/xpcom/base/nsIMacUtils.idl
--- mozilla/xpcom/base/nsIMacUtils.idl	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/xpcom/base/nsIMacUtils.idl	2006-02-22 04:55:29.000000000 +0100
@@ -0,0 +1,52 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is XPCOM utility functions for Mac OS X
+ *
+ * The Initial Developer of the Original Code is Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Mark Mentovai <mark@moxienet.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISupports.idl"
+
+/**
+ * nsIMacUtils: Generic globally-available Mac-specific utilities.
+ */
+
+[scriptable, uuid(59BE3453-873B-450D-8DB8-2643E08A00BE)]
+interface nsIMacUtils : nsISupports
+{
+  /**
+   * True when the main executable is a fat file supporting at least
+   * ppc and x86 (universal binary).
+   */
+  readonly attribute boolean isUniversalBinary;
+};
diff -uprN --exclude=CVS mozilla/xpcom/base/nsMacUtilsImpl.cpp mozilla.new/xpcom/base/nsMacUtilsImpl.cpp
--- mozilla/xpcom/base/nsMacUtilsImpl.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/xpcom/base/nsMacUtilsImpl.cpp	2006-02-22 04:55:29.000000000 +0100
@@ -0,0 +1,125 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is XPCOM utility functions for Mac OS X
+ *
+ * The Initial Developer of the Original Code is Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Mark Mentovai <mark@moxienet.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsMacUtilsImpl.h"
+
+#include <CoreFoundation/CoreFoundation.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <mach-o/fat.h>
+
+NS_IMPL_ISUPPORTS1(nsMacUtilsImpl, nsIMacUtils)
+
+/* readonly attribute boolean isUniversalBinary; */
+// True when the main executable is a fat file supporting at least
+// ppc and x86 (universal binary).
+NS_IMETHODIMP nsMacUtilsImpl::GetIsUniversalBinary(PRBool *aIsUniversalBinary)
+{
+  static PRBool sInitialized = PR_FALSE,
+                sIsUniversalBinary = PR_FALSE;
+
+  if (sInitialized) {
+    *aIsUniversalBinary = sIsUniversalBinary;
+    return NS_OK;
+  }
+
+  PRBool foundPPC = PR_FALSE,
+         foundX86 = PR_FALSE;
+  CFURLRef executableURL = nsnull;
+  int fd = -1;
+
+  CFBundleRef mainBundle;
+  if (!(mainBundle = ::CFBundleGetMainBundle()))
+    goto done;
+
+  if (!(executableURL = ::CFBundleCopyExecutableURL(mainBundle)))
+    goto done;
+
+  char executablePath[PATH_MAX];
+  if (!::CFURLGetFileSystemRepresentation(executableURL, PR_TRUE,
+                                          (UInt8*) executablePath,
+                                          sizeof(executablePath)))
+    goto done;
+
+  if ((fd = open(executablePath, O_RDONLY)) == -1)
+    goto done;
+
+  struct fat_header fatHeader;
+  if (read(fd, &fatHeader, sizeof(fatHeader)) != sizeof(fatHeader))
+    goto done;
+
+  // The fat header is always stored on disk as big-endian.
+  fatHeader.magic = CFSwapInt32BigToHost(fatHeader.magic);
+  fatHeader.nfat_arch = CFSwapInt32BigToHost(fatHeader.nfat_arch);
+
+  // Main executable is thin.
+  if (fatHeader.magic != FAT_MAGIC)
+    goto done;
+
+  // Loop over each architecture in the file.  We're presently only
+  // interested in 32-bit PPC and x86.
+  for (PRUint32 i = 0 ; i < fatHeader.nfat_arch ; i++) {
+    struct fat_arch fatArch;
+    if (read(fd, &fatArch, sizeof(fatArch)) != sizeof(fatArch))
+      goto done;
+
+    // This is still part of the fat header, so byte-swap as needed.
+    fatArch.cputype = CFSwapInt32BigToHost(fatArch.cputype);
+
+    // Don't mask out the ABI bits.  This allows identification of ppc64
+    // as distinct from ppc.  CPU_TYPE_X86 is preferred to CPU_TYPE_I386
+    // but does not exist prior to the 10.4 headers.
+    if (fatArch.cputype == CPU_TYPE_POWERPC)
+      foundPPC = PR_TRUE;
+    else if (fatArch.cputype == CPU_TYPE_I386)
+      foundX86 = PR_TRUE;
+  }
+
+  if (foundPPC && foundX86)
+    sIsUniversalBinary = PR_TRUE;
+
+done:
+  if (fd != -1)
+    close(fd);
+  if (executableURL)
+    ::CFRelease(executableURL);
+
+  *aIsUniversalBinary = sIsUniversalBinary;
+  sInitialized = PR_TRUE;
+
+  return NS_OK;
+}
diff -uprN --exclude=CVS mozilla/xpcom/base/nsMacUtilsImpl.h mozilla.new/xpcom/base/nsMacUtilsImpl.h
--- mozilla/xpcom/base/nsMacUtilsImpl.h	1970-01-01 01:00:00.000000000 +0100
+++ mozilla.new/xpcom/base/nsMacUtilsImpl.h	2006-02-22 04:55:29.000000000 +0100
@@ -0,0 +1,62 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is XPCOM utility functions for Mac OS X
+ *
+ * The Initial Developer of the Original Code is Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Mark Mentovai <mark@moxienet.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsMacUtilsImpl_h___
+#define nsMacUtilsImpl_h___
+
+#include "nsIMacUtils.h"
+
+class nsMacUtilsImpl : public nsIMacUtils
+{
+public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIMACUTILS
+
+  nsMacUtilsImpl() {}
+
+private:
+  ~nsMacUtilsImpl() {}
+};
+
+// Global singleton service
+// 697BD3FD-43E5-41CE-AD5E-C339175C0818
+#define NS_MACUTILSIMPL_CLASSNAME "Mac OS X Utilities"
+#define NS_MACUTILSIMPL_CID \
+ {0x697BD3FD, 0x43E5, 0x41CE, {0xAD, 0x5E, 0xC3, 0x39, 0x17, 0x5C, 0x08, 0x18}}
+#define NS_MACUTILSIMPL_CONTRACTID "@mozilla.org/xpcom/mac-utils;1"
+
+#endif /* nsMacUtilsImpl_h___ */
diff -uprN --exclude=CVS mozilla/xpcom/base/nsStackFrameUnix.cpp mozilla.new/xpcom/base/nsStackFrameUnix.cpp
--- mozilla/xpcom/base/nsStackFrameUnix.cpp	2004-04-18 16:18:12.000000000 +0200
+++ mozilla.new/xpcom/base/nsStackFrameUnix.cpp	2006-02-24 11:16:39.000000000 +0100
@@ -83,25 +83,15 @@ void DemangleSymbol(const char * aSymbol
 }
 
 
-#if defined(linux) && defined(__GLIBC__) && (defined(__i386) || defined(PPC)) // i386 or PPC Linux stackwalking code
+#if defined(linux) && defined(__GNUC__) && (defined(__i386) || defined(PPC)) // i386 or PPC Linux stackwalking code
 
-#include <setjmp.h>
-//
 
 void DumpStackToFile(FILE* aStream)
 {
-  jmp_buf jb;
-  setjmp(jb);
-
   // Stack walking code courtesy Kipp's "leaky".
 
-  // Get the frame pointer out of the jmp_buf
-  void **bp = (void**)
-#if defined(__i386) 
-    (jb[0].__jmpbuf[JB_BP]);
-#elif defined(PPC)
-    (jb[0].__jmpbuf[JB_GPR1]);
-#endif
+  // Get the frame pointer
+  void **bp = (void**) __builtin_frame_address(0);
 
   int skip = 2;
   for ( ; (void**)*bp > bp; bp = (void**)*bp) {
diff -uprN --exclude=CVS mozilla/xpcom/base/nsTraceRefcntImpl.cpp mozilla.new/xpcom/base/nsTraceRefcntImpl.cpp
--- mozilla/xpcom/base/nsTraceRefcntImpl.cpp	2005-06-24 02:24:41.000000000 +0200
+++ mozilla.new/xpcom/base/nsTraceRefcntImpl.cpp	2006-02-24 11:16:39.000000000 +0100
@@ -50,19 +50,6 @@
 
 #if defined(_WIN32)
 #include <windows.h>
-#elif defined(linux) && defined(__GLIBC__) && (defined(__i386) || defined(PPC))
-#include <setjmp.h>
-
-//
-// On glibc 2.1, the Dl_info api defined in <dlfcn.h> is only exposed
-// if __USE_GNU is defined.  I suppose its some kind of standards
-// adherence thing.
-//
-#if (__GLIBC_MINOR__ >= 1) && !defined(__USE_GNU)
-#define __USE_GNU
-#endif
-
-#include <dlfcn.h>
 #endif
 
 #ifdef HAVE_LIBDL
@@ -460,7 +447,7 @@ static PRIntn PR_CALLBACK DumpSerialNumb
 
 #endif /* NS_BUILD_REFCNT_LOGGING */
 
-nsresult
+NS_COM nsresult
 nsTraceRefcntImpl::DumpStatistics(StatisticsType type, FILE* out)
 {
   nsresult rv = NS_OK;
@@ -537,7 +524,7 @@ done:
   return rv;
 }
 
-void
+NS_COM void
 nsTraceRefcntImpl::ResetStatistics()
 {
 #ifdef NS_BUILD_REFCNT_LOGGING
@@ -821,7 +808,7 @@ static void InitTraceLog(void)
 
 #if defined(_WIN32) && defined(_M_IX86) && !defined(WINCE) // WIN32 x86 stack walking code
 #include "nsStackFrameWin.h"
-void
+NS_COM void
 nsTraceRefcntImpl::WalkTheStack(FILE* aStream)
 {
   DumpStackToFile(aStream);
@@ -829,9 +816,9 @@ nsTraceRefcntImpl::WalkTheStack(FILE* aS
 
 // WIN32 x86 stack walking code
 // i386 or PPC Linux stackwalking code or Solaris
-#elif (defined(linux) && defined(__GLIBC__) && (defined(__i386) || defined(PPC))) || (defined(__sun) && (defined(__sparc) || defined(sparc) || defined(__i386) || defined(i386)))
+#elif (defined(linux) && defined(__GNUC__) && (defined(__i386) || defined(PPC))) || (defined(__sun) && (defined(__sparc) || defined(sparc) || defined(__i386) || defined(i386)))
 #include "nsStackFrameUnix.h"
-void
+NS_COM void
 nsTraceRefcntImpl::WalkTheStack(FILE* aStream)
 {
   DumpStackToFile(aStream);
@@ -839,7 +826,7 @@ nsTraceRefcntImpl::WalkTheStack(FILE* aS
 
 #else // unsupported platform.
 
-void
+NS_COM void
 nsTraceRefcntImpl::WalkTheStack(FILE* aStream)
 {
 	fprintf(aStream, "write me, dammit!\n");
diff -uprN --exclude=CVS mozilla/xpcom/build/nsXPComInit.cpp mozilla.new/xpcom/build/nsXPComInit.cpp
--- mozilla/xpcom/build/nsXPComInit.cpp	2005-09-28 18:45:07.000000000 +0200
+++ mozilla.new/xpcom/build/nsXPComInit.cpp	2006-02-24 11:16:39.000000000 +0100
@@ -122,6 +122,10 @@
 #include "nsWindowsRegKey.h"
 #endif
 
+#ifdef XP_MACOSX
+#include "nsMacUtilsImpl.h"
+#endif
+
 #include <locale.h>
 
 // Registry Factory creation function defined in nsRegistry.cpp
@@ -205,6 +209,10 @@ NS_GENERIC_FACTORY_CONSTRUCTOR(nsTimelin
 
 NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsHashPropertyBag, Init)
 
+#ifdef XP_MACOSX
+NS_GENERIC_FACTORY_CONSTRUCTOR(nsMacUtilsImpl)
+#endif
+
 static NS_METHOD
 nsXPTIInterfaceInfoManagerGetSingleton(nsISupports* outer,
                                        const nsIID& aIID,
@@ -391,6 +399,10 @@ static const nsModuleComponentInfo compo
 #if defined(XP_WIN) && !defined(WINCE)
     COMPONENT(WINDOWSREGKEY, nsWindowsRegKeyConstructor),
 #endif
+
+#ifdef XP_MACOSX
+    COMPONENT(MACUTILSIMPL, nsMacUtilsImplConstructor),
+#endif
 };
 
 #undef COMPONENT
diff -uprN --exclude=CVS mozilla/xpcom/glue/nsGREGlue.cpp mozilla.new/xpcom/glue/nsGREGlue.cpp
--- mozilla/xpcom/glue/nsGREGlue.cpp	2006-01-09 06:48:51.000000000 +0100
+++ mozilla.new/xpcom/glue/nsGREGlue.cpp	2006-03-03 07:13:51.000000000 +0100
@@ -211,11 +211,10 @@ GRE_GetGREPathWithProperties(const GREVe
           if (CFURLGetFileSystemRepresentation(xpcomurl, PR_TRUE,
                                                (UInt8*) tbuffer,
                                                sizeof(tbuffer)) &&
-              access(tbuffer, R_OK | X_OK) == 0 &&
-              realpath(tbuffer, aBuffer)) {
-            char *lastslash = strrchr(aBuffer, '/');
-            if (lastslash)
-              *lastslash = '\0';
+              access(tbuffer, R_OK | X_OK) == 0) {
+            if (!realpath(tbuffer, aBuffer)) {
+              aBuffer[0] = '\0';
+            }
           }
 
           CFRelease(xpcomurl);
diff -uprN --exclude=CVS mozilla/xpcom/glue/pldhash.h mozilla.new/xpcom/glue/pldhash.h
--- mozilla/xpcom/glue/pldhash.h	2005-08-19 21:36:58.000000000 +0200
+++ mozilla.new/xpcom/glue/pldhash.h	2006-02-24 11:16:39.000000000 +0100
@@ -46,7 +46,7 @@
 
 PR_BEGIN_EXTERN_C
 
-#if defined(__GNUC__) && defined(__i386__) && (__GNUC__ >= 3) && !defined(XP_OS2) && !defined(XP_MACOSX)
+#if defined(__GNUC__) && defined(__i386__) && (__GNUC__ >= 3) && !defined(XP_OS2)
 #define PL_DHASH_FASTCALL __attribute__ ((regparm (3),stdcall))
 #else
 #define PL_DHASH_FASTCALL
diff -uprN --exclude=CVS mozilla/xpcom/glue/standalone/nsGlueLinkingDlopen.cpp mozilla.new/xpcom/glue/standalone/nsGlueLinkingDlopen.cpp
--- mozilla/xpcom/glue/standalone/nsGlueLinkingDlopen.cpp	2006-01-09 06:48:51.000000000 +0100
+++ mozilla.new/xpcom/glue/standalone/nsGlueLinkingDlopen.cpp	2006-02-24 11:16:39.000000000 +0100
@@ -94,7 +94,7 @@ XPCOMGlueLoad(const char *xpcomFile)
 
             XPCOMGlueLoadDependentLibs(xpcomDir, ReadDependentCB);
 
-            sprintf(lastSlash, "/" XUL_DLL);
+            snprintf(lastSlash, MAXPATHLEN - strlen(xpcomDir), "/" XUL_DLL);
 
             sXULLibHandle = dlopen(xpcomDir, RTLD_GLOBAL | RTLD_LAZY);
         }
diff -uprN --exclude=CVS mozilla/xpcom/glue/standalone/nsGlueLinkingOSX.cpp mozilla.new/xpcom/glue/standalone/nsGlueLinkingOSX.cpp
--- mozilla/xpcom/glue/standalone/nsGlueLinkingOSX.cpp	2006-01-09 06:48:51.000000000 +0100
+++ mozilla.new/xpcom/glue/standalone/nsGlueLinkingOSX.cpp	2006-02-24 11:16:39.000000000 +0100
@@ -45,6 +45,8 @@
 #include <string.h>
 #include <stdio.h>
 
+static const mach_header* sXULLibImage;
+
 static void
 ReadDependentCB(const char *aDependentLib)
 {
@@ -53,9 +55,35 @@ ReadDependentCB(const char *aDependentLi
                       NSADDIMAGE_OPTION_MATCH_FILENAME_BY_INSTALLNAME);
 }
 
+static void*
+LookupSymbol(const mach_header* aLib, const char* aSymbolName)
+{
+    // Try to use |NSLookupSymbolInImage| since it is faster than searching
+    // the global symbol table.  If we couldn't get a mach_header pointer
+    // for the XPCOM dylib, then use |NSLookupAndBindSymbol| to search the
+    // global symbol table (this shouldn't normally happen, unless the user
+    // has called XPCOMGlueStartup(".") and relies on libxpcom.dylib
+    // already being loaded).
+    NSSymbol sym = nsnull;
+    if (aLib) {
+        sym = NSLookupSymbolInImage(aLib, aSymbolName,
+                                 NSLOOKUPSYMBOLINIMAGE_OPTION_BIND |
+                                 NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR);
+    } else {
+        if (NSIsSymbolNameDefined(aSymbolName))
+            sym = NSLookupAndBindSymbol(aSymbolName);
+    }
+    if (!sym)
+        return nsnull;
+
+    return NSAddressOfSymbol(sym);
+}
+
 GetFrozenFunctionsFunc
 XPCOMGlueLoad(const char *xpcomFile)
 {
+    const mach_header* lib = nsnull;
+
     if (xpcomFile[0] != '.' || xpcomFile[1] != '\0') {
         char xpcomDir[PATH_MAX];
         if (realpath(xpcomFile, xpcomDir)) {
@@ -64,22 +92,23 @@ XPCOMGlueLoad(const char *xpcomFile)
                 *lastSlash = '\0';
 
                 XPCOMGlueLoadDependentLibs(xpcomDir, ReadDependentCB);
+
+                snprintf(lastSlash, PATH_MAX - strlen(xpcomDir), "/" XUL_DLL);
+
+                sXULLibImage = NSAddImage(xpcomDir,
+                              NSADDIMAGE_OPTION_RETURN_ON_ERROR |
+                              NSADDIMAGE_OPTION_WITH_SEARCHING |
+                              NSADDIMAGE_OPTION_MATCH_FILENAME_BY_INSTALLNAME);
             }
         }
 
-        (void) NSAddImage(xpcomFile,
-                          NSADDIMAGE_OPTION_RETURN_ON_ERROR |
-                          NSADDIMAGE_OPTION_WITH_SEARCHING |
-                          NSADDIMAGE_OPTION_MATCH_FILENAME_BY_INSTALLNAME);
-        // We don't really care if this fails, as long as we can get
-        // NS_GetFrozenFunctions below.
+        lib = NSAddImage(xpcomFile,
+                         NSADDIMAGE_OPTION_RETURN_ON_ERROR |
+                         NSADDIMAGE_OPTION_WITH_SEARCHING |
+                         NSADDIMAGE_OPTION_MATCH_FILENAME_BY_INSTALLNAME);
     }
 
-    if (!NSIsSymbolNameDefined("_NS_GetFrozenFunctions"))
-      return nsnull;
-
-    NSSymbol sym = NSLookupAndBindSymbol("_NS_GetFrozenFunctions");
-    return (GetFrozenFunctionsFunc) NSAddressOfSymbol(sym);
+    return (GetFrozenFunctionsFunc) LookupSymbol(lib, "_NS_GetFrozenFunctions");
 }
 
 void
@@ -96,13 +125,9 @@ XPCOMGlueLoadXULFunctions(const nsDynami
         char buffer[512];
         snprintf(buffer, sizeof(buffer), "_%s", symbols->functionName);
 
-        if (!NSIsSymbolNameDefined(buffer)) {
+        *symbols->function = (NSFuncPtr) LookupSymbol(sXULLibImage, buffer);
+        if (!*symbols->function)
             rv = NS_ERROR_LOSS_OF_SIGNIFICANT_DATA;
-        }
-        else {
-            NSSymbol sym = NSLookupAndBindSymbol(buffer);
-            *symbols->function = (NSFuncPtr) NSAddressOfSymbol(sym);
-        }
 
         ++symbols;
     }
diff -uprN --exclude=CVS mozilla/xpcom/glue/standalone/nsGlueLinkingWin.cpp mozilla.new/xpcom/glue/standalone/nsGlueLinkingWin.cpp
--- mozilla/xpcom/glue/standalone/nsGlueLinkingWin.cpp	2006-01-09 06:48:51.000000000 +0100
+++ mozilla.new/xpcom/glue/standalone/nsGlueLinkingWin.cpp	2006-02-24 11:16:39.000000000 +0100
@@ -110,7 +110,7 @@ XPCOMGlueLoad(const char *xpcomFile)
 
             XPCOMGlueLoadDependentLibs(xpcomDir, ReadDependentCB);
 
-            sprintf(lastSlash, "\\" XUL_DLL);
+            _snprintf(lastSlash, MAXPATHLEN - strlen(xpcomDir), "\\" XUL_DLL);
 
             sXULLibrary =
                 LoadLibraryEx(xpcomDir, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
diff -uprN --exclude=CVS mozilla/xpcom/obsolete/nsFileSpecWin.cpp mozilla.new/xpcom/obsolete/nsFileSpecWin.cpp
--- mozilla/xpcom/obsolete/nsFileSpecWin.cpp	2005-01-30 22:33:45.000000000 +0100
+++ mozilla.new/xpcom/obsolete/nsFileSpecWin.cpp	2006-02-24 11:16:39.000000000 +0100
@@ -20,6 +20,7 @@
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
+ *   Masayuki Nakano <masayuki@d-toybox.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
@@ -46,6 +47,7 @@
 #include "nsError.h"
 
 #include <windows.h>
+#include <mbstring.h>
 
 #if (_MSC_VER == 1100) || defined(__GNUC__)
 #define INITGUID
@@ -412,12 +414,12 @@ nsresult nsFileSpec::ResolveSymlink(PRBo
 void nsFileSpec::GetParent(nsFileSpec& outSpec) const
 //----------------------------------------------------------------------------------------
 {
-	outSpec.mPath = mPath;
-	char* chars = (char*)outSpec.mPath;
-	chars[outSpec.mPath.Length() - 1] = '\0'; // avoid trailing separator, if any
-    char* cp = strrchr(chars, '\\');
-    if (cp++)
-	    outSpec.mPath.SetLength(cp - chars); // truncate.
+  outSpec.mPath = mPath;
+  char* chars = (char*)outSpec.mPath;
+  chars[outSpec.mPath.Length() - 1] = '\0'; // avoid trailing separator, if any
+  unsigned char* cp = _mbsrchr((unsigned char*)chars, '\\');
+  if (cp++)
+    outSpec.mPath.SetLength(cp - (unsigned char*)chars); // truncate.
 } // nsFileSpec::GetParent
 
 //----------------------------------------------------------------------------------------
diff -uprN --exclude=CVS mozilla/xpcom/reflect/xptcall/src/md/unix/xptcinvoke_unixish_x86.cpp mozilla.new/xpcom/reflect/xptcall/src/md/unix/xptcinvoke_unixish_x86.cpp
--- mozilla/xpcom/reflect/xptcall/src/md/unix/xptcinvoke_unixish_x86.cpp	2005-07-26 02:59:40.000000000 +0200
+++ mozilla.new/xpcom/reflect/xptcall/src/md/unix/xptcinvoke_unixish_x86.cpp	2006-02-24 11:16:39.000000000 +0100
@@ -20,6 +20,7 @@
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
+ *   Mark Mentovai <mark@moxienet.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
@@ -78,34 +79,54 @@ XPTC_InvokeByIndex(nsISupports* that, PR
 {
 #ifdef __GNUC__            /* Gnu compiler. */
   PRUint32 result;
-  // Each param takes at most 2, 4-byte words
-  // It doesn't matter if we push too many words, and calculating the exact
-  // ammount takes time.
+  /* Each param takes at most 2, 4-byte words
+     It doesn't matter if we push too many words, and calculating the exact
+     amount takes time. */
   PRUint32 n = paramCount << 3;
   void (*fn_copy) (unsigned int, nsXPTCVariant *, PRUint32 *) = invoke_copy_to_stack;
-  int temp1, temp2, temp3;
+  int temp1, temp2;
  
-#ifdef XP_MACOSX
+  /* These are only significant when KEEP_STACK_16_BYTE_ALIGNED is
+     defined.  Otherwise, they're just placeholders to keep the parameter
+     indices the same for aligned and unaligned users in the inline asm
+     block. */
   unsigned int saved_esp;
-  __asm__ __volatile__(
-    "movl %%esp, %0\n\t"
-    : "=r"(saved_esp));
-#endif
   
  __asm__ __volatile__(
-    "subl  %8, %%esp\n\t" /* make room for params */
-#ifdef XP_MACOSX
-    /* the subl and the addl around the andl compensate for the push
-       of the this parameter below */
-    "subl $0x4, %%esp\n\t"
-    "andl $0xfffffff0, %%esp\n\t" /* make sure stack is 16-byte aligned */
-    "addl $0x4, %%esp\n\t"
+#ifdef KEEP_STACK_16_BYTE_ALIGNED
+    "movl  %%esp, %3\n\t"
 #endif
+    "subl  %8, %%esp\n\t" /* make room for params */
+#ifdef KEEP_STACK_16_BYTE_ALIGNED
+    /* For the second CALL, there will be one parameter before the ones
+       copied by invoke_copy_to_stack.  Make sure that the stack will be
+       aligned for that CALL. */
+    "subl  $4, %%esp\n\t"
+    "andl  $0xfffffff0, %%esp\n\t"
+    /* For the first CALL, there are three parameters.  Leave padding to
+       ensure alignment. */
+    "subl  $4, %%esp\n\t"
+    /* The third parameter to invoke_copy_to_stack is the destination pointer.
+       It needs to point into the parameter area prepared for the second CALL,
+       leaving room for the |that| parameter.  This reuses |n|, which was
+       the stack space to reserve, but that's OK because it's no longer needed
+       if the stack is being kept aligned. */
+    "leal  8(%%esp), %8\n\t"
+    "pushl %8\n\t"
+#else
     "pushl %%esp\n\t"
+#endif
     "pushl %7\n\t"
     "pushl %6\n\t"
-    "call  *%0\n\t"       /* copy params */
+    "call  *%9\n\t"       /* copy params */
+#ifdef KEEP_STACK_16_BYTE_ALIGNED
+    /* The stack is still aligned from the first CALL.  Keep it aligned for
+       the next one by popping past the parameters from the first CALL and
+       leaving space for the first (|that|) parameter for the second CALL. */
+    "addl  $0x14, %%esp\n\t"
+#else
     "addl  $0xc, %%esp\n\t"
+#endif
     "movl  %4, %%ecx\n\t"
 #ifdef CFRONT_STYLE_THIS_ADJUST
     "movl  (%%ecx), %%edx\n\t"
@@ -128,31 +149,35 @@ XPTC_InvokeByIndex(nsISupports* that, PR
 #endif /* G++ V3 ABI */
 #endif
     "call  *(%%edx)\n\t"    /* safe to not cleanup esp */
+#ifdef KEEP_STACK_16_BYTE_ALIGNED
+    "movl  %3, %%esp\n\t"
+#else
     "addl  $4, %%esp\n\t"
     "addl  %8, %%esp"
+#endif
     : "=a" (result),        /* %0 */
       "=c" (temp1),         /* %1 */
       "=d" (temp2),         /* %2 */
-      "=g" (temp3)          /* %3 */
+#ifdef KEEP_STACK_16_BYTE_ALIGNED
+      "=&g" (saved_esp)     /* %3 */
+#else
+      /* Don't waste a register, this isn't used if alignment is unimportant */
+      "=m" (saved_esp)      /* %3 */
+#endif
     : "g" (that),           /* %4 */
       "g" (methodIndex),    /* %5 */
       "1" (paramCount),     /* %6 */
       "2" (params),         /* %7 */
+#ifdef KEEP_STACK_16_BYTE_ALIGNED
+      /* Must be in a register, it's the target of an LEA instruction */
+      "r" (n),              /* %8 */
+#else
       "g" (n),              /* %8 */
-      "0" (fn_copy)         /* %3 */
+#endif
+      "0" (fn_copy)         /* %9 */
     : "memory"
-#ifdef XP_MACOSX
-      , "%esp"
-#endif 
     );
     
-#ifdef XP_MACOSX
- __asm__ __volatile__(
-    "movl %0, %%esp\n\t"
-    :
-    : "r"(saved_esp));
-#endif 
- 
   return result;
 
 #else
diff -uprN --exclude=CVS mozilla/xpcom/reflect/xptcall/src/md/unix/xptc_platforms_unixish_x86.h mozilla.new/xpcom/reflect/xptcall/src/md/unix/xptc_platforms_unixish_x86.h
--- mozilla/xpcom/reflect/xptcall/src/md/unix/xptc_platforms_unixish_x86.h	2004-04-18 16:18:18.000000000 +0200
+++ mozilla.new/xpcom/reflect/xptcall/src/md/unix/xptc_platforms_unixish_x86.h	2006-02-24 11:16:39.000000000 +0100
@@ -159,3 +159,11 @@
 #if defined(THUNK_BASED_THIS_ADJUST) && defined(CFRONT_STYLE_THIS_ADJUST)
 #error "need to define only ONE 'this' adjust scheme"    
 #endif
+
+/* Define KEEP_STACK_16_BYTE_ALIGNED if the stack needs to maintain alignment
+ * in a CALL for some good reason (like ABI compliance). */
+
+#ifdef XP_MACOSX
+/* http://developer.apple.com/documentation/DeveloperTools/Conceptual/LowLevelABI/Articles/IA32.html */
+#define KEEP_STACK_16_BYTE_ALIGNED
+#endif
diff -uprN --exclude=CVS mozilla/xpcom/typelib/xpidl/Makefile.in mozilla.new/xpcom/typelib/xpidl/Makefile.in
--- mozilla/xpcom/typelib/xpidl/Makefile.in	2006-01-09 06:48:52.000000000 +0100
+++ mozilla.new/xpcom/typelib/xpidl/Makefile.in	2006-02-24 11:16:39.000000000 +0100
@@ -54,6 +54,59 @@ HOST_PROGRAM	= host_xpidl$(HOST_BIN_SUFF
 HOST_CSRCS	= $(CSRCS)
 endif
 
+ifeq ($(OS_ARCH),Darwin)
+# The only reason to not always strip the SDK out is that the libraries
+# in / on ppc currently aren't fat, preventing the target xpidl from linking
+# on a ppc->x86 build.  The SDK, presumably 10.4u, must be included in that
+# case in order to successfully link.  Because the target xpidl isn't
+# currently built in a cross compile, though, this point is moot for the
+# time being.
+
+ifndef CROSS_COMPILE
+# When doing a native build, don't build xpidl against the SDK.  libIDL
+# was most likely configured for the system headers, and bringing in the
+# SDK's headers instead will cause problems.
+_STRIP_SDK = 1
+else
+
+# Cross-compiling
+
+# Don't build xpidl for the target.  This is not intended to be a permanent
+# solution.  It's necessary because it is presently difficult to build
+# xpidl's prerequisites (libIDL and glib) as fat and suitable for a cross.
+# This will be fixed.  -mm
+PROGRAM=
+
+# Since only host_xpidl will be built for now, always strip out the SDK
+# (as above).
+_STRIP_SDK=1
+
+# When fat xpidl prerequisites are available, the PROGRAM= and _STRIP_SDK=1
+# above are expected to disappear, and be replaced with the following
+# conditonal.
+
+# ifeq (86_powerpc,$(findstring 86,$(host_cpu))_$(TARGET_CPU))
+# # When cross-compiling from x86 to ppc, an old (10.2-ish) SDK might be in
+# # use, and libIDL will have been configured for new (10.4-ish) headers.
+# _STRIP_SDK = 1
+# endif
+
+endif # CROSS_COMPILE
+
+ifneq (,$(_STRIP_SDK)$(MACOS_SDK_DIR))
+# libIDL is configured for the system's headers, with no SDK involved.
+# There may be header conflicts if the SDK used for the Mozilla build
+# is used here.  There are very few specific cases where the SDK needs to
+# remain set to build xpidl.
+NEXT_ROOT=
+OS_CFLAGS := $(shell echo $(OS_CFLAGS)|sed -E -e "s%((-I|-isystem )$(MACOS_SDK_DIR)/usr/(include|lib/gcc)[^ ]*)|-F$(MACOS_SDK_DIR)(/System)?/Library/Frameworks[^ ]*|-nostdinc[^ ]*|-isysroot $(MACOS_SDK_DIR)%%g")
+OS_CFLAGS := $(patsubst -I$(MACOS_SDK_DIR)%,-I%,$(OS_CFLAGS))
+OS_LIBS := $(patsubst -L$(MACOS_SDK_DIR)/usr/lib%,,$(OS_LIBS))
+LDFLAGS := $(shell echo $(LDFLAGS)|sed -E -e "s%-Wl,-syslibroot,$(MACOS_SDK_DIR)%%g")
+endif # _STRIP_SDK
+
+endif # Darwin
+
 include $(topsrcdir)/config/rules.mk
 
 CFLAGS		+= $(LIBIDL_CFLAGS)
@@ -93,14 +146,5 @@ endif
 
 endif
 
-ifdef MACOS_SDK_DIR
-# xpidl is for the build host, pull out the cross-compilation stuff
-NEXT_ROOT=
-OS_CFLAGS := $(shell echo $(OS_CFLAGS)|sed -E -e "s%((-I|-isystem )$(MACOS_SDK_DIR)/usr/(include|lib/gcc)[^ ]*)|-F$(MACOS_SDK_DIR)(/System)?/Library/Frameworks[^ ]*|-nostdinc[^ ]*|-isysroot $(MACOS_SDK_DIR)%%g")
-OS_CFLAGS := $(patsubst -I$(MACOS_SDK_DIR)%,-I%,$(OS_CFLAGS))
-OS_LIBS := $(patsubst -L$(MACOS_SDK_DIR)/usr/lib%,,$(OS_LIBS))
-LDFLAGS := $(shell echo $(LDFLAGS)|sed -E -e "s%-Wl,-syslibroot,$(MACOS_SDK_DIR)%%g")
-endif
-
 export::
 	@$(MAKE) libs
diff -uprN --exclude=CVS mozilla/xpfe/appshell/src/nsXULWindow.cpp mozilla.new/xpfe/appshell/src/nsXULWindow.cpp
--- mozilla/xpfe/appshell/src/nsXULWindow.cpp	2005-10-21 01:18:02.000000000 +0200
+++ mozilla.new/xpfe/appshell/src/nsXULWindow.cpp	2006-03-04 21:31:41.000000000 +0100
@@ -857,6 +857,7 @@ NS_IMETHODIMP nsXULWindow::SetTitle(cons
 {
    NS_ENSURE_STATE(mWindow);
    mTitle.Assign(aTitle);
+   mTitle.StripChars("\n\r");
    NS_ENSURE_SUCCESS(mWindow->SetTitle(mTitle), NS_ERROR_FAILURE);
 
    // Tell the window mediator that a title has changed
diff -uprN --exclude=CVS mozilla/xpfe/bootstrap/module.ver mozilla.new/xpfe/bootstrap/module.ver
--- mozilla/xpfe/bootstrap/module.ver	2005-09-19 19:43:56.000000000 +0200
+++ mozilla.new/xpfe/bootstrap/module.ver	2006-02-14 10:01:36.000000000 +0100
@@ -1,7 +1,7 @@
 WIN32_MODULE_COMPANYNAME=mozilla.org
 WIN32_MODULE_COPYRIGHT=Mozilla Developers, according to the MPL 1.1/GPL 2.0/LGPL 2.1 licenses, as applicable.
 WIN32_MODULE_PRODUCTVERSION=1,0,0,0
-WIN32_MODULE_PRODUCTVERSION_STRING=1.0b
+WIN32_MODULE_PRODUCTVERSION_STRING=1.0
 WIN32_MODULE_TRADEMARKS=SeaMonkey and Mozilla are trademarks of The Mozilla Foundation.
 WIN32_MODULE_DESCRIPTION=@MOZ_APP_DISPLAYNAME@
 WIN32_MODULE_PRODUCTNAME=@MOZ_APP_DISPLAYNAME@
diff -uprN --exclude=CVS mozilla/xpfe/bootstrap/nsNativeAppSupportWin.cpp mozilla.new/xpfe/bootstrap/nsNativeAppSupportWin.cpp
--- mozilla/xpfe/bootstrap/nsNativeAppSupportWin.cpp	2006-01-09 06:48:57.000000000 +0100
+++ mozilla.new/xpfe/bootstrap/nsNativeAppSupportWin.cpp	2006-02-14 10:01:36.000000000 +0100
@@ -1936,6 +1936,10 @@ nsNativeAppSupportWin::HandleRequest( LP
     rv = handler->GetDefaultArgs(getter_Copies(defaultArgs));
     if (NS_FAILED(rv) || defaultArgs.IsEmpty()) return rv;
 
+    // force a new window for a home page group
+    if (FindCharInString(defaultArgs, '\n') != kNotFound)
+        newWindow = PR_TRUE;
+
     NS_ConvertUTF16toUTF8 url( defaultArgs );
     return OpenBrowserWindow(url.get(), newWindow, aResult);
 }
diff -uprN --exclude=CVS mozilla/xpfe/communicator/resources/content/contentAreaDD.js mozilla.new/xpfe/communicator/resources/content/contentAreaDD.js
--- mozilla/xpfe/communicator/resources/content/contentAreaDD.js	2005-07-26 01:05:33.000000000 +0200
+++ mozilla.new/xpfe/communicator/resources/content/contentAreaDD.js	2006-02-14 10:01:36.000000000 +0100
@@ -60,7 +60,7 @@ var contentAreaDNDObserver = {
           /^\s*(javascript|data):/.test(url))
         return;
 
-      switch (document.firstChild.getAttribute('windowtype')) {
+      switch (document.documentElement.getAttribute('windowtype')) {
         case "navigator:browser":
           // Perform a security check before loading the URI
           nsDragAndDrop.dragDropSecurityCheck(aEvent, aDragSession, url);
diff -uprN --exclude=CVS mozilla/xpfe/communicator/resources/content/contentAreaUtils.js mozilla.new/xpfe/communicator/resources/content/contentAreaUtils.js
--- mozilla/xpfe/communicator/resources/content/contentAreaUtils.js	2006-01-11 23:06:12.000000000 +0100
+++ mozilla.new/xpfe/communicator/resources/content/contentAreaUtils.js	2006-02-14 10:01:36.000000000 +0100
@@ -96,7 +96,7 @@ function openNewWindowWith(url, sendRefe
   // set, then extract the current charset menu setting from the current document and use it to
   // initialize the new browser window...
   var charsetArg = null;
-  var wintype = document.firstChild.getAttribute('windowtype');
+  var wintype = document.documentElement.getAttribute('windowtype');
   if (wintype == "navigator:browser")
     charsetArg = "charset=" + window.content.document.characterSet;
 
@@ -165,7 +165,7 @@ function openNewTabWith(url, sendReferre
 
   // As in openNewWindowWith(), we want to pass the charset of the
   // current document over to a new tab.
-  var wintype = browserDocument.firstChild.getAttribute('windowtype');
+  var wintype = browserDocument.documentElement.getAttribute('windowtype');
   var originCharset;
   if (wintype == "navigator:browser") {
     originCharset = window.content.document.characterSet;
diff -uprN --exclude=CVS mozilla/xpfe/communicator/resources/locale/en-US/region.properties mozilla.new/xpfe/communicator/resources/locale/en-US/region.properties
--- mozilla/xpfe/communicator/resources/locale/en-US/region.properties	2005-06-19 21:48:21.000000000 +0200
+++ mozilla.new/xpfe/communicator/resources/locale/en-US/region.properties	2006-02-14 10:01:37.000000000 +0100
@@ -7,4 +7,4 @@ browser.search.defaultenginename=Google
 intl.content.langcode=en-US
 
 # update notifications: new update page
-update_notifications.provider.0.datasource=
+update_notifications.provider.0.datasource=http://www.mozilla.org/projects/seamonkey/releases/updates/en-US.rdf
diff -uprN --exclude=CVS mozilla/xpfe/components/prefwindow/resources/locale/en-US/pref-smart_browsing.dtd mozilla.new/xpfe/components/prefwindow/resources/locale/en-US/pref-smart_browsing.dtd
--- mozilla/xpfe/components/prefwindow/resources/locale/en-US/pref-smart_browsing.dtd	2005-05-02 13:05:42.000000000 +0200
+++ mozilla.new/xpfe/components/prefwindow/resources/locale/en-US/pref-smart_browsing.dtd	2006-02-14 10:01:37.000000000 +0100
@@ -5,7 +5,7 @@
 
 <!--LOCALIZATION NOTE (internetKeywordsHeader.label): DONT_TRANSLATE -->
 <!ENTITY internetKeywordsHeader.label          "Internet Keywords">
-<!ENTITY internetKeywordsDescription.label     "&brandShortName; Internet Keywords enables fast access to services such as stock quotes, search and other information from the Location bar.">
+<!ENTITY internetKeywordsDescription.label     "Internet Keywords enable fast access to services such as stock quotes, search and other information from the Location bar.">
 <!ENTITY moreInformation.label                 "More Information...">
 <!ENTITY moreInformation.accesskey             "M">
 <!--LOCALIZATION NOTE (enableKeyCheck.label): Do not translate 'Internet Keywords' -->
diff -uprN --exclude=CVS mozilla/xpfe/components/prefwindow/resources/locale/en-US/pref-smartupdate.dtd mozilla.new/xpfe/components/prefwindow/resources/locale/en-US/pref-smartupdate.dtd
--- mozilla/xpfe/components/prefwindow/resources/locale/en-US/pref-smartupdate.dtd	2005-05-02 13:05:42.000000000 +0200
+++ mozilla.new/xpfe/components/prefwindow/resources/locale/en-US/pref-smartupdate.dtd	2006-02-14 10:01:37.000000000 +0100
@@ -1,7 +1,7 @@
 <!--LOCALIZATION NOTE : FILE UI for Software Updates prefs -->
 <!ENTITY pref.smartUpdate.title               "Software Installation">
 <!ENTITY smartTitle.label                     "Manage Software Installations and Updates">
-<!ENTITY enableSU.label                       "Enable software installation. (You will be prompted for each update.)">
+<!ENTITY enableSU.label                       "Enable software installation. (You will be prompted before each update.)">
 
 <!ENTITY enableSU.accesskey                   "e">
 <!ENTITY enableNotification.label             "Notify me when new and updated software is available">
diff -uprN --exclude=CVS mozilla/xpfe/components/search/src/nsInternetSearchService.cpp mozilla.new/xpfe/components/search/src/nsInternetSearchService.cpp
--- mozilla/xpfe/components/search/src/nsInternetSearchService.cpp	2005-10-17 19:37:24.000000000 +0200
+++ mozilla.new/xpfe/components/search/src/nsInternetSearchService.cpp	2006-02-24 11:16:49.000000000 +0100
@@ -654,44 +654,41 @@ InternetSearchDataSource::GetSearchEngin
 	if (NS_FAILED(rv = mUpdateArray->Count(&numEngines)))	return(rv);
 	if (numEngines < 1)	return(NS_OK);
 
-	nsCOMPtr<nsISupports>	isupports = mUpdateArray->ElementAt(0);
+	nsCOMPtr<nsIRDFResource> aRes (do_QueryElementAt(mUpdateArray, 0));
 
 	// note: important to remove element from array
 	mUpdateArray->RemoveElementAt(0);
-	if (isupports)
+
+	if (aRes)
 	{
-		nsCOMPtr<nsIRDFResource> aRes (do_QueryInterface(isupports));
-		if (aRes)
+		if (isSearchCategoryEngineURI(aRes))
 		{
-			if (isSearchCategoryEngineURI(aRes))
-			{
-				nsCOMPtr<nsIRDFResource>	trueEngine;
-				rv = resolveSearchCategoryEngineURI(aRes, getter_AddRefs(trueEngine));
-				if (NS_FAILED(rv) || (rv == NS_RDF_NO_VALUE))	return(rv);
-				if (!trueEngine)	return(NS_RDF_NO_VALUE);
+			nsCOMPtr<nsIRDFResource>	trueEngine;
+			rv = resolveSearchCategoryEngineURI(aRes, getter_AddRefs(trueEngine));
+			if (NS_FAILED(rv) || (rv == NS_RDF_NO_VALUE))	return(rv);
+			if (!trueEngine)	return(NS_RDF_NO_VALUE);
 
-				aRes = trueEngine;
-			}
+			aRes = trueEngine;
+		}
 
-			if (!aRes)	return(NS_OK);
+		if (!aRes)	return(NS_OK);
 
-			*theEngine = aRes.get();
-			NS_ADDREF(*theEngine);
+		*theEngine = aRes.get();
+		NS_ADDREF(*theEngine);
 
-			// get update URL
-			nsCOMPtr<nsIRDFNode>	aNode;
-			if (NS_SUCCEEDED(rv = mInner->GetTarget(aRes, kNC_Update, PR_TRUE, getter_AddRefs(aNode)))
+		// get update URL
+		nsCOMPtr<nsIRDFNode>	aNode;
+		if (NS_SUCCEEDED(rv = mInner->GetTarget(aRes, kNC_Update, PR_TRUE, getter_AddRefs(aNode)))
 				&& (rv != NS_RDF_NO_VALUE))
+		{
+			nsCOMPtr<nsIRDFLiteral>	aLiteral (do_QueryInterface(aNode));
+			if (aLiteral)
 			{
-				nsCOMPtr<nsIRDFLiteral>	aLiteral (do_QueryInterface(aNode));
-				if (aLiteral)
+				const PRUnichar	*updateUni = nsnull;
+				aLiteral->GetValueConst(&updateUni);
+				if (updateUni)
 				{
-					const PRUnichar	*updateUni = nsnull;
-					aLiteral->GetValueConst(&updateUni);
-					if (updateUni)
-					{
-						updateURL.AssignWithConversion(updateUni);
-					}
+					updateURL.AssignWithConversion(updateUni);
 				}
 			}
 		}
@@ -2225,9 +2222,7 @@ InternetSearchDataSource::filterSite(nsI
 	if (NS_FAILED(rv = array->Count(&count)))	return(rv);
 	for (PRUint32 loop=0; loop<count; loop++)
 	{
-		nsCOMPtr<nsISupports>	element = array->ElementAt(loop);
-		if (!element)	break;
-		nsCOMPtr<nsIRDFResource> aSearchRoot (do_QueryInterface(element));
+		nsCOMPtr<nsIRDFResource> aSearchRoot (do_QueryElementAt(array, loop));
 		if (!aSearchRoot)	break;
 
 		if (NS_SUCCEEDED(rv = mInner->GetTargets(aSearchRoot, kNC_Child,
@@ -2392,9 +2387,7 @@ InternetSearchDataSource::DoCommand(nsIS
 
 	for (loop=((PRInt32)numSources)-1; loop>=0; loop--)
 	{
-		nsCOMPtr<nsISupports>	aSource = aSources->ElementAt(loop);
-		if (!aSource)	return(NS_ERROR_NULL_POINTER);
-		nsCOMPtr<nsIRDFResource> src (do_QueryInterface(aSource));
+		nsCOMPtr<nsIRDFResource> src (do_QueryElementAt(aSources, loop));
 		if (!src)	return(NS_ERROR_NO_INTERFACE);
 
 		if (aCommand == kNC_SearchCommand_AddToBookmarks)
@@ -4065,7 +4058,7 @@ InternetSearchDataSource::DoSearch(nsIRD
 		if (input.IsEmpty())				return(NS_ERROR_UNEXPECTED);
 
 		// HTTP Get method support
-		action += NS_LITERAL_STRING("?") + input;
+		action += input;
 	}
 
 	nsCOMPtr<nsIInternetSearchContext>	context;
diff -uprN --exclude=CVS mozilla/xpfe/components/shistory/src/nsSHistory.cpp mozilla.new/xpfe/components/shistory/src/nsSHistory.cpp
--- mozilla/xpfe/components/shistory/src/nsSHistory.cpp	2005-09-30 04:14:22.000000000 +0200
+++ mozilla.new/xpfe/components/shistory/src/nsSHistory.cpp	2006-02-24 11:16:49.000000000 +0100
@@ -304,8 +304,14 @@ nsSHistory::AddEntry(nsISHEntry * aSHEnt
       nsCOMPtr<nsIURI> uri;
       nsCOMPtr<nsIHistoryEntry> hEntry(do_QueryInterface(aSHEntry));
       if (hEntry) {
+        PRInt32 currentIndex = mIndex;
         hEntry->GetURI(getter_AddRefs(uri));
         listener->OnHistoryNewEntry(uri);
+
+        // If a listener has changed mIndex, we need to get currentTxn again,
+        // otherwise we'll be left at an inconsistent state (see bug 320742)
+        if (currentIndex != mIndex)
+          GetTransactionAtIndex(mIndex, getter_AddRefs(currentTxn));
       }
     }
   }
@@ -324,7 +330,7 @@ nsSHistory::AddEntry(nsISHEntry * aSHEnt
   if(!mListRoot)
     mListRoot = txn;
 
-  //Purge History list if it is too long
+  // Purge History list if it is too long
   if ((gHistoryMaxSize >= 0) && (mLength > gHistoryMaxSize))
     PurgeHistory(mLength-gHistoryMaxSize);
   
diff -uprN --exclude=CVS mozilla/xpfe/components/sidebar/resources/sidebarOverlay.js mozilla.new/xpfe/components/sidebar/resources/sidebarOverlay.js
--- mozilla/xpfe/components/sidebar/resources/sidebarOverlay.js	2005-06-16 14:58:13.000000000 +0200
+++ mozilla.new/xpfe/components/sidebar/resources/sidebarOverlay.js	2006-02-14 10:01:37.000000000 +0100
@@ -747,7 +747,7 @@ function sidebar_overlay_init() {
   sidebarObj.master_datasources = get_remote_datasource_url();
   sidebarObj.master_datasources += " chrome://communicator/content/sidebar/local-panels.rdf";
   sidebarObj.master_resource = 'urn:sidebar:master-panel-list';
-  sidebarObj.component = document.firstChild.getAttribute('windowtype');
+  sidebarObj.component = document.documentElement.getAttribute('windowtype');
   debug("sidebarObj.component is " + sidebarObj.component);
 
   // Initialize the display
diff -uprN --exclude=CVS mozilla/xpfe/global/resources/content/about.xhtml mozilla.new/xpfe/global/resources/content/about.xhtml
--- mozilla/xpfe/global/resources/content/about.xhtml	2006-01-23 08:55:16.000000000 +0100
+++ mozilla.new/xpfe/global/resources/content/about.xhtml	2006-03-12 20:04:23.000000000 +0100
@@ -103,7 +103,7 @@ h1 {
 <ul>
 <li>Copyright &copy; 1998&ndash;2006 by <a href="about:credits">Contributors</a> to 
 the Mozilla codebase under the <a href="about:license">Mozilla Public License
-and Netscape Public License</a>.  All Rights Reserved.</li>
+and other licenses</a>.  All Rights Reserved.</li>
 
 <li>Portions of this software are copyright &copy; 1994 The Regents of the 
 University of California.  All Rights Reserved.</li>
diff -uprN --exclude=CVS mozilla/xpfe/global/resources/content/bindings/tabbrowser.xml mozilla.new/xpfe/global/resources/content/bindings/tabbrowser.xml
--- mozilla/xpfe/global/resources/content/bindings/tabbrowser.xml	2006-01-23 08:55:17.000000000 +0100
+++ mozilla.new/xpfe/global/resources/content/bindings/tabbrowser.xml	2006-02-14 10:01:37.000000000 +0100
@@ -594,10 +594,15 @@
                 this.mCurrentBrowser.focusedElement = document.commandDispatcher.focusedElement;
               }
 
-              if (this.mCurrentBrowser.focusedElement) {
+              if (this.mCurrentBrowser.focusedElement instanceof NSHTMLElement || 
+                  this.mCurrentBrowser.focusedElement instanceof XULElement) {
                 // Clear focus outline before we draw on top of it
                 this.mCurrentBrowser.focusedElement.blur();
               }
+              else {
+                // non-HTML/XUL elements have no blur method, see bug 323806
+                this.mCurrentBrowser.focusedElement = null;
+              }
               this.mCurrentBrowser.setAttribute("type", "content");
             }
 
@@ -1360,16 +1365,22 @@
         <parameter name="aDestIndex"/>
         <body>
           <![CDATA[
+            // for compatibility with extensions
+            if (typeof(aSrcIndex) != "number")
+              aSrcIndex = this.getTabIndex(aSrcIndex);
+
             this.mTabFilters.splice(aDestIndex, 0, this.mTabFilters.splice(aSrcIndex, 1)[0]);
             this.mTabListeners.splice(aDestIndex, 0, this.mTabListeners.splice(aSrcIndex, 1)[0]);
 
-            aDestIndex = aDestIndex < aSrcIndex ? aDestIndex : aDestIndex + 1;
             this.mCurrentTab.selected = false;
-            if (aDestIndex == this.mTabs.length)
-               this.mTabContainer.appendChild(this.mTabs[aSrcIndex]);
-            else
-               this.mTabContainer.insertBefore(this.mTabs[aSrcIndex], this.mTabs[aDestIndex]);
+
+            if (aDestIndex >= aSrcIndex)
+              ++aDestIndex;
+            var tab = this.mTabContainer.insertBefore(this.mTabs[aSrcIndex], this.mTabs.item(aDestIndex));
+
             this.mCurrentTab.selected = true;
+
+            return tab;
           ]]>
         </body>
       </method>
@@ -1500,11 +1511,12 @@
               }
             }
             if (i < oldCount) {
+              var firstTab = this.mTabContainer.firstChild;
               var browserData = {
-                sessionHistory : this.mPanelContainer.firstChild.sessionHistory
+                sessionHistory : firstTab.linkedBrowser.sessionHistory
               }
               oldBrowserGroup.push(browserData);
-              this.removeTab(this.mTabContainer.firstChild);
+              this.removeTab(firstTab);
             }
           }
           return oldBrowserGroup;
diff -uprN --exclude=CVS mozilla/xpfe/global/resources/content/charsetOverlay.js mozilla.new/xpfe/global/resources/content/charsetOverlay.js
--- mozilla/xpfe/global/resources/content/charsetOverlay.js	2005-07-26 00:09:39.000000000 +0200
+++ mozilla.new/xpfe/global/resources/content/charsetOverlay.js	2006-02-14 10:01:37.000000000 +0100
@@ -278,7 +278,7 @@ function mailCharsetLoadListener (event)
     }
 }
 
-var wintype = document.firstChild.getAttribute('windowtype');
+var wintype = document.documentElement.getAttribute('windowtype');
 if (window && (wintype == "navigator:browser"))
 {
     var contentArea = window.document.getElementById("appcontent");
diff -uprN --exclude=CVS mozilla/xpfe/global/resources/locale/en-US/builtinURLs.rdf mozilla.new/xpfe/global/resources/locale/en-US/builtinURLs.rdf
--- mozilla/xpfe/global/resources/locale/en-US/builtinURLs.rdf	2004-04-17 18:51:38.000000000 +0200
+++ mozilla.new/xpfe/global/resources/locale/en-US/builtinURLs.rdf	2006-02-14 10:01:37.000000000 +0100
@@ -58,7 +58,7 @@
 
   <RDF:Description about='urn:clienturl:viewmenu:intlwebcontent'>
     <NC:title>International Languages and Web Content</NC:title>
-    <NC:content>http://www.mozilla.org/projects/l10n/mlp_status.html#contrib</NC:content>
+    <NC:content>http://www.mozilla.org/projects/seamonkey/releases/#l10n</NC:content>
   </RDF:Description>
 
   <!-- Composer -->
diff -uprN --exclude=CVS mozilla/xpinstall/packager/Makefile.in mozilla.new/xpinstall/packager/Makefile.in
--- mozilla/xpinstall/packager/Makefile.in	2005-07-02 22:39:08.000000000 +0200
+++ mozilla.new/xpinstall/packager/Makefile.in	2006-02-24 11:16:39.000000000 +0100
@@ -60,6 +60,7 @@ PLATFORM_EXCLUDE_LIST = ! -name "*.ico"
 endif
 
 NO_PKG_FILES	= \
+		$(MOZ_APP_NAME)-config \
 		$(NULL)
 
 include $(topsrcdir)/config/rules.mk
diff -uprN --exclude=CVS mozilla/xpinstall/src/nsXPITriggerInfo.cpp mozilla.new/xpinstall/src/nsXPITriggerInfo.cpp
--- mozilla/xpinstall/src/nsXPITriggerInfo.cpp	2005-08-26 09:12:58.000000000 +0200
+++ mozilla.new/xpinstall/src/nsXPITriggerInfo.cpp	2006-02-24 11:16:39.000000000 +0100
@@ -257,6 +257,13 @@ static void* handleTriggerEvent(XPITrigg
                              event->status );
     if ( args )
     {
+        // This code is all in a JS request, and here we're about to
+        // push the context onto the context stack and also push
+        // arguments. Be very very sure that no early returns creep in
+        // here w/o doing the proper cleanup!
+
+        const char *errorStr = nsnull;
+
         nsCOMPtr<nsIJSContextStack> stack =
             do_GetService("@mozilla.org/js/xpc/ContextStack;1");
         if (stack)
@@ -267,33 +274,43 @@ static void* handleTriggerEvent(XPITrigg
         
         if (!secman)
         {
-            JS_ReportError(event->cx, "Could not get script security manager service");
-            return 0;
+            errorStr = "Could not get script security manager service";
         }
 
         nsCOMPtr<nsIPrincipal> principal;
-        secman->GetSubjectPrincipal(getter_AddRefs(principal));
-        if (!principal)
+        if (!errorStr)
         {
-            JS_ReportError(event->cx, "Could not get principal from script security manager");
-            return 0;
+            secman->GetSubjectPrincipal(getter_AddRefs(principal));
+            if (!principal)
+            {
+                errorStr = "Could not get principal from script security manager";
+            }
         }
 
-        PRBool equals = PR_FALSE;
-        principal->Equals(event->princ, &equals);
-
-        if (!equals)
+        if (!errorStr)
         {
-            JS_ReportError(event->cx, "Principal of callback context is different then InstallTriggers");
-            return 0;
+            PRBool equals = PR_FALSE;
+            principal->Equals(event->princ, &equals);
+
+            if (!equals)
+            {
+                errorStr = "Principal of callback context is different than InstallTriggers";
+            }
         }
 
-        JS_CallFunctionValue( event->cx,
-                              JSVAL_TO_OBJECT(event->global),
-                              event->cbval,
-                              2,
-                              args,
-                              &ret );
+        if (errorStr)
+        {
+            JS_ReportError(event->cx, errorStr);
+        }
+        else
+        {
+            JS_CallFunctionValue(event->cx,
+                                 JSVAL_TO_OBJECT(event->global),
+                                 event->cbval,
+                                 2,
+                                 args,
+                                 &ret);
+        }
 
         if (stack)
             stack->Pop(nsnull);
diff -uprN --exclude=CVS mozilla/xulrunner/setup/nsXULAppInstall.js mozilla.new/xulrunner/setup/nsXULAppInstall.js
--- mozilla/xulrunner/setup/nsXULAppInstall.js	2005-10-27 21:11:14.000000000 +0200
+++ mozilla.new/xulrunner/setup/nsXULAppInstall.js	2006-03-03 07:11:44.000000000 +0100
@@ -247,7 +247,8 @@ const AppInstall = {
       aDirectory = Components.classes["@mozilla.org/file/local;1"].
         createInstance(nsILocalFile);
       aDirectory.initWithPath("/usr/lib");
-      aDirectory.append(vendor.toLowerCase());
+      if (vendor)
+        aDirectory.append(vendor.toLowerCase());
 #endif
 #endif
     }
