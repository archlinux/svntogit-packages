diff -ru kdegraphics-4.4.4/libs/libkipi/libkipi/imageinfoshared.cpp kdegraphics/libs/libkipi/libkipi/imageinfoshared.cpp
--- kdegraphics-4.4.4/libs/libkipi/libkipi/imageinfoshared.cpp	2009-12-01 01:33:28.000000000 +0100
+++ kdegraphics/libs/libkipi/libkipi/imageinfoshared.cpp	2010-06-10 17:10:43.459458717 +0200
@@ -58,7 +58,7 @@
         return 0;
     }
     else
-        return QFileInfo( _url.path() ).size();
+        return QFileInfo( _url.toLocalFile() ).size();
 }
 
 QDateTime ImageInfoShared::time( TimeSpec )
@@ -69,7 +69,7 @@
         return QDateTime();
     }
     else
-        return QFileInfo( _url.path() ).lastModified();
+        return QFileInfo( _url.toLocalFile() ).lastModified();
 }
 
 void ImageInfoShared::addRef()
diff -ru kdegraphics-4.4.4/libs/libkipi/libkipi/pluginloader.cpp kdegraphics/libs/libkipi/libkipi/pluginloader.cpp
--- kdegraphics-4.4.4/libs/libkipi/libkipi/pluginloader.cpp	2009-12-01 01:33:28.000000000 +0100
+++ kdegraphics/libs/libkipi/libkipi/pluginloader.cpp	2010-06-10 17:10:43.459458717 +0200
@@ -167,8 +167,10 @@
 
 QIcon PluginLoader::Info::icon() const
 {
-    if (d->m_plugin) return QIcon(d->m_plugin->actions()[0]->icon());
-    else return KIcon(d->m_service->icon());
+    if(d->m_service->icon().isEmpty() && d->m_plugin)
+        return QIcon(d->m_plugin->actions()[0]->icon());
+    else
+        return KIcon(d->m_service->icon());
 }
 
 Plugin* PluginLoader::Info::plugin() const
diff -ru kdegraphics-4.4.4/libs/libkipi/NEWS kdegraphics/libs/libkipi/NEWS
--- kdegraphics-4.4.4/libs/libkipi/NEWS	2008-11-19 11:17:36.000000000 +0100
+++ kdegraphics/libs/libkipi/NEWS	2010-06-10 17:10:44.155908077 +0200
@@ -1,3 +1,10 @@
+1.0.0
+------------------------------------------------------------------------
+
+Bugs fixed:
+
+001 ==> 237565 :  Digikam crash when unchecking KIPI external modules.
+
 0.3.0 - Released with KDE 4.2.0
 ------------------------------------------------------------------------
 
diff -ru kdegraphics-4.4.4/libs/libkexiv2/CMakeLists.txt kdegraphics/libs/libkexiv2/CMakeLists.txt
--- kdegraphics-4.4.4/libs/libkexiv2/CMakeLists.txt	2009-11-13 11:57:01.000000000 +0100
+++ kdegraphics/libs/libkexiv2/CMakeLists.txt	2010-06-10 17:10:38.612396666 +0200
@@ -20,10 +20,11 @@
 # 0.5.0 => 7.2.0     (Released with KDE 4.2.0)
 # 0.6.0 => 7.3.0     (Released with KDE 4.3.0)
 # 1.0.0 => 8.0.0     (Released with KDE 4.4.0)
+# 1.1.0 => 8.1.0     (Released with KDE 4.5.0)
 
 # Library API version
 SET(KEXIV2_LIB_MAJOR_VERSION "1")
-SET(KEXIV2_LIB_MINOR_VERSION "0")
+SET(KEXIV2_LIB_MINOR_VERSION "1")
 SET(KEXIV2_LIB_PATCH_VERSION "0")
 
 # Suffix to add at end of version string. Usual values are:
@@ -38,7 +39,7 @@
 # Library ABI version used by linker.
 # For details : http://www.gnu.org/software/libtool/manual/libtool.html#Updating-version-info
 SET(KEXIV2_LIB_SO_CUR_VERSION "8")
-SET(KEXIV2_LIB_SO_REV_VERSION "0")
+SET(KEXIV2_LIB_SO_REV_VERSION "1")
 SET(KEXIV2_LIB_SO_AGE_VERSION "0")
 
 # =======================================================
diff -ru kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/altlangstredit.cpp kdegraphics/libs/libkexiv2/libkexiv2/altlangstredit.cpp
--- kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/altlangstredit.cpp	2010-01-06 17:59:15.000000000 +0100
+++ kdegraphics/libs/libkexiv2/libkexiv2/altlangstredit.cpp	2010-06-10 17:10:37.932376721 +0200
@@ -6,12 +6,13 @@
  * Date        : 2009-06-15
  * Description : multi-languages string editor
  *
- * Copyright (C) 2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2009-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
  * Public License as published by the Free Software Foundation;
- * either version 2, or (at your option) any later version.
+ * either version 2, or (at your option)
+ * any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -240,27 +241,27 @@
         languageCodeMap.insert( "zu-ZA", i18n("isiZulu Zulu (South Africa)") );
     }
 
-    typedef QMap<QString, QString>  LanguageCodeMap;
+    typedef QMap<QString, QString> LanguageCodeMap;
 
-    LanguageCodeMap                 languageCodeMap;
+    LanguageCodeMap                languageCodeMap;
 
-    QString                         currentLanguage;
+    QString                        currentLanguage;
 
-    QLabel                         *titleLabel;
+    QLabel*                        titleLabel;
 
-    QToolButton                    *delValueButton;
+    QToolButton*                   delValueButton;
 
-    MsgTextEdit                    *valueEdit;
+    MsgTextEdit*                   valueEdit;
 
-    KComboBox                      *languageCB;
+    KComboBox*                     languageCB;
 
-    KExiv2::AltLangMap              values;
+    KExiv2::AltLangMap             values;
 };
 
 AltLangStrEdit::AltLangStrEdit(QWidget* parent)
               : QWidget(parent), d(new AltLangStrEditPriv)
 {
-    QGridLayout *grid = new QGridLayout(this);
+    QGridLayout* grid = new QGridLayout(this);
     d->titleLabel     = new QLabel(this);
     d->delValueButton = new QToolButton(this);
     d->delValueButton->setIcon(SmallIcon("edit-clear"));
@@ -346,7 +347,7 @@
     d->valueEdit->blockSignals(true);
 
     QString langISO3066 = d->currentLanguage;
-    langISO3066.replace("-", "_");
+    langISO3066.replace('-', '_');
     d->valueEdit->setSpellCheckingLanguage(langISO3066);
 
     QString text = d->values.value(d->currentLanguage);
@@ -390,7 +391,7 @@
     QStringList list = d->values.keys();
     if (!list.isEmpty())
     {
-        foreach (QString item, list)
+        foreach (const QString &item, list)
         {
               d->languageCB->addItem(item);
               d->languageCB->setItemIcon(d->languageCB->count()-1, SmallIcon("dialog-ok"));
diff -ru kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/altlangstredit.h kdegraphics/libs/libkexiv2/libkexiv2/altlangstredit.h
--- kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/altlangstredit.h	2009-10-15 18:32:02.000000000 +0200
+++ kdegraphics/libs/libkexiv2/libkexiv2/altlangstredit.h	2010-06-10 17:10:37.932376721 +0200
@@ -6,12 +6,13 @@
  * Date        : 2009-06-15
  * Description : multi-languages string editor
  *
- * Copyright (C) 2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2009-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
  * Public License as published by the Free Software Foundation;
- * either version 2, or (at your option) any later version.
+ * either version 2, or (at your option)
+ * any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -28,10 +29,10 @@
 #include <QtGui/QWidget>
 #include <QtCore/QString>
 
-// Local includes
+// Local includes.
 
-#include "kexiv2.h"
 #include "libkexiv2_export.h"
+#include "kexiv2.h"
 
 namespace KExiv2Iface
 {
diff -ru kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/CMakeLists.txt kdegraphics/libs/libkexiv2/libkexiv2/CMakeLists.txt
--- kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/CMakeLists.txt	2009-11-21 10:43:35.000000000 +0100
+++ kdegraphics/libs/libkexiv2/libkexiv2/CMakeLists.txt	2010-06-10 17:10:37.935709576 +0200
@@ -51,4 +51,4 @@
               ${CMAKE_CURRENT_BINARY_DIR}/version.h
         DESTINATION ${INCLUDE_INSTALL_DIR}/libkexiv2 COMPONENT Devel)
 
-INSTALL(FILES topicset.iptc-subjectcode.xml DESTINATION ${DATA_INSTALL_DIR}/libkexiv2/data)
\ Kein Zeilenumbruch am Dateiende.
+INSTALL(FILES topicset.iptc-subjectcode.xml DESTINATION ${DATA_INSTALL_DIR}/libkexiv2/data)
diff -ru kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/countryselector.cpp kdegraphics/libs/libkexiv2/libkexiv2/countryselector.cpp
--- kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/countryselector.cpp	2009-10-02 16:53:41.000000000 +0200
+++ kdegraphics/libs/libkexiv2/libkexiv2/countryselector.cpp	2010-06-10 17:10:37.929054700 +0200
@@ -6,7 +6,7 @@
  * Date        : 2009-07-07
  * Description : country selector combo-box.
  *
- * Copyright (C) 2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2009-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
@@ -30,8 +30,8 @@
 
 // KDE includes
 
-#include <kdebug.h>
 #include <klocale.h>
+#include <kdebug.h>
 
 namespace KExiv2Iface
 {
diff -ru kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/countryselector.h kdegraphics/libs/libkexiv2/libkexiv2/countryselector.h
--- kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/countryselector.h	2009-07-28 21:44:28.000000000 +0200
+++ kdegraphics/libs/libkexiv2/libkexiv2/countryselector.h	2010-06-10 17:10:37.929054700 +0200
@@ -6,7 +6,7 @@
  * Date        : 2009-07-07
  * Description : country selector combo-box.
  *
- * Copyright (C) 2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2009-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
@@ -33,7 +33,7 @@
 
 #include <kcombobox.h>
 
-// Local includes
+// Local includes.
 
 #include "libkexiv2_export.h"
 
diff -ru kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/kexiv2comments.cpp kdegraphics/libs/libkexiv2/libkexiv2/kexiv2comments.cpp
--- kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/kexiv2comments.cpp	2009-11-21 10:43:35.000000000 +0100
+++ kdegraphics/libs/libkexiv2/libkexiv2/kexiv2comments.cpp	2010-06-10 17:10:37.932376721 +0200
@@ -7,8 +7,8 @@
  * Description : Exiv2 library interface for KDE
  *               Comments manipulation methods
  *
- * Copyright (C) 2006-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
- * Copyright (C) 2006-2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2006-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2006-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
@@ -40,7 +40,7 @@
         Exiv2::AccessMode mode = image->checkMode(Exiv2::mdComment);
         return (mode == Exiv2::amWrite || mode == Exiv2::amReadWrite);
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         std::string s(e.what());
         kDebug(51003) << "Cannot check Comment access mode using Exiv2 (Error #" 
@@ -76,7 +76,7 @@
     return true;
 }
 
-QString KExiv2::detectLanguageAlt(const QString &value, QString& lang)
+QString KExiv2::detectLanguageAlt(const QString& value, QString& lang)
 {
     // Ex. from an Xmp tag Xmp.tiff.copyright: "lang="x-default" (c) Gilles Caulier 2007"
 
diff -ru kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/kexiv2.cpp kdegraphics/libs/libkexiv2/libkexiv2/kexiv2.cpp
--- kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/kexiv2.cpp	2010-01-06 17:59:15.000000000 +0100
+++ kdegraphics/libs/libkexiv2/libkexiv2/kexiv2.cpp	2010-06-10 17:10:37.929054700 +0200
@@ -245,9 +245,14 @@
     {
         Exiv2::Image::AutoPtr image = Exiv2::ImageFactory::open((Exiv2::byte*)imgData.data(), imgData.size());
 
-        d->filePath = QString();
+        d->filePath  = QString();
         image->readMetadata();
 
+        // Size and mimetype ---------------------------------
+
+        d->pixelSize = QSize(image->pixelWidth(), image->pixelHeight());
+        d->mimeType  = image->mimeType().c_str();
+
         // Image comments ---------------------------------
 
         d->imageComments() = image->comment();
@@ -270,7 +275,7 @@
 
         return true;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot load metadata using Exiv2 ", e);
     }
@@ -295,6 +300,11 @@
         d->filePath = filePath;
         image->readMetadata();
 
+        // Size and mimetype ---------------------------------
+
+        d->pixelSize = QSize(image->pixelWidth(), image->pixelHeight());
+        d->mimeType  = image->mimeType().c_str();
+
         // Image comments ---------------------------------
 
         d->imageComments() = image->comment();
@@ -317,7 +327,7 @@
 
         return true;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot load metadata using Exiv2 ", e);
     }
@@ -505,7 +515,7 @@
 
         return true;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot save metadata using Exiv2 ", e);
     }
@@ -542,6 +552,16 @@
     return d->filePath;
 }
 
+QSize KExiv2::getPixelSize() const
+{
+    return d->pixelSize;
+}
+
+QString KExiv2::getMimeType() const
+{
+    return d->mimeType;
+}
+
 void KExiv2::setWriteRawFiles(bool on)
 {
     d->writeRawFiles = on;
diff -ru kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/kexiv2data.h kdegraphics/libs/libkexiv2/libkexiv2/kexiv2data.h
--- kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/kexiv2data.h	2009-11-21 10:43:35.000000000 +0100
+++ kdegraphics/libs/libkexiv2/libkexiv2/kexiv2data.h	2010-06-10 17:10:37.929054700 +0200
@@ -6,7 +6,7 @@
  * Date        : 2009-11-15
  * Description : Exiv2 library interface for KDE
  *
- * Copyright (C) 2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2009-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
diff -ru kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/kexiv2exif.cpp kdegraphics/libs/libkexiv2/libkexiv2/kexiv2exif.cpp
--- kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/kexiv2exif.cpp	2009-12-17 17:36:44.000000000 +0100
+++ kdegraphics/libs/libkexiv2/libkexiv2/kexiv2exif.cpp	2010-06-10 17:10:37.932376721 +0200
@@ -7,8 +7,8 @@
  * Description : Exiv2 library interface for KDE
  *               Exif manipulation methods
  *
- * Copyright (C) 2006-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
- * Copyright (C) 2006-2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2006-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2006-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
@@ -44,7 +44,7 @@
         Exiv2::AccessMode mode = image->checkMode(Exiv2::mdExif);
         return (mode == Exiv2::amWrite || mode == Exiv2::amReadWrite);
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         std::string s(e.what());
         kDebug(51003) << "Cannot check Exif access mode using Exiv2 (Error #"
@@ -66,7 +66,7 @@
         d->exifMetadata().clear();
         return true;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot clear Exif data using Exiv2 ", e);
     }
@@ -109,7 +109,7 @@
             return data;
         }
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         if (!d->filePath.isEmpty())
             kDebug(51003) << "From file " << d->filePath.toAscii().constData() << endl;
@@ -137,7 +137,7 @@
 #endif
         }
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         if (!d->filePath.isEmpty())
             kDebug(51003) << "From file " << d->filePath.toAscii().constData() << endl;
@@ -229,7 +229,7 @@
             }
         }
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot find Exif User Comment using Exiv2 ", e);
     }
@@ -261,6 +261,13 @@
             {
                 // write as Unicode (UCS-2)
 
+#if (EXIV2_TEST_VERSION(0,20,0))
+                std::string exifComment("charset=\"Unicode\" ");
+                exifComment += comment.toUtf8().constData();
+                d->exifMetadata()["Exif.Photo.UserComment"] = exifComment;
+#else
+                // Older versions took a UCS2-String, see bug #205824
+
                 // Be aware that we are dealing with a UCS-2 string.
                 // Null termination means \0\0, strlen does not work,
                 // do not use any const-char*-only methods,
@@ -269,11 +276,12 @@
                 std::string exifComment("charset=\"Unicode\" ");
                 exifComment.append((const char*)ucs2, sizeof(unsigned short) * comment.length());
                 d->exifMetadata()["Exif.Photo.UserComment"] = exifComment;
+#endif
             }
         }
         return true;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot set Exif Comment using Exiv2 ", e);
     }
@@ -281,7 +289,7 @@
     return false;
 }
 
-QString KExiv2::getExifTagTitle(const char *exifTagName)
+QString KExiv2::getExifTagTitle(const char* exifTagName)
 {
     try
     {
@@ -297,7 +305,7 @@
     return QString();
 }
 
-QString KExiv2::getExifTagDescription(const char *exifTagName)
+QString KExiv2::getExifTagDescription(const char* exifTagName)
 {
     try
     {
@@ -313,7 +321,7 @@
     return QString();
 }
 
-bool KExiv2::removeExifTag(const char *exifTagName, bool setProgramName) const
+bool KExiv2::removeExifTag(const char* exifTagName, bool setProgramName) const
 {
     if (!setProgramId(setProgramName))
         return false;
@@ -336,7 +344,7 @@
     return false;
 }
 
-bool KExiv2::getExifTagRational(const char *exifTagName, long int &num, long int &den, int component) const
+bool KExiv2::getExifTagRational(const char* exifTagName, long int& num, long int& den, int component) const
 {
     try
     {
@@ -359,7 +367,7 @@
     return false;
 }
 
-bool KExiv2::setExifTagLong(const char *exifTagName, long val, bool setProgramName) const
+bool KExiv2::setExifTagLong(const char* exifTagName, long val, bool setProgramName) const
 {
     if (!setProgramId(setProgramName))
         return false;
@@ -377,7 +385,7 @@
     return false;
 }
 
-bool KExiv2::setExifTagRational(const char *exifTagName, long int num, long int den, bool setProgramName) const
+bool KExiv2::setExifTagRational(const char* exifTagName, long int num, long int den, bool setProgramName) const
 {
     if (!setProgramId(setProgramName))
         return false;
@@ -395,7 +403,7 @@
     return false;
 }
 
-bool KExiv2::setExifTagData(const char *exifTagName, const QByteArray& data, bool setProgramName) const
+bool KExiv2::setExifTagData(const char* exifTagName, const QByteArray& data, bool setProgramName) const
 {
     if (data.isEmpty())
         return false;
@@ -417,7 +425,7 @@
     return false;
 }
 
-bool KExiv2::setExifTagVariant(const char *exifTagName, const QVariant& val,
+bool KExiv2::setExifTagVariant(const char* exifTagName, const QVariant& val,
                                bool rationalWantSmallDenominator, bool setProgramName) const
 {
     switch (val.type())
@@ -483,7 +491,7 @@
     return false;
 }
 
-QString KExiv2::createExifUserStringFromValue(const char *exifTagName, const QVariant &val, bool escapeCR)
+QString KExiv2::createExifUserStringFromValue(const char* exifTagName, const QVariant& val, bool escapeCR)
 {
     try
     {
@@ -563,7 +571,7 @@
     return QString();
 }
 
-bool KExiv2::getExifTagLong(const char* exifTagName, long &val) const
+bool KExiv2::getExifTagLong(const char* exifTagName, long& val) const
 {
     try
     {
@@ -614,7 +622,7 @@
     return QByteArray();
 }
 
-QVariant KExiv2::getExifTagVariant(const char *exifTagName, bool rationalAsListOfInts, bool stringEscapeCR, int component) const
+QVariant KExiv2::getExifTagVariant(const char* exifTagName, bool rationalAsListOfInts, bool stringEscapeCR, int component) const
 {
     try
     {
@@ -722,7 +730,7 @@
     return QString();
 }
 
-bool KExiv2::setExifTagString(const char *exifTagName, const QString& value, bool setProgramName) const
+bool KExiv2::setExifTagString(const char* exifTagName, const QString& value, bool setProgramName) const
 {
     if (!setProgramId(setProgramName))
         return false;
@@ -778,7 +786,7 @@
             }
         }
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot get Exif Thumbnail using Exiv2 ", e);
     }
@@ -786,7 +794,7 @@
     return thumbnail;
 }
 
-bool KExiv2::rotateExifQImage(QImage &image, ImageOrientation orientation) const
+bool KExiv2::rotateExifQImage(QImage& image, ImageOrientation orientation) const
 {
     QMatrix matrix;
 
@@ -835,7 +843,7 @@
     return false;
 }
 
-bool KExiv2::setExifThumbnail(const QImage& thumb, bool setProgramName) const
+bool KExiv2::setExifThumbnail(const QImage& thumbImage, bool setProgramName) const
 {
     if (!setProgramId(setProgramName))
         return false;
@@ -846,7 +854,7 @@
         QByteArray data;
         QBuffer buffer(&data);
         buffer.open(QIODevice::WriteOnly);
-        thumb.save(&buffer, "JPEG");
+        thumbImage.save(&buffer, "JPEG");
         Exiv2::ExifThumb thumb(d->exifMetadata());
         thumb.setJpegThumbnail((Exiv2::byte *)data.data(), data.size());
 #else
@@ -861,7 +869,7 @@
 #endif
         return true;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot set Exif Thumbnail using Exiv2 ", e);
     }
@@ -869,6 +877,74 @@
     return false;
 }
 
+bool KExiv2::setTiffThumbnail(const QImage& thumbImage, bool setProgramName) const
+{
+    if (!setProgramId(setProgramName))
+        return false;
+
+    removeExifThumbnail();
+
+    try
+    {
+#if (EXIV2_TEST_VERSION(0,17,91))
+        // Make sure IFD0 is explicitely marked as a main image
+        Exiv2::ExifData::const_iterator pos = d->exifMetadata().findKey(Exiv2::ExifKey("Exif.Image.NewSubfileType"));
+        if (pos == d->exifMetadata().end() || pos->count() != 1 || pos->toLong() != 0) {
+            throw Exiv2::Error(1, "Exif.Image.NewSubfileType missing or not set as main image");
+        }
+        // Remove sub-IFD tags
+        std::string subImage1("SubImage1");
+        for (Exiv2::ExifData::iterator md = d->exifMetadata().begin(); md != d->exifMetadata().end();)
+        {
+            if (md->groupName() == subImage1)
+                md = d->exifMetadata().erase(md);
+            else
+                ++md;
+        }
+        // Set thumbnail tags
+        QByteArray data;
+        QBuffer buffer(&data);
+        buffer.open(QIODevice::WriteOnly);
+        thumbImage.save(&buffer, "JPEG");
+
+        Exiv2::DataBuf buf((Exiv2::byte *)data.data(), data.size());
+        Exiv2::ULongValue val;
+        val.read("0");
+        val.setDataArea(buf.pData_, buf.size_);
+        d->exifMetadata()["Exif.SubImage1.JPEGInterchangeFormat"] = val;
+        d->exifMetadata()["Exif.SubImage1.JPEGInterchangeFormatLength"] = uint32_t(buf.size_);
+        d->exifMetadata()["Exif.SubImage1.Compression"] = uint16_t(6); // JPEG (old-style)
+        d->exifMetadata()["Exif.SubImage1.NewSubfileType"] = uint32_t(1); // Thumbnail image
+        return true;
+#endif
+    }
+    catch( Exiv2::Error& e )
+    {
+        d->printExiv2ExceptionError("Cannot set TIFF Thumbnail using Exiv2 ", e);
+    }
+
+    return false;
+}
+
+bool KExiv2::removeExifThumbnail() const
+{
+    try
+    {
+#if (EXIV2_TEST_VERSION(0,17,91))
+        // Remove all IFD0 subimages.
+        Exiv2::ExifThumb thumb(d->exifMetadata());
+        thumb.erase();
+        return true;
+#endif
+    }
+    catch( Exiv2::Error& e )
+    {
+        d->printExiv2ExceptionError("Cannot remove Exif Thumbnail using Exiv2 ", e);
+    }
+
+    return false;
+}
+
 KExiv2::TagsMap KExiv2::getStdExifTagsList() const
 {
     try
@@ -884,7 +960,7 @@
         {
             do
             {
-                QString     key = QLatin1String( Exiv2::ExifKey( (*it)->tag_, Exiv2::ExifTags::ifdItem( (*it)->ifdId_ ) ).key().c_str() );
+                QString key = QLatin1String( Exiv2::ExifKey( (*it)->tag_, Exiv2::ExifTags::ifdItem( (*it)->ifdId_ ) ).key().c_str() );
                 QStringList values;
                 values << (*it)->name_ << (*it)->title_ << (*it)->desc_;
                 tagsMap.insert(key, values);
@@ -894,7 +970,7 @@
         }
         return tagsMap;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot get Exif Tags list using Exiv2 ", e);
     }
@@ -916,18 +992,17 @@
              << Exiv2::CanonMakerNote::tagListPa()
              << Exiv2::CanonMakerNote::tagListCf()
              << Exiv2::CanonMakerNote::tagListPi()
-
-             /*
-              * Not yet officially released. I added some new tags to the
-              * Canon Makernote namespace. Should be released with exiv2-0.19...
-              *
-                     << Exiv2::CanonMakerNote::tagListFi()
-              */
-
+#if (EXIV2_TEST_VERSION(0,19,1))
+             << Exiv2::CanonMakerNote::tagListFi()
+#endif
              // Sigma Makernotes.
              << Exiv2::SigmaMakerNote::tagList()
              // Sony Makernotes.
              << Exiv2::SonyMakerNote::tagList()
+#if (EXIV2_TEST_VERSION(0,19,1))
+             << Exiv2::SonyMakerNote::tagListCs()
+             << Exiv2::SonyMakerNote::tagListCs2()
+#endif
              // Minolta Makernotes.
              << Exiv2::MinoltaMakerNote::tagList()
              << Exiv2::MinoltaMakerNote::tagListCsStd()
@@ -971,7 +1046,7 @@
         }
         return tagsMap;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot get Makernote Tags list using Exiv2 ", e);
     }
diff -ru kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/kexiv2gps.cpp kdegraphics/libs/libkexiv2/libkexiv2/kexiv2gps.cpp
--- kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/kexiv2gps.cpp	2009-11-21 10:43:35.000000000 +0100
+++ kdegraphics/libs/libkexiv2/libkexiv2/kexiv2gps.cpp	2010-06-10 17:10:37.932376721 +0200
@@ -7,8 +7,8 @@
  * Description : Exiv2 library interface for KDE
  *               GPS manipulation methods
  *
- * Copyright (C) 2006-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
- * Copyright (C) 2006-2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2006-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2006-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
@@ -49,7 +49,7 @@
     return true;
 }
 
-bool KExiv2::getGPSLatitudeNumber(double *latitude) const
+bool KExiv2::getGPSLatitudeNumber(double* latitude) const
 {
     try
     {
@@ -106,7 +106,7 @@
             return ( convertFromGPSCoordinateString(getXmpTagString("Xmp.exif.GPSLatitude"), latitude) );
         }
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot get GPS tag using Exiv2 ", e);
     }
@@ -114,7 +114,7 @@
     return false;
 }
 
-bool KExiv2::getGPSLongitudeNumber(double *longitude) const
+bool KExiv2::getGPSLongitudeNumber(double* longitude) const
 {
     try
     {
@@ -171,7 +171,7 @@
             return ( convertFromGPSCoordinateString(getXmpTagString("Xmp.exif.GPSLongitude"), longitude) );
         }
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot get GPS tag using Exiv2 ", e);
     }
@@ -179,7 +179,7 @@
     return false;
 }
 
-bool KExiv2::getGPSAltitude(double *altitude) const
+bool KExiv2::getGPSAltitude(double* altitude) const
 {
     try
     {
@@ -237,7 +237,7 @@
             }
         }
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot get GPS tag using Exiv2 ", e);
     }
@@ -269,7 +269,7 @@
         else
             return QString();
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot get Exif GPS tag using Exiv2 ", e);
     }
@@ -301,7 +301,7 @@
         else
             return QString();
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot get Exif GPS tag using Exiv2 ", e);
     }
@@ -439,7 +439,7 @@
 
         return true;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot set Exif GPS tag using Exiv2 ", e);
     }
@@ -447,7 +447,7 @@
     return false;
 }
 
-bool KExiv2::setGPSInfo(double altitude, const QString &latitude, const QString &longitude, bool setProgramName)
+bool KExiv2::setGPSInfo(double altitude, const QString& latitude, const QString& longitude, bool setProgramName)
 {
     if (!setProgramId(setProgramName))
         return false;
@@ -535,7 +535,7 @@
 
         return true;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot set Exif GPS tag using Exiv2 ", e);
     }
@@ -600,7 +600,7 @@
 
         return true;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot remove Exif GPS tag using Exiv2 ", e);
     }
@@ -704,13 +704,15 @@
     }
 
     criterion = 2 * value * DBL_EPSILON;
-    for (leasterr = value, num = 1; num < lastnum; num++) {
+    for (leasterr = value, num = 1; num < lastnum; num++)
+    {
         approx = (int)(num / value + 0.5);
         error  = fabs((double)num / approx - value);
-        if (error < leasterr) {
-            bestnum = num;
+        if (error < leasterr)
+        {
+            bestnum   = num;
             bestdenom = approx;
-            leasterr = error;
+            leasterr  = error;
             if (leasterr <= criterion) break;
         }
     }
@@ -831,11 +833,11 @@
     return coordinateString;
 }
 
-bool KExiv2::convertFromGPSCoordinateString(const QString &gpsString,
-                                            long int *numeratorDegrees, long int *denominatorDegrees,
-                                            long int *numeratorMinutes, long int *denominatorMinutes,
-                                            long int *numeratorSeconds, long int *denominatorSeconds,
-                                            char *directionReference)
+bool KExiv2::convertFromGPSCoordinateString(const QString& gpsString,
+                                            long int* numeratorDegrees, long int* denominatorDegrees,
+                                            long int* numeratorMinutes, long int* denominatorMinutes,
+                                            long int* numeratorSeconds, long int* denominatorSeconds,
+                                            char* directionReference)
 {
     if (gpsString.isEmpty())
         return false;
@@ -876,13 +878,13 @@
         return false;
 }
 
-bool KExiv2::convertFromGPSCoordinateString(const QString &gpsString, double *degrees)
+bool KExiv2::convertFromGPSCoordinateString(const QString& gpsString, double* degrees)
 {
     if (gpsString.isEmpty())
         return false;
 
     char directionReference = gpsString.at(gpsString.length() - 1).toUpper().toLatin1();
-    QString coordinate = gpsString.left(gpsString.length() - 1);
+    QString coordinate      = gpsString.left(gpsString.length() - 1);
 
     QStringList parts = coordinate.split(',');
     if (parts.size() == 2)
@@ -913,8 +915,8 @@
         return false;
 }
 
-bool KExiv2::convertToUserPresentableNumbers(const QString &gpsString,
-                                             int *degrees, int *minutes, double *seconds, char *directionReference)
+bool KExiv2::convertToUserPresentableNumbers(const QString& gpsString,
+                                             int* degrees, int* minutes, double* seconds, char* directionReference)
 {
     if (gpsString.isEmpty())
         return false;
@@ -942,11 +944,13 @@
         return true;
     }
     else
+    {
         return false;
+    }
 }
 
 void KExiv2::convertToUserPresentableNumbers(bool isLatitude, double coordinate,
-                                             int *degrees, int *minutes, double *seconds, char *directionReference)
+                                             int* degrees, int* minutes, double* seconds, char* directionReference)
 {
     if (isLatitude)
     {
diff -ru kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/kexiv2.h kdegraphics/libs/libkexiv2/libkexiv2/kexiv2.h
--- kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/kexiv2.h	2009-11-21 10:43:35.000000000 +0100
+++ kdegraphics/libs/libkexiv2/libkexiv2/kexiv2.h	2010-06-10 17:10:37.932376721 +0200
@@ -6,8 +6,8 @@
  * Date        : 2006-09-15
  * Description : Exiv2 library interface for KDE
  *
- * Copyright (C) 2006-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
- * Copyright (C) 2006-2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2006-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2006-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
  *
  * Exiv2: http://www.exiv2.org
  * Exif : http://www.exif.org/Exif2-2.PDF
@@ -201,6 +201,22 @@
      */
     QString getFilePath() const;
 
+    /** Returns the pixel size of the current image. This information is read from the file,
+     *  not from the metadata. The returned QSize is valid if the KExiv2 object was _constructed_
+     *  by reading a file or image data; the information is not available when the object
+     *  was created from KExiv2Data.
+     *  Note that in the Exif or XMP metadata, there may be fields describing the image size.
+     *  These fields are not accessed by this method.
+     *  When replacing the metadata with setData(), the metadata may change; this information
+     *  always keeps referring to the file it was initially read from.
+     */
+    QSize getPixelSize() const;
+
+    /** Returns the mime type of this image. The information is read from the file;
+     *  see the docs for pixelSize() to know when it is available.
+     */
+    QString getMimeType() const;
+
     /** Enable or disable writing metadata operations to RAW tiff based files.
         It's require Exiv2 0.18. By default RAW files are untouched.
      */
@@ -326,7 +342,7 @@
         header. Header is saved into 'lang'. If no language alternative is founf, value is returned 
         as well and 'lang' is set to a null string.
      */
-    static QString detectLanguageAlt(const QString &value, QString& lang);
+    static QString detectLanguageAlt(const QString& value, QString& lang);
 
     //-----------------------------------------------------------------
     //-- EXIF manipulation methods ------------------------------------
@@ -376,14 +392,20 @@
     /** Fix orientation of a QImage image accordingly with Exif orientation tag.
         Return true if image is rotated, else false.
      */
-    bool rotateExifQImage(QImage &image, ImageOrientation orientation) const;
+    bool rotateExifQImage(QImage& image, ImageOrientation orientation) const;
 
     /** Set the Exif Thumbnail image. The thumbnail image must have the right dimensions before. 
         Look Exif specification for details. Return true if thumbnail have been changed in metadata.
      */
     bool setExifThumbnail(const QImage& thumb, bool setProgramName=true) const;
 
-    /** Return a QString copy of Exif user comments. Return a null string if user comments cannot 
+    /** Remove the Exif Thumbnail from the image */
+    bool removeExifThumbnail() const;
+
+    /** Adds a JPEG thumbnail to a TIFF images. Use this instead of setExifThumbnail for TIFF images. */
+    bool setTiffThumbnail(const QImage& thumb, bool setProgramName=true) const;
+
+    /** Return a QString copy of Exif user comments. Return a null string if user comments cannot
         be found.
      */
     QString getExifComment() const;
@@ -396,11 +418,11 @@
     /** Get an Exif tags content like a string. If 'escapeCR' parameter is true, the CR characters
         will be removed. If Exif tag cannot be found a null string is returned.
      */
-    QString getExifTagString(const char *exifTagName, bool escapeCR=true) const;
+    QString getExifTagString(const char* exifTagName, bool escapeCR=true) const;
 
     /** Set an Exif tag content using a string. Return true if tag is set successfully.
      */
-    bool setExifTagString(const char *exifTagName, const QString& value, bool setProgramName=true) const;
+    bool setExifTagString(const char* exifTagName, const QString& value, bool setProgramName=true) const;
 
     /** Get an Exif tag content like a long value. Return true if Exif tag be found.
      */
@@ -408,28 +430,28 @@
 
     /** Set an Exif tag content using a long value. Return true if tag is set successfully.
      */
-    bool setExifTagLong(const char *exifTagName, long val, bool setProgramName=true) const;
+    bool setExifTagLong(const char* exifTagName, long val, bool setProgramName=true) const;
 
     /** Get the 'component' index of an Exif tags content like a rational value. 
         'num' and 'den' are the numerator and the denominator of the rational value. 
         Return true if Exif tag be found.
      */
-    bool getExifTagRational(const char *exifTagName, long int &num, long int &den, int component=0) const;
+    bool getExifTagRational(const char* exifTagName, long int& num, long int& den, int component=0) const;
 
     /** Set an Exif tag content using a rational value. 
         'num' and 'den' are the numerator and the denominator of the rational value. 
         Return true if tag is set successfully.
      */
-    bool setExifTagRational(const char *exifTagName, long int num, long int den, bool setProgramName=true) const;
+    bool setExifTagRational(const char* exifTagName, long int num, long int den, bool setProgramName=true) const;
 
     /** Get an Exif tag content like a bytes array. Return an empty bytes array if Exif 
         tag cannot be found.
      */
-    QByteArray getExifTagData(const char *exifTagName) const;
+    QByteArray getExifTagData(const char* exifTagName) const;
 
     /** Set an Exif tag content using a bytes array. Return true if tag is set successfully.
      */
-    bool setExifTagData(const char *exifTagName, const QByteArray& data, bool setProgramName=true) const;
+    bool setExifTagData(const char* exifTagName, const QByteArray& data, bool setProgramName=true) const;
 
     /** Get an Exif tags content as a QVariant. Returns a null QVariant if the Exif
         tag cannot be found.
@@ -439,7 +461,7 @@
         if rationalAsListOfInts is true, as double if rationalAsListOfInts is false.
         An exif tag of numerical type may contain more than one value; set component to the desired index.
      */
-    QVariant getExifTagVariant(const char *exifTagName, bool rationalAsListOfInts=true, bool escapeCR=true, int component=0) const;
+    QVariant getExifTagVariant(const char* exifTagName, bool rationalAsListOfInts=true, bool escapeCR=true, int component=0) const;
 
     /** Set an Exif tag content using a QVariant. Returns true if tag is set successfully.
         All types described for the above method are supported.
@@ -447,28 +469,28 @@
         For the meaning of rationalWantSmallDenominator, see the documentation of the convertToRational methods.
         Setting a value with multiple components is currently not supported.
      */
-    bool setExifTagVariant(const char *exifTagName, const QVariant& data,
+    bool setExifTagVariant(const char* exifTagName, const QVariant& data,
                            bool rationalWantSmallDenominator=true, bool setProgramName=true) const;
 
     /** Remove the Exif tag 'exifTagName' from Exif metadata. Return true if tag is 
         removed successfully or if no tag was present.
      */
-    bool removeExifTag(const char *exifTagName, bool setProgramName=true) const;
+    bool removeExifTag(const char* exifTagName, bool setProgramName=true) const;
 
     /** Return the Exif Tag title or a null string.
      */
-    QString getExifTagTitle(const char *exifTagName);
+    QString getExifTagTitle(const char* exifTagName);
 
     /** Return the Exif Tag description or a null string.
      */
-    QString getExifTagDescription(const char *exifTagName);
+    QString getExifTagDescription(const char* exifTagName);
 
     /** Takes a QVariant value as it could have been retrieved by getExifTagVariant with the given exifTagName,
         and returns its value properly converted to a string (including i18n).
         This is equivalent to calling getExifTagString directly.
         If escapeCR is true CR characters will be removed from the result.
      */
-    QString createExifUserStringFromValue(const char *exifTagName, const QVariant &val, bool escapeCR=true);
+    QString createExifUserStringFromValue(const char* exifTagName, const QVariant& val, bool escapeCR=true);
 
     /** Return a map of Exif tags name/value found in metadata sorted by 
         Exif keys given by 'exifKeysFilter'. 
@@ -488,7 +510,7 @@
         - not include "Iop", or "Thumbnail", or "Image", or "Photo" in the Exif tag keys 
           if 'inverSelection' is true.
      */
-    KExiv2::MetaDataMap getExifTagsDataList(const QStringList &exifKeysFilter, bool invertSelection=false) const;
+    KExiv2::MetaDataMap getExifTagsDataList(const QStringList& exifKeysFilter, bool invertSelection=false) const;
 
     //-------------------------------------------------------------
     //-- IPTC manipulation methods --------------------------------
@@ -528,7 +550,7 @@
 
     /** Set an Iptc tag content using a string. Return true if tag is set successfully.
      */
-    bool setIptcTagString(const char *iptcTagName, const QString& value, bool setProgramName=true) const;
+    bool setIptcTagString(const char* iptcTagName, const QString& value, bool setProgramName=true) const;
 
     /** Returns a strings list with of multiple Iptc tags from the image. Return an empty list if no tag is found. */
     /** Get the values of all IPTC tags with the given tag name in a string list.
@@ -549,24 +571,24 @@
     /** Get an Iptc tag content as a bytes array. Return an empty bytes array if Iptc
         tag cannot be found.
      */
-    QByteArray getIptcTagData(const char *iptcTagName) const;
+    QByteArray getIptcTagData(const char* iptcTagName) const;
 
     /** Set an Iptc tag content using a bytes array. Return true if tag is set successfully.
      */
-    bool setIptcTagData(const char *iptcTagName, const QByteArray& data, bool setProgramName=true) const;
+    bool setIptcTagData(const char* iptcTagName, const QByteArray& data, bool setProgramName=true) const;
 
     /** Remove the all instance of Iptc tags 'iptcTagName' from Iptc metadata. Return true if all 
         tags have been removed successfully (or none were present).
      */
-    bool removeIptcTag(const char *iptcTagName, bool setProgramName=true) const;
+    bool removeIptcTag(const char* iptcTagName, bool setProgramName=true) const;
 
     /** Return the Iptc Tag title or a null string.
      */
-    QString getIptcTagTitle(const char *iptcTagName);
+    QString getIptcTagTitle(const char* iptcTagName);
 
     /** Return the Iptc Tag description or a null string.
      */
-    QString getIptcTagDescription(const char *iptcTagName);
+    QString getIptcTagDescription(const char* iptcTagName);
 
     /** Return a map of Iptc tags name/value found in metadata sorted by
         Iptc keys given by 'iptcKeysFilter'. 
@@ -584,7 +606,7 @@
         - not include "Envelope", or "Application2" in the Iptc tag keys 
           if 'inverSelection' is true.
      */
-    KExiv2::MetaDataMap getIptcTagsDataList(const QStringList &iptcKeysFilter, bool invertSelection=false) const;
+    KExiv2::MetaDataMap getIptcTagsDataList(const QStringList& iptcKeysFilter, bool invertSelection=false) const;
 
     /** Return a strings list of Iptc keywords from image. Return an empty list if no keyword are set.
      */
@@ -660,15 +682,15 @@
 
     /** Set a Xmp tag content using a string. Return true if tag is set successfully.
      */
-    bool setXmpTagString(const char *xmpTagName, const QString& value, bool setProgramName=true) const;
+    bool setXmpTagString(const char* xmpTagName, const QString& value, bool setProgramName=true) const;
 
     /** Return the Xmp Tag title or a null string.
      */
-    QString getXmpTagTitle(const char *xmpTagName);
+    QString getXmpTagTitle(const char* xmpTagName);
 
     /** Return the Xmp Tag description or a null string.
      */
-    QString getXmpTagDescription(const char *xmpTagName);
+    QString getXmpTagDescription(const char* xmpTagName);
 
     /** Return a map of Xmp tags name/value found in metadata sorted by 
         Xmp keys given by 'xmpKeysFilter'.
@@ -686,7 +708,7 @@
         - not include "dc", or "xmp" in the Xmp tag keys 
           if 'inverSelection' is true.
      */
-    KExiv2::MetaDataMap getXmpTagsDataList(const QStringList &xmpKeysFilter, bool invertSelection=false) const;
+    KExiv2::MetaDataMap getXmpTagsDataList(const QStringList& xmpKeysFilter, bool invertSelection=false) const;
 
     /** Get all redondant Alternative Language Xmp tags content like a map. 
         See AltLangMap class description for details.
@@ -699,7 +721,7 @@
         description for details. If tag already exist, it wil be removed before.
         Return true if tag is set successfully.
      */
-    bool setXmpTagStringListLangAlt(const char *xmpTagName, const KExiv2::AltLangMap& values,
+    bool setXmpTagStringListLangAlt(const char* xmpTagName, const KExiv2::AltLangMap& values,
                                     bool setProgramName) const;
 
     /** Get a Xmp tag content like a string set with an alternative language
@@ -714,7 +736,7 @@
         set alternative language to default settings ("x-default").
         Return true if tag is set successfully.
      */
-    bool setXmpTagStringLangAlt(const char *xmpTagName, const QString& value, 
+    bool setXmpTagStringLangAlt(const char* xmpTagName, const QString& value, 
                                 const QString& langAlt, bool setProgramName=true) const;
 
     /** Get a Xmp tag content like a sequence of strings. If 'escapeCR' parameter is true, the CR characters
@@ -725,7 +747,7 @@
     /** Set a Xmp tag content using the sequence of strings 'seq'.
         Return true if tag is set successfully.
      */
-    bool setXmpTagStringSeq(const char *xmpTagName, const QStringList& seq,
+    bool setXmpTagStringSeq(const char* xmpTagName, const QStringList& seq,
                             bool setProgramName=true) const;
 
     /** Get a Xmp tag content like a bag of strings. If 'escapeCR' parameter is true, the CR characters
@@ -736,7 +758,7 @@
     /** Set a Xmp tag content using the bag of strings 'bag'.
         Return true if tag is set successfully.
      */
-    bool setXmpTagStringBag(const char *xmpTagName, const QStringList& bag,
+    bool setXmpTagStringBag(const char* xmpTagName, const QStringList& bag,
                             bool setProgramName=true) const;
 
     /** Set an Xmp tag content using a list of strings defined by the 'entriesToAdd' parameter.
@@ -744,14 +766,14 @@
         all new with all already existing entries to prevent duplicates in the image.
         Return true if the entries have been added to metadata.
      */
-    bool addToXmpTagStringBag(const char *xmpTagName, const QStringList& entriesToAdd,
+    bool addToXmpTagStringBag(const char* xmpTagName, const QStringList& entriesToAdd,
                               bool setProgramName) const;
 
     /** Remove those Xmp tag entries that are listed in entriesToRemove from the entries in metadata.
         Return true if tag entries are no longer contained in metadata.
         All other entries are preserved.
      */
-    bool removeFromXmpTagStringBag(const char *xmpTagName, const QStringList& entriesToRemove,
+    bool removeFromXmpTagStringBag(const char* xmpTagName, const QStringList& entriesToRemove,
                                    bool setProgramName) const;
 
     /** Get an Xmp tag content as a QVariant. Returns a null QVariant if the Xmp
@@ -764,7 +786,7 @@
         LangAlt values will have type Map (QMap<QString, QVariant>) with the language
         code as key and the contents as value, of type String.
      */
-    QVariant getXmpTagVariant(const char *xmpTagName, bool rationalAsListOfInts=true, bool stringEscapeCR=true) const;
+    QVariant getXmpTagVariant(const char* xmpTagName, bool rationalAsListOfInts=true, bool stringEscapeCR=true) const;
 
     /** Return a strings list of Xmp keywords from image. Return an empty list if no keyword are set.
      */
@@ -818,7 +840,7 @@
     /** Remove the Xmp tag 'xmpTagName' from Xmp metadata. Return true if tag is
         removed successfully or if no tag was present.
      */
-    bool removeXmpTag(const char *xmpTagName, bool setProgramName=true) const;
+    bool removeXmpTag(const char* xmpTagName, bool setProgramName=true) const;
 
 
     /** Register a namespace which Exiv2 doesn't know yet. This is only needed
@@ -850,12 +872,12 @@
         where the sign determines the direction ref (North + / South - ; East + / West -).
         Returns true if the information is available.
     */
-    bool getGPSLatitudeNumber(double *latitude) const;
-    bool getGPSLongitudeNumber(double *longitude) const;
+    bool getGPSLatitudeNumber(double* latitude) const;
+    bool getGPSLongitudeNumber(double* longitude) const;
 
     /** Get GPS altitude information, in meters, relative to sea level (positive sign above sea level)
      */
-    bool getGPSAltitude(double *altitude) const;
+    bool getGPSAltitude(double* altitude) const;
 
     /** Set all GPS location information into image. Return true if all information have been 
         changed in metadata.
@@ -906,23 +928,23 @@
         Returns true if the conversion was successful.
         If minutes is given in the fractional form, a denominator of 1000000 for the minutes will be used.
      */
-    static bool convertFromGPSCoordinateString(const QString &coordinate,
-                                               long int *numeratorDegrees, long int *denominatorDegrees,
-                                               long int *numeratorMinutes, long int *denominatorMinutes,
-                                               long int *numeratorSeconds, long int *denominatorSeconds,
-                                               char *directionReference);
+    static bool convertFromGPSCoordinateString(const QString& coordinate,
+                                               long int* numeratorDegrees, long int* denominatorDegrees,
+                                               long int* numeratorMinutes, long int* denominatorMinutes,
+                                               long int* numeratorSeconds, long int* denominatorSeconds,
+                                               char* directionReference);
 
     /** Convert a GPSCoordinate string as defined by XMP to a double floating point number in degrees
         where the sign determines the direction ref (North + / South - ; East + / West -).
         Returns true if the conversion was successful.
      */
-    static bool convertFromGPSCoordinateString(const QString &gpsString, double *coordinate);
+    static bool convertFromGPSCoordinateString(const QString& gpsString, double* coordinate);
 
     /** Converts a GPSCoordinate string to user presentable numbers, integer degrees and minutes and
         double floating point seconds, and a direction reference ('N' or 'S', 'E' or 'W')
      */
-    static bool convertToUserPresentableNumbers(const QString &coordinate,
-                                                int *degrees, int *minutes, double *seconds, char *directionReference);
+    static bool convertToUserPresentableNumbers(const QString& coordinate,
+                                                int* degrees, int* minutes, double* seconds, char* directionReference);
 
     /** Converts a double floating point number to user presentable numbers, integer degrees and minutes and
         double floating point seconds, and a direction reference ('N' or 'S', 'E' or 'W').
@@ -930,7 +952,7 @@
         if the latitude or the longitude is meant by the double parameter.
      */
     static void convertToUserPresentableNumbers(bool isLatitude, double coordinate,
-                                                int *degrees, int *minutes, double *seconds, char *directionReference);
+                                                int* degrees, int* minutes, double* seconds, char* directionReference);
 
 protected:
 
diff -ru kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/kexiv2image.cpp kdegraphics/libs/libkexiv2/libkexiv2/kexiv2image.cpp
--- kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/kexiv2image.cpp	2009-11-21 10:43:35.000000000 +0100
+++ kdegraphics/libs/libkexiv2/libkexiv2/kexiv2image.cpp	2010-06-10 17:10:37.932376721 +0200
@@ -7,8 +7,8 @@
  * Description : Exiv2 library interface for KDE
  *               Common metadata image information manipulation methods
  *
- * Copyright (C) 2006-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
- * Copyright (C) 2006-2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2006-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2006-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
@@ -80,7 +80,7 @@
         d->iptcMetadata()["Iptc.Application2.ProgramVersion"] = std::string(version.toAscii().constData());
         return true;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot set Program identity into image using Exiv2 ", e);
     }
@@ -169,7 +169,7 @@
 #endif // _XMP_SUPPORT_
 
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot parse image dimensions tag using Exiv2 ", e);
     }
@@ -205,7 +205,7 @@
 
         return true;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot set image dimensions using Exiv2 ", e);
     }
@@ -296,7 +296,7 @@
 #endif // _XMP_SUPPORT_
 
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot parse Exif Orientation tag using Exiv2 ", e);
     }
@@ -330,10 +330,10 @@
 
 #endif // _XMP_SUPPORT_
 
-        // -- Minolta Cameras ----------------------------------
+        // -- Minolta/Sony Cameras ----------------------------------
 
-        // Minolta camera store image rotation in Makernote.
-        // We remove these information to prevent duplicate values. 
+        // Minolta and Sony camera store image rotation in Makernote.
+        // We remove these information to prevent duplicate values.
 
         Exiv2::ExifData::iterator it;
 
@@ -366,7 +366,7 @@
 
         return true;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot set Exif Orientation tag using Exiv2 ", e);
     }
@@ -468,7 +468,7 @@
 
         return true;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot set Exif color workspace tag using Exiv2 ", e);
     }
@@ -681,7 +681,7 @@
             }
         }
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot parse Exif date & time tag using Exiv2 ", e);
     }
@@ -749,7 +749,7 @@
 
         return true;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot set Date & Time into image using Exiv2 ", e);
     }
@@ -819,7 +819,7 @@
             }
         }
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot parse Exif digitization date & time tag using Exiv2 ", e);
     }
@@ -842,7 +842,7 @@
 
         // TODO : Added here Makernotes preview extraction when Exiv2 will be fixed for that.
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot get image preview using Exiv2 ", e);
     }
@@ -876,7 +876,7 @@
 
         return true;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot get image preview using Exiv2 ", e);
     }
@@ -884,64 +884,4 @@
     return false;
 }
 
-/*
-Prototype code
-
-    //------------------------------------------------------------
-    //-- RAW embedded preview methods --------------------------------
-    //------------------------------------------------------------
-
-    class EmbeddedPreviewInfo
-    {
-        public:
-            int     width;
-            int     height;
-            QString mimeType;
-    };
-    / **
-     * Returns a list of infos about the embedded previews available.
-     * /
-    QList<EmbeddedPreviewInfo> getEmbeddedPreviewInfos() const;
-    / **
-     * Returns the data for an embedded preview. Index is the index
-     * of the corresponding EmbeddedPreviewInfo in the list retrieved from getEmbeddedPreviewInfos().
-     * /
-    QByteArray getEmbeddedPreviewData(unsigned int index) const;
-
-QList<KExiv2::EmbeddedPreviewInfo> KExiv2::getEmbeddedPreviewInfos() const
-{
-    QList<EmbeddedPreviewInfo> infos;
-#if (EXIV2_TEST_VERSION(0,18,0))
-    Exiv2::PreviewManager manager;
-
-    Exiv2::PreviewPropertiesList properties = manager.getPreviewProperties();
-    for (unsigned int i=0; i<properties.size(); i++)
-    {
-        EmbeddedPreviewInfo info;
-        Exiv2::PreviewProperties &property = properties[i];
-        info.width    = property.width_;
-        info.height   = property.height_;
-        info.mimeType = QString::fromLatin1(property.mimeType_.c_str());
-        infos << info;
-    }
-#endif
-    return infos;
-}
-
-QByteArray KExiv2::getEmbeddedPreviewData(unsigned int index) const
-{
-#if (EXIV2_TEST_VERSION(0,18,0))
-    Exiv2::PreviewManager manager;
-    Exiv2::PreviewPropertiesList properties = manager.getPreviewProperties();
-    if (index < properties.size())
-        return QByteArray();
-    Exiv2::PreviewImage image = manager.getPreviewImage(properties[index]);
-    return QByteArray((const char*)image.pData(), image.size());
-#else
-    Q_UNUSED(index)
-    return QByteArray();
-#endif
-}
-*/
-
 }  // NameSpace KExiv2Iface
diff -ru kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/kexiv2iptc.cpp kdegraphics/libs/libkexiv2/libkexiv2/kexiv2iptc.cpp
--- kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/kexiv2iptc.cpp	2009-11-21 10:43:35.000000000 +0100
+++ kdegraphics/libs/libkexiv2/libkexiv2/kexiv2iptc.cpp	2010-06-10 17:10:37.935709576 +0200
@@ -7,8 +7,8 @@
  * Description : Exiv2 library interface for KDE
  *               Iptc manipulation methods
  *
- * Copyright (C) 2006-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
- * Copyright (C) 2006-2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2006-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2006-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
@@ -40,7 +40,7 @@
         Exiv2::AccessMode mode = image->checkMode(Exiv2::mdIptc);
         return (mode == Exiv2::amWrite || mode == Exiv2::amReadWrite);
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         std::string s(e.what());
         kDebug(51003) << "Cannot check Iptc access mode using Exiv2 (Error #"
@@ -62,7 +62,7 @@
         d->iptcMetadata().clear();
         return true;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot clear Iptc data using Exiv2 ", e);
     }
@@ -102,7 +102,7 @@
 
         }
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         if (!d->filePath.isEmpty())
             kDebug(51003) << "From file " << d->filePath.toAscii().constData() << endl;
@@ -130,7 +130,7 @@
 #endif
         }
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         if (!d->filePath.isEmpty())
             kDebug(51003) << "From file " << d->filePath.toAscii().constData() << endl;
@@ -141,7 +141,7 @@
     return false;
 }
 
-KExiv2::MetaDataMap KExiv2::getIptcTagsDataList(const QStringList &iptcKeysFilter, bool invertSelection) const
+KExiv2::MetaDataMap KExiv2::getIptcTagsDataList(const QStringList& iptcKeysFilter, bool invertSelection) const
 {
     if (d->iptcMetadata().empty())
        return MetaDataMap();
@@ -212,7 +212,7 @@
     return MetaDataMap();
 }
 
-QString KExiv2::getIptcTagTitle(const char *iptcTagName)
+QString KExiv2::getIptcTagTitle(const char* iptcTagName)
 {
     try
     {
@@ -228,7 +228,7 @@
     return QString();
 }
 
-QString KExiv2::getIptcTagDescription(const char *iptcTagName)
+QString KExiv2::getIptcTagDescription(const char* iptcTagName)
 {
     try
     {
@@ -244,7 +244,7 @@
     return QString();
 }
 
-bool KExiv2::removeIptcTag(const char *iptcTagName, bool setProgramName) const
+bool KExiv2::removeIptcTag(const char* iptcTagName, bool setProgramName) const
 {
     if (!setProgramId(setProgramName))
         return false;
@@ -271,7 +271,7 @@
         if (i > 0)
             return true;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot remove Iptc tag using Exiv2 ", e);
     }
@@ -279,7 +279,7 @@
     return false;
 }
 
-bool KExiv2::setIptcTagData(const char *iptcTagName, const QByteArray& data, bool setProgramName) const
+bool KExiv2::setIptcTagData(const char* iptcTagName, const QByteArray& data, bool setProgramName) const
 {
     if (data.isEmpty())
         return false;
@@ -293,7 +293,7 @@
         d->iptcMetadata()[iptcTagName] = val;
         return true;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot set Iptc tag data into image using Exiv2 ", e);
     }
@@ -301,7 +301,7 @@
     return false;
 }
 
-QByteArray KExiv2::getIptcTagData(const char *iptcTagName) const
+QByteArray KExiv2::getIptcTagData(const char* iptcTagName) const
 {
     try
     {
@@ -317,7 +317,7 @@
             return data;
         }
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError(QString("Cannot find Iptc key '%1' into image using Exiv2 ")
                                     .arg(iptcTagName), e);
@@ -345,7 +345,7 @@
             return tagValue;
         }
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError(QString("Cannot find Iptc key '%1' into image using Exiv2 ")
                                     .arg(iptcTagName), e);
@@ -354,7 +354,7 @@
     return QString();
 }
 
-bool KExiv2::setIptcTagString(const char *iptcTagName, const QString& value, bool setProgramName) const
+bool KExiv2::setIptcTagString(const char* iptcTagName, const QString& value, bool setProgramName) const
 {
     if (!setProgramId(setProgramName))
         return false;
@@ -364,7 +364,7 @@
         d->iptcMetadata()[iptcTagName] = std::string(value.toAscii().constData());
         return true;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot set Iptc tag string into image using Exiv2 ", e);
     }
@@ -399,7 +399,7 @@
             return values;
         }
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError(QString("Cannot find Iptc key '%1' into image using Exiv2 ")
                                     .arg(iptcTagName), e);
@@ -459,7 +459,7 @@
 
         return true;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError(QString("Cannot set Iptc key '%1' into image using Exiv2 ")
                                     .arg(iptcTagName), e);
@@ -491,7 +491,7 @@
             return keywords;
         }
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot get Iptc Keywords from image using Exiv2 ", e);
     }
@@ -548,7 +548,7 @@
 
         return true;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot set Iptc Keywords into image using Exiv2 ", e);
     }
@@ -579,7 +579,7 @@
             return subjects;
         }
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot get Iptc Subjects from image using Exiv2 ", e);
     }
@@ -631,7 +631,7 @@
 
         return true;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot set Iptc Subjects into image using Exiv2 ", e);
     }
@@ -662,7 +662,7 @@
             return subCategories;
         }
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot get Iptc Sub Categories from image using Exiv2 ", e);
     }
@@ -715,7 +715,7 @@
 
         return true;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot set Iptc Sub Categories into image using Exiv2 ", e);
     }
@@ -746,7 +746,7 @@
         }
         return tagsMap;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot get Iptc Tags list using Exiv2 ", e);
     }
diff -ru kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/kexiv2_p.cpp kdegraphics/libs/libkexiv2/libkexiv2/kexiv2_p.cpp
--- kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/kexiv2_p.cpp	2009-11-21 10:43:35.000000000 +0100
+++ kdegraphics/libs/libkexiv2/libkexiv2/kexiv2_p.cpp	2010-06-10 17:10:37.935709576 +0200
@@ -6,8 +6,8 @@
  * Date        : 2007-09-03
  * Description : Exiv2 library interface for KDE
  *
- * Copyright (C) 2006-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
- * Copyright (C) 2006-2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2006-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2006-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
@@ -54,7 +54,7 @@
                   << e.code() << ": " << s.c_str() << endl;
 }
 
-QString KExiv2Priv::convertCommentValue(const Exiv2::Exifdatum &exifDatum)
+QString KExiv2Priv::convertCommentValue(const Exiv2::Exifdatum& exifDatum)
 {
     try
     {
@@ -93,10 +93,16 @@
 
         if (charset == "\"Unicode\"")
         {
+#if (EXIV2_TEST_VERSION(0,20,0))
+            return QString::fromUtf8(comment.data());
+#else
+            // Older versions give a UCS2-String, see bug #205824
+
             // QString expects a null-terminated UCS-2 string.
             // Is it already null terminated? In any case, add termination "\0\0" for safety.
             comment.resize(comment.length() + 2, '\0');
             return QString::fromUtf16((unsigned short *)comment.data());
+#endif
         }
         else if (charset == "\"Jis\"")
         {
@@ -112,7 +118,7 @@
             return detectEncodingAndDecode(comment);
         }
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         printExiv2ExceptionError("Cannot convert Comment using Exiv2 ", e);
     }
@@ -120,7 +126,7 @@
     return QString();
 }
 
-QString KExiv2Priv::detectEncodingAndDecode(const std::string &value)
+QString KExiv2Priv::detectEncodingAndDecode(const std::string& value)
 {
     // For charset autodetection, we could use sophisticated code
     // (Mozilla chardet, KHTML's autodetection, QTextCodec::codecForContent),
diff -ru kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/kexiv2_p.h kdegraphics/libs/libkexiv2/libkexiv2/kexiv2_p.h
--- kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/kexiv2_p.h	2009-11-21 10:43:35.000000000 +0100
+++ kdegraphics/libs/libkexiv2/libkexiv2/kexiv2_p.h	2010-06-10 17:10:37.935709576 +0200
@@ -6,8 +6,8 @@
  * Date        : 2007-09-03
  * Description : Exiv2 library interface for KDE
  *
- * Copyright (C) 2006-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
- * Copyright (C) 2006-2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2006-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2006-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
@@ -151,35 +151,38 @@
 
     /** Wrapper method to convert a Comments content to a QString.
     */
-    QString convertCommentValue(const Exiv2::Exifdatum &exifDatum);
+    QString convertCommentValue(const Exiv2::Exifdatum& exifDatum);
 
     /** Charset autodetection to convert a string to a QString.
     */
-    QString detectEncodingAndDecode(const std::string &value);
+    QString detectEncodingAndDecode(const std::string& value);
 
     /**
      */
     int getXMPTagsListFromPrefix(const QString& pf, KExiv2::TagsMap& tagsMap);
 
-    const Exiv2::ExifData& exifMetadata() const { return data.constData()->exifMetadata; }
-    const Exiv2::IptcData& iptcMetadata() const { return data.constData()->iptcMetadata; }
-    const Exiv2::XmpData&  xmpMetadata()  const { return data.constData()->xmpMetadata;  }
+    const Exiv2::ExifData& exifMetadata() const { return data.constData()->exifMetadata;  }
+    const Exiv2::IptcData& iptcMetadata() const { return data.constData()->iptcMetadata;  }
+    const Exiv2::XmpData&  xmpMetadata()  const { return data.constData()->xmpMetadata;   }
     const std::string& imageComments()    const { return data.constData()->imageComments; }
 
-    Exiv2::ExifData& exifMetadata() { return data.data()->exifMetadata; }
-    Exiv2::IptcData& iptcMetadata() { return data.data()->iptcMetadata; }
-    Exiv2::XmpData&  xmpMetadata()  { return data.data()->xmpMetadata;  }
+    Exiv2::ExifData& exifMetadata() { return data.data()->exifMetadata;  }
+    Exiv2::IptcData& iptcMetadata() { return data.data()->iptcMetadata;  }
+    Exiv2::XmpData&  xmpMetadata()  { return data.data()->xmpMetadata;   }
     std::string& imageComments()    { return data.data()->imageComments; }
 
 public:
 
-    bool            writeRawFiles;
-    bool            updateFileTimeStamp;
+    bool                               writeRawFiles;
+    bool                               updateFileTimeStamp;
 
-    QString         filePath;
+    QString                            filePath;
+    QSize                              pixelSize;
+    QString                            mimeType;
 
     QSharedDataPointer<KExiv2DataPriv> data;
 };
 
 }  // NameSpace KExiv2Iface
-#endif
+
+#endif // KEXIV2PRIVATE_H
diff -ru kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/kexiv2previews.cpp kdegraphics/libs/libkexiv2/libkexiv2/kexiv2previews.cpp
--- kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/kexiv2previews.cpp	2009-11-21 10:43:35.000000000 +0100
+++ kdegraphics/libs/libkexiv2/libkexiv2/kexiv2previews.cpp	2010-06-10 17:10:37.935709576 +0200
@@ -7,7 +7,7 @@
  * Description : Exiv2 library interface for KDE
  *               Embedded preview loading
  *
- * Copyright (C) 2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2009-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
@@ -62,20 +62,20 @@
         }
     }
 
-    Exiv2::Image::AutoPtr            image;
-    Exiv2::PreviewManager           *manager;
-    QList<Exiv2::PreviewProperties>  properties;
+    Exiv2::Image::AutoPtr           image;
+    Exiv2::PreviewManager*          manager;
+    QList<Exiv2::PreviewProperties> properties;
 };
 
 KExiv2Previews::KExiv2Previews(const QString& filePath)
-    : d(new KExiv2PreviewsPriv)
+              : d(new KExiv2PreviewsPriv)
 {
     try
     {
         Exiv2::Image::AutoPtr image = Exiv2::ImageFactory::open((const char*)(QFile::encodeName(filePath)));
         d->load(image);
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         KExiv2Priv::printExiv2ExceptionError("Cannot load metadata using Exiv2 ", e);
     }
@@ -89,7 +89,7 @@
         Exiv2::Image::AutoPtr image = Exiv2::ImageFactory::open((Exiv2::byte*)imgData.data(), imgData.size());
         d->load(image);
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         KExiv2Priv::printExiv2ExceptionError("Cannot load metadata using Exiv2 ", e);
     }
@@ -105,6 +105,20 @@
     return d->properties.isEmpty();
 }
 
+QSize KExiv2Previews::originalSize() const
+{
+    if (d->image.get())
+        return QSize(d->image->pixelWidth(), d->image->pixelHeight());
+    return QSize();
+}
+
+QString KExiv2Previews::originalMimeType() const
+{
+    if (d->image.get())
+        return d->image->mimeType().c_str();
+    return QString();
+}
+
 int KExiv2Previews::count()
 {
     return d->properties.size();
@@ -142,7 +156,7 @@
         Exiv2::PreviewImage image = d->manager->getPreviewImage(d->properties[index]);
         return QByteArray((const char*)image.pData(), image.size());
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         KExiv2Priv::printExiv2ExceptionError("Cannot load metadata using Exiv2 ", e);
         return QByteArray();
@@ -155,8 +169,8 @@
     QImage image;
     if (!image.loadFromData(previewData))
         return QImage();
-    return image;
-}
 
+    return image;
 }
 
+} // namespace KExiv2Iface
diff -ru kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/kexiv2previews.h kdegraphics/libs/libkexiv2/libkexiv2/kexiv2previews.h
--- kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/kexiv2previews.h	2009-11-21 10:43:35.000000000 +0100
+++ kdegraphics/libs/libkexiv2/libkexiv2/kexiv2previews.h	2010-06-10 17:10:37.929054700 +0200
@@ -7,7 +7,7 @@
  * Description : Exiv2 library interface for KDE
  *               Embedded preview loading
  *
- * Copyright (C) 2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2009-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
@@ -26,8 +26,9 @@
 
 // Qt includes
 
-#include <QtCore/QString>
-#include <QtCore/QByteArray>
+#include <QByteArray>
+#include <QSize>
+#include <QString>
 
 // Local includes.
 
@@ -55,6 +56,11 @@
     KExiv2Previews(const QByteArray& imgData);
     ~KExiv2Previews();
 
+    /// Returns the pixel size of the original image, as read from the file (not the metadata).
+    QSize originalSize() const;
+    /// Returns the mimeType of the original image, detected from the file's content.
+    QString originalMimeType() const;
+
     /// Returns if there are any preview images available
     bool       isEmpty();
 
@@ -91,8 +97,7 @@
     KExiv2PreviewsPriv* const d;
 };
 
-
-} // end of namespace
+} // namespace KExiv2Iface
 
 #endif // KEXIV2PREVIEWS
 
diff -ru kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/kexiv2xmp.cpp kdegraphics/libs/libkexiv2/libkexiv2/kexiv2xmp.cpp
--- kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/kexiv2xmp.cpp	2009-11-21 10:43:35.000000000 +0100
+++ kdegraphics/libs/libkexiv2/libkexiv2/kexiv2xmp.cpp	2010-06-10 17:10:37.935709576 +0200
@@ -7,8 +7,8 @@
  * Description : Exiv2 library interface for KDE
  *               Xmp manipulation methods
  *
- * Copyright (C) 2006-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
- * Copyright (C) 2006-2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2006-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2006-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
@@ -41,7 +41,7 @@
         Exiv2::AccessMode mode = image->checkMode(Exiv2::mdXmp);
         return (mode == Exiv2::amWrite || mode == Exiv2::amReadWrite);
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         std::string s(e.what());
         kDebug(51003) << "Cannot check Xmp access mode using Exiv2 (Error #" 
@@ -79,7 +79,7 @@
         d->xmpMetadata().clear();
         return true;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot clear Xmp data using Exiv2 ", e);
     }
@@ -104,7 +104,7 @@
             return data;
         }
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         if (!d->filePath.isEmpty())
 
@@ -134,7 +134,7 @@
                 return true;
         }
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         if (!d->filePath.isEmpty())
             kDebug(51003) << "From file " << d->filePath.toAscii().constData() << endl;
@@ -147,7 +147,7 @@
     return false;
 }
 
-KExiv2::MetaDataMap KExiv2::getXmpTagsDataList(const QStringList &xmpKeysFilter, bool invertSelection) const
+KExiv2::MetaDataMap KExiv2::getXmpTagsDataList(const QStringList& xmpKeysFilter, bool invertSelection) const
 {
 #ifdef _XMP_SUPPORT_
 
@@ -234,7 +234,7 @@
     return MetaDataMap();
 }
 
-QString KExiv2::getXmpTagTitle(const char *xmpTagName)
+QString KExiv2::getXmpTagTitle(const char* xmpTagName)
 {
 #ifdef _XMP_SUPPORT_
 
@@ -254,7 +254,7 @@
     return QString();
 }
 
-QString KExiv2::getXmpTagDescription(const char *xmpTagName)
+QString KExiv2::getXmpTagDescription(const char* xmpTagName)
 {
 #ifdef _XMP_SUPPORT_
     try 
@@ -293,7 +293,7 @@
             return tagValue;
         }
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError(QString("Cannot find Xmp key '%1' into image using Exiv2 ")
                                     .arg(xmpTagName), e);
@@ -304,7 +304,7 @@
     return QString();
 }
 
-bool KExiv2::setXmpTagString(const char *xmpTagName, const QString& value, bool setProgramName) const
+bool KExiv2::setXmpTagString(const char* xmpTagName, const QString& value, bool setProgramName) const
 {
 #ifdef _XMP_SUPPORT_
 
@@ -320,7 +320,7 @@
         d->xmpMetadata().add(Exiv2::XmpKey(xmpTagName), xmpTxtVal.get());
         return true;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot set Xmp tag string into image using Exiv2 ", e);
     }
@@ -360,7 +360,7 @@
             }
         }
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError(QString("Cannot find Xmp key '%1' into image using Exiv2 ")
                                     .arg(xmpTagName), e);
@@ -371,7 +371,7 @@
     return AltLangMap();
 }
 
-bool KExiv2::setXmpTagStringListLangAlt(const char *xmpTagName, const KExiv2::AltLangMap& values, 
+bool KExiv2::setXmpTagStringListLangAlt(const char* xmpTagName, const KExiv2::AltLangMap& values, 
                                         bool setProgramName) const
 {
 #ifdef _XMP_SUPPORT_
@@ -402,7 +402,7 @@
         }
         return true;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot set Xmp tag string lang-alt into image using Exiv2 ", e);
     }
@@ -442,7 +442,7 @@
             }
         }
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError(QString("Cannot find Xmp key '%1' into image using Exiv2 ")
                                     .arg(xmpTagName), e);
@@ -453,7 +453,7 @@
     return QString();
 }
 
-bool KExiv2::setXmpTagStringLangAlt(const char *xmpTagName, const QString& value, 
+bool KExiv2::setXmpTagStringLangAlt(const char* xmpTagName, const QString& value, 
                                     const QString& langAlt, bool setProgramName) const
 {
 #ifdef _XMP_SUPPORT_
@@ -494,7 +494,7 @@
         d->xmpMetadata().add(Exiv2::XmpKey(xmpTagName), xmpTxtVal.get());
         return true;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot set Xmp tag string lang-alt into image using Exiv2 ", e);
     }
@@ -536,7 +536,7 @@
             }
         }
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError(QString("Cannot find Xmp key '%1' into image using Exiv2 ")
                                     .arg(xmpTagName), e);
@@ -547,7 +547,7 @@
     return QStringList();
 }
 
-bool KExiv2::setXmpTagStringSeq(const char *xmpTagName, const QStringList& seq,
+bool KExiv2::setXmpTagStringSeq(const char* xmpTagName, const QStringList& seq,
                                 bool setProgramName) const
 {
 #ifdef _XMP_SUPPORT_
@@ -575,7 +575,7 @@
             return true;
         }
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot set Xmp tag string Seq into image using Exiv2 ", e);
     }
@@ -616,7 +616,7 @@
             }
         }
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError(QString("Cannot find Xmp key '%1' into image using Exiv2 ")
                                     .arg(xmpTagName), e);
@@ -627,7 +627,7 @@
     return QStringList();
 }
 
-bool KExiv2::setXmpTagStringBag(const char *xmpTagName, const QStringList& bag,
+bool KExiv2::setXmpTagStringBag(const char* xmpTagName, const QStringList& bag,
                                 bool setProgramName) const
 {
 #ifdef _XMP_SUPPORT_
@@ -655,7 +655,7 @@
             return true;
         }
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot set Xmp tag string Bag into image using Exiv2 ", e);
     }
@@ -665,7 +665,7 @@
     return false;
 }
 
-bool KExiv2::addToXmpTagStringBag(const char *xmpTagName, const QStringList& entriesToAdd,
+bool KExiv2::addToXmpTagStringBag(const char* xmpTagName, const QStringList& entriesToAdd,
                                      bool setProgramName) const
 {
 //#ifdef _XMP_SUPPORT_
@@ -691,8 +691,8 @@
     return false;
 }
 
-bool KExiv2::removeFromXmpTagStringBag(const char *xmpTagName, const QStringList& entriesToRemove,
-                                          bool setProgramName) const
+bool KExiv2::removeFromXmpTagStringBag(const char* xmpTagName, const QStringList& entriesToRemove,
+                                       bool setProgramName) const
 {
 //#ifdef _XMP_SUPPORT_
 
@@ -717,7 +717,7 @@
     return false;
 }
 
-QVariant KExiv2::getXmpTagVariant(const char *xmpTagName, bool rationalAsListOfInts, bool stringEscapeCR) const
+QVariant KExiv2::getXmpTagVariant(const char* xmpTagName, bool rationalAsListOfInts, bool stringEscapeCR) const
 {
 #ifdef _XMP_SUPPORT_
     try
@@ -812,7 +812,7 @@
             }
         }
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError(QString("Cannot find Xmp key '%1' into image using Exiv2 ")
                                     .arg(xmpTagName), e);
@@ -834,7 +834,7 @@
         Exiv2::XmpProperties::registerNs(ns.toAscii().constData(), prefix.toAscii().constData());
         return true;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         KExiv2Priv::printExiv2ExceptionError("Cannot register a new Xmp namespace using Exiv2 ", e);
     }
@@ -855,7 +855,7 @@
         Exiv2::XmpProperties::unregisterNs(ns.toAscii().constData());
         return true;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         KExiv2Priv::printExiv2ExceptionError("Cannot unregister a new Xmp namespace using Exiv2 ", e);
     }
@@ -865,7 +865,7 @@
     return false;
 }
 
-bool KExiv2::removeXmpTag(const char *xmpTagName, bool setProgramName) const
+bool KExiv2::removeXmpTag(const char* xmpTagName, bool setProgramName) const
 {
 #ifdef _XMP_SUPPORT_
 
@@ -882,7 +882,7 @@
             return true;
         }
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot remove Xmp tag using Exiv2 ", e);
     }
@@ -965,7 +965,7 @@
 #endif
         return tagsMap;
     }
-    catch( Exiv2::Error &e )
+    catch( Exiv2::Error& e )
     {
         d->printExiv2ExceptionError("Cannot get Xmp Tags list using Exiv2 ", e);
     }
diff -ru kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/msgtextedit.cpp kdegraphics/libs/libkexiv2/libkexiv2/msgtextedit.cpp
--- kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/msgtextedit.cpp	2009-12-05 00:08:59.000000000 +0100
+++ kdegraphics/libs/libkexiv2/libkexiv2/msgtextedit.cpp	2010-06-10 17:10:37.929054700 +0200
@@ -6,32 +6,30 @@
  * Date        : 2009-07-15
  * Description : a text edit widget with click message.
  *
- * Copyright (C) 2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2009-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
  * Public License as published by the Free Software Foundation;
  * either version 2, or (at your option)
  * any later version.
- *
+ * 
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- *
+ * 
  * ============================================================ */
 
-#include "msgtextedit.moc"
-
 // Qt includes.
 
 #include <QColor>
 #include <QPalette>
 #include <QPainter>
 
-// KDE includes.
+// Local includes.
 
-#include <kdebug.h>
+#include "msgtextedit.moc"
 
 namespace KExiv2Iface
 {
@@ -45,10 +43,9 @@
     QString message;
 };
 
-MsgTextEdit::MsgTextEdit(QWidget *parent)
-           : KTextEdit(parent)
+MsgTextEdit::MsgTextEdit(QWidget* parent)
+           : KTextEdit(parent), d(new MsgTextEditPriv)
 {
-    d = new MsgTextEditPriv;
 }
 
 MsgTextEdit::~MsgTextEdit()
@@ -88,19 +85,19 @@
     }
 }
 
-void MsgTextEdit::dropEvent(QDropEvent *e)
+void MsgTextEdit::dropEvent(QDropEvent* e)
 {
     viewport()->repaint();
     KTextEdit::dropEvent(e);
 }
 
-void MsgTextEdit::focusInEvent(QFocusEvent *e)
+void MsgTextEdit::focusInEvent(QFocusEvent* e)
 {
     viewport()->repaint();
     KTextEdit::focusInEvent(e);
 }
 
-void MsgTextEdit::focusOutEvent(QFocusEvent *e)
+void MsgTextEdit::focusOutEvent(QFocusEvent* e)
 {
     viewport()->repaint();
     KTextEdit::focusOutEvent(e);
diff -ru kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/msgtextedit.h kdegraphics/libs/libkexiv2/libkexiv2/msgtextedit.h
--- kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/msgtextedit.h	2009-07-28 21:44:28.000000000 +0200
+++ kdegraphics/libs/libkexiv2/libkexiv2/msgtextedit.h	2010-06-10 17:10:37.929054700 +0200
@@ -5,38 +5,39 @@
  *
  * Date        : 2009-07-15
  * Description : a text edit widget with click message.
- * 
- * Copyright (C) 2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ *
+ * Copyright (C) 2009-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
  * Public License as published by the Free Software Foundation;
  * either version 2, or (at your option)
  * any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * ============================================================ */
 
 #ifndef MSGTEXTEDIT_H
 #define MSGTEXTEDIT_H
 
-// Qt includes.
+// Qt includes
 
 #include <QWidget>
 #include <QString>
 
-// KDE includes.
+// KDE includes
 
 #include <ktextedit.h>
 
-// Local includes
+// Local includes.
 
 #include "libkexiv2_export.h"
 
+
 namespace KExiv2Iface
 {
 
@@ -48,7 +49,7 @@
 
 public:
 
-    MsgTextEdit(QWidget *parent);
+    MsgTextEdit(QWidget* parent);
     ~MsgTextEdit();
 
     void    setClickMessage(const QString& msg);
@@ -65,7 +66,7 @@
 
 private:
 
-    MsgTextEditPriv* d;
+    MsgTextEditPriv* const d;
 };
 
 }  // namespace KExiv2Iface
diff -ru kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/rotationmatrix.cpp kdegraphics/libs/libkexiv2/libkexiv2/rotationmatrix.cpp
--- kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/rotationmatrix.cpp	2009-08-05 11:55:58.000000000 +0200
+++ kdegraphics/libs/libkexiv2/libkexiv2/rotationmatrix.cpp	2010-06-10 17:10:37.932376721 +0200
@@ -6,8 +6,8 @@
  * Date        : 2009-08-03
  * Description : Tools for combining rotation operations
  *
- * Copyright (C) 2004-2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
- * Copyright (C) 2006-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2004-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2006-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
@@ -21,8 +21,6 @@
  *
  * ============================================================ */
 
-// Qt includes
-
 // KDE includes
 
 #include <kdebug.h>
@@ -64,7 +62,7 @@
    matrices defined below.
    (I did not proof that mathematically, but empirically)
 
-   static const RotationMatrix identity;                   //( 1,  0,  0,  1)
+   static const RotationMatrix identity;               //( 1,  0,  0,  1)
    static const RotationMatrix rotate90;               //( 0, -1,  1,  0)
    static const RotationMatrix rotate180;              //(-1,  0,  0, -1)
    static const RotationMatrix rotate270;              //( 0,  1, -1,  0)
@@ -77,6 +75,7 @@
 
 namespace Matrix
 {
+
 static const RotationMatrix identity               ( 1,  0,  0,  1);
 static const RotationMatrix rotate90               ( 0, -1,  1,  0);
 static const RotationMatrix rotate180              (-1,  0,  0, -1);
@@ -133,7 +132,7 @@
 }
 
 
-}
+} // namespace Matrix
 
 RotationMatrix::RotationMatrix()
 {
@@ -168,14 +167,14 @@
     return *this == Matrix::identity;
 }
 
-RotationMatrix &RotationMatrix::operator*=(const RotationMatrix &ma)
+RotationMatrix& RotationMatrix::operator*=(const RotationMatrix& ma)
 {
     set( ma.m[0][0]*m[0][0] + ma.m[0][1]*m[1][0],  ma.m[0][0]*m[0][1] + ma.m[0][1]*m[1][1],
          ma.m[1][0]*m[0][0] + ma.m[1][1]*m[1][0],  ma.m[1][0]*m[0][1] + ma.m[1][1]*m[1][1] );
          return *this;
 }
 
-bool RotationMatrix::operator==(const RotationMatrix &ma) const
+bool RotationMatrix::operator==(const RotationMatrix& ma) const
 {
     return m[0][0]==ma.m[0][0] &&
     m[0][1]==ma.m[0][1] &&
@@ -183,24 +182,24 @@
     m[1][1]==ma.m[1][1];
 }
 
-bool RotationMatrix::operator!=(const RotationMatrix &ma) const
+bool RotationMatrix::operator!=(const RotationMatrix& ma) const
 {
     return !(*this==ma);
 }
 
-RotationMatrix &RotationMatrix::operator*=(TransformationAction action)
+RotationMatrix& RotationMatrix::operator*=(TransformationAction action)
 {
     return (*this *= Matrix::matrix(action));
 }
 
-RotationMatrix &RotationMatrix::operator*=(QList<TransformationAction> actions)
+RotationMatrix& RotationMatrix::operator*=(QList<TransformationAction> actions)
 {
     foreach (TransformationAction action, actions)
         *this *= Matrix::matrix(action);
     return *this;
 }
 
-RotationMatrix &RotationMatrix::operator*=(KExiv2::ImageOrientation exifOrientation)
+RotationMatrix& RotationMatrix::operator*=(KExiv2::ImageOrientation exifOrientation)
 {
     return (*this *= Matrix::matrix(exifOrientation));
 }
diff -ru kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/rotationmatrix.h kdegraphics/libs/libkexiv2/libkexiv2/rotationmatrix.h
--- kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/rotationmatrix.h	2009-08-05 11:55:58.000000000 +0200
+++ kdegraphics/libs/libkexiv2/libkexiv2/rotationmatrix.h	2010-06-10 17:10:37.935709576 +0200
@@ -6,8 +6,8 @@
  * Date        : 2009-08-03
  * Description : Tools for combining rotation operations
  *
- * Copyright (C) 2004-2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
- * Copyright (C) 2006-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2004-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2006-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
@@ -44,12 +44,12 @@
      */
     enum TransformationAction
     {
-        NoTransformation = 0,/// no transformation
-        FlipHorizontal = 1,  /// horizontal flip
-        FlipVertical = 2,    /// vertical flip
-        Rotate90 = 5,        /// 90-degree clockwise rotation
-        Rotate180 = 6,       /// 180-degree rotation
-        Rotate270 = 7        /// 270-degree clockwise (or 90 ccw)
+        NoTransformation = 0, /// no transformation
+        FlipHorizontal   = 1, /// horizontal flip
+        FlipVertical     = 2, /// vertical flip
+        Rotate90         = 5, /// 90-degree clockwise rotation
+        Rotate180        = 6, /// 180-degree rotation
+        Rotate270        = 7  /// 270-degree clockwise (or 90 ccw)
     };
 
     /// Constructs the identity matrix (the matrix describing no transformation)
@@ -57,24 +57,24 @@
     /// Returns the matrix corresponding to the given TransformationAction
     RotationMatrix(TransformationAction action);
     /// Returns the matrix corresponding to the given TransformationAction
-    RotationMatrix(KExiv2Iface::KExiv2::ImageOrientation exifOrientation);
+    RotationMatrix(KExiv2::ImageOrientation exifOrientation);
 
-    bool operator==(const RotationMatrix &ma) const;
-    bool operator!=(const RotationMatrix &ma) const;
+    bool operator==(const RotationMatrix& ma) const;
+    bool operator!=(const RotationMatrix& ma) const;
 
     /// Returns true of this matrix describes no transformation (is the identity matrix)
     bool isNoTransform() const;
 
-    RotationMatrix &operator*=(const RotationMatrix &ma);
+    RotationMatrix& operator*=(const RotationMatrix& ma);
 
     /// Applies the given transform to this matrix
-    RotationMatrix &operator*=(TransformationAction action);
+    RotationMatrix& operator*=(TransformationAction action);
 
     /// Applies the given transform actions to this matrix
-    RotationMatrix &operator*=(QList<TransformationAction> actions);
+    RotationMatrix& operator*=(QList<TransformationAction> actions);
 
     /// Applies the given Exif orientation flag to this matrix
-    RotationMatrix &operator*=(KExiv2Iface::KExiv2::ImageOrientation exifOrientation);
+    RotationMatrix& operator*=(KExiv2::ImageOrientation exifOrientation);
 
     /** Returns the actions described by this matrix. The order matters.
      *  Not all possible matrices are supported, but all those that can be combined
@@ -85,7 +85,7 @@
     /** Returns the Exif orienation flag describing this matrix.
      *  Returns ORIENTATION_UNSPECIFIED if no flag matches this matrix.
      */
-    KExiv2Iface::KExiv2::ImageOrientation exifOrientation() const;
+    KExiv2::ImageOrientation exifOrientation() const;
 
     RotationMatrix(int m11, int m12, int m21, int m22);
 
diff -ru kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/subjectwidget.cpp kdegraphics/libs/libkexiv2/libkexiv2/subjectwidget.cpp
--- kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/subjectwidget.cpp	2009-12-05 00:08:59.000000000 +0100
+++ kdegraphics/libs/libkexiv2/libkexiv2/subjectwidget.cpp	2010-06-10 17:10:37.929054700 +0200
@@ -6,7 +6,7 @@
  * Date        : 2006-10-15
  * Description : IPTC subjects editor.
  *
- * Copyright (C) 2006-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2006-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
  * Copyright (C) 2009      by Andi Clemens <andi dot clemens at gmx dot net>
  *
  * This program is free software; you can redistribute it
@@ -38,7 +38,6 @@
 // KDE includes
 
 #include <kcombobox.h>
-#include <kdebug.h>
 #include <kdialog.h>
 #include <kglobal.h>
 #include <khbox.h>
@@ -47,6 +46,7 @@
 #include <klistwidget.h>
 #include <klocale.h>
 #include <kstandarddirs.h>
+#include <kdebug.h>
 
 namespace KExiv2Iface
 {
@@ -79,32 +79,32 @@
         optionsBox       = 0;
     }
 
-    typedef QMap<QString, SubjectData>  SubjectCodesMap;
+    typedef QMap<QString, SubjectData> SubjectCodesMap;
 
-    SubjectCodesMap                     subMap;
+    SubjectCodesMap                    subMap;
 
-    QStringList                         subjectsList;
+    QStringList                        subjectsList;
 
-    QWidget                            *optionsBox;
+    QWidget*                           optionsBox;
 
-    QPushButton                        *addSubjectButton;
-    QPushButton                        *delSubjectButton;
-    QPushButton                        *repSubjectButton;
+    QPushButton*                       addSubjectButton;
+    QPushButton*                       delSubjectButton;
+    QPushButton*                       repSubjectButton;
 
-    QLabel                             *iprLabel;
-    QLabel                             *refLabel;
-    QLabel                             *nameLabel;
-    QLabel                             *matterLabel;
-    QLabel                             *detailLabel;
+    QLabel*                            iprLabel;
+    QLabel*                            refLabel;
+    QLabel*                            nameLabel;
+    QLabel*                            matterLabel;
+    QLabel*                            detailLabel;
 
-    QButtonGroup                       *btnGroup;
+    QButtonGroup*                      btnGroup;
 
-    QRadioButton                       *stdBtn;
-    QRadioButton                       *customBtn;
+    QRadioButton*                      stdBtn;
+    QRadioButton*                      customBtn;
 
-    KComboBox                          *refCB;
+    KComboBox*                         refCB;
 
-    KListWidget                        *subjectsBox;
+    KListWidget*                       subjectsBox;
 };
 
 // --------------------------------------------------------------------------------
@@ -120,7 +120,7 @@
     QString path = KGlobal::dirs()->findResource("iptcschema", "topicset.iptc-subjectcode.xml");
 
     if (!loadSubjectCodesFromXML(KUrl(path)))
-        kDebug(51001) << "Cannot load IPTC/NAA subject codes XML database";
+        kDebug() << "Cannot load IPTC/NAA subject codes XML database";
 
     // --------------------------------------------------------
 
@@ -130,18 +130,22 @@
 
     // --------------------------------------------------------
 
+    m_subjectsCheck  = new QCheckBox(i18n("Use structured definition of the subject matter:"), this);
     d->optionsBox    = new QWidget;
     d->btnGroup      = new QButtonGroup(this);
     d->stdBtn        = new QRadioButton;
     d->customBtn     = new QRadioButton;
     d->refCB         = new KComboBox;
-    QLabel *codeLink = new QLabel(i18n("Use standard "
+    QLabel* codeLink = new QLabel(i18n("Use standard "
                                        "<b><a href='http://www.iptc.org/NewsCodes'>"
                                        "reference code</a></b>"));
     codeLink->setOpenExternalLinks(true);
     codeLink->setWordWrap(false);
 
-    QLabel *customLabel = new QLabel(i18n("Use custom definition"));
+    // By default, check box is not visible. (digiKam do not use it, kipi-plugins yes).
+    m_subjectsCheck->setVisible(false);
+
+    QLabel* customLabel = new QLabel(i18n("Use custom definition"));
 
     d->btnGroup->addButton(d->stdBtn,    SubjectWidgetPriv::STANDARD);
     d->btnGroup->addButton(d->customBtn, SubjectWidgetPriv::CUSTOM);
@@ -219,7 +223,7 @@
 
     // --------------------------------------------------------
 
-    QGridLayout *optionsBoxLayout = new QGridLayout;
+    QGridLayout* optionsBoxLayout = new QGridLayout;
     optionsBoxLayout->addWidget(d->stdBtn,      0, 0, 1, 1);
     optionsBoxLayout->addWidget(codeLink,       0, 1, 1, 2);
     optionsBoxLayout->addWidget(d->refCB,       0, 3, 1, 1);
@@ -242,15 +246,16 @@
 
     // --------------------------------------------------------
 
-    QGridLayout *mainLayout = new QGridLayout;
+    QGridLayout* mainLayout = new QGridLayout;
     mainLayout->setAlignment( Qt::AlignTop );
-    mainLayout->addWidget(d->optionsBox,       0, 0, 1, 4);
-    mainLayout->addWidget(d->subjectsBox,      1, 0, 5, 3);
-    mainLayout->addWidget(d->addSubjectButton, 1, 3, 1, 1);
-    mainLayout->addWidget(d->delSubjectButton, 2, 3, 1, 1);
-    mainLayout->addWidget(d->repSubjectButton, 3, 3, 1, 1);
-    mainLayout->addWidget(m_note,              4, 3, 1, 1);
-    mainLayout->setRowStretch(5, 10);
+    mainLayout->addWidget(m_subjectsCheck,     0, 0, 1, 4);
+    mainLayout->addWidget(d->optionsBox,       1, 0, 1, 4);
+    mainLayout->addWidget(d->subjectsBox,      2, 0, 5, 3);
+    mainLayout->addWidget(d->addSubjectButton, 2, 3, 1, 1);
+    mainLayout->addWidget(d->delSubjectButton, 3, 3, 1, 1);
+    mainLayout->addWidget(d->repSubjectButton, 4, 3, 1, 1);
+    mainLayout->addWidget(m_note,              5, 3, 1, 1);
+    mainLayout->setRowStretch(6, 10);
     mainLayout->setColumnStretch(2, 1);
     mainLayout->setMargin(0);
     mainLayout->setSpacing(KDialog::spacingHint());
@@ -278,6 +283,14 @@
 
     // --------------------------------------------------------
 
+    connect(m_subjectsCheck, SIGNAL(toggled(bool)),
+            this, SLOT(slotSubjectsToggled(bool)));
+
+    // --------------------------------------------------------
+
+    connect(m_subjectsCheck, SIGNAL(toggled(bool)),
+            this, SIGNAL(signalModified()));
+
     connect(d->addSubjectButton, SIGNAL(clicked()),
             this, SIGNAL(signalModified()));
 
@@ -297,6 +310,16 @@
     delete d;
 }
 
+void SubjectWidget::slotSubjectsToggled(bool b)
+{
+    d->optionsBox->setEnabled(b);
+    d->subjectsBox->setEnabled(b);
+    d->addSubjectButton->setEnabled(b);
+    d->delSubjectButton->setEnabled(b);
+    d->repSubjectButton->setEnabled(b);
+    slotEditOptionChanged(d->btnGroup->id(d->btnGroup->checkedButton()));
+}
+
 void SubjectWidget::slotEditOptionChanged(int b)
 {
     if (b == SubjectWidgetPriv::CUSTOM)
@@ -358,7 +381,7 @@
 
 void SubjectWidget::slotDelSubject()
 {
-    QListWidgetItem *item = d->subjectsBox->currentItem();
+    QListWidgetItem* item = d->subjectsBox->currentItem();
     if (!item) return;
     d->subjectsBox->takeItem(d->subjectsBox->row(item));
     delete item;
@@ -408,7 +431,7 @@
     bool found = false;
     for (int i = 0 ; i < d->subjectsBox->count(); i++)
     {
-        QListWidgetItem *item = d->subjectsBox->item(i);
+        QListWidgetItem* item = d->subjectsBox->item(i);
         if (newSubject == item->text())
         {
             found = true;
@@ -499,7 +522,7 @@
          it != d->subMap.end(); ++it)
     {
         QString name, keyPrefix;
-        if (it.key().endsWith("00000"))
+        if (it.key().endsWith(QLatin1String("00000")))
         {
             keyPrefix = it.key().left(3);
             name      = it.value().name;
@@ -508,7 +531,7 @@
                 it2 != d->subMap.end(); ++it2)
             {
                 if (it2.key().startsWith(keyPrefix) &&
-                    !it2.key().endsWith("00000"))
+                    !it2.key().endsWith(QLatin1String("00000")))
                 {
                     it2.value().name = name;
                 }
@@ -522,7 +545,7 @@
          it != d->subMap.end(); ++it)
     {
         QString matter, keyPrefix;
-        if (it.key().endsWith("000"))
+        if (it.key().endsWith(QLatin1String("000")))
         {
             keyPrefix = it.key().left(5);
             matter    = it.value().matter;
@@ -531,7 +554,7 @@
                 it2 != d->subMap.end(); ++it2)
             {
                 if (it2.key().startsWith(keyPrefix) &&
-                    !it2.key().endsWith("000"))
+                    !it2.key().endsWith(QLatin1String("000")))
                 {
                     it2.value().matter = matter;
                 }
@@ -542,16 +565,21 @@
     return true;
 }
 
-void SubjectWidget::setSubjectList(const QStringList& list)
+void SubjectWidget::setSubjectsList(const QStringList& list)
 {
     d->subjectsList = list;
 
     blockSignals(true);
     d->subjectsBox->clear();
+    m_subjectsCheck->setChecked(false);
     if (!d->subjectsList.isEmpty())
+    {
         d->subjectsBox->insertItems(0, d->subjectsList);
+        m_subjectsCheck->setChecked(true);
+    }
 
     blockSignals(false);
+    slotSubjectsToggled(m_subjectsCheck->isChecked());
 }
 
 QStringList SubjectWidget::subjectsList() const
@@ -560,7 +588,7 @@
 
     for (int i = 0 ; i < d->subjectsBox->count(); i++)
     {
-        QListWidgetItem *item = d->subjectsBox->item(i);
+        QListWidgetItem* item = d->subjectsBox->item(i);
         newSubjects.append(item->text());
     }
 
diff -ru kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/subjectwidget.h kdegraphics/libs/libkexiv2/libkexiv2/subjectwidget.h
--- kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/subjectwidget.h	2009-07-28 21:44:28.000000000 +0200
+++ kdegraphics/libs/libkexiv2/libkexiv2/subjectwidget.h	2010-06-10 17:10:37.929054700 +0200
@@ -6,7 +6,7 @@
  * Date        : 2006-10-15
  * Description : IPTC subjects editor.
  *
- * Copyright (C) 2006-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2006-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
  * Copyright (C) 2009      by Andi Clemens <andi dot clemens at gmx dot net>
  *
  * This program is free software; you can redistribute it
@@ -31,20 +31,18 @@
 #include <QtCore/QMap>
 #include <QtCore/QStringList>
 #include <QtGui/QWidget>
+#include <QtGui/QCheckBox>
+#include <QtGui/QLabel>
 
 // KDE includes
 
 #include <kurl.h>
+#include <klineedit.h>
 
-// Local includes
+// Local includes.
 
 #include "libkexiv2_export.h"
 
-class QCheckBox;
-class QLabel;
-
-class KLineEdit;
-
 namespace KExiv2Iface
 {
 
@@ -77,7 +75,7 @@
     SubjectWidget(QWidget* parent);
     ~SubjectWidget();
 
-    void setSubjectList(const QStringList& list);
+    void setSubjectsList(const QStringList& list);
     QStringList subjectsList() const;
 
 Q_SIGNALS:
@@ -86,6 +84,7 @@
 
 protected Q_SLOTS:
 
+    virtual void slotSubjectsToggled(bool);
     virtual void slotRefChanged();
     virtual void slotEditOptionChanged(int);
     virtual void slotSubjectSelectionChanged();
@@ -100,13 +99,15 @@
 
 protected:
 
-    QLabel    *m_note;
+    QLabel*    m_note;
+
+    QCheckBox* m_subjectsCheck;
 
-    KLineEdit *m_iprEdit;
-    KLineEdit *m_refEdit;
-    KLineEdit *m_nameEdit;
-    KLineEdit *m_matterEdit;
-    KLineEdit *m_detailEdit;
+    KLineEdit* m_iprEdit;
+    KLineEdit* m_refEdit;
+    KLineEdit* m_nameEdit;
+    KLineEdit* m_matterEdit;
+    KLineEdit* m_detailEdit;
 
 private:
 
diff -ru kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/version.h.cmake kdegraphics/libs/libkexiv2/libkexiv2/version.h.cmake
--- kdegraphics-4.4.4/libs/libkexiv2/libkexiv2/version.h.cmake	2009-04-28 15:45:57.000000000 +0200
+++ kdegraphics/libs/libkexiv2/libkexiv2/version.h.cmake	2010-06-10 17:10:37.929054700 +0200
@@ -6,7 +6,7 @@
  * Date        : 2007-02-06
  * Description : Exiv2 library interface for KDE
  *
- * Copyright (C) 2007-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2007-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
diff -ru kdegraphics-4.4.4/libs/libkexiv2/test/setiptcpreview.cpp kdegraphics/libs/libkexiv2/test/setiptcpreview.cpp
--- kdegraphics-4.4.4/libs/libkexiv2/test/setiptcpreview.cpp	2009-02-04 19:17:36.000000000 +0100
+++ kdegraphics/libs/libkexiv2/test/setiptcpreview.cpp	2010-06-10 17:10:38.253753252 +0200
@@ -31,15 +31,9 @@
 
 #include "kdeversion.h"
 
-#if KDE_IS_VERSION(4,0,0)
 #include "qdebug.h"
 #define PRINT_DEBUG qDebug()
 #define ENDL
-#else
-#include "kdebug.h"
-#define PRINT_DEBUG kDebug()
-#define ENDL << endl
-#endif
 
 // Local includes.
 
diff -ru kdegraphics-4.4.4/libs/libkdcraw/CMakeLists.txt kdegraphics/libs/libkdcraw/CMakeLists.txt
--- kdegraphics-4.4.4/libs/libkdcraw/CMakeLists.txt	2010-01-31 20:32:18.000000000 +0100
+++ kdegraphics/libs/libkdcraw/CMakeLists.txt	2010-06-10 17:10:42.372822284 +0200
@@ -24,11 +24,12 @@
 # 0.3.0 => 6.0.0  (released with KDE 4.1.2)
 # 0.4.0 => 7.0.0  (using libRaw-Released with KDE 4.2.0)
 # 0.5.0 => 7.1.0  (Released with KDE 4.3.0)
-# 1.0.0 => 8.0.0  (Released with KDE 4.4.0
+# 1.0.0 => 8.0.0  (Released with KDE 4.4.0)
+# 1.1.0 => 8.1.0  (Released with KDE 4.4.2)
 
 # Library API version
 SET(DCRAW_LIB_MAJOR_VERSION "1")
-SET(DCRAW_LIB_MINOR_VERSION "0")
+SET(DCRAW_LIB_MINOR_VERSION "1")
 SET(DCRAW_LIB_PATCH_VERSION "0")
 
 # Suffix to add at end of version string. Usual values are:
@@ -43,7 +44,7 @@
 # Library ABI version used by linker.
 # For details : http://www.gnu.org/software/libtool/manual/libtool.html#Updating-version-info
 SET(DCRAW_LIB_SO_CUR_VERSION "8")
-SET(DCRAW_LIB_SO_REV_VERSION "0")
+SET(DCRAW_LIB_SO_REV_VERSION "1")
 SET(DCRAW_LIB_SO_AGE_VERSION "0")
 
 # ==================================================================================================
@@ -76,13 +77,13 @@
 
 IF(VERSION_CMAKE AND NOT MSVC)
     MACRO_OPTIONAL_FIND_PACKAGE(OpenMP)
-    IF(OPENMP_FOUND)
+    IF(OPENMP_FOUND AND NOT MSVC)
         MESSAGE(STATUS "OpenMP detected: LibRaw will be compiled with parallelized code.")
         SET(USE_OPENMP TRUE)
-    ELSEIF(OPENMP_FOUND)
+    ELSEIF(OPENMP_FOUND AND NOT MSVC)
         MESSAGE(STATUS "OpenMP not detected: LibRaw will not be compiled with parallelized code.")
         SET(USE_OPENMP FALSE)
-    ENDIF(OPENMP_FOUND)
+    ENDIF(OPENMP_FOUND AND NOT MSVC)
 ELSE(VERSION_CMAKE)
     MESSAGE(STATUS "CMake version too old: cannot detected OpenMP: LibRaw will not be compiled with parallelized code.")
     SET(USE_OPENMP FALSE)
@@ -119,7 +120,6 @@
 
 SET(libraw_LIB_SRCS ${CMAKE_CURRENT_SOURCE_DIR}/libraw/internal/dcraw_common.cpp
                     ${CMAKE_CURRENT_SOURCE_DIR}/libraw/internal/dcraw_fileio.cpp
-                    ${CMAKE_CURRENT_SOURCE_DIR}/libraw/internal/foveon.cpp
                     ${CMAKE_CURRENT_SOURCE_DIR}/libraw/src/libraw_cxx.cpp
                     ${CMAKE_CURRENT_SOURCE_DIR}/libraw/src/libraw_c_api.cpp
    )
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libkdcraw/dcrawinfocontainer.cpp kdegraphics/libs/libkdcraw/libkdcraw/dcrawinfocontainer.cpp
--- kdegraphics-4.4.4/libs/libkdcraw/libkdcraw/dcrawinfocontainer.cpp	2009-07-06 12:42:45.000000000 +0200
+++ kdegraphics/libs/libkdcraw/libkdcraw/dcrawinfocontainer.cpp	2010-06-10 17:10:41.385719040 +0200
@@ -49,6 +49,8 @@
     whitePoint        = 0;
     topMargin         = 0;
     leftMargin        = 0;
+    rightMargin       = 0;
+    bottomMargin      = 0;
     orientation       = ORIENTATION_NONE;
 
     for (int x=0 ; x<3 ; x++)
@@ -71,6 +73,7 @@
     if (make.isEmpty()                  &&
         model.isEmpty()                 &&
         filterPattern.isEmpty()         &&
+        colorKeys.isEmpty()             &&
         DNGVersion.isEmpty()            &&
         exposureTime     == -1.0        &&
         aperture         == -1.0        &&
@@ -83,6 +86,8 @@
         whitePoint       == 0           &&
         topMargin        == 0           &&
         leftMargin       == 0           &&
+        rightMargin      == 0           &&
+        bottomMargin     == 0           &&
         !dateTime.isValid()             &&
         !imageSize.isValid()            &&
         !fullSize.isValid()             &&
@@ -153,6 +158,8 @@
     dbg.nospace() << "DcrawInfoContainer::blackPoint: "       << c.blackPoint << ", ";
     dbg.nospace() << "DcrawInfoContainer::topMargin: "        << c.topMargin << ", ";
     dbg.nospace() << "DcrawInfoContainer::leftMargin: "       << c.leftMargin << ", ";
+    dbg.nospace() << "DcrawInfoContainer::rightMargin: "      << c.rightMargin << ", ";
+    dbg.nospace() << "DcrawInfoContainer::bottomMargin: "     << c.bottomMargin << ", ";
     dbg.nospace() << "DcrawInfoContainer::orientation: "      << c.orientation;
     return dbg.space();
 }
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libkdcraw/dcrawinfocontainer.h kdegraphics/libs/libkdcraw/libkdcraw/dcrawinfocontainer.h
--- kdegraphics-4.4.4/libs/libkdcraw/libkdcraw/dcrawinfocontainer.h	2009-07-06 12:42:45.000000000 +0200
+++ kdegraphics/libs/libkdcraw/libkdcraw/dcrawinfocontainer.h	2010-06-10 17:10:41.385719040 +0200
@@ -46,10 +46,11 @@
      */
     enum ImageOrientation
     {
-        ORIENTATION_NONE  = 0,
-        ORIENTATION_180   = 3,
-        ORIENTATION_90CCW = 5,
-        ORIENTATION_90CW  = 6
+        ORIENTATION_NONE        = 0,
+        ORIENTATION_180         = 3,
+        ORIENTATION_Mirror90CCW = 4,
+        ORIENTATION_90CCW       = 5,
+        ORIENTATION_90CW        = 6
     };
 
 public:
@@ -88,6 +89,12 @@
     /** Left margin of raw image. */
     unsigned int     leftMargin;
 
+    /** Right margin of raw image. */
+    unsigned int     rightMargin;
+
+    /** Bottom margin of raw image. */
+    unsigned int     bottomMargin;
+
     /** The raw image orientation */
     ImageOrientation orientation;
 
@@ -111,7 +118,10 @@
     /** Camera Color Matrix */
     float            cameraColorMatrix1[3][4];
     float            cameraColorMatrix2[3][4];
-    float            cameraXYZMatrix[3][4];
+    float            cameraXYZMatrix[4][3];
+
+    /** The used Color Keys */
+    QString          colorKeys;
 
     /** The camera maker. */
     QString          make;
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libkdcraw/dcrawsettingswidget.cpp kdegraphics/libs/libkdcraw/libkdcraw/dcrawsettingswidget.cpp
--- kdegraphics-4.4.4/libs/libkdcraw/libkdcraw/dcrawsettingswidget.cpp	2009-12-05 00:08:59.000000000 +0100
+++ kdegraphics/libs/libkdcraw/libkdcraw/dcrawsettingswidget.cpp	2010-06-10 17:10:41.385719040 +0200
@@ -6,8 +6,8 @@
  * Date        : 2006-09-13
  * Description : LibRaw settings widgets
  *
- * Copyright (C) 2006-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
- * Copyright (C) 2006-2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2006-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2006-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
  * Copyright (C) 2007-2008 by Guillaume Castagnino <casta at xwing dot info>
  *
  * This program is free software; you can redistribute it
@@ -24,7 +24,7 @@
 
 #include "dcrawsettingswidget.moc"
 
-// Qt includes.
+// Qt includes
 
 #include <QCheckBox>
 #include <QLabel>
@@ -32,7 +32,7 @@
 #include <QWhatsThis>
 #include <QToolTip>
 
-// KDE includes.
+// KDE includes
 
 #include <kapplication.h>
 #include <kdialog.h>
@@ -40,7 +40,7 @@
 #include <kurllabel.h>
 #include <ktoolinvocation.h>
 
-// Local includes.
+// Local includes
 
 #include "kdcraw.h"
 #include "rnuminput.h"
@@ -98,59 +98,61 @@
         outIccUrlEdit                  = 0;
         inputColorSpaceLabel           = 0;
         inputColorSpaceComboBox        = 0;
+        fixColorsHighlights            = 0;
     }
 
-    QWidget         *demosaicingSettings;
-    QWidget         *whiteBalanceSettings;
-    QWidget         *correctionsSettings;
-    QWidget         *colormanSettings;
-
-    QLabel          *whiteBalanceLabel;
-    QLabel          *customWhiteBalanceLabel;
-    QLabel          *customWhiteBalanceGreenLabel;
-    QLabel          *brightnessLabel;
-    QLabel          *RAWQualityLabel;
-    QLabel          *NRThresholdLabel;
-    QLabel          *caRedMultLabel;
-    QLabel          *caBlueMultLabel;
-    QLabel          *unclipColorLabel;
-    QLabel          *reconstructLabel;
-    QLabel          *inputColorSpaceLabel;
-    QLabel          *outputColorSpaceLabel;
-    QLabel          *medianFilterPassesLabel;
-
-    QCheckBox       *blackPointCheckBox;
-    QCheckBox       *whitePointCheckBox;
-    QCheckBox       *sixteenBitsImage;
-    QCheckBox       *autoBrightnessBox;
-    QCheckBox       *fourColorCheckBox;
-    QCheckBox       *dontStretchPixelsCheckBox;
-    QCheckBox       *enableNoiseReduction;
-    QCheckBox       *enableCACorrection;
-
-    KUrlRequester   *inIccUrlEdit;
-    KUrlRequester   *outIccUrlEdit;
-
-    RComboBox       *whiteBalanceComboBox;
-    RComboBox       *RAWQualityComboBox;
-    RComboBox       *unclipColorComboBox;
-    RComboBox       *inputColorSpaceComboBox;
-    RComboBox       *outputColorSpaceComboBox;
-
-    RIntNumInput    *customWhiteBalanceSpinBox;
-    RIntNumInput    *reconstructSpinBox;
-    RIntNumInput    *blackPointSpinBox;
-    RIntNumInput    *whitePointSpinBox;
-    RIntNumInput    *NRThresholdSpinBox;
-    RIntNumInput    *medianFilterPassesSpinBox;
-
-    RDoubleNumInput *customWhiteBalanceGreenSpinBox;
-    RDoubleNumInput *caRedMultSpinBox;
-    RDoubleNumInput *caBlueMultSpinBox;
-    RDoubleNumInput *brightnessSpinBox;
+    QWidget*         demosaicingSettings;
+    QWidget*         whiteBalanceSettings;
+    QWidget*         correctionsSettings;
+    QWidget*         colormanSettings;
+
+    QLabel*          whiteBalanceLabel;
+    QLabel*          customWhiteBalanceLabel;
+    QLabel*          customWhiteBalanceGreenLabel;
+    QLabel*          brightnessLabel;
+    QLabel*          RAWQualityLabel;
+    QLabel*          NRThresholdLabel;
+    QLabel*          caRedMultLabel;
+    QLabel*          caBlueMultLabel;
+    QLabel*          unclipColorLabel;
+    QLabel*          reconstructLabel;
+    QLabel*          inputColorSpaceLabel;
+    QLabel*          outputColorSpaceLabel;
+    QLabel*          medianFilterPassesLabel;
+
+    QCheckBox*       blackPointCheckBox;
+    QCheckBox*       whitePointCheckBox;
+    QCheckBox*       sixteenBitsImage;
+    QCheckBox*       autoBrightnessBox;
+    QCheckBox*       fourColorCheckBox;
+    QCheckBox*       dontStretchPixelsCheckBox;
+    QCheckBox*       enableNoiseReduction;
+    QCheckBox*       enableCACorrection;
+    QCheckBox*       fixColorsHighlights;
+
+    KUrlRequester*   inIccUrlEdit;
+    KUrlRequester*   outIccUrlEdit;
+
+    RComboBox*       whiteBalanceComboBox;
+    RComboBox*       RAWQualityComboBox;
+    RComboBox*       unclipColorComboBox;
+    RComboBox*       inputColorSpaceComboBox;
+    RComboBox*       outputColorSpaceComboBox;
+
+    RIntNumInput*    customWhiteBalanceSpinBox;
+    RIntNumInput*    reconstructSpinBox;
+    RIntNumInput*    blackPointSpinBox;
+    RIntNumInput*    whitePointSpinBox;
+    RIntNumInput*    NRThresholdSpinBox;
+    RIntNumInput*    medianFilterPassesSpinBox;
+
+    RDoubleNumInput* customWhiteBalanceGreenSpinBox;
+    RDoubleNumInput* caRedMultSpinBox;
+    RDoubleNumInput* caBlueMultSpinBox;
+    RDoubleNumInput* brightnessSpinBox;
 };
 
-DcrawSettingsWidget::DcrawSettingsWidget(QWidget *parent, int advSettings)
+DcrawSettingsWidget::DcrawSettingsWidget(QWidget* parent, int advSettings)
                    : RExpanderBox(parent), d(new DcrawSettingsWidgetPriv)
 {
     setup(advSettings);
@@ -328,6 +330,11 @@
                                              "Specify the reconstruct highlight level. "
                                              "Low values favor whites and high values favor colors."));
 
+    d->fixColorsHighlights = new QCheckBox(i18n("Correct false colors in highlights"), d->whiteBalanceSettings);
+    d->fixColorsHighlights->setWhatsThis(i18n("<p>If enabled, images with overblown channels are processed much "
+                                              "more accurately, without 'pink clouds' (and blue highlights under "
+                                              "tungsten lamps)."));
+
     d->autoBrightnessBox = new QCheckBox(i18n("Auto Brightness"), d->whiteBalanceSettings);
     d->autoBrightnessBox->setWhatsThis(i18n("<p>If disable, use a fixed white level "
                                             "and ignore the image histogram to adjust brightness."));
@@ -337,7 +344,7 @@
     d->brightnessSpinBox->setDecimals(2);
     d->brightnessSpinBox->setRange(0.0, 10.0, 0.01);
     d->brightnessSpinBox->setDefaultValue(1.0);
-    d->brightnessSpinBox->setWhatsThis(i18n("<p><b>Brighness</b><p>"
+    d->brightnessSpinBox->setWhatsThis(i18n("<p><b>Brightness</b><p>"
                                             "Specify the brightness level of output image."
                                             "The default value is 1.0 (works in 8-bit mode only).<p>"));
 
@@ -389,13 +396,14 @@
     whiteBalanceLayout->addWidget(d->unclipColorComboBox,            3, 1, 1, 2);
     whiteBalanceLayout->addWidget(d->reconstructLabel,               4, 0, 1, 1);
     whiteBalanceLayout->addWidget(d->reconstructSpinBox,             4, 1, 1, 2);
-    whiteBalanceLayout->addWidget(d->autoBrightnessBox,              5, 0, 1, 2);
-    whiteBalanceLayout->addWidget(d->brightnessLabel,                6, 0, 1, 1);
-    whiteBalanceLayout->addWidget(d->brightnessSpinBox,              6, 1, 1, 2);
-    whiteBalanceLayout->addWidget(d->blackPointCheckBox,             7, 0, 1, 1);
-    whiteBalanceLayout->addWidget(d->blackPointSpinBox,              7, 1, 1, 2);
-    whiteBalanceLayout->addWidget(d->whitePointCheckBox,             8, 0, 1, 1);
-    whiteBalanceLayout->addWidget(d->whitePointSpinBox,              8, 1, 1, 2);
+    whiteBalanceLayout->addWidget(d->fixColorsHighlights,            5, 0, 1, 2);
+    whiteBalanceLayout->addWidget(d->autoBrightnessBox,              6, 0, 1, 2);
+    whiteBalanceLayout->addWidget(d->brightnessLabel,                7, 0, 1, 1);
+    whiteBalanceLayout->addWidget(d->brightnessSpinBox,              7, 1, 1, 2);
+    whiteBalanceLayout->addWidget(d->blackPointCheckBox,             8, 0, 1, 1);
+    whiteBalanceLayout->addWidget(d->blackPointSpinBox,              8, 1, 1, 2);
+    whiteBalanceLayout->addWidget(d->whitePointCheckBox,             9, 0, 1, 1);
+    whiteBalanceLayout->addWidget(d->whitePointSpinBox,              9, 1, 1, 2);
     whiteBalanceLayout->setSpacing(KDialog::spacingHint());
     whiteBalanceLayout->setMargin(KDialog::spacingHint());
 
@@ -587,6 +595,9 @@
     connect(d->sixteenBitsImage, SIGNAL(toggled(bool)),
             this, SIGNAL(signalSettingsChanged()));
 
+    connect(d->fixColorsHighlights, SIGNAL(toggled(bool)),
+            this, SIGNAL(signalSettingsChanged()));
+
     connect(d->autoBrightnessBox, SIGNAL(toggled(bool)),
             this, SIGNAL(signalSettingsChanged()));
 
@@ -665,26 +676,12 @@
 
 void DcrawSettingsWidget::setDefaultSettings()
 {
-    setWhiteBalance((RawDecodingSettings::WhiteBalance)d->whiteBalanceComboBox->defaultIndex());
-    setCustomWhiteBalance(d->customWhiteBalanceSpinBox->defaultValue());
-    setCustomWhiteBalanceGreen(d->customWhiteBalanceGreenSpinBox->defaultValue());
-    setFourColor(false);
-    setUnclipColor(d->unclipColorComboBox->defaultIndex());
-    setDontStretchPixels(false);
-    setNoiseReduction(false);
-    setUseCACorrection(false);
-    setcaRedMultiplier(d->caRedMultSpinBox->defaultValue());
-    setcaBlueMultiplier(d->caBlueMultSpinBox->defaultValue());
-    setBrightness(d->brightnessSpinBox->defaultValue());
-    setUseBlackPoint(false);
-    setUseWhitePoint(false);
-    setBlackPoint(d->blackPointSpinBox->defaultValue());
-    setWhitePoint(d->whitePointSpinBox->defaultValue());
-    setNRThreshold(d->NRThresholdSpinBox->defaultValue());
-    setQuality((RawDecodingSettings::DecodingQuality)d->RAWQualityComboBox->defaultIndex());
-    setInputColorSpace((RawDecodingSettings::InputColorSpace)d->inputColorSpaceComboBox->defaultIndex());
-    setOutputColorSpace((RawDecodingSettings::OutputColorSpace)d->outputColorSpaceComboBox->defaultIndex());
-    setMedianFilterPasses(d->medianFilterPassesSpinBox->defaultValue());
+    resetToDefault();
+}
+
+void DcrawSettingsWidget::resetToDefault()
+{
+    setSettings(RawDecodingSettings());
 }
 
 void DcrawSettingsWidget::slotsixteenBitsImageToggled(bool b)
@@ -749,8 +746,6 @@
     d->outIccUrlEdit->setEnabled(item == RawDecodingSettings::CUSTOMOUTPUTCS);
 }
 
-// ---------------------------------------------------------------
-
 void DcrawSettingsWidget::setEnabledBrightnessSettings(bool b)
 {
     d->brightnessLabel->setEnabled(b);
@@ -762,7 +757,188 @@
     return d->brightnessSpinBox->isEnabled();
 }
 
-// ---------------------------------------------------------------
+void DcrawSettingsWidget::setSettings(const RawDecodingSettings& settings)
+{
+    d->sixteenBitsImage->setChecked(settings.sixteenBitsImage);
+
+    switch(settings.whiteBalance)
+    {
+        case RawDecodingSettings::CAMERA:
+            d->whiteBalanceComboBox->setCurrentIndex(1);
+            break;
+        case RawDecodingSettings::AUTO:
+            d->whiteBalanceComboBox->setCurrentIndex(2);
+            break;
+        case RawDecodingSettings::CUSTOM:
+            d->whiteBalanceComboBox->setCurrentIndex(3);
+            break;
+        default:
+            d->whiteBalanceComboBox->setCurrentIndex(0);
+            break;
+    }
+    slotWhiteBalanceToggled(d->whiteBalanceComboBox->currentIndex());
+
+    d->medianFilterPassesSpinBox->setValue(settings.medianFilterPasses);
+    d->customWhiteBalanceSpinBox->setValue(settings.customWhiteBalance);
+    d->customWhiteBalanceGreenSpinBox->setValue(settings.customWhiteBalanceGreen);
+    d->fourColorCheckBox->setChecked(settings.RGBInterpolate4Colors);
+    d->autoBrightnessBox->setChecked(settings.autoBrightness);
+    d->fixColorsHighlights->setChecked(settings.fixColorsHighlights);
+
+    switch(settings.unclipColors)
+    {
+        case 0:
+            d->unclipColorComboBox->setCurrentIndex(0);
+            break;
+        case 1:
+            d->unclipColorComboBox->setCurrentIndex(1);
+            break;
+        case 2:
+            d->unclipColorComboBox->setCurrentIndex(2);
+            break;
+        default:         // Reconstruct Highlight method
+            d->unclipColorComboBox->setCurrentIndex(3);
+            d->reconstructSpinBox->setValue(settings.unclipColors-3);
+            break;
+    }
+    slotUnclipColorActivated(d->unclipColorComboBox->currentIndex());
+
+    d->dontStretchPixelsCheckBox->setChecked(settings.DontStretchPixels);
+    d->brightnessSpinBox->setValue(settings.brightness);
+    d->blackPointCheckBox->setChecked(settings.enableBlackPoint);
+    d->blackPointSpinBox->setEnabled(settings.enableBlackPoint);
+    d->blackPointSpinBox->setValue(settings.blackPoint);
+    d->whitePointCheckBox->setChecked(settings.enableWhitePoint);
+    d->whitePointSpinBox->setEnabled(settings.enableWhitePoint);
+    d->whitePointSpinBox->setValue(settings.whitePoint);
+
+    switch(settings.RAWQuality)
+    {
+        case RawDecodingSettings::VNG:
+            d->RAWQualityComboBox->setCurrentIndex(1);
+            break;
+        case RawDecodingSettings::PPG:
+            d->RAWQualityComboBox->setCurrentIndex(2);
+            break;
+        case RawDecodingSettings::AHD:
+            d->RAWQualityComboBox->setCurrentIndex(3);
+            break;
+        default:
+            d->RAWQualityComboBox->setCurrentIndex(0);
+            break;
+    }
+
+    d->inputColorSpaceComboBox->setCurrentIndex((int)settings.inputColorSpace);
+    slotInputColorSpaceChanged((int)settings.inputColorSpace);
+    d->outputColorSpaceComboBox->setCurrentIndex((int)settings.outputColorSpace);
+    slotOutputColorSpaceChanged((int)settings.outputColorSpace);
+    d->enableNoiseReduction->setChecked(settings.enableNoiseReduction);
+    slotNoiseReductionToggled(settings.enableNoiseReduction);
+    d->NRThresholdSpinBox->setValue(settings.NRThreshold);
+    d->enableCACorrection->setChecked(settings.enableCACorrection);
+    slotCACorrectionToggled(settings.enableCACorrection);
+    d->caRedMultSpinBox->setValue(settings.caMultiplier[0]);
+    d->caBlueMultSpinBox->setValue(settings.caMultiplier[1]);
+    d->inIccUrlEdit->setUrl(KUrl(settings.inputProfile));
+    d->outIccUrlEdit->setUrl(KUrl(settings.outputProfile));
+}
+
+RawDecodingSettings DcrawSettingsWidget::settings() const
+{
+    RawDecodingSettings prm;
+    prm.sixteenBitsImage = d->sixteenBitsImage->isChecked();
+
+    switch(d->whiteBalanceComboBox->currentIndex())
+    {
+        case 1:
+            prm.whiteBalance = RawDecodingSettings::CAMERA;
+            break;
+        case 2:
+            prm.whiteBalance = RawDecodingSettings::AUTO;
+            break;
+        case 3:
+            prm.whiteBalance = RawDecodingSettings::CUSTOM;
+            break;
+        default:
+            prm.whiteBalance = RawDecodingSettings::NONE;
+            break;
+    }
+
+    prm.medianFilterPasses      = d->medianFilterPassesSpinBox->value();
+    prm.customWhiteBalance      = d->customWhiteBalanceSpinBox->value();
+    prm.customWhiteBalanceGreen = d->customWhiteBalanceGreenSpinBox->value();
+    prm.RGBInterpolate4Colors   = d->fourColorCheckBox->isChecked();
+    prm.autoBrightness          = d->autoBrightnessBox->isChecked();
+    prm.fixColorsHighlights     = d->fixColorsHighlights->isChecked();
+
+    switch(d->unclipColorComboBox->currentIndex())
+    {
+        case 0:
+            prm.unclipColors = 0;
+            break;
+        case 1:
+            prm.unclipColors = 1;
+            break;
+        case 2:
+            prm.unclipColors = 2;
+            break;
+        default:         // Reconstruct Highlight method
+            prm.unclipColors =  d->reconstructSpinBox->value()+3;
+            break;
+    }
+
+    prm.DontStretchPixels = d->dontStretchPixelsCheckBox->isChecked();
+    prm.brightness        = d->brightnessSpinBox->value();
+    prm.enableBlackPoint  = d->blackPointCheckBox->isChecked();
+    prm.blackPoint        = d->blackPointSpinBox->value();
+    prm.enableWhitePoint  = d->whitePointCheckBox->isChecked();
+    prm.whitePoint        = d->whitePointSpinBox->value();
+
+    switch(d->RAWQualityComboBox->currentIndex())
+    {
+        case 1:
+            prm.RAWQuality = RawDecodingSettings::VNG;
+            break;
+        case 2:
+            prm.RAWQuality = RawDecodingSettings::PPG;
+            break;
+        case 3:
+            prm.RAWQuality = RawDecodingSettings::AHD;
+            break;
+        default:
+            prm.RAWQuality = RawDecodingSettings::BILINEAR;
+            break;
+    }
+
+    prm.inputColorSpace      = (RawDecodingSettings::InputColorSpace)(d->inputColorSpaceComboBox->currentIndex());
+    prm.outputColorSpace     = (RawDecodingSettings::OutputColorSpace)(d->outputColorSpaceComboBox->currentIndex());
+    prm.enableNoiseReduction = d->enableNoiseReduction->isChecked();
+    prm.NRThreshold          = d->NRThresholdSpinBox->value();
+    prm.enableCACorrection   = d->enableCACorrection->isChecked();
+    prm.caMultiplier[0]      = d->caRedMultSpinBox->value();
+    prm.caMultiplier[1]      = d->caBlueMultSpinBox->value();
+    prm.inputProfile         = d->inIccUrlEdit->url().toLocalFile();
+    prm.outputProfile        = d->outIccUrlEdit->url().toLocalFile();
+
+    return prm;
+}
+
+void DcrawSettingsWidget::writeSettings(KConfigGroup& group)
+{
+    RawDecodingSettings prm = settings();
+    prm.writeSettings(group);
+    RExpanderBox::writeSettings();
+}
+
+void DcrawSettingsWidget::readSettings(KConfigGroup& group)
+{
+    RawDecodingSettings prm;
+    prm.readSettings(group);
+    setSettings(prm);
+    RExpanderBox::readSettings();
+}
+
+// -- DEPRECATED METHODS -------------------------------------------------------------
 
 bool DcrawSettingsWidget::sixteenBits()
 {
@@ -774,8 +950,6 @@
     d->sixteenBitsImage->setChecked(b);
 }
 
-// ---------------------------------------------------------------
-
 RawDecodingSettings::WhiteBalance DcrawSettingsWidget::whiteBalance()
 {
     switch(d->whiteBalanceComboBox->currentIndex())
@@ -815,8 +989,6 @@
     slotWhiteBalanceToggled(d->whiteBalanceComboBox->currentIndex());
 }
 
-// ---------------------------------------------------------------
-
 int DcrawSettingsWidget::medianFilterPasses()
 {
     return d->medianFilterPassesSpinBox->value();
@@ -827,8 +999,6 @@
     d->medianFilterPassesSpinBox->setValue(p);
 }
 
-// ---------------------------------------------------------------
-
 int DcrawSettingsWidget::customWhiteBalance()
 {
     return d->customWhiteBalanceSpinBox->value();
@@ -839,8 +1009,6 @@
     d->customWhiteBalanceSpinBox->setValue(v);
 }
 
-// ---------------------------------------------------------------
-
 double DcrawSettingsWidget::customWhiteBalanceGreen()
 {
     return d->customWhiteBalanceGreenSpinBox->value();
@@ -851,8 +1019,6 @@
     d->customWhiteBalanceGreenSpinBox->setValue(v);
 }
 
-// ---------------------------------------------------------------
-
 bool DcrawSettingsWidget::useFourColor()
 {
     return d->fourColorCheckBox->isChecked();
@@ -863,8 +1029,6 @@
     d->fourColorCheckBox->setChecked(b);
 }
 
-// ---------------------------------------------------------------
-
 bool DcrawSettingsWidget::useAutoBrightness()
 {
     return d->autoBrightnessBox->isChecked();
@@ -875,8 +1039,6 @@
     d->autoBrightnessBox->setChecked(b);
 }
 
-// ---------------------------------------------------------------
-
 int DcrawSettingsWidget::unclipColor()
 {
     switch(d->unclipColorComboBox->currentIndex())
@@ -918,8 +1080,6 @@
     slotUnclipColorActivated(d->unclipColorComboBox->currentIndex());
 }
 
-// ---------------------------------------------------------------
-
 bool DcrawSettingsWidget::useDontStretchPixels()
 {
     return d->dontStretchPixelsCheckBox->isChecked();
@@ -930,8 +1090,6 @@
     d->dontStretchPixelsCheckBox->setChecked(b);
 }
 
-// ---------------------------------------------------------------
-
 double DcrawSettingsWidget::brightness()
 {
     return d->brightnessSpinBox->value();
@@ -942,8 +1100,6 @@
     d->brightnessSpinBox->setValue(b);
 }
 
-// ---------------------------------------------------------------
-
 bool DcrawSettingsWidget::useBlackPoint()
 {
     return d->blackPointCheckBox->isChecked();
@@ -955,8 +1111,6 @@
     d->blackPointSpinBox->setEnabled(b);
 }
 
-// ---------------------------------------------------------------
-
 int DcrawSettingsWidget::blackPoint()
 {
     return d->blackPointSpinBox->value();
@@ -967,8 +1121,6 @@
     d->blackPointSpinBox->setValue(b);
 }
 
-// ---------------------------------------------------------------
-
 bool DcrawSettingsWidget::useWhitePoint()
 {
     return d->whitePointCheckBox->isChecked();
@@ -980,8 +1132,6 @@
     d->whitePointSpinBox->setEnabled(b);
 }
 
-// ---------------------------------------------------------------
-
 int DcrawSettingsWidget::whitePoint()
 {
     return d->whitePointSpinBox->value();
@@ -992,8 +1142,6 @@
     d->whitePointSpinBox->setValue(b);
 }
 
-// ---------------------------------------------------------------
-
 RawDecodingSettings::DecodingQuality DcrawSettingsWidget::quality()
 {
     switch(d->RAWQualityComboBox->currentIndex())
@@ -1032,8 +1180,6 @@
     }
 }
 
-// ---------------------------------------------------------------
-
 RawDecodingSettings::InputColorSpace DcrawSettingsWidget::inputColorSpace()
 {
     return (RawDecodingSettings::InputColorSpace)(d->inputColorSpaceComboBox->currentIndex());
@@ -1045,8 +1191,6 @@
     slotInputColorSpaceChanged((int)c);
 }
 
-// ---------------------------------------------------------------
-
 RawDecodingSettings::OutputColorSpace DcrawSettingsWidget::outputColorSpace()
 {
     return (RawDecodingSettings::OutputColorSpace)(d->outputColorSpaceComboBox->currentIndex());
@@ -1058,8 +1202,6 @@
     slotOutputColorSpaceChanged((int)c);
 }
 
-// ---------------------------------------------------------------
-
 bool DcrawSettingsWidget::useNoiseReduction()
 {
     return d->enableNoiseReduction->isChecked();
@@ -1071,8 +1213,6 @@
     slotNoiseReductionToggled(b);
 }
 
-// ---------------------------------------------------------------
-
 int DcrawSettingsWidget::NRThreshold()
 {
     return d->NRThresholdSpinBox->value();
@@ -1083,8 +1223,6 @@
     d->NRThresholdSpinBox->setValue(b);
 }
 
-// ---------------------------------------------------------------
-
 bool DcrawSettingsWidget::useCACorrection()
 {
     return d->enableCACorrection->isChecked();
@@ -1096,8 +1234,6 @@
     slotCACorrectionToggled(b);
 }
 
-// ---------------------------------------------------------------
-
 double DcrawSettingsWidget::caRedMultiplier()
 {
     return d->caRedMultSpinBox->value();
@@ -1108,8 +1244,6 @@
     d->caRedMultSpinBox->setValue(b);
 }
 
-// ---------------------------------------------------------------
-
 double DcrawSettingsWidget::caBlueMultiplier()
 {
     return d->caBlueMultSpinBox->value();
@@ -1120,11 +1254,9 @@
     d->caBlueMultSpinBox->setValue(b);
 }
 
-// ---------------------------------------------------------------
-
 QString DcrawSettingsWidget::inputColorProfile()
 {
-    return d->inIccUrlEdit->url().path();
+    return d->inIccUrlEdit->url().toLocalFile();
 }
 
 void DcrawSettingsWidget::setInputColorProfile(const QString& path)
@@ -1132,11 +1264,9 @@
     d->inIccUrlEdit->setUrl(KUrl(path));
 }
 
-// ---------------------------------------------------------------
-
 QString DcrawSettingsWidget::outputColorProfile()
 {
-    return d->outIccUrlEdit->url().path();
+    return d->outIccUrlEdit->url().toLocalFile();
 }
 
 void DcrawSettingsWidget::setOutputColorProfile(const QString& path)
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libkdcraw/dcrawsettingswidget.h kdegraphics/libs/libkdcraw/libkdcraw/dcrawsettingswidget.h
--- kdegraphics-4.4.4/libs/libkdcraw/libkdcraw/dcrawsettingswidget.h	2009-07-17 23:44:37.000000000 +0200
+++ kdegraphics/libs/libkdcraw/libkdcraw/dcrawsettingswidget.h	2010-06-10 17:10:41.389042049 +0200
@@ -6,8 +6,8 @@
  * Date        : 2006-09-13
  * Description : LibRaw settings widgets
  *
- * Copyright (C) 2006-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
- * Copyright (C) 2006-2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2006-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2006-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
  * Copyright (C) 2007-2008 by Guillaume Castagnino <casta at xwing dot info>
  *
  * This program is free software; you can redistribute it
@@ -32,6 +32,7 @@
 // KDE includes.
 
 #include <kurlrequester.h>
+#include <kconfig.h>
 
 // Local includes.
 
@@ -48,7 +49,7 @@
 {
     Q_OBJECT
 
-public: 
+public:
 
     enum AdvancedSettingsOptions
     {
@@ -71,73 +72,90 @@
     /**
      * @param advSettings the default value is COLORSPACE
      */
-    DcrawSettingsWidget(QWidget *parent, int advSettings = COLORSPACE);
+    DcrawSettingsWidget(QWidget* parent, int advSettings = COLORSPACE);
     virtual ~DcrawSettingsWidget();
 
+    KUrlRequester* inputProfileUrlEdit() const;
+    KUrlRequester* outputProfileUrlEdit() const;
+
     void setup(int advSettings);
 
-    bool   sixteenBits();
-    int    customWhiteBalance();
-    double customWhiteBalanceGreen();
-    bool   useFourColor();
-    bool   useDontStretchPixels();
-    bool   useNoiseReduction();
-    bool   useCACorrection();
-    bool   useBlackPoint();
-    bool   useWhitePoint();
-    int    unclipColor();
-    bool   useAutoBrightness();
-    double brightness();
-    int    blackPoint();
-    int    whitePoint();
-    int    NRThreshold();
-    double caRedMultiplier();
-    double caBlueMultiplier();
-    int    medianFilterPasses();
-
-    RawDecodingSettings::WhiteBalance     whiteBalance();
-    RawDecodingSettings::DecodingQuality  quality();
-    RawDecodingSettings::InputColorSpace  inputColorSpace();
-    RawDecodingSettings::OutputColorSpace outputColorSpace();
-
-    QString inputColorProfile();
-    QString outputColorProfile();
-
-    void   setSixteenBits(bool b);
-    void   setCameraWB(bool b);
-    void   setWhiteBalance(RawDecodingSettings::WhiteBalance v);
-    void   setCustomWhiteBalance(int v);
-    void   setCustomWhiteBalanceGreen(double v);
-    void   setFourColor(bool b);
-    void   setDontStretchPixels(bool b);
-    void   setNoiseReduction(bool b);
-    void   setUseCACorrection(bool b);
-    void   setUseBlackPoint(bool b);
-    void   setUseWhitePoint(bool b);
-    void   setUnclipColor(int v);
-    void   setAutoBrightness(bool b);
-    void   setBrightness(double b);
-    void   setBlackPoint(int b);
-    void   setWhitePoint(int b);
-    void   setNRThreshold(int b);
-    void   setcaRedMultiplier(double b);
-    void   setcaBlueMultiplier(double b);
-    void   setMedianFilterPasses(int p);
-    void   setQuality(RawDecodingSettings::DecodingQuality q);
-    void   setInputColorSpace(RawDecodingSettings::InputColorSpace c);
-    void   setOutputColorSpace(RawDecodingSettings::OutputColorSpace c);
-    void   setInputColorProfile(const QString& path);
-    void   setOutputColorProfile(const QString& path);
+    void setEnabledBrightnessSettings(bool b);
+    bool brightnessSettingsIsEnabled();
 
-    void   setDefaultSettings();
+    void updateMinimumWidth();
 
-    void   setEnabledBrightnessSettings(bool b);
-    bool   brightnessSettingsIsEnabled();
+    /** deprecated. use resetToDefault() instead.
+     */
+    KDE_DEPRECATED void setDefaultSettings();
+    void resetToDefault();
 
-    void   updateMinimumWidth();
+    void setSettings(const RawDecodingSettings& settings);
+    RawDecodingSettings settings() const;
 
-    KUrlRequester* inputProfileUrlEdit() const;
-    KUrlRequester* outputProfileUrlEdit() const;
+    /** deprecated. use KConfigGroup based methods instead.
+     */
+    KDE_DEPRECATED void readSettings() { RExpanderBox::readSettings();  };
+    KDE_DEPRECATED void writeSettings(){ RExpanderBox::writeSettings(); };
+    void readSettings(KConfigGroup& group);
+    void writeSettings(KConfigGroup& group);
+
+    /** All methods below are deprecated and will be remove for 1.1.0. 
+        Use settings() and setSettings() instead.
+     */
+
+    KDE_DEPRECATED bool   sixteenBits();
+    KDE_DEPRECATED int    customWhiteBalance();
+    KDE_DEPRECATED double customWhiteBalanceGreen();
+    KDE_DEPRECATED bool   useFourColor();
+    KDE_DEPRECATED bool   useDontStretchPixels();
+    KDE_DEPRECATED bool   useNoiseReduction();
+    KDE_DEPRECATED bool   useCACorrection();
+    KDE_DEPRECATED bool   useBlackPoint();
+    KDE_DEPRECATED bool   useWhitePoint();
+    KDE_DEPRECATED int    unclipColor();
+    KDE_DEPRECATED bool   useAutoBrightness();
+    KDE_DEPRECATED double brightness();
+    KDE_DEPRECATED int    blackPoint();
+    KDE_DEPRECATED int    whitePoint();
+    KDE_DEPRECATED int    NRThreshold();
+    KDE_DEPRECATED double caRedMultiplier();
+    KDE_DEPRECATED double caBlueMultiplier();
+    KDE_DEPRECATED int    medianFilterPasses();
+
+    KDE_DEPRECATED RawDecodingSettings::WhiteBalance     whiteBalance();
+    KDE_DEPRECATED RawDecodingSettings::DecodingQuality  quality();
+    KDE_DEPRECATED RawDecodingSettings::InputColorSpace  inputColorSpace();
+    KDE_DEPRECATED RawDecodingSettings::OutputColorSpace outputColorSpace();
+
+    KDE_DEPRECATED QString inputColorProfile();
+    KDE_DEPRECATED QString outputColorProfile();
+
+    KDE_DEPRECATED void setSixteenBits(bool b);
+    KDE_DEPRECATED void setCameraWB(bool b);
+    KDE_DEPRECATED void setWhiteBalance(RawDecodingSettings::WhiteBalance v);
+    KDE_DEPRECATED void setCustomWhiteBalance(int v);
+    KDE_DEPRECATED void setCustomWhiteBalanceGreen(double v);
+    KDE_DEPRECATED void setFourColor(bool b);
+    KDE_DEPRECATED void setDontStretchPixels(bool b);
+    KDE_DEPRECATED void setNoiseReduction(bool b);
+    KDE_DEPRECATED void setUseCACorrection(bool b);
+    KDE_DEPRECATED void setUseBlackPoint(bool b);
+    KDE_DEPRECATED void setUseWhitePoint(bool b);
+    KDE_DEPRECATED void setUnclipColor(int v);
+    KDE_DEPRECATED void setAutoBrightness(bool b);
+    KDE_DEPRECATED void setBrightness(double b);
+    KDE_DEPRECATED void setBlackPoint(int b);
+    KDE_DEPRECATED void setWhitePoint(int b);
+    KDE_DEPRECATED void setNRThreshold(int b);
+    KDE_DEPRECATED void setcaRedMultiplier(double b);
+    KDE_DEPRECATED void setcaBlueMultiplier(double b);
+    KDE_DEPRECATED void setMedianFilterPasses(int p);
+    KDE_DEPRECATED void setQuality(RawDecodingSettings::DecodingQuality q);
+    KDE_DEPRECATED void setInputColorSpace(RawDecodingSettings::InputColorSpace c);
+    KDE_DEPRECATED void setOutputColorSpace(RawDecodingSettings::OutputColorSpace c);
+    KDE_DEPRECATED void setInputColorProfile(const QString& path);
+    KDE_DEPRECATED void setOutputColorProfile(const QString& path);    
 
 Q_SIGNALS:
 
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libkdcraw/kdcraw.cpp kdegraphics/libs/libkdcraw/libkdcraw/kdcraw.cpp
--- kdegraphics-4.4.4/libs/libkdcraw/libkdcraw/kdcraw.cpp	2009-12-05 00:08:59.000000000 +0100
+++ kdegraphics/libs/libkdcraw/libkdcraw/kdcraw.cpp	2010-06-10 17:10:41.385719040 +0200
@@ -6,8 +6,8 @@
  * Date        : 2006-12-09
  * Description : a tread-safe libraw C++ program interface
  *
- * Copyright (C) 2006-2009 by Gilles Caulier <caulier dot gilles at gmail dot com> 
- * Copyright (C) 2006-2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2006-2010 by Gilles Caulier <caulier dot gilles at gmail dot com> 
+ * Copyright (C) 2006-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
  * Copyright (C) 2007-2008 by Guillaume Castagnino <casta at xwing dot info>
  *
  * This program is free software; you can redistribute it
@@ -191,7 +191,7 @@
         return false;
     }
 
-    libraw_processed_image_t *halfImg = raw.dcraw_make_mem_image(&ret);
+    libraw_processed_image_t* halfImg = raw.dcraw_make_mem_image(&ret);
     if(!halfImg)
     {
         kDebug(51002) << "LibRaw: failed to run dcraw_make_mem_image: " << libraw_strerror(ret) << endl;
@@ -251,6 +251,14 @@
 
 bool KDcraw::extractRAWData(const QString& filePath, QByteArray& rawData, DcrawInfoContainer& identify)
 {
+    return extractRAWData(filePath, rawData, identify, false, 0);
+}
+
+// ----------------------------------------------------------------------------------
+
+bool KDcraw::extractRAWData(const QString& filePath, QByteArray& rawData, DcrawInfoContainer& identify,
+                            bool addMaskedBorders, unsigned int shotSelect)
+{
     QFileInfo fileInfo(filePath);
     QString   rawFilesExt(rawFiles());
     QString ext          = fileInfo.suffix().toUpper();
@@ -285,6 +293,7 @@
 
     raw.imgdata.params.output_bps    = 16;
     raw.imgdata.params.document_mode = 2;
+    raw.imgdata.params.shot_select   = shotSelect;
 
     ret = raw.unpack();
     if (ret != LIBRAW_SUCCESS)
@@ -294,6 +303,18 @@
         return false;
     }
 
+    if (addMaskedBorders)
+    {
+
+        ret = raw.add_masked_borders_to_bitmap();
+        if (ret != LIBRAW_SUCCESS)
+        {
+            kDebug(51002) << "LibRaw: failed to add masked borders: " << libraw_strerror(ret) << endl;
+            raw.recycle();
+            return false;
+        }
+    }
+
     if (m_cancel)
     {
         raw.recycle();
@@ -319,7 +340,7 @@
     {
         for (uint col=0 ; col < raw.imgdata.sizes.iwidth ; col++)
         {
-            *output = raw.imgdata.image[raw.imgdata.sizes.iwidth*row + col] [raw.FC(row, col)];
+            *output = raw.imgdata.image[raw.imgdata.sizes.iwidth*row + col] [raw.COLOR(row, col)];
             *output++;
         }
     }
@@ -629,6 +650,7 @@
 
     args.append(filePath);
     kDebug(51002) << "LibRaw: dcraw emulation: " << args << endl;
+    kDebug(51002) << "LibRaw highlights adjustements : " << m_rawDecodingSettings.fixColorsHighlights << endl;
 
     int ret = raw.open_file(QFile::encodeName(filePath));
     if (ret != LIBRAW_SUCCESS)
@@ -660,6 +682,19 @@
     }
     d->setProgress(0.25);
 
+    if (m_rawDecodingSettings.fixColorsHighlights)
+    {
+        kDebug(51002) << "Applying LibRaw highlights adjustements" << endl;
+        // 1.0 is fallback to default value
+        raw.imgdata.params.adjust_maximum_thr = 1.0; 
+    }
+    else
+    {
+        kDebug(51002) << "Disabling LibRaw highlights adjustements" << endl;
+        // 0.0 disables this feature
+        raw.imgdata.params.adjust_maximum_thr = 0.0; 
+    }
+
     ret = raw.dcraw_process();
     if (ret != LIBRAW_SUCCESS)
     {
@@ -675,7 +710,7 @@
     }
     d->setProgress(0.3);
 
-    libraw_processed_image_t *img = raw.dcraw_make_mem_image(&ret);
+    libraw_processed_image_t* img = raw.dcraw_make_mem_image(&ret);
     if(!img)
     {
         kDebug(51002) << "LibRaw: failed to run dcraw_make_mem_image: " << libraw_strerror(ret) << endl;
@@ -709,7 +744,7 @@
     return true;
 }
 
-const char *KDcraw::rawFiles()
+const char* KDcraw::rawFiles()
 {
     return raw_file_extentions;
 }
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libkdcraw/kdcraw.h kdegraphics/libs/libkdcraw/libkdcraw/kdcraw.h
--- kdegraphics-4.4.4/libs/libkdcraw/libkdcraw/kdcraw.h	2009-12-01 01:33:27.000000000 +0100
+++ kdegraphics/libs/libkdcraw/libkdcraw/kdcraw.h	2010-06-10 17:10:41.385719040 +0200
@@ -6,8 +6,8 @@
  * Date        : 2006-12-09
  * Description : a tread-safe libraw C++ program interface
  *
- * Copyright (C) 2006-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
- * Copyright (C) 2006-2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2006-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2006-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
  * Copyright (C) 2007-2008 by Guillaume Castagnino <casta at xwing dot info>
  *
  * This program is free software; you can redistribute it
@@ -117,19 +117,32 @@
 
 public:
 
-    /** Extract Raw image data undemosaiced and without post processing from 'filePath' picture file. 
-        This is a cancelable method which require a class instance to run because RAW pictures loading 
+    /** Extract Raw image data undemosaiced and without post processing from 'filePath' picture file.
+        This is a cancelable method which require a class instance to run because RAW pictures loading
         can take a while.
 
         This method return:
 
-            - A byte array container 'rawData' with raw data. 
-            - All info about Raw image into 'identify' container. 
-            - 'false' is returned if loadding failed, else 'true'.  
+            - A byte array container 'rawData' with raw data.
+            - All info about Raw image into 'identify' container.
+            - 'false' is returned if loadding failed, else 'true'.
      */
     bool extractRAWData(const QString& filePath, QByteArray& rawData, DcrawInfoContainer& identify);
 
-    /** Extract a small size of decode RAW data from 'filePath' picture file using 
+    /** Extract Raw image data undemosaiced and without post processing from 'filePath' picture file.
+        This is a cancelable method which require a class instance to run because RAW pictures loading
+        can take a while.
+
+        This method return:
+
+            - A byte array container 'rawData' with raw data.
+            - All info about Raw image into 'identify' container.
+            - 'false' is returned if loadding failed, else 'true'.
+     */
+    bool extractRAWData(const QString& filePath, QByteArray& rawData, DcrawInfoContainer& identify,
+                        bool addMaskedBorders, unsigned int shotSelect);
+
+    /** Extract a small size of decode RAW data from 'filePath' picture file using
         'rawDecodingSettings' settings. This is a cancelable method which require 
         a class instance to run because RAW pictures decoding can take a while.
 
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libkdcraw/kdcraw_p.cpp kdegraphics/libs/libkdcraw/libkdcraw/kdcraw_p.cpp
--- kdegraphics-4.4.4/libs/libkdcraw/libkdcraw/kdcraw_p.cpp	2009-07-06 12:42:45.000000000 +0200
+++ kdegraphics/libs/libkdcraw/libkdcraw/kdcraw_p.cpp	2010-06-10 17:10:41.389042049 +0200
@@ -6,7 +6,7 @@
  * Date        : 2008-10-09
  * Description : internal private container for KDcraw
  *
- * Copyright (C) 2008-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2008-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
@@ -109,6 +109,8 @@
     identify.thumbSize        = QSize(raw->imgdata.thumbnail.twidth, raw->imgdata.thumbnail.theight);
     identify.topMargin        = raw->imgdata.sizes.top_margin;
     identify.leftMargin       = raw->imgdata.sizes.left_margin;
+    identify.rightMargin      = raw->imgdata.sizes.right_margin;
+    identify.bottomMargin     = raw->imgdata.sizes.bottom_margin;
     identify.hasIccProfile    = raw->imgdata.color.profile ? true : false;
     identify.isDecodable      = true;
     identify.pixelAspectRatio = raw->imgdata.sizes.pixel_aspect;
@@ -125,7 +127,9 @@
     {
         if (!raw->imgdata.idata.cdesc[3]) raw->imgdata.idata.cdesc[3] = 'G';
         for (int i=0; i < 16; i++)
-            identify.filterPattern.append(raw->imgdata.idata.cdesc[raw->fc(i >> 1,i & 1)]);
+            identify.filterPattern.append(raw->imgdata.idata.cdesc[raw->COLOR(i >> 1,i & 1)]);
+
+        identify.colorKeys = raw->imgdata.idata.cdesc;
     }
 
     for(int c = 0 ; c < raw->imgdata.idata.colors ; c++)
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libkdcraw/kdcraw_p.h kdegraphics/libs/libkdcraw/libkdcraw/kdcraw_p.h
--- kdegraphics-4.4.4/libs/libkdcraw/libkdcraw/kdcraw_p.h	2009-04-28 15:45:57.000000000 +0200
+++ kdegraphics/libs/libkdcraw/libkdcraw/kdcraw_p.h	2010-06-10 17:10:41.382416243 +0200
@@ -6,7 +6,7 @@
  * Date        : 2008-10-09
  * Description : internal private container for KDcraw
  *
- * Copyright (C) 2008-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2008-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libkdcraw/rawdecodingsettings.cpp kdegraphics/libs/libkdcraw/libkdcraw/rawdecodingsettings.cpp
--- kdegraphics-4.4.4/libs/libkdcraw/libkdcraw/rawdecodingsettings.cpp	2009-07-06 12:42:45.000000000 +0200
+++ kdegraphics/libs/libkdcraw/libkdcraw/rawdecodingsettings.cpp	2010-06-10 17:10:41.382416243 +0200
@@ -6,8 +6,8 @@
  * Date        : 2006-12-09
  * Description : Raw decoding settings
  *
- * Copyright (C) 2006-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
- * Copyright (C) 2006-2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2006-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2006-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
  * Copyright (C) 2007-2008 by Guillaume Castagnino <casta at xwing dot info>
  *
  * This program is free software; you can redistribute it
@@ -22,7 +22,31 @@
  *
  * ============================================================ */
 
-// Local includes
+#define OPTIONFIXCOLORSHIGHLIGHTSENTRY      "FixColorsHighlights"
+#define OPTIONDECODESIXTEENBITENTRY         "SixteenBitsImage"
+#define OPTIONWHITEBALANCEENTRY             "White Balance"
+#define OPTIONCUSTOMWHITEBALANCEENTRY       "Custom White Balance"
+#define OPTIONCUSTOMWBGREENENTRY            "Custom White Balance Green"
+#define OPTIONFOURCOLORRGBENTRY             "Four Color RGB"
+#define OPTIONUNCLIPCOLORSENTRY             "Unclip Color"
+#define OPTIONDONTSTRETCHPIXELSENTRY        "Dont Stretch Pixels"
+#define OPTIONNOISEREDUCTIONENTRY           "Use Noise Reduction"
+#define OPTIONMEDIANFILTERPASSESENTRY       "Median Filter Passes"
+#define OPTIONNRTHRESHOLDENTRY              "NR Threshold"
+#define OPTIONUSECACORRECTIONENTRY          "EnableCACorrection"
+#define OPTIONCAREDMULTIPLIERENTRY          "caRedMultiplier"
+#define OPTIONCABLUEMULTIPLIERENTRY         "caBlueMultiplier"
+#define OPTIONAUTOBRIGHTNESSENTRY           "AutoBrightness"
+#define OPTIONDECODINGQUALITYENTRY          "Decoding Quality"
+#define OPTIONINPUTCOLORSPACEENTRY          "Input Color Space"
+#define OPTIONOUTPUTCOLORSPACEENTRY         "Output Color Space"
+#define OPTIONINPUTCOLORPROFILEENTRY        "Input Color Profile"
+#define OPTIONOUTPUTCOLORPROFILEENTRY       "Output Color Profile"
+#define OPTIONBRIGHTNESSMULTIPLIERENTRY     "Brightness Multiplier"
+#define OPTIONUSEBLACKPOINTENTRY            "Use Black Point"
+#define OPTIONBLACKPOINTENTRY               "Black Point"
+#define OPTIONUSEWHITEPOINTENTRY            "Use White Point"
+#define OPTIONWHITEPOINTENTRY               "White Point"
 
 #include "rawdecodingsettings.h"
 
@@ -31,6 +55,7 @@
 
 RawDecodingSettings::RawDecodingSettings()
 {
+    fixColorsHighlights        = false;
     autoBrightness             = true;
     sixteenBitsImage           = false;
     brightness                 = 1.0;
@@ -68,9 +93,47 @@
     whiteBalanceArea           = QRect();
 }
 
-bool RawDecodingSettings::operator==(const RawDecodingSettings &o) const
+RawDecodingSettings::~RawDecodingSettings()
 {
-    return autoBrightness          == o.autoBrightness
+}
+
+RawDecodingSettings& RawDecodingSettings::operator=(const RawDecodingSettings& o)
+{
+    fixColorsHighlights     = o.fixColorsHighlights;
+    autoBrightness          = o.autoBrightness;
+    sixteenBitsImage        = o.sixteenBitsImage;
+    brightness              = o.brightness;
+    RAWQuality              = o.RAWQuality;
+    inputColorSpace         = o.inputColorSpace;
+    outputColorSpace        = o.outputColorSpace;
+    RGBInterpolate4Colors   = o.RGBInterpolate4Colors;
+    DontStretchPixels       = o.DontStretchPixels;
+    unclipColors            = o.unclipColors;
+    whiteBalance            = o.whiteBalance;
+    customWhiteBalance      = o.customWhiteBalance;
+    customWhiteBalanceGreen = o.customWhiteBalanceGreen;
+    halfSizeColorImage      = o.halfSizeColorImage;
+    enableBlackPoint        = o.enableBlackPoint;
+    blackPoint              = o.blackPoint;
+    enableWhitePoint        = o.enableWhitePoint;
+    whitePoint              = o.whitePoint;
+    enableNoiseReduction    = o.enableNoiseReduction;
+    NRThreshold             = o.NRThreshold;
+    enableCACorrection      = o.enableCACorrection;
+    caMultiplier[0]         = o.caMultiplier[0];
+    caMultiplier[1]         = o.caMultiplier[1];
+    medianFilterPasses      = o.medianFilterPasses;
+    inputProfile            = o.inputProfile;
+    outputProfile           = o.outputProfile;
+    deadPixelMap            = o.deadPixelMap;
+    whiteBalanceArea        = o.whiteBalanceArea;
+    return *this;
+}
+
+bool RawDecodingSettings::operator==(const RawDecodingSettings& o) const
+{
+    return fixColorsHighlights     == o.fixColorsHighlights
+        && autoBrightness          == o.autoBrightness
         && sixteenBitsImage        == o.sixteenBitsImage
         && brightness              == o.brightness
         && RAWQuality              == o.RAWQuality
@@ -100,12 +163,9 @@
         ;
 }
 
-RawDecodingSettings::~RawDecodingSettings()
-{
-}
-
 void RawDecodingSettings::optimizeTimeLoading()
 {
+    fixColorsHighlights     = false;
     autoBrightness          = true;
     sixteenBitsImage        = true;
     brightness              = 1.0;
@@ -142,6 +202,60 @@
     whiteBalanceArea        = QRect();
 }
 
+void RawDecodingSettings::readSettings(KConfigGroup& group)
+{
+    RawDecodingSettings defaultPrm;
+
+    fixColorsHighlights     = group.readEntry(OPTIONFIXCOLORSHIGHLIGHTSENTRY, defaultPrm.fixColorsHighlights);
+    sixteenBitsImage        = group.readEntry(OPTIONDECODESIXTEENBITENTRY, defaultPrm.sixteenBitsImage);
+    whiteBalance            = (WhiteBalance)group.readEntry(OPTIONWHITEBALANCEENTRY, (int)defaultPrm.whiteBalance);
+    customWhiteBalance      = group.readEntry(OPTIONCUSTOMWHITEBALANCEENTRY, defaultPrm.customWhiteBalance);
+    customWhiteBalanceGreen = group.readEntry(OPTIONCUSTOMWBGREENENTRY, defaultPrm.customWhiteBalanceGreen);
+    RGBInterpolate4Colors   = group.readEntry(OPTIONFOURCOLORRGBENTRY, defaultPrm.RGBInterpolate4Colors);
+    unclipColors            = group.readEntry(OPTIONUNCLIPCOLORSENTRY, defaultPrm.unclipColors);
+    DontStretchPixels       = group.readEntry(OPTIONDONTSTRETCHPIXELSENTRY, defaultPrm.DontStretchPixels);
+    enableNoiseReduction    = group.readEntry(OPTIONNOISEREDUCTIONENTRY, defaultPrm.enableNoiseReduction);
+    brightness              = group.readEntry(OPTIONBRIGHTNESSMULTIPLIERENTRY, defaultPrm.brightness);
+    enableBlackPoint        = group.readEntry(OPTIONUSEBLACKPOINTENTRY, defaultPrm.enableBlackPoint);
+    blackPoint              = group.readEntry(OPTIONBLACKPOINTENTRY, defaultPrm.blackPoint);
+    enableWhitePoint        = group.readEntry(OPTIONUSEWHITEPOINTENTRY, defaultPrm.enableWhitePoint);
+    whitePoint              = group.readEntry(OPTIONWHITEPOINTENTRY, defaultPrm.whitePoint);
+    medianFilterPasses      = group.readEntry(OPTIONMEDIANFILTERPASSESENTRY, defaultPrm.medianFilterPasses);
+    NRThreshold             = group.readEntry(OPTIONNRTHRESHOLDENTRY, defaultPrm.NRThreshold);
+    enableCACorrection      = group.readEntry(OPTIONUSECACORRECTIONENTRY, defaultPrm.enableCACorrection);
+    caMultiplier[0]         = group.readEntry(OPTIONCAREDMULTIPLIERENTRY, defaultPrm.caMultiplier[0]);
+    caMultiplier[1]         = group.readEntry(OPTIONCABLUEMULTIPLIERENTRY, defaultPrm.caMultiplier[1]);
+    RAWQuality              = (DecodingQuality)group.readEntry(OPTIONDECODINGQUALITYENTRY, (int)defaultPrm.RAWQuality);
+    outputColorSpace        = (OutputColorSpace)group.readEntry(OPTIONOUTPUTCOLORSPACEENTRY, (int)defaultPrm.outputColorSpace);
+    autoBrightness          = group.readEntry(OPTIONAUTOBRIGHTNESSENTRY, defaultPrm.autoBrightness);
+}
+
+void RawDecodingSettings::writeSettings(KConfigGroup& group)
+{
+    group.writeEntry(OPTIONFIXCOLORSHIGHLIGHTSENTRY,  fixColorsHighlights);
+    group.writeEntry(OPTIONDECODESIXTEENBITENTRY,     sixteenBitsImage);
+    group.writeEntry(OPTIONWHITEBALANCEENTRY,         (int)whiteBalance);
+    group.writeEntry(OPTIONCUSTOMWHITEBALANCEENTRY,   customWhiteBalance);
+    group.writeEntry(OPTIONCUSTOMWBGREENENTRY,        customWhiteBalanceGreen);
+    group.writeEntry(OPTIONFOURCOLORRGBENTRY,         RGBInterpolate4Colors);
+    group.writeEntry(OPTIONUNCLIPCOLORSENTRY,         unclipColors);
+    group.writeEntry(OPTIONDONTSTRETCHPIXELSENTRY,    DontStretchPixels);
+    group.writeEntry(OPTIONNOISEREDUCTIONENTRY,       enableNoiseReduction);
+    group.writeEntry(OPTIONBRIGHTNESSMULTIPLIERENTRY, brightness);
+    group.writeEntry(OPTIONUSEBLACKPOINTENTRY,        enableBlackPoint);
+    group.writeEntry(OPTIONBLACKPOINTENTRY,           blackPoint);
+    group.writeEntry(OPTIONUSEWHITEPOINTENTRY,        enableWhitePoint);
+    group.writeEntry(OPTIONWHITEPOINTENTRY,           whitePoint);
+    group.writeEntry(OPTIONMEDIANFILTERPASSESENTRY,   medianFilterPasses);
+    group.writeEntry(OPTIONNRTHRESHOLDENTRY,          NRThreshold);
+    group.writeEntry(OPTIONUSECACORRECTIONENTRY,      enableCACorrection);
+    group.writeEntry(OPTIONCAREDMULTIPLIERENTRY,      caMultiplier[0]);
+    group.writeEntry(OPTIONCABLUEMULTIPLIERENTRY,     caMultiplier[1]);
+    group.writeEntry(OPTIONDECODINGQUALITYENTRY,      (int)RAWQuality);
+    group.writeEntry(OPTIONOUTPUTCOLORSPACEENTRY,     (int)outputColorSpace);
+    group.writeEntry(OPTIONAUTOBRIGHTNESSENTRY,       autoBrightness);
+}
+
 QDebug operator<<(QDebug dbg, const RawDecodingSettings& s)
 {
     dbg.nospace() << "RawDecodingSettings::autoBrightness: "          << s.autoBrightness   << ", ";
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libkdcraw/rawdecodingsettings.h kdegraphics/libs/libkdcraw/libkdcraw/rawdecodingsettings.h
--- kdegraphics-4.4.4/libs/libkdcraw/libkdcraw/rawdecodingsettings.h	2009-07-06 12:42:45.000000000 +0200
+++ kdegraphics/libs/libkdcraw/libkdcraw/rawdecodingsettings.h	2010-06-10 17:10:41.385719040 +0200
@@ -6,8 +6,8 @@
  * Date        : 2006-12-09
  * Description : Raw decoding settings
  *
- * Copyright (C) 2006-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
- * Copyright (C) 2006-2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2006-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2006-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
  * Copyright (C) 2007-2008 by Guillaume Castagnino <casta at xwing dot info>
  *
  * This program is free software; you can redistribute it
@@ -31,6 +31,10 @@
 #include <QtCore/QString>
 #include <QtCore/QDebug>
 
+// KDE includes
+
+#include <kconfiggroup.h>
+
 // Local includes
 
 #include "libkdcraw_export.h"
@@ -118,6 +122,9 @@
     /** Standard constructor with default settings */
     RawDecodingSettings();
 
+    /** Equivalent to the copy constructor */
+    RawDecodingSettings& operator=(const RawDecodingSettings& prm);  
+
     /** Compare for equality */
     bool operator==(const RawDecodingSettings &o) const;
 
@@ -127,8 +134,17 @@
     /** Method to use a settings to optimize time loading, for exemple to compute image histogram */
     void optimizeTimeLoading();
 
+    /** Methods to read/write settings from/to a config file */
+    void readSettings(KConfigGroup& group);
+    void writeSettings(KConfigGroup& group);
+
 public:
 
+    /** If true, images with overblown channels are processed much more accurate, 
+        without 'pink clouds' (and blue highlights under tungsteen lamps).
+     */
+    bool fixColorsHighlights;
+
     /** If false, use a fixed white level, ignoring the image histogram.
     */
     bool autoBrightness;
@@ -203,7 +219,7 @@
 
     /** Brightness of output image.
     */
-    float brightness;
+    double brightness;
 
     /** Set on the black point setting to decode RAW image.
     */
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libkdcraw/rexpanderbox.cpp kdegraphics/libs/libkdcraw/libkdcraw/rexpanderbox.cpp
--- kdegraphics-4.4.4/libs/libkdcraw/libkdcraw/rexpanderbox.cpp	2009-12-05 00:08:59.000000000 +0100
+++ kdegraphics/libs/libkdcraw/libkdcraw/rexpanderbox.cpp	2010-06-10 17:10:41.382416243 +0200
@@ -6,8 +6,8 @@
  * Date        : 2008-03-14
  * Description : A widget to host settings as expander box
  *
- * Copyright (C) 2008-2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
- * Copyright (C) 2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2008-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2009-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
@@ -34,6 +34,7 @@
 #include <QStyleOption>
 #include <QGridLayout>
 #include <QHBoxLayout>
+#include <QCheckBox>
 
 // KDE includes
 
@@ -47,13 +48,13 @@
 namespace KDcrawIface
 {
 
-RClickLabel::RClickLabel(QWidget *parent)
+RClickLabel::RClickLabel(QWidget* parent)
            : QLabel(parent)
 {
     setCursor(Qt::PointingHandCursor);
 }
 
-RClickLabel::RClickLabel(const QString& text, QWidget *parent)
+RClickLabel::RClickLabel(const QString& text, QWidget* parent)
            : QLabel(text, parent)
 {
     setCursor(Qt::PointingHandCursor);
@@ -71,7 +72,7 @@
     }
 }
 
-void RClickLabel::keyPressEvent(QKeyEvent *e)
+void RClickLabel::keyPressEvent(QKeyEvent* e)
 {
     switch (e->key())
     {
@@ -89,13 +90,13 @@
 
 // ------------------------------------------------------------------------
 
-RSqueezedClickLabel::RSqueezedClickLabel(QWidget *parent)
+RSqueezedClickLabel::RSqueezedClickLabel(QWidget* parent)
                    : KSqueezedTextLabel(parent)
 {
     setCursor(Qt::PointingHandCursor);
 }
 
-RSqueezedClickLabel::RSqueezedClickLabel(const QString& text, QWidget *parent)
+RSqueezedClickLabel::RSqueezedClickLabel(const QString& text, QWidget* parent)
                    : KSqueezedTextLabel(text, parent)
 {
     setCursor(Qt::PointingHandCursor);
@@ -113,7 +114,7 @@
     }
 }
 
-void RSqueezedClickLabel::keyPressEvent(QKeyEvent *e)
+void RSqueezedClickLabel::keyPressEvent(QKeyEvent* e)
 {
     switch (e->key())
     {
@@ -131,7 +132,7 @@
 
 // ------------------------------------------------------------------------
 
-RArrowClickLabel::RArrowClickLabel(QWidget *parent)
+RArrowClickLabel::RArrowClickLabel(QWidget* parent)
                 : QWidget(parent), m_arrowType(Qt::DownArrow)
 {
     setCursor(Qt::PointingHandCursor);
@@ -259,34 +260,38 @@
         arrow           = 0;
         line            = 0;
         hbox            = 0;
+        checkBox        = 0;
         expandByDefault = true;
     }
 
     bool              expandByDefault;
 
-    QLabel           *pixmapLabel;
-    QWidget          *containerWidget;
-    QGridLayout      *grid;
+    QCheckBox*        checkBox;
+    QLabel*           pixmapLabel;
+    QWidget*          containerWidget;
+    QGridLayout*      grid;
 
-    KSeparator       *line;
-    QWidget          *hbox;
+    KSeparator*       line;
+    QWidget*          hbox;
 
-    RArrowClickLabel *arrow;
-    RClickLabel      *clickLabel;
+    RArrowClickLabel* arrow;
+    RClickLabel*      clickLabel;
 };
 
-RLabelExpander::RLabelExpander(QWidget *parent)
+RLabelExpander::RLabelExpander(QWidget* parent)
               : QWidget(parent), d(new RLabelExpanderPriv)
 {
     d->grid        = new QGridLayout(this);
     d->line        = new KSeparator(Qt::Horizontal, this);
     d->hbox        = new QWidget(this);
     d->arrow       = new RArrowClickLabel(d->hbox);
+    d->checkBox    = new QCheckBox(d->hbox);
     d->pixmapLabel = new QLabel(d->hbox);
     d->clickLabel  = new RClickLabel(d->hbox);
 
-    QHBoxLayout *hlay = new QHBoxLayout(d->hbox);
+    QHBoxLayout* hlay = new QHBoxLayout(d->hbox);
     hlay->addWidget(d->arrow);
+    hlay->addWidget(d->checkBox);
     hlay->addWidget(d->pixmapLabel);
     hlay->addWidget(d->clickLabel, 10);
     hlay->setMargin(0);
@@ -296,6 +301,7 @@
     d->pixmapLabel->setCursor(Qt::PointingHandCursor);
 
     d->hbox->setCursor(Qt::PointingHandCursor);
+    setCheckBoxVisible(false);
 
     d->grid->addWidget(d->line, 0, 0, 1, 3);
     d->grid->addWidget(d->hbox, 1, 0, 1, 3);
@@ -308,6 +314,9 @@
 
     connect(d->clickLabel, SIGNAL(activated()),
             this, SLOT(slotToggleContainer()));
+
+    connect(d->checkBox, SIGNAL(toggled(bool)),
+            this, SIGNAL(signalToggled(bool)));
 }
 
 RLabelExpander::~RLabelExpander()
@@ -315,6 +324,26 @@
     delete d;
 }
 
+void RLabelExpander::setCheckBoxVisible(bool b)
+{
+    d->checkBox->setVisible(b);
+}
+
+bool RLabelExpander::checkBoxIsVisible() const
+{
+    return d->checkBox->isVisible();
+}
+
+void RLabelExpander::setChecked(bool b)
+{
+    d->checkBox->setChecked(b);
+}
+
+bool RLabelExpander::isChecked() const
+{
+    return d->checkBox->isChecked();
+}
+
 void RLabelExpander::setLineVisible(bool b)
 {
     d->line->setVisible(b);
@@ -395,7 +424,7 @@
         setExpanded(!d->containerWidget->isVisible());
 }
 
-bool RLabelExpander::eventFilter(QObject *obj, QEvent *ev)
+bool RLabelExpander::eventFilter(QObject* obj, QEvent* ev)
 {
     if ( obj == d->pixmapLabel)
     {
@@ -429,10 +458,10 @@
         vbox   = 0;
     }
 
-    void createItem(int index, QWidget *w, const QPixmap& pix, const QString& txt,
+    void createItem(int index, QWidget* w, const QPixmap& pix, const QString& txt,
                     const QString& objName, bool expandBydefault)
     {
-        RLabelExpander *exp = new RLabelExpander(parent->viewport());
+        RLabelExpander* exp = new RLabelExpander(parent->viewport());
         exp->setText(txt);
         exp->setIcon(pix);
         exp->setWidget(w);
@@ -453,21 +482,24 @@
 
         parent->connect(exp, SIGNAL(signalExpanded(bool)),
                         parent, SLOT(slotItemExpanded(bool)));
+
+        parent->connect(exp, SIGNAL(signalToggled(bool)),
+                        parent, SLOT(slotItemToggled(bool)));
     }
 
-    QList<RLabelExpander*>  wList;
+    QList<RLabelExpander*> wList;
 
-    QVBoxLayout            *vbox;
+    QVBoxLayout*           vbox;
 
-    RExpanderBox           *parent;
+    RExpanderBox*          parent;
 };
 
-RExpanderBox::RExpanderBox(QWidget *parent)
+RExpanderBox::RExpanderBox(QWidget* parent)
             : QScrollArea(parent), d(new RExpanderBoxPriv(this))
 {
     setFrameStyle(QFrame::NoFrame);
     setWidgetResizable(true);
-    QWidget *main = new QWidget(viewport());
+    QWidget* main = new QWidget(viewport());
     d->vbox       = new QVBoxLayout(main);
     d->vbox->setMargin(0);
     d->vbox->setSpacing(KDialog::spacingHint());
@@ -485,13 +517,37 @@
     delete d;
 }
 
-void RExpanderBox::addItem(QWidget *w, const QPixmap& pix, const QString& txt,
+void RExpanderBox::setCheckBoxVisible(int index, bool b)
+{
+    if (index > d->wList.count() || index < 0) return;
+    d->wList[index]->setCheckBoxVisible(b);
+}
+
+bool RExpanderBox::checkBoxIsVisible(int index) const
+{
+    if (index > d->wList.count() || index < 0) return false;
+    return d->wList[index]->checkBoxIsVisible();
+}
+
+void RExpanderBox::setChecked(int index, bool b)
+{
+    if (index > d->wList.count() || index < 0) return;
+    d->wList[index]->setChecked(b);
+}
+
+bool RExpanderBox::isChecked(int index) const
+{
+    if (index > d->wList.count() || index < 0) return false;
+    return d->wList[index]->isChecked();
+}
+
+void RExpanderBox::addItem(QWidget* w, const QPixmap& pix, const QString& txt,
                            const QString& objName, bool expandBydefault)
 {
     d->createItem(-1, w, pix, txt, objName, expandBydefault);
 }
 
-void RExpanderBox::addItem(QWidget *w, const QString& txt,
+void RExpanderBox::addItem(QWidget* w, const QString& txt,
                            const QString& objName, bool expandBydefault)
 {
     addItem(w, QPixmap(), txt, objName, expandBydefault);
@@ -502,7 +558,7 @@
     d->vbox->addStretch(10);
 }
 
-void RExpanderBox::insertItem(int index, QWidget *w, const QPixmap& pix, const QString& txt,
+void RExpanderBox::insertItem(int index, QWidget* w, const QPixmap& pix, const QString& txt,
                               const QString& objName, bool expandBydefault)
 {
     d->createItem(index, w, pix, txt, objName, expandBydefault);
@@ -518,7 +574,17 @@
     }
 }
 
-void RExpanderBox::insertItem(int index, QWidget *w, const QString& txt,
+void RExpanderBox::slotItemToggled(bool b)
+{
+    RLabelExpander* exp = dynamic_cast<RLabelExpander*>(sender());
+    if (exp)
+    {
+        int index = indexOf(exp);
+        emit signalItemToggled(index, b);
+    }
+}
+
+void RExpanderBox::insertItem(int index, QWidget* w, const QString& txt,
                               const QString& objName, bool expandBydefault)
 {
     insertItem(index, w, QPixmap(), txt, objName, expandBydefault);
@@ -596,7 +662,7 @@
     return d->wList[index];
 }
 
-int RExpanderBox::indexOf(RLabelExpander *widget) const
+int RExpanderBox::indexOf(RLabelExpander* widget) const
 {
     for (int i = 0 ; i < count(); ++i)
     {
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libkdcraw/rexpanderbox.h kdegraphics/libs/libkdcraw/libkdcraw/rexpanderbox.h
--- kdegraphics-4.4.4/libs/libkdcraw/libkdcraw/rexpanderbox.h	2009-07-17 23:44:37.000000000 +0200
+++ kdegraphics/libs/libkdcraw/libkdcraw/rexpanderbox.h	2010-06-10 17:10:41.382416243 +0200
@@ -6,8 +6,8 @@
  * Date        : 2008-03-14
  * Description : A widget to host settings as expander box
  *
- * Copyright (C) 2008-2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
- * Copyright (C) 2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2008-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2009-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
@@ -50,8 +50,8 @@
 
 public:
 
-    RClickLabel(QWidget *parent = 0);
-    RClickLabel(const QString& text, QWidget *parent = 0);
+    RClickLabel(QWidget* parent = 0);
+    RClickLabel(const QString& text, QWidget* parent = 0);
     ~RClickLabel(){};
 
 Q_SIGNALS:
@@ -75,8 +75,8 @@
 
 public:
 
-    RSqueezedClickLabel(QWidget *parent = 0);
-    RSqueezedClickLabel(const QString& text, QWidget *parent = 0);
+    RSqueezedClickLabel(QWidget* parent = 0);
+    RSqueezedClickLabel(const QString& text, QWidget* parent = 0);
     ~RSqueezedClickLabel(){};
 
 Q_SIGNALS:
@@ -98,7 +98,7 @@
 
 public:
 
-    RArrowClickLabel(QWidget *parent = 0);
+    RArrowClickLabel(QWidget* parent = 0);
     ~RArrowClickLabel(){};
 
     void setArrowType(Qt::ArrowType arrowType);
@@ -132,9 +132,15 @@
 
 public:
 
-    RLabelExpander(QWidget *parent = 0);
+    RLabelExpander(QWidget* parent = 0);
     ~RLabelExpander();
 
+    void setCheckBoxVisible(bool b);
+    bool checkBoxIsVisible() const;
+
+    void setChecked(bool b);
+    bool isChecked() const;
+
     void setLineVisible(bool b);
     bool lineIsVisible() const;
 
@@ -155,7 +161,8 @@
 
 Q_SIGNALS:
 
-    void signalExpanded(bool b);
+    void signalExpanded(bool);
+    void signalToggled(bool);
 
 private Q_SLOTS:
 
@@ -163,7 +170,7 @@
 
 private:
 
-    bool eventFilter(QObject *obj, QEvent *ev);
+    bool eventFilter(QObject* obj, QEvent* ev);
 
 private:
 
@@ -180,7 +187,7 @@
 
 public:
 
-    RExpanderBox(QWidget *parent = 0);
+    RExpanderBox(QWidget* parent = 0);
     ~RExpanderBox();
 
     /** Add RLabelExpander item at end of box layout with these settings :
@@ -190,9 +197,9 @@
         'objName'         : item object name used to read/save expanded settings to rc file.
         'expandBydefault' : item state by default (expanded or not).
      */
-    void addItem(QWidget *w, const QPixmap& pix, const QString& txt,
+    void addItem(QWidget* w, const QPixmap& pix, const QString& txt,
                  const QString& objName, bool expandBydefault);
-    void addItem(QWidget *w, const QString& txt,
+    void addItem(QWidget* w, const QString& txt,
                  const QString& objName, bool expandBydefault);
 
     /** Insert RLabelExpander item at box layout index with these settings :
@@ -202,13 +209,19 @@
         'objName'         : item object name used to read/save expanded settings to rc file.
         'expandBydefault' : item state by default (expanded or not).
      */
-    void insertItem(int index, QWidget *w, const QPixmap& pix, const QString& txt,
+    void insertItem(int index, QWidget* w, const QPixmap& pix, const QString& txt,
                     const QString& objName, bool expandBydefault);
-    void insertItem(int index, QWidget *w, const QString& txt,
+    void insertItem(int index, QWidget* w, const QString& txt,
                     const QString& objName, bool expandBydefault);
 
     void removeItem(int index);
 
+    void setCheckBoxVisible(int index, bool b);
+    bool checkBoxIsVisible(int index) const;
+
+    void setChecked(int index, bool b);
+    bool isChecked(int index) const;
+
     void setItemText(int index, const QString& txt);
     QString itemText (int index) const;
 
@@ -230,7 +243,7 @@
     int  count() const;
 
     RLabelExpander* widget(int index) const;
-    int indexOf(RLabelExpander *widget) const;
+    int indexOf(RLabelExpander* widget) const;
 
     void readSettings();
     void writeSettings();
@@ -238,10 +251,12 @@
 Q_SIGNALS:
 
     void signalItemExpanded(int index, bool b);
+    void signalItemToggled(int index, bool b);
 
 private Q_SLOTS:
 
     void slotItemExpanded(bool b);
+    void slotItemToggled(bool b);
 
 private:
 
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libraw/Changelog.txt kdegraphics/libs/libkdcraw/libraw/Changelog.txt
--- kdegraphics-4.4.4/libs/libkdcraw/libraw/Changelog.txt	2009-10-26 10:14:14.000000000 +0100
+++ kdegraphics/libs/libkdcraw/libraw/Changelog.txt	2010-06-10 17:10:40.115729532 +0200
@@ -1,3 +1,123 @@
+2010-05-15 Alex Tutubalin <lexa@lexa.ru>
+           * Fixed bug in 8-bit RAW processing code
+           * LibRaw 0.9.1-Release
+
+2010-04-26 Alex Tutubalin <lexa@lexa.ru>
+           * OpenMP support: OpenMP is possible under MinGW (untested)
+           * LibRaw 0.9.0-Release
+
+2010-04-21 Alex Tutubalin <lexa@lexa.ru>
+           * Finally fixed inconsistency in Fuji files processing
+           * New COLOR(row,col) call to get bayer color index in image[] array
+           * Old FC() call is deprecated and will be removed in future releases
+           * unprocessed_raw sample switched to COLOR() call
+           * LibRaw 0.9.0-Beta5
+
+
+2010-04-10 Alex Tutubalin <lexa@lexa.ru>
+           * Fixed bug in unpacking DNG files made from Fuji RAFs.
+           * LibRaw 0.9.0-Beta4
+
+2010-04-09 Alex Tutubalin <lexa@lexa.ru>
+
+           * Fixed typecast error (problem reported only on gcc 4.2.1/32bit)
+            in CRW files processing.
+
+           * C++ API call LibRaw::adjust_maximum() is now deprecated and
+             de-documented, use params.adjust_maximum_thr instead (on by default)
+
+           *  C-API call libraw_adjust_maximum() removed.
+
+           * New postprocessing parameter params.adjust_maximum_thr
+             This parameter replaces LibRaw::adjust_maximum(), but more flexible
+             Defaults are reasonable (0.75, same as in old adjust_maximum),
+             look into documentation for more details.
+
+           * Removed last OpenMP warning
+
+           * dcraw_emu's -c parameter now wants numeric (float) argument. This value
+             is assigned to params.adjust_maximum_thr.
+             Use -c 0.0 for dcraw compatibility.
+
+           * all client code should be recompiled due to structures size 
+             change
+
+           * LibRaw 0.9.0-Beta3
+
+
+2010-03-29 Alex Tutubalin <lexa@lexa.ru>
+           * Fixed a bug in channel_maximum[] calculation for
+             Panasonic cameras.
+           * channel_maximum[] data now calculated for ALL cameras.
+           * OpenMP warnings suppressed.
+           * Documented the -c command-line switch for dcraw_emu sample.
+           * Removed extra messages from dcraw_emu sample.
+           * LibRaw 0.9.0-Beta2
+
+2010-03-28 Alex Tutubalin <lexa@lexa.ru>
+           
+           New licensing:
+
+           * Triple licensing (selected by LibRaw user):
+
+              + LGPL 2.1 (http://www.gnu.org/licenses/lgpl-2.1.html)
+              + CDDL 1.0 (http://www.opensource.org/licenses/cddl1.txt)
+              + LibRaw Software License (27 March 2010 version)
+               (http://www.libraw.org/data/LICENSE.LibRaw.pdf)
+
+           * There is no separate LibRaw-Lite and LibRaw-Commercial versions,
+             only single LibRaw.
+             Current LibRaw-Lite and LibRaw-Commercial users should switch
+             to LibRaw without loss of functionality.
+             It is possible to change licensig too (e.g. from LGPL to CDDL
+             for LibRaw-Lite users and from LibRaw License to LGPL or CDDL
+             for LibRaw-Commercial users).
+
+           * No Foveon support :(
+             It is not possible to get good color from Foveon sensors with
+             *any* converter. So, there is no need to support these cameras.
+             Dcraw's Foveon-processing code is too strict licensed (GPL),
+             so we choose to drop it.
+             
+           New Features:
+
+           * New data field  colordata.channel_maximum[4] - per channel data
+            maximum (calculated for most cameras, 0 for others).
+
+           * New call LibRaw::adjust_maximum() (and libraw_adjust_maximum() in C API).
+             This call changes hardcoded colordata.maximum value to calculated
+             at unpack stage. This helps suppress false color in highlights
+             (magenta clouds and so).
+
+           * New command line parameter -c for dcraw_emu sample. Calls adjust_maximum()
+             for each processed file.
+
+           * all client code should be recompiled due to structures size 
+             change
+
+           * LibRaw 0.9.0-Beta1
+
+2010-02-06 Alex Tutubalin <lexa@lexa.ru>
+           * Fixed ambiguity in pow/sqrt calls (to make Sun C++ compiler happy)
+           * OpenMP is not supported under MS Visual Studio
+           * Masked a bug in RIFF format parser 
+           * LibRaw 0.8.6
+
+2009-12-30 Alex Tutubalin <lexa@lexa.ru>
+           * Fixed bug in simple_dcraw sample parameters processing
+           * Imported dcraw 8.99 (1.432):
+             + New cameras: Canon:  1D mk IV, Canon S90; Casio Z750, 
+               Nikon D3S, Pentax K-x, Sony A-500/550, Fuji S200EXR
+             + New color data for Canon G11 and Sony A850
+             + Changes in Canon sRAW processing
+             + Changes in Kodak metadata processing
+             + Changes in uncompressed Fuji files processing (FinePix S5xxx)
+           * LibRaw 0.8.5
+
+2009-11-21 Alex Tutubalin <lexa@lexa.ru>
+           + Fixed a bug in processing of uncompressed Phase One files 
+           * LibRaw 0.8.4
+
 2009-10-24 Alex Tutubalin <lexa@lexa.ru>
            + Imported dcraw 8.98/1.431:
              * New Cameras: Canon 7D, Panasonic GF1, Sony A850 and A380, 
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libraw/COPYRIGHT kdegraphics/libs/libkdcraw/libraw/COPYRIGHT
--- kdegraphics-4.4.4/libs/libkdcraw/libraw/COPYRIGHT	2009-09-04 13:30:32.000000000 +0200
+++ kdegraphics/libs/libkdcraw/libraw/COPYRIGHT	2010-06-10 17:10:40.115729532 +0200
@@ -1,358 +1,19 @@
-
  ** LibRaw: Raw images processing library **
 
- Copyright (C) 2008-2009 Alex Tutubalin <lexa@lexa.ru> and Illiah Borg <ib@pochtar.com>
+ Copyright (C) 2008-2010 LibRaw LLC (http://www.libraw.org, info@libraw.org)
  
 LibRaw is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2, or (at your option)
-any later version.  See below details.
-
-Contact author if you want to use and/or redistribute LibRaw under non
-GNU GPL license.
-
-
-LibRaw uses code from dcraw.c -- Dave Coffin's raw photo decoder,
-dcraw.c is copyright 1997-2008 by Dave Coffin, dcoffin a cybercom o net.
-
-========================================================================
-
-		    GNU GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
-
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
- 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Lesser General Public License instead.)  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-		    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The "Program", below,
-refers to any such program or work, and a "work based on the Program"
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term "modification".)  Each licensee is addressed as "you".
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
+it under the terms of the one of three licenses as you choose:
 
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
 
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
 
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
 
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
 
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and "any
-later version", you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-			    NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-	    How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License along
-    with this program; if not, write to the Free Software Foundation, Inc.,
-    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-
-Also add information on how to contact you by electronic and paper mail.
-
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
-
-    Gnomovision version 69, Copyright (C) year name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the program, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  <signature of Ty Coon>, 1 April 1989
-  Ty Coon, President of Vice
-
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Lesser General
-Public License instead of this License.
+LibRaw uses code from dcraw.c -- Dave Coffin's raw photo decoder,
+dcraw.c is copyright 1997-2009 by Dave Coffin, dcoffin a cybercom o net.
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libraw/internal/dcraw_common.cpp kdegraphics/libs/libkdcraw/libraw/internal/dcraw_common.cpp
--- kdegraphics-4.4.4/libs/libkdcraw/libraw/internal/dcraw_common.cpp	2009-12-31 14:27:23.000000000 +0100
+++ kdegraphics/libs/libkdcraw/libraw/internal/dcraw_common.cpp	2010-06-10 17:10:40.109103403 +0200
@@ -1,10 +1,11 @@
 /* 
    GENERATED FILE, DO NOT EDIT
-   Generated from dcraw/dcraw.c at Wed Dec 30 14:11:09 2009
+   Generated from dcraw/dcraw.c at Sun Jun  6 17:42:15 2010
    Look into original file (probably http://cybercom.net/~dcoffin/dcraw/dcraw.c)
    for copyright information.
 */
 
+#line 264 "dcraw/dcraw.c"
 #define CLASS LibRaw::
 #include "libraw/libraw_types.h"
 #define LIBRAW_LIBRARY_BUILD
@@ -12,7 +13,7 @@
 #include "libraw/libraw.h"
 #include "internal/defines.h"
 #include "internal/var_defines.h"
-
+#line 274 "dcraw/dcraw.c"
 
 #ifndef __GLIBC__
 char *my_memmem (char *haystack, size_t haystacklen,
@@ -27,6 +28,7 @@
 #define memmem my_memmem
 #endif
 
+#line 308 "dcraw/dcraw.c"
 
 ushort CLASS sget2 (uchar *s)
 {
@@ -101,26 +103,7 @@
   if ((order == 0x4949) == (ntohs(0x1234) == 0x1234))
       swab ((char*)pixel, (char*)pixel, count*2);
 }
-void CLASS canon_black (double dark[2], int nblack)
-{
-  int c, diff, row, col;
-
-#ifdef LIBRAW_LIBRARY_BUILD
-  if(!( filtering_mode & LIBRAW_FILTERING_NOBLACKS) )
-      {
-#endif
-  if (!nblack) return;
-  FORC(2) dark[c] /= nblack >> 1;
-  if ((diff = dark[0] - dark[1]))
-    for (row=0; row < height; row++)
-      for (col=1; col < width; col+=2)
-	BAYER(row,col) += diff;
-#ifdef LIBRAW_LIBRARY_BUILD
-      }
-#endif
-  dark[1] += diff;
-  black = (dark[0] + dark[1] + 1) / 2;
-}
+#line 386 "dcraw/dcraw.c"
 
 void CLASS canon_600_fixed_wb (int temp)
 {
@@ -268,7 +251,9 @@
       pix[7] = (dp[8] << 2) + (dp[9] >> 6    );
     }
     for (col=0; col < width; col++)
-      BAYER(row,col) = pixel[col];
+        {
+            BAYER(row,col) = pixel[col];
+        }
     for (col=width; col < raw_width; col++)
         {
             black += pixel[col];
@@ -291,6 +276,9 @@
       if ((val = BAYER(row,col) - black) < 0) val = 0;
       val = val * mul[row & 3][col & 1] >> 9;
       BAYER(row,col) = val;
+#ifdef LIBRAW_LIBRARY_BUILD
+      if((int)channel_maximum[FC(row,col)] < val ) channel_maximum[FC(row,col)] = val;
+#endif
     }
   canon_600_fixed_wb(1311);
   canon_600_auto_wb();
@@ -497,7 +485,8 @@
 int CLASS canon_has_lowbits()
 {
   uchar test[0x4000];
-  int ret=1, i;
+  int ret=1;
+  unsigned i;
 
   fseek (ifp, 0, SEEK_SET);
   fread (test, 1, sizeof test, ifp);
@@ -512,10 +501,9 @@
 void CLASS canon_compressed_load_raw()
 {
   ushort *pixel, *prow, *huff[2];
-  int nblocks, lowbits, i, c, row, r, col, save, val, nblack=0;
+  int nblocks, lowbits, i, c, row, r, col, save, val;
   unsigned irow, icol;
   int block, diffbuf[64], leaf, len, diff, carry=0, pnum=0, base[2];
-  double dark[2] = { 0,0 };
 
   crw_init_tables (tiff_compress, huff);
   pixel = (ushort *) calloc (raw_width*8, sizeof *pixel);
@@ -575,18 +563,26 @@
           if (irow >= height) continue; // skip for top/bottom rows
 #endif
 	icol = col - left_margin;
+	c = FC(irow,icol);
 	if (icol < width)
-	  BAYER(irow,icol) = pixel[r*raw_width+col];
+            {
+#ifdef LIBRAW_LIBRARY_BUILD
+                ushort val = pixel[r*raw_width+col];
+                if(channel_maximum[c] < val) channel_maximum[c]=val;
+#endif
+                BAYER(irow,icol) = pixel[r*raw_width+col];
+            }
 	else if (col > 1 && (unsigned) (col-left_margin+2) > width+3)
-	  dark[icol & 1] += (nblack++,pixel[r*raw_width+col]);
+	  cblack[c] += (cblack[4+c]++,pixel[r*raw_width+col]);
       }
     }
   }
   free (pixel);
   FORC(2) free (huff[c]);
-  canon_black (dark, nblack);
+  FORC4 if (cblack[4+c]) cblack[c] /= cblack[4+c];
 }
 
+#line 875 "dcraw/dcraw.c"
 int CLASS ljpeg_start (struct jhead *jh, int info_only)
 {
   int c, tag, len;
@@ -698,8 +694,7 @@
 
 void CLASS lossless_jpeg_load_raw()
 {
-  int jwide, jrow, jcol, val, jidx, i, j, row=0, col=0, nblack=0;
-  double dark[2] = { 0,0 };
+  int jwide, jrow, jcol, val, jidx, c, i, j, row=0, col=0;
   struct jhead jh;
   int min=INT_MAX;
   ushort *rp;
@@ -732,18 +727,22 @@
       if(dfp) *dfp = val;
 #endif
       if ((unsigned) (row-top_margin) < height) {
+	c = FC(row-top_margin,col-left_margin);
 	if ((unsigned) (col-left_margin) < width) {
+#ifdef LIBRAW_LIBRARY_BUILD
+            if(channel_maximum[c] < val) channel_maximum[c] = val;
+#endif
 	  BAYER(row-top_margin,col-left_margin) = val;
 	  if (min > val) min = val;
 	} else if (col > 1 && (unsigned) (col-left_margin+2) > width+3)
-	  dark[(col-left_margin) & 1] += (nblack++,val);
+	  cblack[c] += (cblack[4+c]++,val);
       }
       if (++col >= raw_width)
 	col = (row++,0);
     }
   }
   ljpeg_end (&jh);
-  canon_black (dark, nblack);
+  FORC4 if (cblack[4+c]) cblack[c] /= cblack[4+c];
   if (!strcasecmp(make,"KODAK"))
     black = min;
 }
@@ -809,7 +808,15 @@
       pix[1] = rp[0] + ((-5640*rp[1] - 11751*rp[2]) >> 14);
       pix[2] = rp[0] + ((29040*rp[1] -   101*rp[2]) >> 14);
     }
-    FORC3 rp[c] = CLIP(pix[c] * sraw_mul[c] >> 10);
+    FORC3 { 
+#ifdef LIBRAW_LIBRARY_BUILD
+        ushort val = CLIP(pix[c] * sraw_mul[c] >> 10);
+        rp[c] = val;
+        if(channel_maximum[c] < val) channel_maximum[c] = val;
+#else
+        rp[c] = CLIP(pix[c] * sraw_mul[c] >> 10);
+#endif
+    }
   }
   ljpeg_end (&jh);
   maximum = 0x3fff;
@@ -834,7 +841,11 @@
     if(!(filtering_mode & LIBRAW_FILTERING_NORAWCURVE))
         val = **rp < 0x1000 ? curve[**rp] : **rp;
     if (r < height && c < width)
-        BAYER(r,c) = val;
+        {
+            ushort color = COLOR(r,c);
+            image[((row) >> shrink)*iwidth + ((col) >> shrink)][color] = val;
+            if(channel_maximum[color] < val) channel_maximum[color] = val;
+        }
     else
         {
             ushort *dfp = get_masked_pointer(row+top_margin,col+left_margin);
@@ -929,7 +940,13 @@
       if (col < 2) hpred[col] = vpred[row & 1][col] += diff;
       else	   hpred[col & 1] += diff;
       if ((unsigned) (row-top_margin) < height && col < width)
-	BAYER(row-top_margin,col) = hpred[col & 1];
+          {
+#ifdef LIBRAW_LIBRARY_BUILD
+              ushort color = FC(row-top_margin,col);
+              if(channel_maximum[color] < hpred[col & 1])  channel_maximum[color] = hpred[col & 1];
+#endif
+              BAYER(row-top_margin,col) = hpred[col & 1];
+          }
 #ifdef LIBRAW_LIBRARY_BUILD
       else
         {
@@ -1020,6 +1037,8 @@
           xval = curve[LIM((short)xval,0,0x3fff)];
       if ((unsigned) (col-left_margin) < width)
           {
+              ushort color = FC(row,col-left_margin);
+              if(channel_maximum[color] < xval ) channel_maximum[color] = xval;
               BAYER(row,col-left_margin) =  xval;
           }
       else
@@ -1166,15 +1185,9 @@
             {
                 int rrow = row-top_margin;
                 int ccol = col-left_margin;
-                if (fuji_layout) {
-                    r = fuji_width - 1 - ccol + (rrow >> 1);
-                    c = ccol + ((rrow+1) >> 1);
-                } else {
-                    r = fuji_width - 1 + rrow - (ccol >> 1);
-                    c = rrow + ((ccol+1) >> 1);
-                }
-
-                image[((row-top_margin) >> shrink)*iwidth + ((col-left_margin) >> shrink)][FC(r,c)] = pixel[col];
+                ushort color = FCF(rrow,ccol);
+                image[((rrow) >> shrink)*iwidth + ((ccol) >> shrink)][color] = pixel[col];
+                if(channel_maximum[color] < pixel[col] ) channel_maximum[color] = pixel[col];
             }
         else
             {
@@ -1186,6 +1199,7 @@
   free (pixel);
 #endif
 }
+#line 1496 "dcraw/dcraw.c"
 void CLASS ppm_thumb()
 {
   char *thumb;
@@ -1253,7 +1267,14 @@
       row = todo[i] / raw_width - top_margin;
       col = todo[i] % raw_width - left_margin;
       if (row < height && col < width)
-	BAYER(row,col) = (todo[i+1] & 0x3ff);
+          {
+#ifdef LIBRAW_LIBRARY_BUILD
+              ushort color = FC(row,col);
+              if(channel_maximum[color] < (todo[i+1] & 0x3ff))
+                  channel_maximum[color] = (todo[i+1] & 0x3ff);
+#endif
+              BAYER(row,col) = (todo[i+1] & 0x3ff);
+          }
 #ifdef LIBRAW_LIBRARY_BUILD
       else
           {
@@ -1484,7 +1505,11 @@
             if(dfp)
                 *dfp = pixel[col];
             else
-                BAYER(row-top_margin,col-left_margin) = pixel[col];
+                {
+                    ushort color = FC(row-top_margin,col-left_margin);
+                    if(channel_maximum[color] < pixel[col]) channel_maximum[color] = pixel[col];
+                    BAYER(row-top_margin,col-left_margin) = pixel[col];
+                }
         }
   }
   free (pixel);
@@ -1595,7 +1620,11 @@
                   - ph1.t_black + t_black[row][(col /* - left_margin */) >= ph1.split_col]; // changed to fix Coffin's bug!
           if(col >= left_margin && col < width+left_margin)
               {
-                  if (i > 0) BAYER(row-top_margin,col-left_margin) = i;
+                  if (i > 0){
+                      ushort color = FC(row-top_margin,col-left_margin);
+                      BAYER(row-top_margin,col-left_margin) = i;
+                      if(channel_maximum[color] < i) channel_maximum[color] = i ;
+                  }
               }
           else
               {
@@ -1646,7 +1675,13 @@
 	if (diff == 65535) diff = -32768;
 	pred[c] += diff;
 	if (row >= 0 && row < height && (unsigned)(col+c) < width)
+            {
+#ifdef LIBRAW_LIBRARY_BUILD
+                ushort color = FC(row,col+c);
+                if(channel_maximum[color] < pred[c] ) channel_maximum[color]=pred[c];
+#endif
 	  BAYER(row,col+c) = pred[c];
+            }
 #ifdef LIBRAW_LIBRARY_BUILD
         else
             {
@@ -1678,8 +1713,19 @@
       read_shorts (pixel, raw_width);
       if ((row = r - top_margin) >= height) continue;
       for (col=0; col < width; col++)
-	if (filters)  BAYER(row,col) = pixel[col];
-	else image[row*width+col][c] = pixel[col];
+          {
+              if (filters)  BAYER(row,col) = pixel[col];
+              else image[row*width+col][c] = pixel[col];
+#ifdef LIBRAW_LIBRARY_BUILD
+              if(filters)
+                  {
+                      ushort color = FC(row,col);
+                      if(channel_maximum[color] < pixel[col]) channel_maximum[color] = pixel[col];
+                  }
+              else
+                  if(channel_maximum[c] < pixel[col]) channel_maximum[c] = pixel[col];
+#endif              
+          }
     }
   free (pixel);
   if (!filters) {
@@ -1688,6 +1734,7 @@
   }
 }
 
+#line 2034 "dcraw/dcraw.c"
 void CLASS sinar_4shot_load_raw()
 {
   ushort *pixel;
@@ -1729,7 +1776,13 @@
 
   for (row=0; row < height; row++)
     for (col=0; col < width; col++)
+        {
       read_shorts (image[row*width+col], 3);
+#ifdef LIBRAW_LIBRARY_BUILD
+      for(int c=0; c<3; c++)
+          if(image[row*width+col][c] > channel_maximum[c]) channel_maximum[c] = image[row*width+col][c];
+#endif
+        }
 }
 
 void CLASS packed_load_raw()
@@ -1766,12 +1819,20 @@
       val = bitbuf << (64-tiff_bps-vbits) >> (64-tiff_bps);
       i = (col ^ (bite == 24)) - left_margin;
       if ((unsigned) i < width)
-	BAYER(row,i) = val << (load_flags >> 6);
+          {
+#ifdef LIBRAW_LIBRARY_BUILD
+              ushort color = FC(row,i);
+              if( channel_maximum[color] < val ) channel_maximum[color] = val;
+              BAYER(row,i) = val;
+#else
+	BAYER(row,i) = val;
+#endif
+          }
       else if (load_flags & 32)
 #ifdef LIBRAW_LIBRARY_BUILD
           {
               ushort *dfp = get_masked_pointer(row,col);
-              if(dfp) *dfp = val << (load_flags >> 6);
+              if(dfp) *dfp = val;
 #endif
 	black += val;
 #ifdef LIBRAW_LIBRARY_BUILD
@@ -1800,7 +1861,7 @@
     read_shorts (pixel, width);
     fseek (ifp, 2*(raw_width - width), SEEK_CUR);
     for (col=0; col < width; col++)
-      if ((BAYER2(row,col) = pixel[col]) >> bits) derror();
+      if ((BAYER2(row,col) = pixel[col] >> load_flags) >> bits) derror();
   }
   free (pixel);
 #else
@@ -1814,10 +1875,12 @@
         {
             ushort *dfp = get_masked_pointer(row,col);
             if(dfp) 
-                *dfp = pixel[col];
+                *dfp = pixel[col] >> load_flags;
             else
                 {
-                    if ((BAYER2(row-top_margin,col-left_margin) = pixel[col]) >> bits) derror();
+                    ushort color = FC(row-top_margin,col-left_margin);
+                    if ((BAYER2(row-top_margin,col-left_margin) = pixel[col] >> load_flags) >> bits) derror();
+                    if (channel_maximum[color] < pixel[col]>>load_flags)channel_maximum[color]= pixel[col]>>load_flags;
                 }
         }
   }
@@ -1854,8 +1917,14 @@
 #else
       FORC(width) black += pixel[c];
 #endif
-    else
-      FORC(width) BAYER(row-top_margin,c) = pixel[c];
+      else
+              FORC(width){
+#ifdef LIBRAW_LIBRARY_BUILD
+                  ushort color = FC(row-top_margin,c);
+                  if(channel_maximum[color] < pixel[c]) channel_maximum[color] = pixel[c];
+#endif
+                  BAYER(row-top_margin,c) = pixel[c];
+              }
   }
   free (data);
   if (top_margin) black /= top_margin * width;
@@ -1906,7 +1975,15 @@
       } else if ((nonz[i & 1] = pana_bits(8)) || i > 11)
 	pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);
       if (col < width)
-      if ((BAYER(row,col) = pred[col & 1]) > 4098) derror();
+          {
+#ifdef LIBRAW_LIBRARY_BUILD
+              ushort color = FC(row,col);
+#endif
+              if ((BAYER(row,col) = pred[col & 1]) > 4098) derror();
+#ifdef LIBRAW_LIBRARY_BUILD
+              if( channel_maximum[color] < pred[col &1] ) channel_maximum[color] = pred[col &1];
+#endif
+          }
 #ifdef LIBRAW_LIBRARY_BUILD
       if(col>=width)
           {
@@ -1956,7 +2033,17 @@
 	  else pred = (w + n) >> 1;
 	} else pred = ABS(w-nw) > ABS(n-nw) ? w : n;
       }
+#ifdef LIBRAW_LIBRARY_BUILD
+      {
+          ushort val = pred + ((diff << 2) | low);
+          ushort color = FC(row,col);
+          if(val >> 12) derror();
+          BAYER(row,col)=val;
+          if(channel_maximum[color] < val ) channel_maximum[color] = val;
+      }
+#else
       if ((BAYER(row,col) = pred + ((diff << 2) | low)) >> 12) derror();
+#endif
     }
   }
 }
@@ -1984,7 +2071,14 @@
       BAYER(row,1533) = pixel[765] << 1;
     } else
       for (col=row & 1; col < 1534; col+=2)
-	BAYER(row,col) = pixel[col/2] << 1;
+          {
+#ifdef LIBRAW_LIBRARY_BUILD
+              ushort color = FC(row,col);
+              if(channel_maximum[color] < pixel[col/2] << 1)
+                  channel_maximum[color] = pixel[col/2] << 1;
+#endif
+              BAYER(row,col) = pixel[col/2] << 1;
+          }
   }
   maximum = 0xff << 1;
 }
@@ -2052,7 +2146,14 @@
     }
   for (row=0; row < height; row++)
     for (col=0; col < width; col++)
-      BAYER(row,col) = t_curve[pixel[row+2][col+2]];
+        {
+#ifdef LIBRAW_LIBRARY_BUILD
+            ushort color = FC(row,col);
+            if(channel_maximum[color] < t_curve[pixel[row+2][col+2]])
+                channel_maximum[color] = t_curve[pixel[row+2][col+2]];
+#endif
+            BAYER(row,col) = t_curve[pixel[row+2][col+2]];
+        }
   maximum = 0x3ff;
 }
 
@@ -2156,7 +2257,15 @@
 	}
   }
   for (i=0; i < iheight*iwidth*4; i++)
+#ifdef LIBRAW_LIBRARY_BUILD
+      {
+          ushort c = i%4;
+          image[0][i] = curve[image[0][i]];
+          if(channel_maximum[c] < image[0][i]) channel_maximum[c] = image[0][i];
+      }
+#else
     image[0][i] = curve[image[0][i]];
+#endif
   maximum = 0x3fff;
 }
 
@@ -2226,6 +2335,15 @@
       BAYER(row+1,col+1) = pixel[col+1][1] << 1;
       BAYER(row+0,col+1) = pixel[col][0] + pixel[col+1][0];
       BAYER(row+1,col+0) = pixel[col][2] + pixel[col+1][2];
+
+#ifdef LIBRAW_LIBRARY_BUILD
+      if(channel_maximum[FC(row+0,col+0)] < pixel[col+0][1] << 1) channel_maximum[FC(row+0,col+0)]=pixel[col+0][1]<<1;
+      if(channel_maximum[FC(row+1,col+1)] < pixel[col+1][1] << 1) channel_maximum[FC(row+1,col+1)]=pixel[col+1][1]<<1;
+      if(channel_maximum[FC(row+0,col+1)] < pixel[col][0] + pixel[col+1][0])
+          channel_maximum[FC(row+0,col+1)] = pixel[col][0] + pixel[col+1][0];
+      if(channel_maximum[FC(row+1,col+0)] < pixel[col][2] + pixel[col+1][2])
+          channel_maximum[FC(row+1,col+0)] = pixel[col][2] + pixel[col+1][2];
+#endif
     }
   }
   jpeg_finish_decompress (&cinfo);
@@ -2245,7 +2363,16 @@
     if (fread (pixel, 1, 848, ifp) < 848) derror();
     shift = row * mul[row & 3] + add[row & 3];
     for (col=0; col < width; col++)
+#ifdef LIBRAW_LIBRARY_BUILD
+        {
+            ushort val = pixel[(col + shift) % 848];
+            ushort color = FC(row,col);
+            BAYER(row,col) = val;
+            if(channel_maximum[color] < val) channel_maximum[color] = val;
+        }
+#else
       BAYER(row,col) = (ushort) pixel[(col + shift) % 848];
+#endif
   }
   maximum = 0xff;
 }
@@ -2282,7 +2409,11 @@
       if((unsigned) (row-top_margin)< height)
           {
               if ((unsigned) (col-left_margin) < width)
-                  BAYER(row,col-left_margin) = val;
+                  {
+                      ushort color=FC(row-top_margin,col-left_margin);
+                      if(channel_maximum[color] < val) channel_maximum[color] = val;
+                      BAYER(row-top_margin,col-left_margin) = val;
+                  }
               else
                   {
                       ushort *dfp = get_masked_pointer(row,col);
@@ -2327,7 +2458,12 @@
       rgb[1] = y-((cb + cr + 2) >> 2);
       rgb[2] = rgb[1] + cb;
       rgb[0] = rgb[1] + cr;
-      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];
+      FORC3{
+          image[row*width+col][c] = curve[LIM(rgb[c],0,255)];
+#ifdef LIBRAW_LIBRARY_BUILD
+          if(channel_maximum[c] < image[row*width+col][c]) channel_maximum[c] = image[row*width+col][c];
+#endif
+      }
     }
   }
   free (pixel);
@@ -2376,7 +2512,13 @@
       val = curve[pixel[pi++]];
 #endif
       if ((unsigned) (col-left_margin) < width)
+          {
+#ifdef LIBRAW_LIBRARY_BUILD
+              ushort color = FC(row,col-left_margin);
+              if(channel_maximum[color] < val ) channel_maximum[color]=val;
+#endif
 	BAYER(row,col-left_margin) = val;
+          }
       else
 #ifndef LIBRAW_LIBRARY_BUILD
           black += val;
@@ -2458,9 +2600,11 @@
 #else
       {
           ushort val = ret ? buf[i] : (pred[i & 1] += buf[i]);
+          ushort color = FC(row,col);
           if(!(filtering_mode & LIBRAW_FILTERING_NORAWCURVE))
               val = curve[val];
           BAYER(row,col+i)=val;
+          if(channel_maximum[color] < val ) channel_maximum[color]=val;
           if(curve[val]>>12) derror();
       }
 #endif
@@ -2495,6 +2639,9 @@
               FORC3 ip[c] = curve[LIM(y[j][k]+rgb[c], 0, 0xfff)];
           else
               FORC3 ip[c] = y[j][k]+rgb[c];;
+          FORC3
+              if(channel_maximum[c] < ip[c])
+                  channel_maximum[c] = ip[c];
 #endif
 	  }
       }
@@ -2513,7 +2660,12 @@
       kodak_65000_decode (buf, len*3);
       memset (rgb, 0, sizeof rgb);
       for (bp=buf, i=0; i < len; i++, ip+=4)
-	FORC3 if ((ip[c] = rgb[c] += *bp++) >> 12) derror();
+          FORC3{
+              if ((ip[c] = rgb[c] += *bp++) >> 12) derror();
+#ifdef LIBRAW_LIBRARY_BUILD
+              if(channel_maximum[c] < ip[c]) channel_maximum[c] = ip[c];
+#endif
+          }
     }
 }
 
@@ -2589,8 +2741,19 @@
     for (col=9; col < left_margin; col++)
       black += ntohs(pixel[col]);
     for (col=0; col < width; col++)
+#ifdef LIBRAW_LIBRARY_BUILD
+        {
+            ushort color = FC(row,col);
+            ushort  val = ntohs(pixel[col+left_margin]);
+            if(val>>14)
+                derror();
+            BAYER(row,col)=val;
+            if(channel_maximum[color] < val ) channel_maximum[color] = val;
+        }
+#else
       if ((BAYER(row,col) = ntohs(pixel[col+left_margin])) >> 14)
 	derror();
+#endif    
   }
   free (pixel);
   if (left_margin > 9)
@@ -2617,7 +2780,14 @@
       if ((diff & (1 << (len-1))) == 0)
 	diff -= (1 << len) - 1;
       if ((sum += diff) >> 12) derror();
-      if (row < height) BAYER(row,col) = sum;
+      if (row < height)
+          {
+              BAYER(row,col) = sum;
+#ifdef LIBRAW_LIBRARY_BUILD
+            ushort color = FC(row,col);
+            if(channel_maximum[color] < sum ) channel_maximum[color] = sum;
+#endif
+          }
 #ifdef LIBRAW_LIBRARY_BUILD
       else
           {
@@ -2654,13 +2824,15 @@
 	}
       for (i=0; i < 16; i++, col+=2)
 #ifndef LIBRAW_LIBRARY_BUILD
-	  BAYER(row,col) = curve[pix[i] << 1] >> 1;
+          BAYER(row,col) = curve[pix[i] << 1] >> 2;
 #else
         {
             ushort val = pix[i];
+            ushort color = FC(row,col);
             if(!(filtering_mode & LIBRAW_FILTERING_NORAWCURVE))
-                val = curve[val<<1]>>1;
+                val = curve[val<<1]>>2;
             BAYER(row,col)=val;
+            if(channel_maximum[color] < val ) channel_maximum[color] = val;
         }
 #endif
       col -= col & 1 ? 1:31;
@@ -2732,7 +2904,14 @@
     row = pix / raw_width - top_margin;
     col = pix % raw_width - left_margin;
     if (row < height && col < width)
-      BAYER(row,col) = pred[pix & 1];
+        {
+#ifdef LIBRAW_LIBRARY_BUILD
+            ushort color = FC(row,col);
+            if(channel_maximum[color] < pred[pix & 1])
+                channel_maximum[color] = pred[pix & 1];
+#endif
+            BAYER(row,col) = pred[pix & 1];
+        }
 #ifdef LIBRAW_LIBRARY_BUILD
     else
         {
@@ -2815,6 +2994,7 @@
     smal_decode_segment (seg+i, holes);
   if (holes) fill_holes (holes);
 }
+#line 4107 "dcraw/dcraw.c"
 
 void CLASS gamma_curve (double pwr, double ts, int mode, int imax)
 {
@@ -2994,7 +3174,7 @@
 void CLASS wavelet_denoise()
 {
   float *fimg=0, *temp, thold, mul[2], avg, diff;
-  int scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast;
+  int scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];
   ushort *window[4];
   static const float noise[] =
   { 0.8002,0.2735,0.1202,0.0585,0.0291,0.0152,0.0080,0.0044 };
@@ -3006,6 +3186,7 @@
   while (maximum << scale < 0x10000) scale++;
   maximum <<= --scale;
   black <<= scale;
+  FORC4 cblack[c] <<= scale;
   if ((size = iheight*iwidth) < 0x15550000)
     fimg = (float *) malloc ((size*3 + iheight + iwidth) * sizeof *fimg);
   merror (fimg, "wavelet_denoise()");
@@ -3040,8 +3221,10 @@
       image[i][c] = CLIP(SQR(fimg[i]+fimg[lpass+i])/0x10000);
   }
   if (filters && colors == 3) {  /* pull G1 and G3 closer together */
-    for (row=0; row < 2; row++)
+    for (row=0; row < 2; row++) {
       mul[row] = 0.125 * pre_mul[FC(row+1,0) | 1] / pre_mul[FC(row,0) | 1];
+      blk[row] = cblack[FC(row,0) | 1];
+    }
     for (i=0; i < 4; i++)
       window[i] = (ushort *) fimg + width*i;
     for (wlast=-1, row=1; row < height-1; row++) {
@@ -3054,8 +3237,8 @@
       thold = threshold/512;
       for (col = (FC(row,0) & 1)+1; col < width-1; col+=2) {
 	avg = ( window[0][col-1] + window[0][col+1] +
-		window[2][col-1] + window[2][col+1] - black*4 )
-	      * mul[row & 1] + (window[1][col] - black) * 0.5 + black;
+		window[2][col-1] + window[2][col+1] - blk[~row & 1]*4 )
+	      * mul[row & 1] + (window[1][col] + blk[row & 1]) * 0.5;
 	avg = avg < 0 ? 0 : sqrt(avg);
 	diff = sqrt((double)(BAYER(row,col))) - avg;
 	if      (diff < -thold) diff += thold;
@@ -3071,7 +3254,7 @@
 void CLASS wavelet_denoise()
 {
   float *fimg=0, *temp, thold, mul[2], avg, diff;
-  int scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast;
+   int scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];
   ushort *window[4];
   static const float noise[] =
   { 0.8002,0.2735,0.1202,0.0585,0.0291,0.0152,0.0080,0.0044 };
@@ -3083,13 +3266,14 @@
   while (maximum << scale < 0x10000) scale++;
   maximum <<= --scale;
   black <<= scale;
+  FORC4 cblack[c] <<= scale;
   if ((size = iheight*iwidth) < 0x15550000)
     fimg = (float *) malloc ((size*3 + iheight + iwidth) * sizeof *fimg);
   merror (fimg, "wavelet_denoise()");
   temp = fimg + size*3;
   if ((nc = colors) == 3 && filters) nc++;
 #ifdef LIBRAW_LIBRARY_BUILD
-#pragma omp parallel default(shared) private(i,col,row,thold,lev,lpass,hpass,temp) firstprivate(c,scale,size) 
+#pragma omp parallel default(shared) private(i,col,row,thold,lev,lpass,hpass,temp,c) firstprivate(scale,size) 
 #endif
   {
       temp = (float*)malloc( (iheight + iwidth) * sizeof *fimg);
@@ -3143,8 +3327,10 @@
  * second part should be easyer, but did not yet get it right.
  */
   if (filters && colors == 3) {  /* pull G1 and G3 closer together */
-    for (row=0; row < 2; row++)
+   for (row=0; row < 2; row++){
       mul[row] = 0.125 * pre_mul[FC(row+1,0) | 1] / pre_mul[FC(row,0) | 1];
+      blk[row] = cblack[FC(row,0) | 1];
+   }
     for (i=0; i < 4; i++)
       window[i] = (ushort *) fimg + width*i;
     for (wlast=-1, row=1; row < height-1; row++) {
@@ -3157,10 +3343,10 @@
       thold = threshold/512;
       for (col = (FC(row,0) & 1)+1; col < width-1; col+=2) {
 	avg = ( window[0][col-1] + window[0][col+1] +
-		window[2][col-1] + window[2][col+1] - black*4 )
-	      * mul[row & 1] + (window[1][col] - black) * 0.5 + black;
+		window[2][col-1] + window[2][col+1] - blk[~row & 1]*4 )
+	      * mul[row & 1] + (window[1][col] + blk[row & 1]) * 0.5;
 	avg = avg < 0 ? 0 : sqrt(avg);
-	diff = sqrt(BAYER(row,col)) - avg;
+	diff = sqrt((double)BAYER(row,col)) - avg;
 	if      (diff < -thold) diff += thold;
 	else if (diff >  thold) diff -= thold;
 	else diff = 0;
@@ -3173,6 +3359,53 @@
 
 #endif
 
+
+
+// green equilibration
+void CLASS green_matching()
+{
+  int i,j;
+  double m1,m2,c1,c2;
+  int o1_1,o1_2,o1_3,o1_4;
+  int o2_1,o2_2,o2_3,o2_4;
+  ushort (*img)[4];
+  const int margin = 3;
+  int oj = 2, oi = 2;
+  float f;
+  const float thr = 0.01f;
+  if(FC(oj, oi) != 3) oj++;
+  if(FC(oj, oi) != 3) oi++;
+
+  img = (ushort (*)[4]) calloc (height*width, sizeof *image);
+  merror (img, "green_matching()");
+  memcpy(img,image,height*width*sizeof *image);
+
+  for(j=oj;j<height-margin;j+=2)
+    for(i=oi;i<width-margin;i+=2){
+      o1_1=img[(j-1)*width+i-1][1];
+      o1_2=img[(j-1)*width+i+1][1];
+      o1_3=img[(j+1)*width+i-1][1];
+      o1_4=img[(j+1)*width+i+1][1];
+      o2_1=img[(j-2)*width+i][3];
+      o2_2=img[(j+2)*width+i][3];
+      o2_3=img[j*width+i-2][3];
+      o2_4=img[j*width+i+2][3];
+
+      m1=(o1_1+o1_2+o1_3+o1_4)/4.0;
+      m2=(o2_1+o2_2+o2_3+o2_4)/4.0;
+
+      c1=(abs(o1_1-o1_2)+abs(o1_1-o1_3)+abs(o1_1-o1_4)+abs(o1_2-o1_3)+abs(o1_3-o1_4)+abs(o1_2-o1_4))/6.0;
+      c2=(abs(o2_1-o2_2)+abs(o2_1-o2_3)+abs(o2_1-o2_4)+abs(o2_2-o2_3)+abs(o2_3-o2_4)+abs(o2_2-o2_4))/6.0;
+      if((img[j*width+i][3]<maximum*0.95)&&(c1<maximum*thr)&&(c2<maximum*thr))
+      {
+        f = image[j*width+i][3]*m1/m2;
+        image[j*width+i][3]=f>0xffff?0xffff:f;
+      }
+    }
+  free(img);
+}
+
+
 void CLASS scale_colors()
 {
   unsigned bottom, right, size, row, col, ur, uc, i, x, y, c, sum[8];
@@ -3185,6 +3418,7 @@
   RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS,0,2);
 #endif
 
+  FORC4 cblack[c] += black;
   if (user_mul[0])
     memcpy (pre_mul, user_mul, sizeof pre_mul);
   if (use_auto_wb || (use_camera_wb && cam_mul[0] == -1)) {
@@ -3203,7 +3437,7 @@
 	      } else
 		val = image[y*width+x][c];
 	      if (val > maximum-25) goto skip_block;
-	      if ((val -= black) < 0) val = 0;
+	      if ((val -= cblack[c]) < 0) val = 0;
 	      sum[c] += val;
 	      sum[c+4]++;
 	      if (filters) break;
@@ -3221,7 +3455,7 @@
     for (row=0; row < 8; row++)
       for (col=0; col < 8; col++) {
 	c = FC(row,col);
-	if ((val = white[row][col] - black) > 0)
+	if ((val = white[row][col] - cblack[c]) > 0)
 	  sum[c] += val;
 	sum[c+4]++;
       }
@@ -3254,6 +3488,13 @@
   sat = maximum;
   if (threshold) wavelet_denoise();
   maximum -= black;
+#ifdef LIBRAW_LIBRARY_BUILD
+  for(i=0;i<4;i++)
+      if(channel_maximum[i]>=cblack[i])
+          channel_maximum[i]-=cblack[i];
+      else
+          channel_maximum[i] = 0;
+#endif
   for (dmin=DBL_MAX, dmax=c=0; c < 4; c++) {
     if (dmin > pre_mul[c])
 	dmin = pre_mul[c];
@@ -3274,7 +3515,7 @@
   for (i=0; i < size*4; i++) {
     val = image[0][i];
     if (!val) continue;
-    val -= black;
+    val -= cblack[i & 3];
     val *= scale_mul[i & 3];
     image[0][i] = CLIP(val);
   }
@@ -3430,7 +3671,7 @@
 
    "Interpolation using a Threshold-based variable number of gradients"
 
-   described in http://scien.stanford.edu/class/psych221/projects/99/tingchen/algodep/vargra.html
+   described in http://scien.stanford.edu/pages/labsite/1999/psych221/projects/99/tingchen/algodep/vargra.html
 
    I've extended the basic idea to work with non-Bayer filter arrays.
    Gradients are numbered clockwise from NW=0 to W=7.
@@ -3582,6 +3823,9 @@
 /*  Fill in the green layer with gradients and pattern recognition: */
 #ifdef LIBRAW_LIBRARY_BUILD
   RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,0,3);
+#ifdef _OPENMP
+#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)
+#endif
 #endif
   for (row=3; row < height-3; row++)
     for (col=3+(FC(row,3) & 1), c=FC(row,col); col < width-3; col+=2) {
@@ -3601,6 +3845,9 @@
 /*  Calculate red and blue for each green pixel:		*/
 #ifdef LIBRAW_LIBRARY_BUILD
   RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,1,3);
+#ifdef _OPENMP
+#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)
+#endif
 #endif
   for (row=1; row < height-1; row++)
     for (col=1+(FC(row,2) & 1), c=FC(row,col+1); col < width-1; col+=2) {
@@ -3612,6 +3859,9 @@
 /*  Calculate blue for red pixels and vice versa:		*/
 #ifdef LIBRAW_LIBRARY_BUILD
   RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE,2,3);
+#ifdef _OPENMP
+#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)
+#endif
 #endif
   for (row=1; row < height-1; row++)
     for (col=1+(FC(row,1) & 1), c=2-FC(row,col); col < width-1; col+=2) {
@@ -3785,7 +4035,7 @@
 
   for (i=0; i < 0x10000; i++) {
     r = i / 65535.0;
-    cbrt[i] = r > 0.008856 ? pow(r,1/3.0) : 7.787*r + 16/116.0;
+    cbrt[i] = r > 0.008856 ? pow((double)r,1/3.0) : 7.787*r + 16/116.0;
   }
   for (i=0; i < 3; i++)
     for (j=0; j < colors; j++)
@@ -3795,7 +4045,7 @@
   border_interpolate(5);
 
 #ifdef LIBRAW_LIBRARY_BUILD
-#pragma omp parallel private(buffer,rgb,lab,homo,top,left,row,c,col,pix,val,d,rix,xyz,lix,tc,tr,ldiff,abdiff,leps,abeps,hm,i,j) firstprivate(cbrt) shared(xyz_cam)
+#pragma omp parallel default(shared) private(buffer,rgb,lab,homo,top,left,row,c,col,pix,val,d,rix,xyz,lix,tc,tr,ldiff,abdiff,leps,abeps,hm,i,j) firstprivate(cbrt) shared(xyz_cam)
 #endif
   {
     buffer = (char *) malloc (26*TS*TS);		/* 1664 kB */
@@ -4093,6 +4343,7 @@
   }
 }
 
+#line 5459 "dcraw/dcraw.c"
 void CLASS parse_makernote (int base, int uptag)
 {
   static const uchar xlat[2][256] = {
@@ -4315,14 +4566,13 @@
     if (tag == 0x200 && len == 3)
       shot_order = (get4(),get4());
     if (tag == 0x200 && len == 4)
-      black = (get2()+get2()+get2()+get2())/4;
+      FORC4 cblack[c ^ c >> 1] = get2();
     if (tag == 0x201 && len == 4)
       goto get2_rggb;
     if (tag == 0x220 && len == 53)
       meta_offset = ftell(ifp) + 14;
-    if (tag == 0x401 && type == 4 && len == 4) {
-      black = (get4()+get4()+get4()+get4())/4;
-    }
+    if (tag == 0x401 && type == 4 && len == 4)
+      FORC4 cblack[c ^ c >> 1] = get4();
     if (tag == 0xe01) {		/* Nikon Capture Note */
       type = order;
       order = 0x4949;
@@ -4361,8 +4611,7 @@
 #endif
         }
     if ((tag == 0x1012 || tag == 0x20400600) && len == 4)
-      for (black = i=0; i < 4; i++)
-	black += get2() << 2;
+      FORC4 cblack[c ^ c >> 1] = get2();
     if (tag == 0x1017 || tag == 0x20400100)
         {
       cam_mul[0] = get2() / 256.0;
@@ -4395,7 +4644,7 @@
     if (tag == 0x2040)
       parse_makernote (base, 0x2040);
     if (tag == 0xb028) {
-      fseek (ifp, get4(), SEEK_SET);
+      fseek (ifp, get4()+base, SEEK_SET);
       parse_thumb_note (base, 136, 137);
     }
     if (tag == 0x4001 && len > 500) {
@@ -4634,13 +4883,15 @@
   }
 }
 
+#line 6002 "dcraw/dcraw.c"
 int CLASS parse_tiff_ifd (int base)
 {
   unsigned entries, tag, type, len, plen=16, save;
   int ifd, use_cm=0, cfa, i, j, c, ima_len=0;
+  int blrr=1, blrc=1, dblack[] = { 0,0,0,0 };
   char software[64], *cbuf, *cp;
   uchar cfa_pat[16], cfa_pc[] = { 0,1,2,3 }, tab[256];
-  double dblack, cc[4][4], cm[4][3], cam_xyz[4][3], num;
+  double cc[4][4], cm[4][3], cam_xyz[4][3], num;
   double ab[]={ 1,1,1,1 }, asn[] = { 0,0,0,0 }, xyz[] = { 1,1,1 };
   unsigned sony_curve[] = { 0,0,0,0,0,4095 };
   unsigned *buf, sony_offset=0, sony_length=0, sony_key=0;
@@ -4686,15 +4937,19 @@
 	thumb_offset = ftell(ifp) - 2;
 	thumb_length = len;
 	break;
-      case 2: case 256:			/* ImageWidth */
+      case 61440:			/* Fuji HS10 table */
+	parse_tiff_ifd (base);
+	break;
+      case 2: case 256: case 61441:	/* ImageWidth */
 	tiff_ifd[ifd].t_width = getint(type);
 	break;
-      case 3: case 257:			/* ImageHeight */
+      case 3: case 257: case 61442:	/* ImageHeight */
 	tiff_ifd[ifd].t_height = getint(type);
 	break;
       case 258:				/* BitsPerSample */
+      case 61443:
 	tiff_ifd[ifd].samples = len & 7;
-	tiff_ifd[ifd].bps = get2();
+	tiff_ifd[ifd].bps = getint(type);
 	break;
       case 259:				/* Compression */
 	tiff_ifd[ifd].comp = get2();
@@ -4717,6 +4972,7 @@
 	load_flags = 0x2008;
       case 273:				/* StripOffset */
       case 513:
+      case 61447:
 	tiff_ifd[ifd].offset = get4()+base;
 	if (!tiff_ifd[ifd].bps) {
 	  fseek (ifp, tiff_ifd[ifd].offset, SEEK_SET);
@@ -4737,8 +4993,12 @@
 	break;
       case 279:				/* StripByteCounts */
       case 514:
+      case 61448:
 	tiff_ifd[ifd].bytes = get4();
 	break;
+      case 61454:
+	FORC3 cam_mul[(4-c) % 3] = getint(type);
+	break;
       case 305:  case 11:		/* Software */
 	fgets (software, 64, ifp);
 	if (!strncmp(software,"Adobe",5) ||
@@ -4808,7 +5068,9 @@
 #endif
 	break;
       case 29459:
-	FORC4 cam_mul[c ^ (c >> 1)] = get2();
+       FORC4 cam_mul[c] = get2();
+       i = (cam_mul[1] == 1024 && cam_mul[2] == 1024) << 1;
+       SWAP (cam_mul[i],cam_mul[i+1])
 #ifdef LIBRAW_LIBRARY_BUILD
         color_flags.cam_mul_state = LIBRAW_COLORSTATE_LOADED;
 #endif
@@ -4986,12 +5248,28 @@
       case 50712:			/* LinearizationTable */
 	linear_table (len);
 	break;
+      case 50713:			/* BlackLevelRepeatDim */
+	blrr = get2();
+	blrc = get2();
+	break;
       case 50714:			/* BlackLevel */
-      case 50715:			/* BlackLevelDeltaH */
-      case 50716:			/* BlackLevelDeltaV */
-	for (dblack=i=0; i < len; i++)
-	  dblack += getreal(type);
-	black += dblack/len + 0.5;
+	black = getreal(type);
+	if (!filters || !~filters) break;
+	dblack[0] = black;
+	dblack[1] = (blrc == 2) ? getreal(type):dblack[0];
+	dblack[2] = (blrr == 2) ? getreal(type):dblack[0];
+	dblack[3] = (blrc == 2 && blrr == 2) ? getreal(type):dblack[1];
+	if (colors == 3)
+	  filters |= ((filters >> 2 & 0x22222222) |
+		      (filters << 2 & 0x88888888)) & filters << 1;
+	FORC4 cblack[filters >> (c << 1) & 3] = dblack[c];
+	black = 0;
+	break;
+     case 50715:   /* BlackLevelDeltaH */
+     case 50716:   /* BlackLevelDeltaV */
+	for (num=i=0; i < len; i++)
+	   num += getreal(type);
+	black += num/len + 0.5;
 	break;
       case 50717:			/* WhiteLevel */
 	maximum = getint(type);
@@ -5156,9 +5434,8 @@
 	}
 	if (tiff_ifd[raw].bytes*5 == raw_width*raw_height*8) {
 	  tiff_bps = 12;
-	  maximum = 0xffff;
 	  load_raw = &CLASS packed_load_raw;
-	  load_flags = 273;
+	  load_flags = 17;
 	}
 	break;
       case 6:  case 7:  case 99:
@@ -5174,9 +5451,10 @@
 	  raw_height += 8;
 	  load_raw = &CLASS sony_arw_load_raw;			break;
 	}
-	load_flags = 79;
+	load_flags = 15;
       case 32769:
 	load_flags++;
+      case 32770:
       case 32773:
 	load_raw = &CLASS packed_load_raw;			break;
       case 34713:
@@ -5406,7 +5684,7 @@
       fread (artist, 64, 1, ifp);
     if (type == 0x080a) {
       fread (make, 64, 1, ifp);
-      fseek (ifp, strlen(make) - 63, SEEK_CUR);
+      fseek (ifp, ((INT64)strlen(make)) - 63, SEEK_CUR);
       fread (model, 64, 1, ifp);
     }
     if (type == 0x1810) {
@@ -5674,6 +5952,11 @@
         }
     fseek (ifp, save+len, SEEK_SET);
   }
+  if (!raw_height) {
+    filters = 0x16161616;
+    load_raw = &CLASS packed_load_raw;
+    load_flags = 24;
+  }
   height <<= fuji_layout;
   width  >>= fuji_layout;
 }
@@ -5717,9 +6000,13 @@
   size = get4();
   end = ftell(ifp) + size;
   if (!memcmp(tag,"RIFF",4) || !memcmp(tag,"LIST",4)) {
+      int cnt=0;
     get4();
     while (ftell(ifp)+7 < end)
-      parse_riff();
+        {
+            parse_riff();
+            if(cnt++>10000) break; // no more than 10k times
+        }
   } else if (!memcmp(tag,"nctg",4)) {
     while (ftell(ifp)+7 < end) {
       i = get2();
@@ -5814,6 +6101,7 @@
   data_offset  = (INT64) get4() + 8;
   data_offset += (INT64) get4() << 32;
 }
+#line 7321 "dcraw/dcraw.c"
 void CLASS adobe_coeff (const char *p_make, const char *p_model)
 {
   static const struct {
@@ -5860,6 +6148,8 @@
 	{ 5784,-262,-821,-7539,15064,2672,-1982,2681,7427 } },
     { "Canon EOS 500D", 0, 0x3479,
 	{ 4763,712,-646,-6821,14399,2640,-1921,3276,6561 } },
+    { "Canon EOS 550D", 0, 0x3dd7,
+	{ 6941,-1164,-857,-3825,11597,2534,-416,1540,6039 } },
     { "Canon EOS 1000D", 0, 0xe43,
 	{ 6771,-1139,-977,-7818,15123,2928,-1244,1437,7533 } },
     { "Canon EOS-1Ds Mark III", 0, 0x3bb0,
@@ -5966,6 +6256,8 @@
 	{ 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },
     { "FUJIFILM FinePix S100FS", 514, 0,
 	{ 11521,-4355,-1065,-6524,13767,3058,-1466,1984,6045 } },
+    { "FUJIFILM FinePix S200EXR", 512, 0x3fff,
+	{ 0 } },
     { "FUJIFILM FinePix S20Pro", 0, 0,
 	{ 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },
     { "FUJIFILM FinePix S2Pro", 128, 0,
@@ -5976,9 +6268,9 @@
 	{ 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },
     { "FUJIFILM FinePix S5000", 0, 0,
 	{ 8754,-2732,-1019,-7204,15069,2276,-1702,2334,6982 } },
-    { "FUJIFILM FinePix S5100", 0, 0x3e00,
+    { "FUJIFILM FinePix S5100", 0, 0,
 	{ 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },
-    { "FUJIFILM FinePix S5500", 0, 0x3e00,
+    { "FUJIFILM FinePix S5500", 0, 0,
 	{ 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },
     { "FUJIFILM FinePix S5200", 0, 0,
 	{ 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },
@@ -6000,6 +6292,8 @@
 	{ 21461,-10807,-1441,-2332,10599,1999,289,875,7703 } },
     { "FUJIFILM IS Pro", 0, 0,
 	{ 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },
+    { "FUJIFILM FinePix HS10 HS11", 79, 0xf68, /* DJC */
+	{ 12123,-3090,-1806,-1486,10894,593,-683,2369,3114 } },
     { "Imacon Ixpress", 0, 0,		/* DJC */
 	{ 7025,-1415,-704,-5188,13765,1424,-1248,2742,6038 } },
     { "KODAK NC2000", 0, 0,
@@ -6048,6 +6342,8 @@
 	{ 12805,-4662,-1376,-7480,15267,2360,-1626,2194,7904 } },
     { "KODAK EasyShare Z980", 0, 0,
 	{ 11313,-3559,-1101,-3893,11891,2257,-1214,2398,4908 } },
+    { "KODAK EasyShare Z981", 0, 0,
+	{ 12729,-4717,-1188,-1367,9187,2582,274,860,4411 } },
     { "KODAK EASYSHARE Z1015", 0, 0xef1,
 	{ 11265,-4286,-992,-4694,12343,2647,-1090,1523,5447 } },
     { "Leaf CMost", 0, 0,
@@ -6164,11 +6460,11 @@
 	{ 10793,-3791,-1146,-7498,15177,2488,-1390,1577,7321 } },
     { "OLYMPUS C80", 0, 0,
 	{ 8606,-2509,-1014,-8238,15714,2703,-942,979,7760 } },
-    { "OLYMPUS E-10", 0, 0xffc0,
+    { "OLYMPUS E-10", 0, 0xffc,
 	{ 12745,-4500,-1416,-6062,14542,1580,-1934,2256,6603 } },
-    { "OLYMPUS E-1", 0, 0xfff0,
+    { "OLYMPUS E-1", 0, 0,
 	{ 11846,-4767,-945,-7027,15878,1089,-2699,4122,8311 } },
-    { "OLYMPUS E-20", 0, 0xffc0,
+    { "OLYMPUS E-20", 0, 0xffc,
 	{ 13173,-4732,-1499,-5807,14036,1895,-2045,2452,7142 } },
     { "OLYMPUS E-300", 0, 0,
 	{ 7828,-1761,-348,-5788,14071,1830,-2853,4518,6557 } },
@@ -6178,7 +6474,7 @@
 	{ 8144,-1861,-1111,-7763,15894,1929,-1865,2542,7607 } },
     { "OLYMPUS E-3", 0, 0xf99,
 	{ 9487,-2875,-1115,-7533,15606,2010,-1618,2100,7389 } },
-    { "OLYMPUS E-400", 0, 0xfff0,
+    { "OLYMPUS E-400", 0, 0,
 	{ 6169,-1483,-21,-7107,14761,2536,-2904,3580,8568 } },
     { "OLYMPUS E-410", 0, 0xf6a,
 	{ 8856,-2582,-1026,-7761,15766,2082,-2009,2575,7469 } },
@@ -6186,7 +6482,7 @@
 	{ 8746,-2425,-1095,-7594,15612,2073,-1780,2309,7416 } },
     { "OLYMPUS E-450", 0, 0xfd2,
 	{ 8745,-2425,-1095,-7594,15613,2073,-1780,2309,7416 } },
-    { "OLYMPUS E-500", 0, 0xfff0,
+    { "OLYMPUS E-500", 0, 0,
 	{ 8136,-1968,-299,-5481,13742,1871,-2556,4205,6630 } },
     { "OLYMPUS E-510", 0, 0xf6a,
 	{ 8785,-2529,-1033,-7639,15624,2112,-1783,2300,7817 } },
@@ -6196,6 +6492,8 @@
 	{ 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },
     { "OLYMPUS E-P1", 0, 0xffd,
 	{ 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },
+    { "OLYMPUS E-PL1", 0, 0,
+	{ 11408,-4289,-1215,-4286,12385,2118,-387,1467,7787 } },
     { "OLYMPUS SP350", 0, 0,
 	{ 12078,-4836,-1069,-6671,14306,2578,-786,939,7418 } },
     { "OLYMPUS SP3", 0, 0,
@@ -6236,25 +6534,25 @@
 	{ 8843,-2837,-625,-5025,12644,2668,-411,1234,7410 } },
     { "PENTAX K-7", 0, 0,
 	{ 9142,-2947,-678,-8648,16967,1663,-2224,2898,8615 } },
-    { "Panasonic DMC-FZ8", 0, 0xf7f0,
+    { "Panasonic DMC-FZ8", 0, 0xf7f,
 	{ 8986,-2755,-802,-6341,13575,3077,-1476,2144,6379 } },
     { "Panasonic DMC-FZ18", 0, 0,
 	{ 9932,-3060,-935,-5809,13331,2753,-1267,2155,5575 } },
     { "Panasonic DMC-FZ28", 15, 0xfff,
 	{ 10109,-3488,-993,-5412,12812,2916,-1305,2140,5543 } },
-    { "Panasonic DMC-FZ30", 0, 0xf94c,
+    { "Panasonic DMC-FZ30", 0, 0xf94,
 	{ 10976,-4029,-1141,-7918,15491,2600,-1670,2071,8246 } },
     { "Panasonic DMC-FZ35", 147, 0xfff,
 	{ 9938,-2780,-890,-4604,12393,2480,-1117,2304,4620 } },
-    { "Panasonic DMC-FZ50", 0, 0xfff0,	/* aka "LEICA V-LUX1" */
+    { "Panasonic DMC-FZ50", 0, 0xfff,	/* aka "LEICA V-LUX1" */
 	{ 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },
     { "Panasonic DMC-L10", 15, 0xf96,
 	{ 8025,-1942,-1050,-7920,15904,2100,-2456,3005,7039 } },
-    { "Panasonic DMC-L1", 0, 0xf7fc,	/* aka "LEICA DIGILUX 3" */
+    { "Panasonic DMC-L1", 0, 0x3dff,	/* aka "LEICA DIGILUX 3" */
 	{ 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },
     { "Panasonic DMC-LC1", 0, 0,	/* aka "LEICA DIGILUX 2" */
 	{ 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },
-    { "Panasonic DMC-LX1", 0, 0xf7f0,	/* aka "LEICA D-LUX2" */
+    { "Panasonic DMC-LX1", 0, 0x3dfc,	/* aka "LEICA D-LUX2" */
 	{ 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },
     { "Panasonic DMC-LX2", 0, 0,	/* aka "LEICA D-LUX3" */
 	{ 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },
@@ -6262,8 +6560,12 @@
 	{ 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },
     { "Panasonic DMC-FX150", 15, 0xfff,
 	{ 9082,-2907,-925,-6119,13377,3058,-1797,2641,5609 } },
+    { "Panasonic DMC-G10", 0, 0,
+	{ 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },
     { "Panasonic DMC-G1", 15, 0xfff,
 	{ 8199,-2065,-1056,-8124,16156,2033,-2458,3022,7220 } },
+    { "Panasonic DMC-G2", 0, 0,
+	{ 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },
     { "Panasonic DMC-GF1", 15, 0xf92,
 	{ 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },
     { "Panasonic DMC-GH1", 15, 0xf92,
@@ -6276,8 +6578,8 @@
 	{ 4516,-245,-37,-7020,14976,2173,-3206,4671,7087 } },
     { "Phase One P 45", 0, 0,
 	{ 5053,-24,-117,-5684,14076,1702,-2619,4492,5849 } },
-    { "Phase One P65", 0, 0,		/* DJC */
-	{ 8522,1268,-1916,-7706,16350,1358,-2397,4344,4923 } },
+    { "Phase One P65", 0, 0,
+	{ 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },
     { "SAMSUNG GX-1", 0, 0,
 	{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },
     { "SAMSUNG S85", 0, 0,		/* DJC */
@@ -6292,9 +6594,7 @@
 	{ 7511,-2571,-692,-7894,15088,3060,-948,1111,8128 } },
     { "SONY DSLR-A100", 0, 0xfeb,
 	{ 9437,-2811,-774,-8405,16215,2290,-710,596,7181 } },
-    { "SONY DSLR-A200", 0, 0,
-	{ 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },
-    { "SONY DSLR-A230", 0, 0,	/* copied */
+    { "SONY DSLR-A2", 0, 0,
 	{ 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },
     { "SONY DSLR-A300", 0, 0,
 	{ 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },
@@ -6304,14 +6604,20 @@
 	{ 6038,-1484,-578,-9146,16746,2513,-875,746,7217 } },
     { "SONY DSLR-A380", 0, 0,
 	{ 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },
-    { "SONY DSLR-A5", 254, 0x1ffe,
+    { "SONY DSLR-A450", 128, 0xfeb,
+	{ 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },
+    { "SONY DSLR-A5", 128, 0xfeb,
 	{ 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },
-    { "SONY DSLR-A700", 254, 0x1ffe,
+    { "SONY DSLR-A700", 126, 0,
 	{ 5775,-805,-359,-8574,16295,2391,-1943,2341,7249 } },
-    { "SONY DSLR-A850", 256, 0x1ffe,
+    { "SONY DSLR-A850", 128, 0,
 	{ 5413,-1162,-365,-5665,13098,2866,-608,1179,8440 } },
-    { "SONY DSLR-A900", 254, 0x1ffe,
-	{ 5209,-1072,-397,-8845,16120,2919,-1618,1803,8654 } }
+    { "SONY DSLR-A900", 128, 0,
+	{ 5209,-1072,-397,-8845,16120,2919,-1618,1803,8654 } },
+    { "SONY NEX-3", 138, 0,		/* DJC */
+	{ 6907,-1256,-645,-4940,12621,2320,-1710,2581,6230 } },
+    { "SONY NEX-5", 116, 0,		/* DJC */
+	{ 6807,-1350,-342,-4216,11649,2567,-1089,2001,6420 } }
   };
   double cam_xyz[4][3];
   char name[130];
@@ -6376,6 +6682,7 @@
   return sum[0] < sum[1] ? 0x4d4d : 0x4949;
 }
 
+#line 7905 "dcraw/dcraw.c"
 
 float CLASS find_green (int bps, int bite, int off0, int off1)
 {
@@ -6409,7 +6716,7 @@
 void CLASS identify()
 {
   char head[32], *cp;
-  int hlen, fsize, i, c, is_canon;
+  int hlen, flen, fsize, zero_fsize=1, i, c, is_canon;
   struct jhead jh;
   static const struct {
     int fsize;
@@ -6433,7 +6740,9 @@
     {  1447680, "AVT",      "F-145C"          ,0 },
     {  1920000, "AVT",      "F-201C"          ,0 },
     {  5067304, "AVT",      "F-510C"          ,0 },
+    {  5067316, "AVT",      "F-510C"          ,0 },
     { 10134608, "AVT",      "F-510C"          ,0 },
+    { 10134620, "AVT",      "F-510C"          ,0 },
     { 16157136, "AVT",      "F-810C"          ,0 },
     {  1409024, "Sony",     "XCD-SX910CR"     ,0 },
     {  2818048, "Sony",     "XCD-SX910CR"     ,0 },
@@ -6477,6 +6786,7 @@
     { 10843712, "CASIO",    "EX-Z75"          ,1 },
     { 10834368, "CASIO",    "EX-Z750"         ,1 },
     { 12310144, "CASIO",    "EX-Z850"         ,1 },
+    { 15499264, "CASIO",    "EX-Z1050"        ,1 },
     {  7426656, "CASIO",    "EX-P505"         ,1 },
     {  9313536, "CASIO",    "EX-P600"         ,1 },
     { 10979200, "CASIO",    "EX-P700"         ,1 },
@@ -6487,6 +6797,8 @@
     { 15980544, "AGFAPHOTO","DC-833m"         ,1 },
     { 16098048, "SAMSUNG",  "S85"             ,1 },
     { 16215552, "SAMSUNG",  "S85"             ,1 },
+    { 20487168, "SAMSUNG",  "WB550"           ,1 },
+    { 24000000, "SAMSUNG",  "WB550"           ,1 },
     { 12582980, "Sinar",    ""                ,0 },
     { 33292868, "Sinar",    ""                ,0 },
     { 44390468, "Sinar",    ""                ,0 } };
@@ -6505,13 +6817,18 @@
   cdesc[0] = desc[0] = artist[0] = make[0] = model[0] = model2[0] = 0;
   iso_speed = shutter = aperture = focal_len = unique_id = 0;
   memset (gpsdata, 0, sizeof gpsdata);
+  memset (cblack, 0, sizeof cblack);
   memset (white, 0, sizeof white);
   thumb_offset = thumb_length = thumb_width = thumb_height = 0;
   load_raw = thumb_load_raw = 0;
   write_thumb = &CLASS jpeg_thumb;
   data_offset = meta_length = tiff_bps = tiff_compress = 0;
   kodak_cbpp = zero_after_ff = dng_version = load_flags = 0;
-  timestamp = shot_order = tiff_samples = black = is_foveon = 0;
+  timestamp = shot_order = tiff_samples = black = 
+#ifndef LIBRAW_LIBRARY_BUILD
+      is_foveon = 
+#endif
+      0;
   mix_green = profile_length = data_error = zero_is_bad = 0;
   pixel_aspect = is_raw = raw_color = 1;
   tile_width = tile_length = INT_MAX;
@@ -6538,15 +6855,15 @@
   fseek (ifp, 0, SEEK_SET);
   fread (head, 1, 32, ifp);
   fseek (ifp, 0, SEEK_END);
-  fsize = ftell(ifp);
-  if ((cp = (char *) memmem (head, 32, "MMMM", 4)) ||
-      (cp = (char *) memmem (head, 32, "IIII", 4))) {
+  flen = fsize = ftell(ifp);
+  if ((cp = (char *) memmem (head, 32, (char*)"MMMM", 4)) ||
+      (cp = (char *) memmem (head, 32, (char*)"IIII", 4))) {
     parse_phase_one (cp-head);
     if (cp-head) parse_tiff(0);
   } else if (order == 0x4949 || order == 0x4d4d) {
     if (!memcmp (head+6,"HEAPCCDR",8)) {
       data_offset = hlen;
-      parse_ciff (hlen, fsize - hlen);
+      parse_ciff (hlen, flen - hlen);
     } else {
       parse_tiff(0);
     }
@@ -6590,7 +6907,7 @@
 	parse_fuji (i);
     }
     fseek (ifp, 100, SEEK_SET);
-    data_offset = get4();
+    parse_tiff (data_offset = get4());
     parse_tiff (thumb_offset+12);
   } else if (!memcmp (head,"RIFF",4)) {
     fseek (ifp, 0, SEEK_SET);
@@ -6612,19 +6929,22 @@
     parse_sinar_ia();
   else if (!memcmp (head,"\0MRM",4))
     parse_minolta(0);
+#ifndef LIBRAW_LIBRARY_BUILD
   else if (!memcmp (head,"FOVb",4))
     parse_foveon();
+#endif
   else if (!memcmp (head,"CI",2))
     parse_cine();
   else
-    for (i=0; i < sizeof table / sizeof *table; i++)
+    for (zero_fsize=i=0; i < sizeof table / sizeof *table; i++)
       if (fsize == table[i].fsize) {
 	strcpy (make,  table[i].t_make );
 	strcpy (model, table[i].t_model);
 	if (table[i].withjpeg)
 	  parse_external_jpeg();
       }
-  if (make[0] == 0) parse_smal (0, fsize);
+  if (zero_fsize) fsize = 0;
+  if (make[0] == 0) parse_smal (0, flen);
   if (make[0] == 0) parse_jpeg (is_raw = 0);
 
   for (i=0; i < sizeof corp / sizeof *corp; i++)
@@ -6689,13 +7009,16 @@
 
 /* Set parameters based on camera name (for non-DNG files). */
 
+#ifndef LIBRAW_LIBRARY_BUILD
   if (is_foveon) {
     if (height*2 < width) pixel_aspect = 0.5;
     if (height   > width) pixel_aspect = 2;
     filters = 0;
     load_raw = &CLASS foveon_load_raw;
     simple_coeff(0);
-  } else if (is_canon && tiff_bps == 15) {
+  } else 
+#endif
+if (is_canon && tiff_bps == 15) {
     switch (width) {
       case 3344: width -= 66;
       case 3872: width -= 6;
@@ -6955,6 +7278,13 @@
     left_margin = 142;
     raw_width *= 4;
     width = 4916;
+  } else if (is_canon && raw_width == 1336) {
+    top_margin = 51;
+    left_margin = 142;
+    raw_width = width *= 4;
+    if (unique_id == 0x80000270)
+      adobe_coeff ("Canon","EOS 550D");
+    goto canon_cr2;
   } else if (is_canon && raw_width == 1340) {
     top_margin = 51;
     left_margin = 158;
@@ -7092,8 +7422,8 @@
       filters = 0x16161616;
     }
     if (make[0] == 'O') {
-      i = find_green (12, 32, 0, fsize/2);
-      c = find_green (12, 32, 0, 3096);
+      i = find_green (12, 32, 1188864, 3576832);
+      c = find_green (12, 32, 2383920, 2387016);
       if (abs(i) < abs(c)) {
 	SWAP(i,c);
 	load_flags = 24;
@@ -7132,7 +7462,7 @@
       height = 2144;
       width  = 2880;
       flip = 6;
-    } else
+    } else if (load_raw != &CLASS packed_load_raw)
       maximum = 0x3e00;
     if (is_raw == 2 && shot_select)
       maximum = 0x2f00;
@@ -7243,6 +7573,22 @@
     order = 0x4d4d;
     load_raw = &CLASS unpacked_load_raw;
     maximum = 0xffff;
+  } else if (!strcmp(model,"NX10")) {
+    height -= top_margin = 4;
+    width -= 2 * (left_margin = 8);
+  } else if (fsize == 20487168) {
+    height = 2808;
+    width  = 3648;
+    goto wb550;
+  } else if (fsize == 24000000) {
+    height = 3000;
+    width  = 4000;
+wb550:
+    strcpy (model, "WB550");
+    order = 0x4d4d;
+    load_raw = &CLASS unpacked_load_raw;
+    load_flags = 6;
+    maximum = 0x3df;
   } else if (!strcmp(model,"STV680 VGA")) {
     height = 484;
     width  = 644;
@@ -7274,6 +7620,7 @@
     width  = 2588;
     load_raw = fsize < 7500000 ?
 	&CLASS eight_bit_load_raw : &CLASS unpacked_load_raw;
+    data_offset = fsize - width*height*(fsize >> 22);
     maximum = 0xfff0;
   } else if (!strcmp(model,"F-810C")) {
     height = 2469;
@@ -7383,10 +7730,12 @@
       filters = 0x16161616;
     }
   } else if (!strcmp(make,"LEICA") || !strcmp(make,"Panasonic")) {
-    maximum = 0xfff0;
-    if ((fsize-data_offset) / (width*8/7) == height)
+    if ((flen - data_offset) / (width*8/7) == height)
       load_raw = &CLASS panasonic_load_raw;
-    if (!load_raw) load_raw = &CLASS unpacked_load_raw;
+    if (!load_raw) {
+      load_raw = &CLASS unpacked_load_raw;
+      load_flags = 4;
+    }
     switch (width) {
       case 2568:
 	adobe_coeff ("Panasonic","DMC-LC1");  break;
@@ -7406,6 +7755,7 @@
 	width -= 27;
       case 3177:
 	width -= 10;
+	load_flags = 2;
 	filters = 0x49494949;
 	zero_is_bad = 1;
 	adobe_coeff ("Panasonic","DMC-L1");  break;
@@ -7416,7 +7766,7 @@
       case 3330:
 	width += 43;
 	left_margin = -6;
-	maximum = 0xf7f0;
+	maximum = 0xf7f;
       case 3370:
 	width -= 82;
 	left_margin += 15;
@@ -7453,6 +7803,7 @@
       case 3880:
 	width -= 22;
 	left_margin = 6;
+	load_flags = 2;
 	zero_is_bad = 1;
 	adobe_coeff ("Panasonic","DMC-LX1");  break;
       case 4060:
@@ -7499,25 +7850,22 @@
     height += height & 1;
     filters = exif_cfa;
     if (width == 4100) width -= 4;
-    if (load_raw == &CLASS olympus_load_raw) {
-      tiff_bps = 12;
-      black >>= 4;
-    } else if (!strcmp(model,"E-10") ||
-	      !strncmp(model,"E-20",4)) {
-      black <<= 2;
-    } else if (!strcmp(model,"E-300") ||
-	       !strcmp(model,"E-500")) {
+    if (load_raw == &CLASS unpacked_load_raw)
+      load_flags = 4;
+    tiff_bps = 12;
+    if (!strcmp(model,"E-300") ||
+	!strcmp(model,"E-500")) {
       width -= 20;
       if (load_raw == &CLASS unpacked_load_raw) {
-	maximum = 0xfc30;
-	black = 0;
+	maximum = 0xfc3;
+	memset (cblack, 0, sizeof cblack);
       }
     } else if (!strcmp(model,"E-330")) {
       width -= 30;
       if (load_raw == &CLASS unpacked_load_raw)
-	maximum = 0xf790;
+	maximum = 0xf79;
     } else if (!strcmp(model,"SP550UZ")) {
-      thumb_length = fsize - (thumb_offset = 0xa39800);
+      thumb_length = flen - (thumb_offset = 0xa39800);
       thumb_height = 480;
       thumb_width  = 640;
     }
@@ -7545,8 +7893,13 @@
     width = 3925;
     order = 0x4d4d;
   } else if (!strcmp(model,"DSLR-A100")) {
-    height--;
-    width = ++raw_width;
+    if (width == 3880) {
+      height--;
+      width = ++raw_width;
+    } else {
+      order = 0x4d4d;
+      load_flags = 2;
+    }
     filters = 0x61616161;
   } else if (!strcmp(model,"DSLR-A350")) {
     height -= 4;
@@ -7594,7 +7947,7 @@
   }
 #if 1
   else
-      identify2(fsize,head); /* Avoid MS VS 2008 bug */
+      identify2(fsize,flen,head); /* Avoid MS VS 2008 bug */
 #else
  else if (!strcmp(model,"EASYSHARE Z1015 IS")) {
     height = 2742;
@@ -7645,7 +7998,7 @@
     }
     if (!strncmp(model,"DC2",3)) {
       height = 242;
-      if (fsize < 100000) {
+      if (flen < 100000) {
 	raw_width = 256; width = 249;
 	pixel_aspect = (4.0*height) / (3.0*width);
       } else {
@@ -7809,6 +8162,11 @@
     width  = 3279;
     raw_width = 4928;
     maximum = 0xfff;
+  } else if (!strcmp(model,"EX-Z1050")) {
+    height = 2752;
+    width  = 3672;
+    raw_width = 5632;
+    maximum = 0xffc;
   } else if (!strcmp(model,"EX-P505")) {
     height = 1928;
     width  = 2568;
@@ -7857,12 +8215,8 @@
   if (!raw_height) raw_height = height;
   if (!raw_width ) raw_width  = width;
   if (filters && colors == 3)
-    for (i=0; i < 32; i+=4) {
-      if ((filters >> i & 15) == 9)
-	filters |= 2 << i;
-      if ((filters >> i & 15) == 6)
-	filters |= 8 << i;
-    }
+    filters |= ((filters >> 2 & 0x22222222) |
+		(filters << 2 & 0x88888888)) & filters << 1;
 notraw:
   if (flip == -1) flip = tiff_flip;
   if (flip == -1) flip = 0;
@@ -7871,7 +8225,7 @@
 #endif
 }
 
-void CLASS identify2(unsigned fsize, char *head)
+void CLASS identify2(unsigned fsize, unsigned flen, char *head)
 {
     if (!strcmp(model,"EASYSHARE Z1015 IS")) {
     height = 2742;
@@ -7922,7 +8276,7 @@
     }
     if (!strncmp(model,"DC2",3)) {
       height = 242;
-      if (fsize < 100000) {
+      if (flen < 100000) {
 	raw_width = 256; width = 249;
 	pixel_aspect = (4.0*height) / (3.0*width);
       } else {
@@ -8085,6 +8439,11 @@
     width  = 3279;
     raw_width = 4928;
     maximum = 0xfff;
+  } else if (!strcmp(model,"EX-Z1050")) {
+    height = 2752;
+    width  = 3672;
+    raw_width = 5632;
+    maximum = 0xffc;
   } else if (!strcmp(model,"EX-P505")) {
     height = 1928;
     width  = 2568;
@@ -8101,6 +8460,7 @@
   }
 }
 
+#line 9774 "dcraw/dcraw.c"
 void CLASS convert_to_rgb()
 {
   int row, col, c, i, j, k;
@@ -8319,6 +8679,7 @@
   return row * iwidth + col;
 }
 
+#line 10017 "dcraw/dcraw.c"
 void CLASS tiff_set (ushort *ntag,
 	ushort tag, ushort type, int count, int val)
 {
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libraw/internal/dcraw_fileio.cpp kdegraphics/libs/libkdcraw/libraw/internal/dcraw_fileio.cpp
--- kdegraphics-4.4.4/libs/libkdcraw/libraw/internal/dcraw_fileio.cpp	2009-12-31 14:27:23.000000000 +0100
+++ kdegraphics/libs/libkdcraw/libraw/internal/dcraw_fileio.cpp	2010-06-10 17:10:40.105739551 +0200
@@ -1,16 +1,18 @@
 /* 
    GENERATED FILE, DO NOT EDIT
-   Generated from dcraw/dcraw.c at Wed Dec 30 14:11:10 2009
+   Generated from dcraw/dcraw.c at Sun Jun  6 17:42:22 2010
    Look into original file (probably http://cybercom.net/~dcoffin/dcraw/dcraw.c)
    for copyright information.
 */
 
+#line 3954 "dcraw/dcraw.c"
 #define CLASS LibRaw::
 #include "libraw/libraw_types.h"
 #define LIBRAW_LIBRARY_BUILD
 #include "libraw/libraw.h"
 #include "internal/defines.h"
 #include "internal/var_defines.h"
+#line 3964 "dcraw/dcraw.c"
 
 /*
    Seach from the current directory up to the root looking for
@@ -28,6 +30,7 @@
 #endif
   if (cfname)
     fp = fopen (cfname, "r");
+#line 4007 "dcraw/dcraw.c"
   if (!fp) 
       {
 #ifdef LIBRAW_LIBRARY_BUILD
@@ -118,11 +121,14 @@
       BAYER(row,col) = MAX (BAYER(row,col) - ntohs(pixel[col]), 0);
   }
   free (pixel);
+  fclose (fp);
+  memset (cblack, 0, sizeof cblack);
   black = 0;
 #ifdef LIBRAW_LIBRARY_BUILD
   RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME,1,2);
 #endif
 }
+#line 9685 "dcraw/dcraw.c"
 
 #ifndef NO_LCMS
 void CLASS apply_profile (const char *input, const char *output)
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libraw/internal/defines.h kdegraphics/libs/libkdcraw/libraw/internal/defines.h
--- kdegraphics-4.4.4/libs/libkdcraw/libraw/internal/defines.h	2009-12-31 14:27:23.000000000 +0100
+++ kdegraphics/libs/libkdcraw/libraw/internal/defines.h	2010-06-10 17:10:40.102416739 +0200
@@ -1,12 +1,14 @@
 /* 
    GENERATED FILE, DO NOT EDIT
-   Generated from dcraw/dcraw.c at Wed Dec 30 14:11:09 2009
+   Generated from dcraw/dcraw.c at Sun Jun  6 17:42:15 2010
    Look into original file (probably http://cybercom.net/~dcoffin/dcraw/dcraw.c)
    for copyright information.
 */
 
+#line 27 "dcraw/dcraw.c"
 #define NO_JPEG
-#define VERSION "8.99"
+#line 32 "dcraw/dcraw.c"
+#define VERSION "9.01"
 
 #ifndef _GNU_SOURCE
 #define _GNU_SOURCE
@@ -43,6 +45,7 @@
 #else
 #define _(String) (String)
 #endif
+#line 77 "dcraw/dcraw.c"
 #ifdef __CYGWIN__
 #include <io.h>
 #endif
@@ -53,10 +56,12 @@
 #define snprintf _snprintf
 #define strcasecmp _stricmp
 #define strncasecmp strnicmp
+#line 91 "dcraw/dcraw.c"
 #else
 #include <unistd.h>
 #include <utime.h>
 #include <netinet/in.h>
+#line 99 "dcraw/dcraw.c"
 #endif
 
 #ifdef LJPEG_DECODE
@@ -67,6 +72,7 @@
 #ifndef LONG_BIT
 #define LONG_BIT (8 * sizeof (long))
 #endif
+#line 175 "dcraw/dcraw.c"
 #define FORC(cnt) for (c=0; c < cnt; c++)
 #define FORC3 FORC(3)
 #define FORC4 FORC(4)
@@ -79,7 +85,7 @@
 #define LIM(x,min,max) MAX(min,MIN(x,max))
 #define ULIM(x,y,z) ((y) < (z) ? LIM(x,y,z) : LIM(x,z,y))
 #define CLIP(x) LIM(x,0,65535)
-#define SWAP(a,b) { a ^= b; a ^= (b ^= a); }
+#define SWAP(a,b) { a=a+b; b=a-b; a=a-b; }
 
 /*
    In order to inline this calculation, I make the risky
@@ -120,8 +126,8 @@
 	3 G R G R G R	3 B G B G B G	3 R G R G R G	3 G B G B G B
  */
 
+#line 233 "dcraw/dcraw.c"
 #define BAYER(row,col) \
 	image[((row) >> shrink)*iwidth + ((col) >> shrink)][FC(row,col)]
-
 #define BAYER2(row,col) \
 	image[((row) >> shrink)*iwidth + ((col) >> shrink)][fc(row,col)]
Nur in kdegraphics-4.4.4/libs/libkdcraw/libraw/internal: foveon.cpp.
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libraw/internal/libraw_internal_funcs.h kdegraphics/libs/libkdcraw/libraw/internal/libraw_internal_funcs.h
--- kdegraphics-4.4.4/libs/libkdcraw/libraw/internal/libraw_internal_funcs.h	2009-09-04 13:30:32.000000000 +0200
+++ kdegraphics/libs/libkdcraw/libraw/internal/libraw_internal_funcs.h	2010-06-10 17:10:40.102416739 +0200
@@ -62,7 +62,6 @@
     void        canon_compressed_load_raw();
     void        lossless_jpeg_load_raw();
     void        canon_sraw_load_raw();
-void        canon_black(double *, int nblack);
 // Adobe DNG
     void        adobe_copy_pixel (int row, int col, ushort **rp);
     void        adobe_dng_load_raw_lj();
@@ -148,20 +147,6 @@
     void        sony_arw2_load_raw();
     void        parse_minolta (int base);
 
-// Foveon/Sigma
-    void        foveon_load_camf();
-    void        foveon_load_raw();
-    const char* foveon_camf_param (const char *block, const char *param);
-    void *      foveon_camf_matrix (unsigned dim[3], const char *name);
-    int         foveon_fixed (void *ptr, int size, const char *name);
-    float       foveon_avg (short *pix, int range[2], float cfilt);
-    short *     foveon_make_curve (double max, double mul, double filt);
-    void        foveon_make_curves(short **curvep, float dq[3], float div[3], float filt);
-    int         foveon_apply_curve (short *curve, int i);
-    void        foveon_interpolate();
-    char *      foveon_gets (int offset, char *str, int len);
-    void        parse_foveon();
-
 // CAM/RGB
     void        pseudoinverse (double (*in)[3], double (*out)[3], int size);
     void        cam_xyz_coeff (double cam_xyz[4][3]);
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libraw/internal/var_defines.h kdegraphics/libs/libkdcraw/libraw/internal/var_defines.h
--- kdegraphics-4.4.4/libs/libkdcraw/libraw/internal/var_defines.h	2009-07-06 12:42:44.000000000 +0200
+++ kdegraphics/libs/libkdcraw/libraw/internal/var_defines.h	2010-06-10 17:10:40.109103403 +0200
@@ -29,7 +29,6 @@
 #define model           (imgdata.idata.model)
 #define is_raw          (imgdata.idata.raw_count)
 #define dng_version     (imgdata.idata.dng_version)
-#define is_foveon       (imgdata.idata.is_foveon)
 #define colors          (imgdata.idata.colors)
 #define cdesc           (imgdata.idata.cdesc)
 #define filters         (imgdata.idata.filters)
@@ -62,8 +61,10 @@
 #endif
 #ifndef SRC_USES_BLACK
 #define black           (imgdata.color.black)
+#define cblack           (imgdata.color.cblack)
 #endif
 #define maximum         (imgdata.color.maximum)
+#define channel_maximum         (imgdata.color.channel_maximum)
 #define profile_length  (imgdata.color.profile_length)
 #define color_flags     (imgdata.color.color_flags)
 #define ph1             (imgdata.color.phase_one_data)
@@ -173,6 +174,9 @@
 #define fseeko(stream,o,w)	 stream->seek(o,w)
 #define ftell(stream)		 stream->tell()
 #define ftello(stream)		 stream->tell()
+#ifdef getc
+#undef getc
+#endif
 #define getc(stream)		 stream->get_char()
 #define fgetc(stream)		 stream->get_char()
 #define fgets(str,n,stream)	 stream->gets(str,n)
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libraw/libraw/libraw_alloc.h kdegraphics/libs/libkdcraw/libraw/libraw/libraw_alloc.h
--- kdegraphics-4.4.4/libs/libkdcraw/libraw/libraw/libraw_alloc.h	2009-08-20 04:41:49.000000000 +0200
+++ kdegraphics/libs/libkdcraw/libraw/libraw/libraw_alloc.h	2010-06-10 17:10:38.961393404 +0200
@@ -1,24 +1,22 @@
 /* -*- C++ -*-
  * File: libraw_alloc.h
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Sat Mar  22, 2008 
  *
  * LibRaw C++ interface
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
  */
 
 #ifndef __LIBRAW_ALLOC_H
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libraw/libraw/libraw_const.h kdegraphics/libs/libkdcraw/libraw/libraw/libraw_const.h
--- kdegraphics-4.4.4/libs/libkdcraw/libraw/libraw/libraw_const.h	2009-09-04 13:30:30.000000000 +0200
+++ kdegraphics/libs/libkdcraw/libraw/libraw/libraw_const.h	2010-06-10 17:10:38.962802381 +0200
@@ -1,29 +1,29 @@
 /* -*- C++ -*-
  * File: libraw_const.h
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Sat Mar  8 , 2008
  *
  * LibRaw error codes
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
  */
 
 #ifndef _LIBRAW_ERRORS_H
 #define _LIBRAW_ERRORS_H
 
+#define LIBRAW_DEFAULT_ADJUST_MAXIMUM_THRESHOLD 0.75
+#define LIBRAW_DEFAULT_AUTO_BRIGHTNESS_THRESHOLD 0.01
+
 enum LibRaw_constructor_flags
 {
     LIBRAW_OPTIONS_NONE         =0,
@@ -34,8 +34,6 @@
 enum LibRaw_warnings
 {
     LIBRAW_WARN_NONE            =0,
-    LIBRAW_WARN_FOVEON_NOMATRIX =1,
-    LIBRAW_WARN_FOVEON_INVALIDWB =1<<1,
     LIBRAW_WARN_BAD_CAMERA_WB   =1<<2,
     LIBRAW_WARN_NO_METADATA     =1<<3,
     LIBRAW_WARN_NO_JPEGLIB     = 1<<4,
@@ -94,7 +92,6 @@
     LIBRAW_PROGRESS_REMOVE_ZEROES       = 1<<4,
     LIBRAW_PROGRESS_BAD_PIXELS          = 1<<5,
     LIBRAW_PROGRESS_DARK_FRAME          = 1<<6,
-    LIBRAW_PROGRESS_FOVEON_INTERPOLATE  = 1<<7,
     LIBRAW_PROGRESS_SCALE_COLORS        = 1<<8,
     LIBRAW_PROGRESS_PRE_INTERPOLATE     = 1<<9,
     LIBRAW_PROGRESS_INTERPOLATE         = 1<<10,
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libraw/libraw/libraw_datastream.h kdegraphics/libs/libkdcraw/libraw/libraw/libraw_datastream.h
--- kdegraphics-4.4.4/libs/libkdcraw/libraw/libraw/libraw_datastream.h	2009-10-26 10:14:14.000000000 +0100
+++ kdegraphics/libs/libkdcraw/libraw/libraw/libraw_datastream.h	2010-06-10 17:10:38.962802381 +0200
@@ -1,24 +1,22 @@
 /* -*- C -*-
  * File: libraw_datastream.h
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Sun Jan 18 13:07:35 2009
  *
  * LibRaw Data stream interface
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
  */
 
 #ifndef __LIBRAW_DATASTREAM_H
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libraw/libraw/libraw.h kdegraphics/libs/libkdcraw/libraw/libraw/libraw.h
--- kdegraphics-4.4.4/libs/libkdcraw/libraw/libraw/libraw.h	2009-12-31 14:27:23.000000000 +0100
+++ kdegraphics/libs/libkdcraw/libraw/libraw/libraw.h	2010-06-10 17:10:38.961393404 +0200
@@ -1,25 +1,24 @@
 /* -*- C++ -*-
  * File: libraw.h
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Sat Mar  8, 2008 
  *
  * LibRaw C++ interface
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
+
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
+*/
 
 #ifndef _LIBRAW_CLASS_H
 #define _LIBRAW_CLASS_H
@@ -100,6 +99,7 @@
     int                         unpack_thumb(void);
 
     int                         adjust_sizes_info_only(void);
+    int                         adjust_maximum();
     void                        set_memerror_handler( memory_callback cb,void *data) {callbacks.memcb_data = data; callbacks.mem_cb = cb; }
     void                        set_dataerror_handler(data_callback func, void *data) { callbacks.datacb_data = data; callbacks.data_cb = func;}
     void                        set_progress_handler(progress_callback pcb, void *data) { callbacks.progresscb_data = data; callbacks.progress_cb = pcb;}
@@ -124,6 +124,8 @@
     void         recycle(); 
     ~LibRaw(void) { recycle(); delete tls; }
 
+    int COLOR(int row, int col) { return libraw_internal_data.internal_output_params.fuji_width? FCF(row,col):FC(row,col);}
+
     int FC(int row,int col) { return (imgdata.idata.filters >> ((((row) << 1 & 14) + ((col) & 1)) << 1) & 3);}
     int         fc (int row, int col);
     int add_masked_borders_to_bitmap();
@@ -131,10 +133,23 @@
     const char *unpack_function_name();
     int         rotate_fuji_raw();
 
+    void        free(void *p);
   private:
+
+    int FCF(int row,int col) { 
+        int rr,cc;
+        if (libraw_internal_data.unpacker_data.fuji_layout) {
+            rr = libraw_internal_data.internal_output_params.fuji_width - 1 - col + (row >> 1);
+            cc = col + ((row+1) >> 1);
+        } else {
+            rr = libraw_internal_data.internal_output_params.fuji_width - 1 + row - (col >> 1);
+            cc = row + ((col+1) >> 1);
+        }
+        return FC(rr,cc);
+    }
+
     void*        malloc(size_t t);
     void*        calloc(size_t n,size_t t);
-    void        free(void *p);
     void        merror (void *ptr, const char *where);
     void        derror();
 
@@ -153,15 +168,13 @@
 
     void        kodak_thumb_loader();
     void        write_thumb_ppm_tiff(FILE *); 
-    void        foveon_thumb_loader (void);
-
     
     void init_masked_ptrs();
     ushort *get_masked_pointer(int row, int col); 
     
     int         own_filtering_supported(){ return 0;}
     void        identify();
-    void        identify2(unsigned, char*);
+    void        identify2(unsigned, unsigned, char*);
     void        write_ppm_tiff ();
     void        convert_to_rgb();
     void        kodak_ycbcr_load_raw();
@@ -184,11 +197,11 @@
     void        median_filter ();
     void        blend_highlights();
     void        recover_highlights();
+    void        green_matching();
 
     void        fuji_rotate();
     void        stretch();
 
-    void        foveon_thumb ();
     void        jpeg_thumb_writer (FILE *tfp,char *thumb,int thumb_length);
     void        jpeg_thumb ();
     void        ppm_thumb ();
@@ -196,7 +209,6 @@
     void        rollei_thumb ();
     void        kodak_thumb_load_raw();
 
-    void        foveon_decoder (unsigned size, unsigned code);
     unsigned    get4();
 
     int         flip_index (int row, int col);
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libraw/libraw/libraw_internal.h kdegraphics/libs/libkdcraw/libraw/libraw/libraw_internal.h
--- kdegraphics-4.4.4/libs/libkdcraw/libraw/libraw/libraw_internal.h	2009-08-20 04:41:49.000000000 +0200
+++ kdegraphics/libs/libkdcraw/libraw/libraw/libraw_internal.h	2010-06-10 17:10:38.961393404 +0200
@@ -1,24 +1,22 @@
 /* -*- C++ -*-
  * File: libraw_internal.h
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Sat Mar  8 , 2008
  *
  * LibRaw internal data structures (not visible outside)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
  */
 
 #ifndef _LIBRAW_INTERNAL_TYPES_H
@@ -61,7 +59,6 @@
     {
          unsigned pad[128], p;
     }sony_decrypt;
-    unsigned foveon_decoder_huff[1024];
     uchar jpeg_buffer[4096];
     struct
     {
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libraw/libraw/libraw_types.h kdegraphics/libs/libkdcraw/libraw/libraw/libraw_types.h
--- kdegraphics-4.4.4/libs/libkdcraw/libraw/libraw/libraw_types.h	2009-09-04 13:30:30.000000000 +0200
+++ kdegraphics/libs/libkdcraw/libraw/libraw/libraw_types.h	2010-06-10 17:10:38.962802381 +0200
@@ -1,24 +1,23 @@
 /* -*- C++ -*-
  * File: libraw_types.h
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Sat Mar  8 , 2008
  *
  * LibRaw C data structures
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
  */
 
 #ifndef _LIBRAW_TYPES_H
@@ -30,6 +29,9 @@
 #endif
 #include <stdio.h>
 #ifdef _OPENMP
+#ifdef _MSC_VER
+#error OpenMP is not supported under MS Visual Studio
+#endif
 #include <omp.h>
 #endif
 
@@ -102,9 +104,6 @@
                 width,
                 colors,
                 bits;
-#ifdef _OPENMP
-#pragma omp firstprivate(colors,height,width)
-#endif
     unsigned int  data_size; 
     unsigned char data[1]; 
 }libraw_processed_image_t;
@@ -117,7 +116,6 @@
 
     unsigned    raw_count;
     unsigned    dng_version;
-    unsigned    is_foveon;
     int         colors;
 
     unsigned    filters; 
@@ -135,9 +133,6 @@
                 left_margin;
     ushort      iheight,
                 iwidth;
-#ifdef _OPENMP
-#pragma omp firstprivate(iheight,iwidth)
-#endif
     double      pixel_aspect;
     int         flip;
 
@@ -173,7 +168,9 @@
     float       cam_xyz[4][3]; 
     ushort      curve[0x10000]; 
     unsigned    black;
+    unsigned    cblack[8];
     unsigned    maximum;
+    unsigned    channel_maximum[4];
     struct ph1_t       phase_one_data;
     float       flash_used; 
     float       canon_ev; 
@@ -215,9 +212,6 @@
     unsigned    shot_select;    /* -s */
     float       bright;         /* -b */
     float       threshold;      /*  -n */
-#ifdef _OPENMP
-#pragma omp firstprivate(threshold)
-#endif
     int         half_size;      /* -h */
     int         four_color_rgb; /* -f */
     int         document_mode;  /* -d/-D */
@@ -239,8 +233,10 @@
 
     int         med_passes;     /* -m */
     float       auto_bright_thr; 
+    float       adjust_maximum_thr;
     int         no_auto_bright; /* -W */
     int         use_fuji_rotate;/* -j */
+    int         green_matching;
     enum LibRaw_filtering    filtering_mode; 
 }libraw_output_params_t;
 
@@ -269,9 +265,6 @@
     libraw_thumbnail_t          thumbnail;
     libraw_masked_t             masked_pixels;
     ushort                      (*image)[4] ;
-#ifdef _OPENMP
-#pragma omp shared(image)
-#endif
     libraw_output_params_t     params;
     void                *parent_class;      
 } libraw_data_t;
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libraw/libraw/libraw_version.h kdegraphics/libs/libkdcraw/libraw/libraw/libraw_version.h
--- kdegraphics-4.4.4/libs/libkdcraw/libraw/libraw/libraw_version.h	2009-12-31 14:27:23.000000000 +0100
+++ kdegraphics/libs/libkdcraw/libraw/libraw/libraw_version.h	2010-06-10 17:10:38.962802381 +0200
@@ -1,33 +1,32 @@
 /* -*- C++ -*-
  * File: libraw_version.h
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Mon Sept  8, 2008 
  *
  * LibRaw C++ interface
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See the file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See the file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See the file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
  */
 
 #ifndef __VERSION_H
 #define __VERSION_H
 
 #define LIBRAW_MAJOR_VERSION  0
-#define LIBRAW_MINOR_VERSION  8
-#define LIBRAW_PATCH_VERSION  5
-#define LIBRAW_VERSION_TAIL   Release
+#define LIBRAW_MINOR_VERSION  10
+#define LIBRAW_PATCH_VERSION  0
+#define LIBRAW_VERSION_TAIL   Beta1
 
 #define _LIBRAW_VERSION_MAKE(a,b,c,d) #a"."#b"."#c"-"#d
 #define LIBRAW_VERSION_MAKE(a,b,c,d) _LIBRAW_VERSION_MAKE(a,b,c,d)
Nur in kdegraphics/libs/libkdcraw/libraw: LICENSE.CDDL.
Nur in kdegraphics/libs/libkdcraw/libraw: LICENSE.LGPL.
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libraw/samples/4channels.cpp kdegraphics/libs/libkdcraw/libraw/samples/4channels.cpp
--- kdegraphics-4.4.4/libs/libkdcraw/libraw/samples/4channels.cpp	2009-07-06 12:42:44.000000000 +0200
+++ kdegraphics/libs/libkdcraw/libraw/samples/4channels.cpp	2010-06-10 17:10:39.392812613 +0200
@@ -1,25 +1,26 @@
 /* -*- C++ -*-
  * File: 4channels.cpp
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Mon Feb 09, 2009
  *
  * LibRaw sample
  * Generates 4 TIFF file from RAW data, one file per channel
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
+
+
  */
 #include <stdio.h>
 #include <string.h>
@@ -111,11 +112,6 @@
                     fprintf(stderr,"Cannot open %s: %s\n",av[i],libraw_strerror(ret));
                     continue; // no recycle b/c open file will recycle itself
                 }
-            if(P1.is_foveon)
-                {
-                    printf("Cannot process foveon image %s\n",av[i]);
-                    continue ;
-                }
             if( (ret = RawProcessor.unpack() ) != LIBRAW_SUCCESS)
                 {
                     fprintf(stderr,"Cannot unpack %s: %s\n",av[i],libraw_strerror(ret));
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libraw/samples/dcraw_emu.cpp kdegraphics/libs/libkdcraw/libraw/samples/dcraw_emu.cpp
--- kdegraphics-4.4.4/libs/libkdcraw/libraw/samples/dcraw_emu.cpp	2009-12-31 14:27:23.000000000 +0100
+++ kdegraphics/libs/libkdcraw/libraw/samples/dcraw_emu.cpp	2010-06-10 17:10:39.392812613 +0200
@@ -1,24 +1,25 @@
 /* -*- C++ -*-
  * File: dcraw_emu.cpp
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Sun Mar 23,   2008
  *
  * LibRaw simple C++ API sample: almost complete dcraw emulator
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
+
+
  */
 #include <stdio.h>
 #include <string.h>
@@ -43,6 +44,7 @@
     printf("dcraw_emu: almost complete dcraw emulator\n");
     printf("Usage:  %s [OPTION]... [FILE]...\n", prog);
     printf(
+"-c float-num       Set adjust maximum threshold (default 0.75)\n"
 "-v        Verbose: print progress messages (repeated -v will add verbosity)\n"
 "-w        Use camera white balance, if possible\n"
 "-a        Average the whole image for white balance\n"
@@ -74,6 +76,7 @@
 "-6        Write 16-bit linear instead of 8-bit with gamma\n"
 "-g pow ts Set gamma curve to gamma pow and toe slope ts (default = 2.222 4.5)\n"
 "-T        Write TIFF instead of PPM\n"
+"-G        Use green_matching() filter\n"
 #ifndef WIN32
 "-B        Use mmap()-ed buffer instead of plain FILE I/O\n"
 #endif
@@ -119,8 +122,8 @@
   for (arg=1; (((opm = argv[arg][0]) - 2) | 2) == '+'; ) 
       {
           opt = argv[arg++][1];
-          if ((cp = strchr (sp=(char*)"nbrkStqmHACgU", opt)))
-              for (i=0; i < "11411111142"[cp-sp]-'0'; i++)
+          if ((cp = strchr (sp=(char*)"cnbrkStqmHACgU", opt)))
+              for (i=0; i < "111411111142"[cp-sp]-'0'; i++)
                   if (!isdigit(argv[arg+i][0])) 
                       {
                           fprintf (stderr,"Non-numeric argument to \"-%c\"\n", opt);
@@ -129,7 +132,8 @@
           switch (opt) 
               {
               case 'v':  verbosity++;  break;
-                  
+              case 'G':  OUT.green_matching = 1; break;
+              case 'c':  OUT.adjust_maximum_thr   = atof(argv[arg++]);  break;
               case 'U':  OUT.auto_bright_thr   = atof(argv[arg++]);  break;
               case 'n':  OUT.threshold   = atof(argv[arg++]);  break;
               case 'b':  OUT.bright      = atof(argv[arg++]);  break;
@@ -263,7 +267,10 @@
                      "%s.%s",
                      argv[arg], OUT.output_tiff ? "tiff" : (P1.colors>1?"ppm":"pgm"));
 
-            if(verbosity) printf("Writing file %s\n",outfn);
+            if(verbosity)
+                {
+                    printf("Writing file %s\n",outfn);
+                }
 
             if( LIBRAW_SUCCESS != (ret = RawProcessor.dcraw_ppm_tiff_writer(outfn)))
                 fprintf(stderr,"Cannot write %s: %s\n",outfn,libraw_strerror(ret));
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libraw/samples/dcraw_half.c kdegraphics/libs/libkdcraw/libraw/samples/dcraw_half.c
--- kdegraphics-4.4.4/libs/libkdcraw/libraw/samples/dcraw_half.c	2009-09-04 13:30:31.000000000 +0200
+++ kdegraphics/libs/libkdcraw/libraw/samples/dcraw_half.c	2010-06-10 17:10:39.392812613 +0200
@@ -1,24 +1,24 @@
 /* -*- C++ -*-
  * File: dcraw_half.c
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Sat Mar  8 , 2008
  *
  * LibRaw  C API sample:  emulates "dcraw  -h"
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
+
+
  */
 #include <stdio.h>
 #include <string.h>
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libraw/samples/half_mt.c kdegraphics/libs/libkdcraw/libraw/samples/half_mt.c
--- kdegraphics-4.4.4/libs/libkdcraw/libraw/samples/half_mt.c	2009-07-06 12:42:44.000000000 +0200
+++ kdegraphics/libs/libkdcraw/libraw/samples/half_mt.c	2010-06-10 17:10:39.396155856 +0200
@@ -1,24 +1,24 @@
 /* -*- C++ -*-
  * File: halt_mt.c
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Sat Mar  8 , 2008
  *
  * LibRaw  C API mutithreaded sample: emulates call to "dcraw  -h [-w] [-a] [-v]"
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
+
  */
 #include <stdio.h>
 #include <string.h>
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libraw/samples/half_mt_win32.c kdegraphics/libs/libkdcraw/libraw/samples/half_mt_win32.c
--- kdegraphics-4.4.4/libs/libkdcraw/libraw/samples/half_mt_win32.c	2009-12-31 14:27:23.000000000 +0100
+++ kdegraphics/libs/libkdcraw/libraw/samples/half_mt_win32.c	2010-06-10 17:10:39.396155856 +0200
@@ -1,25 +1,24 @@
 /* -*- C++ -*-
  * File: halt_mt_win32.c
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Sat Mar  8 , 2008
  *
  * LibRaw  C API mutithreaded sample:  emulates call to "dcraw  -h [-w] [-a] [-v]"
  * Win32 version
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
+
  */
 #include <stdio.h>
 #include <string.h>
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libraw/samples/mem_image.cpp kdegraphics/libs/libkdcraw/libraw/samples/mem_image.cpp
--- kdegraphics-4.4.4/libs/libkdcraw/libraw/samples/mem_image.cpp	2009-07-06 12:42:44.000000000 +0200
+++ kdegraphics/libs/libkdcraw/libraw/samples/mem_image.cpp	2010-06-10 17:10:39.392812613 +0200
@@ -1,25 +1,24 @@
 /* -*- C++ -*-
  * File: mem_image.cpp
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Sat Mar  8 , 2008
  *
  * LibRaw mem_image/mem_thumb API test. Results should be same (bitwise) to dcraw [-4] [-6] [-e]
  * Testing note: for ppm-thumbnails you should use dcraw -w -e for thumbnail extraction
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
+
  */
 #include <stdio.h>
 #include <string.h>
@@ -100,11 +99,12 @@
     if(ac<2) 
         {
             printf(
-                "mem_image - LibRaw sample, to illustrate work for memory buffers. Emulates dcraw [-4] [-1] [-e]\n"
+                "mem_image - LibRaw sample, to illustrate work for memory buffers. Emulates dcraw [-4] [-1] [-e] [-h]\n"
                 "Usage: %s [-D] [-T] [-v] [-e] raw-files....\n"
                 "\t-6 - output 16-bit PPM\n"
                 "\t-4 - linear 16-bit data\n"
                 "\t-e - extract thumbnails (same as dcraw -e in separate run)\n",
+                "\t-h - use half_size\n",
                 av[0]);
             return 0;
         }
@@ -132,6 +132,8 @@
                         }
                     if(av[i][1]=='e' && av[i][2]==0)
                         output_thumbs++;
+                    if(av[i][1]=='h' && av[i][2]==0)
+                        OUT.half_size=1;
                     continue;
                 }
             printf("Processing %s\n",av[i]);
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libraw/samples/raw-identify.cpp kdegraphics/libs/libkdcraw/libraw/samples/raw-identify.cpp
--- kdegraphics-4.4.4/libs/libkdcraw/libraw/samples/raw-identify.cpp	2009-07-06 12:42:44.000000000 +0200
+++ kdegraphics/libs/libkdcraw/libraw/samples/raw-identify.cpp	2010-06-10 17:10:39.392812613 +0200
@@ -1,24 +1,24 @@
 /* -*- C++ -*-
  * File: identify.cpp
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Sat Mar  8 , 2008
  *
  * LibRaw C++ demo: emulates dcraw -i [-v]
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
+
  */
 
 #include <stdio.h>
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libraw/samples/simple_dcraw.cpp kdegraphics/libs/libkdcraw/libraw/samples/simple_dcraw.cpp
--- kdegraphics-4.4.4/libs/libkdcraw/libraw/samples/simple_dcraw.cpp	2009-07-06 12:42:44.000000000 +0200
+++ kdegraphics/libs/libkdcraw/libraw/samples/simple_dcraw.cpp	2010-06-10 17:10:39.392812613 +0200
@@ -1,24 +1,24 @@
 /* -*- C++ -*-
  * File: simple_dcraw.cpp
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Sat Mar  8 , 2008
  *
  * LibRaw simple C++ API:  emulates call to "dcraw  [-D]  [-T] [-v] [-e] [-4]"
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
+
+
  */
 #include <stdio.h>
 #include <string.h>
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libraw/samples/unprocessed_raw.cpp kdegraphics/libs/libkdcraw/libraw/samples/unprocessed_raw.cpp
--- kdegraphics-4.4.4/libs/libkdcraw/libraw/samples/unprocessed_raw.cpp	2009-07-06 12:42:44.000000000 +0200
+++ kdegraphics/libs/libkdcraw/libraw/samples/unprocessed_raw.cpp	2010-06-10 17:10:39.392812613 +0200
@@ -1,25 +1,24 @@
 /* -*- C++ -*-
  * File: unprocessed_raw.cpp
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Fri Jan 02, 2009
  *
  * LibRaw sample
  * Generates unprocessed raw image: with masked pixels and without black subtraction
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
  */
 #include <stdio.h>
 #include <string.h>
@@ -115,6 +114,7 @@
                     fprintf(stderr,"Cannot unpack %s: %s\n",av[i],libraw_strerror(ret));
                     continue;
                 }
+
             if(verbose)
                 printf("Unpacked....\n");
 
@@ -122,10 +122,13 @@
                 {
                     fprintf(stderr,"Cannot add mask data to bitmap %s\n",av[i]);
                 }
+
+            // move all pixel data to component 0
+
             for(int r=0;r<S.iheight;r++)
                 for(c=0;c<S.iwidth;c++)
                     RawProcessor.imgdata.image[r*S.iwidth+c][0] 
-                        = RawProcessor.imgdata.image[r*S.iwidth+c][RawProcessor.FC(r,c)];
+		      = RawProcessor.imgdata.image[r*S.iwidth+c][RawProcessor.COLOR(r,c)];
 
             P1.colors=1;
             if(autoscale)
@@ -144,6 +147,7 @@
                                 RawProcessor.imgdata.image[j][0] *= scale;
                         }
                 }
+
             
             if(OUT.shot_select)
                 snprintf(outfn,sizeof(outfn),"%s-%d.tiff",av[i],OUT.shot_select);
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libraw/src/libraw_c_api.cpp kdegraphics/libs/libkdcraw/libraw/src/libraw_c_api.cpp
--- kdegraphics-4.4.4/libs/libkdcraw/libraw/src/libraw_c_api.cpp	2009-09-04 13:30:31.000000000 +0200
+++ kdegraphics/libs/libkdcraw/libraw/src/libraw_c_api.cpp	2010-06-10 17:10:39.522406516 +0200
@@ -1,9 +1,25 @@
 /* -*- C++ -*-
  * File: libraw_c_api.cpp
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Sat Mar  8 , 2008
  *
  * LibRaw C interface 
+
+
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
+
+
  */
 #include <errno.h>
 #include "libraw/libraw.h"
@@ -110,7 +126,6 @@
         LibRaw *ip = (LibRaw*) lr->parent_class;
         return ip->adjust_sizes_info_only();
     }
-
     int  libraw_dcraw_document_mode_processing(libraw_data_t* lr)
     {
         if(!lr) return EINVAL;
diff -ru kdegraphics-4.4.4/libs/libkdcraw/libraw/src/libraw_cxx.cpp kdegraphics/libs/libkdcraw/libraw/src/libraw_cxx.cpp
--- kdegraphics-4.4.4/libs/libkdcraw/libraw/src/libraw_cxx.cpp	2009-12-31 14:27:23.000000000 +0100
+++ kdegraphics/libs/libkdcraw/libraw/src/libraw_cxx.cpp	2010-06-10 17:10:39.522406516 +0200
@@ -1,9 +1,22 @@
 /* -*- C++ -*-
  * File: libraw_cxx.cpp
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Sat Mar  8 , 2008
  *
  * LibRaw C++ interface (implementation)
+
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
  */
 
 #include <errno.h>
@@ -170,7 +183,9 @@
     imgdata.params.output_color=1;
     imgdata.params.output_bps=8;
     imgdata.params.use_fuji_rotate=1;
-    imgdata.params.auto_bright_thr = 0.01;
+    imgdata.params.auto_bright_thr = LIBRAW_DEFAULT_AUTO_BRIGHTNESS_THRESHOLD;
+    imgdata.params.adjust_maximum_thr= LIBRAW_DEFAULT_ADJUST_MAXIMUM_THRESHOLD;
+    imgdata.params.green_matching = 0;
     imgdata.parent_class = this;
     imgdata.progress_flags = 0;
     tls = new LibRaw_TLS;
@@ -239,6 +254,7 @@
 #undef FREE
     ZERO(imgdata.masked_pixels);
     ZERO(imgdata.sizes);
+    ZERO(imgdata.color);
     ZERO(libraw_internal_data.internal_output_params);
     memmgr.cleanup();
     imgdata.thumbnail.tformat = LIBRAW_THUMBNAIL_UNKNOWN;
@@ -252,61 +268,86 @@
     if(!load_raw) return "Function not set";
 
     // sorted names order
-    if (load_raw == &LibRaw::adobe_dng_load_raw_lj)     return "adobe_dng_load_raw_lj()";
-    if (load_raw == &LibRaw::adobe_dng_load_raw_nc)     return "adobe_dng_load_raw_nc()";
-    if (load_raw == &LibRaw::canon_600_load_raw)        return "canon_600_load_raw()";
-
-    if (load_raw == &LibRaw::canon_compressed_load_raw) return "canon_compressed_load_raw()";
-    if (load_raw == &LibRaw::canon_sraw_load_raw)       return "canon_sraw_load_raw()";
-
-    if (load_raw == &LibRaw::eight_bit_load_raw )       return "eight_bit_load_raw()";
-    if (load_raw == &LibRaw::foveon_load_raw )          return "foveon_load_raw()";
-    if (load_raw == &LibRaw::fuji_load_raw )            return "fuji_load_raw()";
+    if (load_raw == &LibRaw::adobe_dng_load_raw_lj)     return "adobe_dng_load_raw_lj()"; //+
+    if (load_raw == &LibRaw::adobe_dng_load_raw_nc)     return "adobe_dng_load_raw_nc()"; //+
+    if (load_raw == &LibRaw::canon_600_load_raw)        return "canon_600_load_raw()";    //+
+
+    if (load_raw == &LibRaw::canon_compressed_load_raw) return "canon_compressed_load_raw()"; //+
+    if (load_raw == &LibRaw::canon_sraw_load_raw)       return "canon_sraw_load_raw()"; //+
+
+    if (load_raw == &LibRaw::eight_bit_load_raw )       return "eight_bit_load_raw()"; //+
+    if (load_raw == &LibRaw::fuji_load_raw )            return "fuji_load_raw()"; //+
     // 10
-    if (load_raw == &LibRaw::hasselblad_load_raw )      return "hasselblad_load_raw()";
-    if (load_raw == &LibRaw::imacon_full_load_raw )     return "imacon_full_load_raw()";
-    if (load_raw == &LibRaw::kodak_262_load_raw )       return "kodak_262_load_raw()";
-
-    if (load_raw == &LibRaw::kodak_65000_load_raw )     return "kodak_65000_load_raw()";
-    if (load_raw == &LibRaw::kodak_dc120_load_raw )     return "kodak_dc120_load_raw()";
-    if (load_raw == &LibRaw::kodak_jpeg_load_raw )      return "kodak_jpeg_load_raw()";
-
-    if (load_raw == &LibRaw::kodak_radc_load_raw )      return "kodak_radc_load_raw()";
-    if (load_raw == &LibRaw::kodak_rgb_load_raw )       return "kodak_rgb_load_raw()";
-    if (load_raw == &LibRaw::kodak_yrgb_load_raw )      return "kodak_yrgb_load_raw()";
-    if (load_raw == &LibRaw::kodak_ycbcr_load_raw )     return "kodak_ycbcr_load_raw()";
+    if (load_raw == &LibRaw::hasselblad_load_raw )      return "hasselblad_load_raw()"; //+
+    if (load_raw == &LibRaw::imacon_full_load_raw )     return "imacon_full_load_raw()"; //+ (untested)
+    if (load_raw == &LibRaw::kodak_262_load_raw )       return "kodak_262_load_raw()"; //+
+
+    if (load_raw == &LibRaw::kodak_65000_load_raw )     return "kodak_65000_load_raw()";//+
+    if (load_raw == &LibRaw::kodak_dc120_load_raw )     return "kodak_dc120_load_raw()"; //+
+    if (load_raw == &LibRaw::kodak_jpeg_load_raw )      return "kodak_jpeg_load_raw()"; //+ (untested)
+
+    if (load_raw == &LibRaw::kodak_radc_load_raw )      return "kodak_radc_load_raw()"; //+
+    if (load_raw == &LibRaw::kodak_rgb_load_raw )       return "kodak_rgb_load_raw()"; //+ (untested)
+    if (load_raw == &LibRaw::kodak_yrgb_load_raw )      return "kodak_yrgb_load_raw()"; //+
+    if (load_raw == &LibRaw::kodak_ycbcr_load_raw )     return "kodak_ycbcr_load_raw()"; //+ (untested)
     // 20
-    if (load_raw == &LibRaw::leaf_hdr_load_raw )        return "leaf_hdr_load_raw()";
-    if (load_raw == &LibRaw::lossless_jpeg_load_raw)    return "lossless_jpeg_load_raw()";
-    if (load_raw == &LibRaw::minolta_rd175_load_raw )   return "minolta_rd175_load_raw()";
-
-    if (load_raw == &LibRaw::nikon_compressed_load_raw) return "nikon_compressed_load_raw()";
-    if (load_raw == &LibRaw::nokia_load_raw )           return "nokia_load_raw()";
-
-    if (load_raw == &LibRaw::olympus_load_raw )    return "olympus_load_raw()";
-    if (load_raw == &LibRaw::packed_load_raw )       return "packed_load_raw()";
-    if (load_raw == &LibRaw::panasonic_load_raw )       return "panasonic_load_raw()";
+    if (load_raw == &LibRaw::leaf_hdr_load_raw )        return "leaf_hdr_load_raw()"; //+
+    if (load_raw == &LibRaw::lossless_jpeg_load_raw)    return "lossless_jpeg_load_raw()"; //+
+    if (load_raw == &LibRaw::minolta_rd175_load_raw )   return "minolta_rd175_load_raw()"; //+
+
+    if (load_raw == &LibRaw::nikon_compressed_load_raw) return "nikon_compressed_load_raw()";//+
+    if (load_raw == &LibRaw::nokia_load_raw )           return "nokia_load_raw()";//+ (untested)
+
+    if (load_raw == &LibRaw::olympus_load_raw )    return "olympus_load_raw()"; //+
+    if (load_raw == &LibRaw::packed_load_raw )       return "packed_load_raw()"; //+
+    if (load_raw == &LibRaw::panasonic_load_raw )       return "panasonic_load_raw()";//+
     // 30
-    if (load_raw == &LibRaw::pentax_load_raw )          return "pentax_load_raw()";
-    if (load_raw == &LibRaw::phase_one_load_raw )       return "phase_one_load_raw()";
-    if (load_raw == &LibRaw::phase_one_load_raw_c )     return "phase_one_load_raw_c()";
-
-    if (load_raw == &LibRaw::quicktake_100_load_raw )   return "quicktake_100_load_raw()";
-    if (load_raw == &LibRaw::rollei_load_raw )          return "rollei_load_raw()";
-    if (load_raw == &LibRaw::sinar_4shot_load_raw )     return "sinar_4shot_load_raw()";
-
-    if (load_raw == &LibRaw::smal_v6_load_raw )         return "smal_v6_load_raw()";
-    if (load_raw == &LibRaw::smal_v9_load_raw )         return "smal_v9_load_raw()";
-    if (load_raw == &LibRaw::sony_load_raw )            return "sony_load_raw()";
-    if (load_raw == &LibRaw::sony_arw_load_raw )        return "sony_arw_load_raw()";
+    if (load_raw == &LibRaw::pentax_load_raw )          return "pentax_load_raw()"; //+
+    if (load_raw == &LibRaw::phase_one_load_raw )       return "phase_one_load_raw()"; //+
+    if (load_raw == &LibRaw::phase_one_load_raw_c )     return "phase_one_load_raw_c()"; //+
+
+    if (load_raw == &LibRaw::quicktake_100_load_raw )   return "quicktake_100_load_raw()";//+ (untested)
+    if (load_raw == &LibRaw::rollei_load_raw )          return "rollei_load_raw()"; //+ (untested)
+    if (load_raw == &LibRaw::sinar_4shot_load_raw )     return "sinar_4shot_load_raw()";//+
+
+    if (load_raw == &LibRaw::smal_v6_load_raw )         return "smal_v6_load_raw()";//+ (untested)
+    if (load_raw == &LibRaw::smal_v9_load_raw )         return "smal_v9_load_raw()";//+ (untested)
+    if (load_raw == &LibRaw::sony_load_raw )            return "sony_load_raw()"; //+
+    if (load_raw == &LibRaw::sony_arw_load_raw )        return "sony_arw_load_raw()";//+
     // 40
-    if (load_raw == &LibRaw::sony_arw2_load_raw )       return "sony_arw2_load_raw()";
-    if (load_raw == &LibRaw::unpacked_load_raw )        return "unpacked_load_raw()";
+    if (load_raw == &LibRaw::sony_arw2_load_raw )       return "sony_arw2_load_raw()";//+
+    if (load_raw == &LibRaw::unpacked_load_raw )        return "unpacked_load_raw()"; //+
     // 42 total
         
     return "Unknown unpack function";
 }
 
+int LibRaw::adjust_maximum()
+{
+    int i;
+    ushort real_max;
+    float  auto_threshold;
+
+    if(O.adjust_maximum_thr < 0.00001)
+        return LIBRAW_SUCCESS;
+    else if (O.adjust_maximum_thr > 0.99999)
+        auto_threshold = LIBRAW_DEFAULT_ADJUST_MAXIMUM_THRESHOLD;
+    else
+        auto_threshold = O.adjust_maximum_thr;
+        
+    
+    real_max = C.channel_maximum[0];
+    for(i = 1; i< 4; i++)
+        if(real_max < C.channel_maximum[i])
+            real_max = C.channel_maximum[i];
+
+    if (real_max > 0 && real_max < C.maximum && real_max > C.maximum* auto_threshold)
+        {
+            C.maximum = real_max;
+        }
+    return LIBRAW_SUCCESS;
+}
+
 
 void LibRaw:: merror (void *ptr, const char *where)
 {
@@ -413,7 +454,6 @@
     M.br = M.bottom + (S.width * S.bottom_margin);
 
 }
-
 int LibRaw::add_masked_borders_to_bitmap()
 {
     CHECK_ORDER_HIGH(LIBRAW_PROGRESS_PRE_INTERPOLATE);
@@ -422,7 +462,7 @@
     if(S.width != S.iwidth || S.height!=S.iheight)
         return LIBRAW_CANNOT_ADDMASK;
 
-    if(P1.is_foveon || !P1.filters)
+    if(!P1.filters)
         return LIBRAW_CANNOT_ADDMASK;
         
     if(!imgdata.image)
@@ -446,7 +486,7 @@
             {
                 ushort *p = get_masked_pointer(r,c);
                 if(p)
-                    newimage[r*S.raw_width+c][FC(r,c)] = *p;
+                    newimage[r*S.raw_width+c][COLOR(r,c)] = *p;
             }
     // middle rows
     for (r=S.top_margin; r<S.top_margin+S.height;r++)
@@ -456,18 +496,20 @@
                 {
                     ushort *p = get_masked_pointer(r,c);
                     if(p)
-                        newimage[r*S.raw_width+c][FC(r,c)] =  *p;
+                        newimage[r*S.raw_width+c][COLOR(r,c)] =  *p;
                 }
             for(c=S.left_margin; c<S.left_margin+S.iwidth;c++)
                 {
                     int col = c - S.left_margin;
-                    newimage[r*S.raw_width+c][FC(r,c)] = imgdata.image[row*S.iwidth+col][FC(row,col)];
+                    newimage[r*S.raw_width+c][COLOR(r,c)] = imgdata.image[row*S.iwidth+col][COLOR(r,c)];
+//                    for(int cc=0;cc<4;cc++)
+//                        newimage[r*S.raw_width+c][cc] = imgdata.image[row*S.iwidth+col][cc];
                 }
             for(c=S.left_margin+S.iwidth;c<S.raw_width;c++)
                 {
                     ushort *p = get_masked_pointer(r,c);
                     if(p)
-                        newimage[r*S.raw_width+c][FC(r,c)] =  *p;
+                        newimage[r*S.raw_width+c][COLOR(r,c)] =  *p;
                 }
         }
     // bottom rows
@@ -476,7 +518,7 @@
             {
                 ushort *p = get_masked_pointer(r,c);
                 if(p)
-                    newimage[r*S.raw_width+c][FC(r,c)] = *p;
+                    newimage[r*S.raw_width+c][COLOR(r,c)] = *p;
             }
     free(imgdata.image);
     imgdata.image=newimage;
@@ -670,8 +712,6 @@
                 merror (libraw_internal_data.internal_data.meta_data, "LibRaw::unpack()");
             }
         ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);
-        // foveon_load_raw produces different data for document_mode, we'll
-        // deal with it in dcraw_document_mode_processing
         int save_document_mode = O.document_mode;
         O.document_mode = 0;
 
@@ -709,17 +749,6 @@
             O.filtering_mode = LIBRAW_FILTERING_AUTOMATIC_BIT; // turn on black and zeroes filtering
 
         O.document_mode = 2;
-        if(P1.is_foveon)
-            {
-                // filter image data for foveon document mode
-                short *iptr = (short *)imgdata.image;
-                for (int i=0; i < S.height*S.width*4; i++)
-                    {
-                        if ((short) iptr[i] < 0) 
-                            iptr[i] = 0;
-                    }
-                SET_PROC_FLAG(LIBRAW_PROGRESS_FOVEON_INTERPOLATE);
-            }
 
         O.use_fuji_rotate = 0;
         if (!(O.filtering_mode & LIBRAW_FILTERING_NOZEROES) && IO.zero_is_bad)
@@ -757,14 +786,14 @@
             }
         SET_PROC_FLAG(LIBRAW_PROGRESS_MIX_GREEN);
 
-        if (!P1.is_foveon && P1.colors == 3) 
+        if ( P1.colors == 3) 
             median_filter();
         SET_PROC_FLAG(LIBRAW_PROGRESS_MEDIAN_FILTER);
 
-        if (!P1.is_foveon && O.highlight == 2) 
+        if ( O.highlight == 2) 
             blend_highlights();
 
-        if (!P1.is_foveon && O.highlight > 2) 
+        if ( O.highlight > 2) 
             recover_highlights();
         SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);
 
@@ -1189,62 +1218,6 @@
 #undef SWAP
 
 
-void LibRaw::foveon_thumb_loader (void)
-{
-    unsigned bwide, row, col, bitbuf=0, bit=1, c, i;
-    struct decode *dindex;
-    short pred[3];
-    
-    if(T.thumb) free(T.thumb);
-    T.thumb = NULL;
-    
-    bwide = get4();
-    if (bwide > 0) 
-        {
-            if (bwide < (unsigned)T.twidth*3) return;
-            T.thumb = (char*)malloc(3*T.twidth * T.theight);
-            merror (T.thumb, "foveon_thumb()");
-            char *buf = (char*)malloc(bwide); 
-            merror (buf, "foveon_thumb()");
-            for (row=0; row < T.theight; row++) 
-                {
-                    ID.input->read(buf, 1, bwide);
-                    memmove(T.thumb+(row*T.twidth*3),buf,T.twidth*3);
-                }
-            free(buf);
-            T.tlength = 3*T.twidth * T.theight;
-            T.tformat = LIBRAW_THUMBNAIL_BITMAP;
-            return;
-        }
-    else 
-        {
-            foveon_decoder (256, 0);
-            T.thumb = (char*)malloc(3*T.twidth * T.theight);
-            char *bufp = T.thumb;
-            merror (T.thumb, "foveon_thumb()");
-            for (row=0; row < T.theight; row++) 
-                {
-                    memset (pred, 0, sizeof pred);
-                    if (!bit) get4();
-                    for (bit=col=0; col < T.twidth; col++)
-                        for(c=0;c<3;c++) 
-                            {
-                                for (dindex=first_decode; dindex->branch[0]; ) 
-                                    {
-                                        if ((bit = (bit-1) & 31) == 31)
-                                            for (i=0; i < 4; i++)
-                                                bitbuf = (bitbuf << 8) + ID.input->get_char();
-                                        dindex = dindex->branch[bitbuf >> bit & 1];
-                                    }
-                                pred[c] += dindex->leaf;
-                                (*bufp++)=pred[c];
-                            }
-                }
-            T.tformat = LIBRAW_THUMBNAIL_BITMAP;
-            T.tlength = 3*T.twidth * T.theight;
-        }
-    return;
-}
 
 
 //  thumbnail  ,  thumb_format    
@@ -1294,14 +1267,6 @@
                         return 0;
 
                     }
-                else if (write_thumb == &LibRaw::foveon_thumb)
-                    {
-                        foveon_thumb_loader();
-                        // may return with error, so format is set in
-                        // foveon thumb loader itself
-                        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);
-                        return 0;
-                    }
                 // else if -- all other write_thumb cases!
                 else
                     {
@@ -1418,7 +1383,6 @@
         {
             for(col=0;col<S.width;col++)
                 {
-
                     if (libraw_internal_data.unpacker_data.fuji_layout) {
                         r = IO.fuji_width - 1 - col + (row >> 1);
                         c = col + ((row+1) >> 1);
@@ -1426,8 +1390,8 @@
                         r = IO.fuji_width - 1 + row - (col >> 1);
                         c = row + ((col+1) >> 1);
                     }
-                    newimage[((r) >> IO.shrink)*fiwidth + ((c) >> IO.shrink)][FC(r,c)] = 
-                        imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][FC(r,c)];
+                    newimage[((r) >> IO.shrink)*fiwidth + ((c) >> IO.shrink)][FCF(row,col)] = 
+                        imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][FCF(row,col)];
                 }
         }
     // restore fuji sizes!
@@ -1455,6 +1419,7 @@
 
     try {
 
+        adjust_maximum();
         if(IO.fwidth) 
             rotate_fuji_raw();
 
@@ -1484,19 +1449,31 @@
         quality = 2 + !IO.fuji_width;
 
         if(O.filtering_mode & LIBRAW_FILTERING_NOBLACKS)
-            C.black=0;
+            {
+                C.black=0;
+                memset(&C.cblack,0,sizeof(C.cblack));
+            }
 
         if (O.user_qual >= 0) quality = O.user_qual;
+
+        unsigned int i = C.cblack[3];
+        unsigned int c;
+        for(c=0;c<3;c++)
+            if (i > C.cblack[c]) i = C.cblack[c];
+        for (c=0;c<4;c++)
+            C.cblack[c] -= i;
+        C.black += i;
+
+
         if (O.user_black >= 0) C.black = O.user_black;
         if (O.user_sat > 0) C.maximum = O.user_sat;
 
-        if (P1.is_foveon && !O.document_mode) 
+        if (O.green_matching)
             {
-                foveon_interpolate();
-                SET_PROC_FLAG(LIBRAW_PROGRESS_FOVEON_INTERPOLATE);
+                green_matching();
             }
 
-        if (!P1.is_foveon && O.document_mode < 2)
+        if ( O.document_mode < 2)
             {
                 scale_colors();
                 SET_PROC_FLAG(LIBRAW_PROGRESS_SCALE_COLORS);
@@ -1524,26 +1501,24 @@
                 SET_PROC_FLAG(LIBRAW_PROGRESS_MIX_GREEN);
             }
 
-        if(!P1.is_foveon)
+        if (P1.colors == 3) 
             {
-                if (P1.colors == 3) 
-                    {
-                        median_filter();
-                        SET_PROC_FLAG(LIBRAW_PROGRESS_MEDIAN_FILTER);
-                    }
-            
-                if (O.highlight == 2) 
-                    {
-                        blend_highlights();
-                        SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);
-                    }
-            
-                if (O.highlight > 2) 
-                    {
-                        recover_highlights();
-                        SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);
-                    }
+                median_filter();
+                SET_PROC_FLAG(LIBRAW_PROGRESS_MEDIAN_FILTER);
+            }
+        
+        if (O.highlight == 2) 
+            {
+                blend_highlights();
+                SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);
             }
+        
+        if (O.highlight > 2) 
+            {
+                recover_highlights();
+                SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);
+            }
+        
         if (O.use_fuji_rotate) 
             {
                 fuji_rotate();
@@ -1649,6 +1624,7 @@
 "Canon EOS 400D / Digital Rebel XTi / Kiss Digital X",
 "Canon EOS 450D / Digital Rebel XSi / Kiss Digital X2",
 "Canon EOS 500D / Digital Rebel T1i / Kiss Digital X3",
+"Canon EOS 550D / Digital Rebel T2i / Kiss Digital X4",
 "Canon EOS 1000D / Digital Rebel XS / Kiss Digital F",
 "Canon EOS D2000C",
 "Canon EOS-1D",
@@ -1676,6 +1652,7 @@
 "Casio EX-Z75",
 "Casio EX-Z750",
 "Casio EX-Z850",
+"Casio EX-Z1050",
 "Casio Exlim Pro 505",
 "Casio Exlim Pro 600",
 "Casio Exlim Pro 700",
@@ -1702,6 +1679,7 @@
 "Fuji FinePix S9000/S9500",
 "Fuji FinePix S9100/S9600",
 "Fuji FinePix S200EXR",
+"Fuji FinePix HS10/HS11",
 "Fuji IS-1",
 "Hasselblad CFV",
 "Hasselblad H3D",
@@ -1710,8 +1688,8 @@
 "Imacon Ixpress 22-megapixel",
 "Imacon Ixpress 39-megapixel",
 "ISG 2020x1520",
-"Kodak DC20 (see Oliver Hartman's page)",
-"Kodak DC25 (see Jun-ichiro Itoh's page)",
+"Kodak DC20",
+"Kodak DC25",
 "Kodak DC40",
 "Kodak DC50",
 "Kodak DC120 (also try kdc2tiff)",
@@ -1746,6 +1724,7 @@
 "Kodak P850",
 "Kodak P880",
 "Kodak Z980",
+"Kodak Z981",
 "Kodak Z1015",
 "Kodak KAI-0340",
 "Konica KD-400Z",
@@ -1861,6 +1840,7 @@
 "Olympus E-520",
 "Olympus E-620",
 "Olympus E-P1",
+"Olympus E-PL1",
 "Olympus SP310",
 "Olympus SP320",
 "Olympus SP350",
@@ -1877,6 +1857,8 @@
 "Panasonic DMC-FZ50",
 "Panasonic DMC-FX150",
 "Panasonic DMC-G1",
+"Panasonic DMC-G10",
+"Panasonic DMC-G2",
 "Panasonic DMC-GH1",
 "Panasonic DMC-L1",
 "Panasonic DMC-L10",
@@ -1910,18 +1892,17 @@
 "Phase One P 30",
 "Phase One P 45",
 "Phase One P 45+",
+"Phase One P 65",
 "Pixelink A782",
-"Polaroid x530",
 "Rollei d530flex",
 "RoverShot 3320af",
 "Samsung GX-1S",
 "Samsung GX-10",
+"Samsung NX-10",
+"Samsung WB550",
 "Samsung S85 (hacked)",
 "Samsung S850 (hacked)",
 "Sarnoff 4096x5440",
-"Sigma SD9",
-"Sigma SD10",
-"Sigma SD14",
 "Sinar 3072x2048",
 "Sinar 4080x4080",
 "Sinar 4080x5440",
@@ -1938,14 +1919,16 @@
 "Sony DSLR-A330",
 "Sony DSLR-A350",
 "Sony DSLR-A380",
+"Sony DSLR-A450 (beta)",
 "Sony DSLR-A500",
 "Sony DSLR-A550",
 "Sony DSLR-A700",
 "Sony DSLR-A850",
 "Sony DSLR-A900",
+"Sony NEX-3",
+"Sony NEX-5",
 "Sony XCD-SX910CR",
 "STV680 VGA",
-
    NULL
 };
 
@@ -1973,8 +1956,6 @@
             return "Removing dead pixels";
         case LIBRAW_PROGRESS_DARK_FRAME:
             return "Subtracting dark frame data";
-        case LIBRAW_PROGRESS_FOVEON_INTERPOLATE:
-            return "Interpolating Foveon sensor data";
         case LIBRAW_PROGRESS_SCALE_COLORS:
             return "Scaling colors";
         case LIBRAW_PROGRESS_PRE_INTERPOLATE:
diff -ru kdegraphics-4.4.4/libs/libkdcraw/NEWS kdegraphics/libs/libkdcraw/NEWS
--- kdegraphics-4.4.4/libs/libkdcraw/NEWS	2009-11-23 15:59:02.000000000 +0100
+++ kdegraphics/libs/libkdcraw/NEWS	2010-06-10 17:10:42.372822284 +0200
@@ -1,3 +1,27 @@
+1.1.0 - Released with KDE 4.5.0
+------------------------------------------------------------------------
+
+* dcraw 9.01 (1.434) imported:
+    + Separate black levels for each color channel.
+    + New cameras: Canon 550D, Casio EX-Z1050, Fuji HS10/HS11,
+        Kodak Z981, Panasonic G2 and G10, Phase One P65,
+        Samsung NX-10 and WB550, Sony NEX-3 and NEX-5.
+    + Fixed file descriptor leak in dark frame subtraction processing
+
+* Fixed dcraw 9.01's bug in DNG black level processing
+
+* Preliminary support for Sony A450 camera.
+
+* New command-line switch -h in mem_image sample (half_size support)
+
+* Some patches by Johannes Hanika (darktable author):
+    + OpenMP speedup  for PPG-interpolation
+    + green_matching  - suppress of 'color maze' on cameras with
+    different green channel sensitivity. This option is turns on
+    by  filed with same name in imgdata.params
+
+* LibRaw::free() is now public instead of private.
+
 1.0.0 - Released with KDE 4.4.0
 ------------------------------------------------------------------------
 
@@ -31,13 +55,13 @@
     * New color data for many cameras.
     * Generalized unpacking code for many formats.
     * Removed hardcoded white-balance data for many P&S cameras. It is recommended to set params.use_camera_wb to 1 for safe WB.
-    * Canon cameras: black level is not subtracted if params.document_mode =2 
+    * Canon cameras: black level is not subtracted if params.document_mode =2
 # API changes: params.gamma_16bit field removed. Gamma curve is set via params.gamm[0]/gamm[1] values (see documentation and samples for details)
 # Many cosmetic changes to support more platforms/compilers.
 # Samples: dcraw_emu and mem_image samples supports new dcraw 16bit/gamma semantics:
     * -6: set 16 bit output
-    * -4: set 16 bit output and linear gamma curve and no auto brightness 
-# C-API: added missed (but documented) calls libraw_dcraw_make_mem_image() and libraw_dcraw_ make_mem_thumb() 
+    * -4: set 16 bit output and linear gamma curve and no auto brightness
+# C-API: added missed (but documented) calls libraw_dcraw_make_mem_image() and libraw_dcraw_ make_mem_thumb()
 
 - API changed : remove RawDecodingSetting::gamma16bit settings. Obsolete with LibRaw 0.8.0.
                 remove KDcraw depreciated methods.
@@ -46,18 +70,18 @@
 0.5.0 - Released with KDE 4.3.0
 ------------------------------------------------------------------------
 - Updated to LibRaw 0.7.2 : More accurate types conversion in libraw_datastream.h to make compilers happy.
-                            New postprocessing parameter auto_bright_thr: set portion of clipped pixels for 
+                            New postprocessing parameter auto_bright_thr: set portion of clipped pixels for
                             auto brightening code (instead of dcraw-derived hardcoded 1%).
                             -U option for dcraw_emu sample sets auto_bright_thr parameter.
 - Updated to LibRaw 0.7.1 : Fixed broken OpenMP support.
 - Updated to LibRaw 0.7.0 : Black (masked) pixels data extracted from RAW and avaliable in application.
-                            Application can turn off RAW data filtering (black level subtraction, 
+                            Application can turn off RAW data filtering (black level subtraction,
                             zero pixels removal and raw tone curve).
-                            New 'input framework' released. Reading raw data from file and memory buffer supported from scratch. 
+                            New 'input framework' released. Reading raw data from file and memory buffer supported from scratch.
                             LibRaw-using application can implement own data reading functions (e.g. reading from network stream).
                             Fuji SuperCCD: raw data extracted without 45-degree rotation.
                             New sample applications: 4channels and unprocessed_raw
-                            Imported (subsequentally) new dcraw versions from 8.89 to 8.93 (up to date) 
+                            Imported (subsequentally) new dcraw versions from 8.89 to 8.93 (up to date)
 - New option to switch on/off auto brightness adjsutements.
 - Add support of Leica Raw files (RWL).
 - New method to see if Libraw use OpenMP shared library to perform parallel demosaicing.
@@ -65,7 +89,7 @@
 
 0.4.0 - Released with KDE 4.2.0
 ------------------------------------------------------------------------
-- Updated to LibRaw 0.6.5 : Fixed file descriptor and buffer memory leak when thumbnail extractor is called, 
+- Updated to LibRaw 0.6.5 : Fixed file descriptor and buffer memory leak when thumbnail extractor is called,
                             but library object is not properly initialized.
                             Fixes in Imacon files unpacking.
                             Fixes in Hasselblad .fff files unpacking.
@@ -116,7 +140,7 @@
 - updated dcraw to 8.82
                new cameras: Sony DSLR-A200, Sony DSLR-A700, Sony XCD-SX910CR, STV680 VGA
                no new options introduced.
-                                      
+
 Bugs fixed from B.K.O (http://bugs.kde.org):
 001 ==> 142055 : Which whitebalance is used.
 
@@ -131,7 +155,7 @@
                Nikon Coolpix S6, Panasonic DMC-FZ18, Sony DSLR-A700
 
                -m number_of_passes
-               After interpolation, clean up color artifacts by repeatedly 
+               After interpolation, clean up color artifacts by repeatedly
                applying a 3x3 median filter to the R-G and B-G channels.
 - dcraw.c licence : is GPL compatible again == less wories)
 
diff -ru kdegraphics-4.4.4/libs/libkdcraw/test/CMakeLists.txt kdegraphics/libs/libkdcraw/test/CMakeLists.txt
--- kdegraphics-4.4.4/libs/libkdcraw/test/CMakeLists.txt	2009-07-06 12:42:43.000000000 +0200
+++ kdegraphics/libs/libkdcraw/test/CMakeLists.txt	2010-06-10 17:10:38.705730027 +0200
@@ -2,7 +2,7 @@
 INCLUDE_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR}/../libkdcraw)
 
 # add a small macro so that this is a bit cleaner
-MACRO(libkdcraw_build_test)
+MACRO(LIBKDCRAW_BUILD_TEST)
     SET(_target ${ARGV0})
     SET(${_target}_SRCS 
         ../libraw/samples/${_target}.cpp
@@ -15,18 +15,18 @@
     ENDFOREACH(_curentfile ${${_target}_SRCS})
 
     KDE4_ADD_EXECUTABLE(${_target} NOGUI ${${_target}_SRCS})
-    TARGET_LINK_LIBRARIES(${_target} 
-                          ${MATH_LIBRARY} 
-                          ${LCMS_LIBRARIES} 
-                          ${JPEG_LIBRARY} 
-                          ${OPENMP_LDFLAGS} 
+    TARGET_LINK_LIBRARIES(${_target}
+                          ${MATH_LIBRARY}
+                          ${LCMS_LIBRARIES}
+                          ${JPEG_LIBRARY}
+                          ${OPENMP_LDFLAGS}
                           ${CMAKE_THREAD_LIBS_INIT}
                          )
     SET_TARGET_PROPERTIES(${_target} PROPERTIES COMPILE_FLAGS -DLIBRAW_BUILDLIB)
     IF(WIN32)
         TARGET_LINK_LIBRARIES(${_target} ws2_32)
     ENDIF(WIN32)
-ENDMACRO(libkdcraw_build_test)
+ENDMACRO(LIBKDCRAW_BUILD_TEST)
 
 SET(raw2png_SRCS raw2png.cpp)
 KDE4_ADD_EXECUTABLE(raw2png NOGUI ${raw2png_SRCS})
diff -ru kdegraphics-4.4.4/libs/libkdcraw/test/raw2png.cpp kdegraphics/libs/libkdcraw/test/raw2png.cpp
--- kdegraphics-4.4.4/libs/libkdcraw/test/raw2png.cpp	2008-09-17 22:54:23.000000000 +0200
+++ kdegraphics/libs/libkdcraw/test/raw2png.cpp	2010-06-10 17:10:38.705730027 +0200
@@ -30,15 +30,9 @@
 
 #include "kdeversion.h"
 
-#if KDE_IS_VERSION(4,0,0)
 #include "qdebug.h"
 #define PRINT_DEBUG qDebug()
 #define ENDL
-#else
-#include "kdebug.h"
-#define PRINT_DEBUG kdDebug()
-#define ENDL << endl
-#endif
 
 // Local includes.
 
