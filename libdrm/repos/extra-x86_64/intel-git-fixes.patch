commit 6717b7579f84d05e45e7846d2b6e767760461709
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Jan 12 10:57:46 2011 +0000

    intel: Fallback to old exec if no mrb_exec is available
    
    Reported-by: Torsten Hilbrich <torsten.hilbrich@secunet.com>
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=33016
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/intel/intel_bufmgr.c b/intel/intel_bufmgr.c
index b7c5c09..2546222 100644
--- a/intel/intel_bufmgr.c
+++ b/intel/intel_bufmgr.c
@@ -143,6 +143,10 @@ drm_intel_bo_mrb_exec(drm_intel_bo *bo, int used,
 					cliprects, num_cliprects, DR4,
 					rings);
 
+	if (ring_flag == 0)
+		return bo->bufmgr->bo_exec(bo, used,
+					   cliprects, num_cliprects, DR4);
+
 	return -ENODEV;
 }
 
commit 53581b6210c024044e0065527d1506e6f5657ef5
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Feb 14 09:27:05 2011 +0000

    intel: Set the public handle after opening by name
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/intel/intel_bufmgr_gem.c b/intel/intel_bufmgr_gem.c
index 72c8731..092b56a 100644
--- a/intel/intel_bufmgr_gem.c
+++ b/intel/intel_bufmgr_gem.c
@@ -816,6 +816,7 @@ drm_intel_bo_gem_create_from_name(drm_intel_bufmgr *bufmgr,
 	atomic_set(&bo_gem->refcount, 1);
 	bo_gem->validate_index = -1;
 	bo_gem->gem_handle = open_arg.handle;
+	bo_gem->bo.handle = open_arg.handle;
 	bo_gem->global_name = handle;
 	bo_gem->reusable = 0;
 
commit 36d4939343d8789d9066f7245fa2d4fe69119dd8
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Feb 14 09:39:06 2011 +0000

    intel: Remember named bo
    
    ... and if asked to open a bo by the same global name, return a fresh
    reference to the previously allocated buffer.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/intel/intel_bufmgr_gem.c b/intel/intel_bufmgr_gem.c
index 092b56a..3cdffce 100644
--- a/intel/intel_bufmgr_gem.c
+++ b/intel/intel_bufmgr_gem.c
@@ -95,6 +95,8 @@ typedef struct _drm_intel_bufmgr_gem {
 	int num_buckets;
 	time_t time;
 
+	drmMMListHead named;
+
 	uint64_t gtt_size;
 	int available_fences;
 	int pci_device;
@@ -124,6 +126,7 @@ struct _drm_intel_bo_gem {
 	 * Kenel-assigned global name for this object
 	 */
 	unsigned int global_name;
+	drmMMListHead name_list;
 
 	/**
 	 * Index of the buffer within the validation list while preparing a
@@ -690,6 +693,8 @@ retry:
 		    drm_intel_gem_bo_free(&bo_gem->bo);
 		    return NULL;
 		}
+
+		DRMINITLISTHEAD(&bo_gem->name_list);
 	}
 
 	bo_gem->name = name;
@@ -792,6 +797,23 @@ drm_intel_bo_gem_create_from_name(drm_intel_bufmgr *bufmgr,
 	int ret;
 	struct drm_gem_open open_arg;
 	struct drm_i915_gem_get_tiling get_tiling;
+	drmMMListHead *list;
+
+	/* At the moment most applications only have a few named bo.
+	 * For instance, in a DRI client only the render buffers passed
+	 * between X and the client are named. And since X returns the
+	 * alternating names for the front/back buffer a linear search
+	 * provides a sufficiently fast match.
+	 */
+	for (list = bufmgr_gem->named.next;
+	     list != &bufmgr_gem->named;
+	     list = list->next) {
+		bo_gem = DRMLISTENTRY(drm_intel_bo_gem, list, name_list);
+		if (bo_gem->global_name == handle) {
+			drm_intel_gem_bo_reference(&bo_gem->bo);
+			return &bo_gem->bo;
+		}
+	}
 
 	bo_gem = calloc(1, sizeof(*bo_gem));
 	if (!bo_gem)
@@ -834,6 +856,7 @@ drm_intel_bo_gem_create_from_name(drm_intel_bufmgr *bufmgr,
 	/* XXX stride is unknown */
 	drm_intel_bo_gem_set_in_aperture_size(bufmgr_gem, bo_gem);
 
+	DRMLISTADDTAIL(&bo_gem->name_list, &bufmgr_gem->named);
 	DBG("bo_create_from_handle: %d (%s)\n", handle, bo_gem->name);
 
 	return &bo_gem->bo;
@@ -925,6 +948,8 @@ drm_intel_gem_bo_unreference_final(drm_intel_bo *bo, time_t time)
 		bo_gem->relocs = NULL;
 	}
 
+	DRMLISTDEL(&bo_gem->name_list);
+
 	bucket = drm_intel_gem_bo_bucket_for_size(bufmgr_gem, bo->size);
 	/* Put the buffer into our internal cache for reuse if we can. */
 	if (bufmgr_gem->bo_reuse && bo_gem->reusable && bucket != NULL &&
@@ -1771,6 +1796,8 @@ drm_intel_gem_bo_flink(drm_intel_bo *bo, uint32_t * name)
 			return -errno;
 		bo_gem->global_name = flink.name;
 		bo_gem->reusable = 0;
+
+		DRMLISTADDTAIL(&bo_gem->name_list, &bufmgr_gem->named);
 	}
 
 	*name = bo_gem->global_name;
@@ -2217,6 +2244,7 @@ drm_intel_bufmgr_gem_init(int fd, int batch_size)
 	    drm_intel_gem_get_pipe_from_crtc_id;
 	bufmgr_gem->bufmgr.bo_references = drm_intel_gem_bo_references;
 
+	DRMINITLISTHEAD(&bufmgr_gem->named);
 	init_cache_buckets(bufmgr_gem);
 
 	return &bufmgr_gem->bufmgr;
