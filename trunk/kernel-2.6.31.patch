--- lirc-0.8.5/drivers/lirc_i2c/lirc_i2c.c	2009-02-14 20:35:52.000000000 +0100
+++ lirc-0.8.5/drivers/lirc_i2c/lirc_i2c.c	2009-09-11 21:27:08.000000000 +0200
@@ -1,4 +1,4 @@
-/*      $Id: lirc_i2c.c,v 1.64 2009/02/14 19:35:52 lirc Exp $      */
+/*      $Id: lirc_i2c.c,v 1.70 2009/08/30 16:59:53 jarodwilson Exp $      */
 
 /*
  * lirc_i2c.c
@@ -175,15 +175,18 @@
 	struct IR *ir = data;
 	__u16 code;
 	unsigned char codes[2];
+	int ret;
 
 	/* poll IR chip */
-	if (size == i2c_master_recv(&ir->c, keybuf, size)) {
+	ret = i2c_master_recv(&ir->c, keybuf, size);
+	if (ret == size) {
 		ir->b[0] = keybuf[offset];
 		ir->b[1] = keybuf[offset+1];
 		ir->b[2] = keybuf[offset+2];
-		dprintk("key (0x%02x/0x%02x)\n", ir->b[0], ir->b[1]);
+		if (ir->b[0] != 0x00 && ir->b[1] != 0x00)
+			dprintk("key (0x%02x/0x%02x)\n", ir->b[0], ir->b[1]);
 	} else {
-		dprintk("read error\n");
+		dprintk("read error (ret=%d)\n", ret);
 		/* keep last successful read buffer */
 	}
 
@@ -198,6 +201,7 @@
 	codes[1] = code & 0xff;
 
 	/* return it */
+	dprintk("sending code 0x%02x%02x to lirc\n", codes[0], codes[1]);
 	lirc_buffer_write(buf, codes);
 	return 0;
 }
@@ -329,12 +333,15 @@
 static int set_use_inc(void *data)
 {
 	struct IR *ir = data;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25)
+	int ret;
+#endif
+
+	dprintk("%s called\n", __func__);
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
 	i2c_use_client(&ir->c);
 #else
-	int ret;
-
 	/* lock bttv in memory while /dev/lirc is in use  */
 	ret = i2c_use_client(&ir->c);
 	if (ret != 0)
@@ -349,6 +356,8 @@
 {
 	struct IR *ir = data;
 
+	dprintk("%s called\n", __func__);
+
 	i2c_release_client(&ir->c);
 	MOD_DEC_USE_COUNT;
 }
@@ -361,12 +370,25 @@
 	.owner		= THIS_MODULE,
 };
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31)
 static int ir_attach(struct i2c_adapter *adap, int addr,
 		      unsigned short flags, int kind);
-static int ir_detach(struct i2c_client *client);
 static int ir_probe(struct i2c_adapter *adap);
+# else
+static int ir_probe(struct i2c_client *client, const struct i2c_device_id *id);
+#endif
+static int ir_remove(struct i2c_client *client);
 static int ir_command(struct i2c_client *client, unsigned int cmd, void *arg);
 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 30)
+static const struct i2c_device_id ir_receiver_id[] = {
+	/* Generic entry for any IR receiver */
+	{ "ir_video", 0 },
+	/* IR device specific entries could be added here */
+	{ }
+};
+#endif
+
 static struct i2c_driver driver = {
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 16)
 	.name		= "i2c ir driver",
@@ -378,34 +400,80 @@
 	},
 #endif
 	.id		= I2C_DRIVERID_EXP3, /* FIXME */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31)
 	.attach_adapter	= ir_probe,
-	.detach_client	= ir_detach,
+	.detach_client	= ir_remove,
+#else
+	.probe		= ir_probe,
+	.remove		= ir_remove,
+	.id_table	= ir_receiver_id,
+#endif
 	.command	= ir_command,
 };
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31)
 static struct i2c_client client_template = {
 	.name		= "unset",
 	.driver		= &driver
 };
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31)
 static int ir_attach(struct i2c_adapter *adap, int addr,
 		     unsigned short flags, int kind)
+#else
+static void pcf_probe(struct i2c_client *client, struct IR *ir)
+{
+	int ret1, ret2, ret3, ret4;
+
+	ret1 = i2c_smbus_write_byte(client, 0xff);
+	ret2 = i2c_smbus_read_byte(client);
+	ret3 = i2c_smbus_write_byte(client, 0x00);
+	ret4 = i2c_smbus_read_byte(client);
+
+	/* in the Asus TV-Box: bit 1-0 */
+	if (((ret2 & 0x03) == 0x03) && ((ret4 & 0x03) == 0x00)) {
+		ir->bits = (unsigned char) ~0x07;
+		ir->flag = 0x04;
+	/* in the Creative/VisionTek BreakOut-Box: bit 7-6 */
+	} else if (((ret2 & 0xc0) == 0xc0) && ((ret4 & 0xc0) == 0x00)) {
+		ir->bits = (unsigned char) ~0xe0;
+		ir->flag = 0x20;
+	}
+
+	return;
+}
+
+static int ir_probe(struct i2c_client *client, const struct i2c_device_id *id)
+#endif
 {
 	struct IR *ir;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31)
 	int err, retval;
 
 	client_template.adapter = adap;
 	client_template.addr = addr;
+#else
+	struct i2c_adapter *adap = client->adapter;
+	unsigned short addr = client->addr;
+	int retval;
+#endif
 
 	ir = kmalloc(sizeof(struct IR), GFP_KERNEL);
 	if (!ir)
 		return -ENOMEM;
 	memcpy(&ir->l, &lirc_template, sizeof(struct lirc_driver));
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31)
 	memcpy(&ir->c, &client_template, sizeof(struct i2c_client));
 
 	ir->c.adapter = adap;
 	ir->c.addr    = addr;
 	i2c_set_clientdata(&ir->c, ir);
+#else
+	memcpy(&ir->c, client, sizeof(struct i2c_client));
+
+	i2c_set_clientdata(client, ir);
+#endif
 	ir->l.data    = ir;
 	ir->l.minor   = minor;
 	ir->l.sample_rate = 10;
@@ -470,11 +538,15 @@
 		break;
 	case 0x21:
 	case 0x23:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31)
+		ir->bits = flags & 0xff;
+		ir->flag = (flags >> 8) & 0xff;
+#else
+		pcf_probe(client, ir);
+#endif
 		strlcpy(ir->c.name, "TV-Box IR", I2C_NAME_SIZE);
 		ir->l.code_length = 8;
 		ir->l.add_to_buf = add_to_buf_pcf8574;
-		ir->bits = flags & 0xff;
-		ir->flag = (flags >> 8) & 0xff;
 		break;
 	default:
 		/* shouldn't happen */
@@ -485,18 +557,22 @@
 	printk(KERN_INFO "lirc_i2c: chip 0x%x found @ 0x%02x (%s)\n",
 	       adap->id, addr, ir->c.name);
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31)
 	/* register device */
 	err = i2c_attach_client(&ir->c);
 	if (err) {
 		kfree(ir);
 		return err;
 	}
+#endif
 
 	retval = lirc_register_driver(&ir->l);
 
 	if (retval < 0) {
 		printk(KERN_ERR "lirc_i2c: failed to register driver!\n");
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31)
 		i2c_detach_client(&ir->c);
+#endif
 		kfree(ir);
 		return retval;
 	}
@@ -506,19 +582,22 @@
 	return 0;
 }
 
-static int ir_detach(struct i2c_client *client)
+static int ir_remove(struct i2c_client *client)
 {
 	struct IR *ir = i2c_get_clientdata(client);
 
 	/* unregister device */
 	lirc_unregister_driver(ir->l.minor);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31)
 	i2c_detach_client(&ir->c);
+#endif
 
 	/* free memory */
 	kfree(ir);
 	return 0;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31)
 static int ir_probe(struct i2c_adapter *adap)
 {
 	/*
@@ -656,6 +735,7 @@
 	return rc;
 
 }
+#endif
 
 static int ir_command(struct i2c_client *client, unsigned int cmd, void *arg)
 {
