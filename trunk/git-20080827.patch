diff --git a/src/AtomBios/CD_Operations.c b/src/AtomBios/CD_Operations.c
index 509aa0c..58c4ae9 100644
--- a/src/AtomBios/CD_Operations.c
+++ b/src/AtomBios/CD_Operations.c
@@ -44,7 +44,6 @@ Revision History:
 #include "xorg-server.h"
 
 #include "Decoder.h"
-#include	"atombios.h"
 
 VOID PutDataRegister(PARSER_TEMP_DATA STACK_BASED * pParserTempData);
 VOID PutDataPS(PARSER_TEMP_DATA STACK_BASED * pParserTempData);
@@ -231,7 +230,7 @@ UINT32 IndirectInputOutput(PARSER_TEMP_DATA STACK_BASED * pParserTempData)
 		IndirectIOParserCommands[*pParserTempData->IndirectIOTablePointer].func(pParserTempData);
 		pParserTempData->IndirectIOTablePointer+=IndirectIOParserCommands[*pParserTempData->IndirectIOTablePointer].csize;
 	    }
-	    pParserTempData->IndirectIOTablePointer-=*(UINT16*)(pParserTempData->IndirectIOTablePointer+1);
+	    pParserTempData->IndirectIOTablePointer-=UINT16LE_TO_CPU(*(UINT16*)(pParserTempData->IndirectIOTablePointer+1));
 	    pParserTempData->IndirectIOTablePointer++;
 	    return pParserTempData->IndirectData;
 	} else pParserTempData->IndirectIOTablePointer+=IndirectIOParserCommands[*pParserTempData->IndirectIOTablePointer].csize;
@@ -243,7 +242,7 @@ UINT32 IndirectInputOutput(PARSER_TEMP_DATA STACK_BASED * pParserTempData)
 
 VOID PutDataRegister(PARSER_TEMP_DATA STACK_BASED * pParserTempData)
 {
-    pParserTempData->Index=(UINT32)pParserTempData->pCmd->Parameters.WordXX.PA_Destination;
+    pParserTempData->Index=(UINT32)UINT16LE_TO_CPU(pParserTempData->pCmd->Parameters.WordXX.PA_Destination);
     pParserTempData->Index+=pParserTempData->CurrentRegBlock;
     switch(pParserTempData->Multipurpose.CurrentPort){
 	case ATI_RegsPort:
@@ -269,16 +268,16 @@ VOID PutDataRegister(PARSER_TEMP_DATA STACK_BASED * pParserTempData)
 VOID PutDataPS(PARSER_TEMP_DATA STACK_BASED * pParserTempData)
 {
     *(pParserTempData->pDeviceData->pParameterSpace+pParserTempData->pCmd->Parameters.ByteXX.PA_Destination)=
-	pParserTempData->DestData32;
+	    CPU_TO_UINT32LE(pParserTempData->DestData32);
 }
 
 VOID PutDataWS(PARSER_TEMP_DATA STACK_BASED * pParserTempData)
 {
     if (pParserTempData->pCmd->Parameters.ByteXX.PA_Destination < WS_QUOTIENT_C)
-	*(pParserTempData->pWorkingTableData->pWorkSpace+pParserTempData->pCmd->Parameters.ByteXX.PA_Destination) = pParserTempData->DestData32;
+      *(pParserTempData->pWorkingTableData->pWorkSpace+pParserTempData->pCmd->Parameters.ByteXX.PA_Destination) = pParserTempData->DestData32;
     else
-	switch (pParserTempData->pCmd->Parameters.ByteXX.PA_Destination)
-	{
+	  switch (pParserTempData->pCmd->Parameters.ByteXX.PA_Destination)
+	  {
 	    case WS_REMINDER_C:
 		pParserTempData->MultiplicationOrDivision.Division.Reminder32=pParserTempData->DestData32;
 		break;
@@ -339,7 +338,7 @@ VOID SkipParameters16(PARSER_TEMP_DATA STACK_BASED *	pParserTempData)
 
 UINT32 GetParametersRegister(PARSER_TEMP_DATA STACK_BASED *	pParserTempData)
 {
-    pParserTempData->Index=*(UINT16*)pParserTempData->pWorkingTableData->IP;
+    pParserTempData->Index=UINT16LE_TO_CPU(*(UINT16*)pParserTempData->pWorkingTableData->IP);
     pParserTempData->pWorkingTableData->IP+=sizeof(UINT16);
     pParserTempData->Index+=pParserTempData->CurrentRegBlock;
     switch(pParserTempData->Multipurpose.CurrentPort)
@@ -361,9 +360,11 @@ UINT32 GetParametersRegister(PARSER_TEMP_DATA STACK_BASED *	pParserTempData)
 
 UINT32 GetParametersPS(PARSER_TEMP_DATA STACK_BASED *	pParserTempData)
 {
+    UINT32 data;
     pParserTempData->Index=*pParserTempData->pWorkingTableData->IP;
     pParserTempData->pWorkingTableData->IP+=sizeof(UINT8);
-    return *(pParserTempData->pDeviceData->pParameterSpace+pParserTempData->Index);
+    data = UINT32LE_TO_CPU(*(pParserTempData->pDeviceData->pParameterSpace+pParserTempData->Index));
+    return data;
 }
 
 UINT32 GetParametersWS(PARSER_TEMP_DATA STACK_BASED *	pParserTempData)
@@ -419,9 +420,12 @@ UINT32 GetParametersMC(PARSER_TEMP_DATA STACK_BASED *	pParserTempData)
 
 UINT32 GetParametersIndirect(PARSER_TEMP_DATA STACK_BASED *	pParserTempData)
 {
-    pParserTempData->Index=*(UINT16*)pParserTempData->pWorkingTableData->IP;
+	  UINT32 ret;
+
+    pParserTempData->Index=UINT16LE_TO_CPU(*(UINT16*)pParserTempData->pWorkingTableData->IP);
     pParserTempData->pWorkingTableData->IP+=sizeof(UINT16);
-    return *(UINT32*)(RELATIVE_TO_BIOS_IMAGE(pParserTempData->Index)+pParserTempData->CurrentDataBlock);
+    ret = UINT32LE_TO_CPU(*(UINT32*)(RELATIVE_TO_BIOS_IMAGE(pParserTempData->Index)+pParserTempData->CurrentDataBlock));
+    return ret;
 }
 
 UINT32 GetParametersDirect8(PARSER_TEMP_DATA STACK_BASED *	pParserTempData)
@@ -435,7 +439,7 @@ UINT32 GetParametersDirect8(PARSER_TEMP_DATA STACK_BASED *	pParserTempData)
 UINT32 GetParametersDirect16(PARSER_TEMP_DATA STACK_BASED *	pParserTempData)
 {
     pParserTempData->CD_Mask.SrcAlignment=alignmentLowerWord;
-    pParserTempData->Index=*(UINT16*)pParserTempData->pWorkingTableData->IP;
+    pParserTempData->Index=UINT16LE_TO_CPU(*(UINT16*)pParserTempData->pWorkingTableData->IP);
     pParserTempData->pWorkingTableData->IP+=sizeof(UINT16);
     return pParserTempData->Index;
 }
@@ -443,7 +447,7 @@ UINT32 GetParametersDirect16(PARSER_TEMP_DATA STACK_BASED *	pParserTempData)
 UINT32 GetParametersDirect32(PARSER_TEMP_DATA STACK_BASED *	pParserTempData)
 {
     pParserTempData->CD_Mask.SrcAlignment=alignmentDword;
-    pParserTempData->Index=*(UINT32*)pParserTempData->pWorkingTableData->IP;
+    pParserTempData->Index=UINT32LE_TO_CPU(*(UINT32*)pParserTempData->pWorkingTableData->IP);
     pParserTempData->pWorkingTableData->IP+=sizeof(UINT32);
     return pParserTempData->Index;
 }
@@ -474,7 +478,7 @@ VOID ProcessMove(PARSER_TEMP_DATA STACK_BASED * pParserTempData)
 {
     if (pParserTempData->CD_Mask.SrcAlignment!=alignmentDword)
     {
-	pParserTempData->DestData32=GetDestination[pParserTempData->ParametersType.Destination](pParserTempData);
+				pParserTempData->DestData32=GetDestination[pParserTempData->ParametersType.Destination](pParserTempData);
     } else
     {
 	SkipDestination[pParserTempData->ParametersType.Destination](pParserTempData);
@@ -664,7 +668,8 @@ VOID ProcessSwitch(PARSER_TEMP_DATA STACK_BASED * pParserTempData){
     pParserTempData->SourceData32=GetSource[pParserTempData->ParametersType.Source](pParserTempData);
     pParserTempData->SourceData32 >>= SourceAlignmentShift[pParserTempData->CD_Mask.SrcAlignment];
     pParserTempData->SourceData32 &= AlignmentMask[pParserTempData->CD_Mask.SrcAlignment];
-    while ( *(UINT16*)pParserTempData->pWorkingTableData->IP != (((UINT16)NOP_OPCODE << 8)+NOP_OPCODE))
+
+    while ( UINT16LE_TO_CPU(*(UINT16*)pParserTempData->pWorkingTableData->IP) != (((UINT16)NOP_OPCODE << 8)+NOP_OPCODE))
     {
 	if (*pParserTempData->pWorkingTableData->IP == 'c')
 	{
@@ -673,7 +678,7 @@ VOID ProcessSwitch(PARSER_TEMP_DATA STACK_BASED * pParserTempData){
 	    pParserTempData->Index=GetParametersDirect16(pParserTempData);
 	    if (pParserTempData->SourceData32 == pParserTempData->DestData32)
 	    {
-		pParserTempData->pWorkingTableData->IP= RELATIVE_TO_TABLE(pParserTempData->Index);
+ 	        pParserTempData->pWorkingTableData->IP= RELATIVE_TO_TABLE(pParserTempData->Index);
 		return;
 	    }
 	}
@@ -695,7 +700,7 @@ VOID	cmdSetDataBlock(PARSER_TEMP_DATA STACK_BASED * pParserTempData)
         } else
 	{
 	    pMasterDataTable = GetDataMasterTablePointer(pParserTempData->pDeviceData);
-	    pParserTempData->CurrentDataBlock= (TABLE_UNIT_TYPE)((PTABLE_UNIT_TYPE)pMasterDataTable)[value];
+	    pParserTempData->CurrentDataBlock= UINT16LE_TO_CPU((TABLE_UNIT_TYPE)((PTABLE_UNIT_TYPE)pMasterDataTable)[value]);
 	}
     }
     pParserTempData->pWorkingTableData->IP+=sizeof(COMMAND_TYPE_OPCODE_VALUE_BYTE);
@@ -704,13 +709,13 @@ VOID	cmdSetDataBlock(PARSER_TEMP_DATA STACK_BASED * pParserTempData)
 VOID	cmdSet_ATI_Port(PARSER_TEMP_DATA STACK_BASED * pParserTempData)
 {
     pParserTempData->Multipurpose.CurrentPort=ATI_RegsPort;
-    pParserTempData->CurrentPortID = (UINT8)((COMMAND_TYPE_1*)pParserTempData->pWorkingTableData->IP)->Parameters.WordXX.PA_Destination;
+    pParserTempData->CurrentPortID = (UINT8)UINT16LE_TO_CPU(((COMMAND_TYPE_1*)pParserTempData->pWorkingTableData->IP)->Parameters.WordXX.PA_Destination);
     pParserTempData->pWorkingTableData->IP+=sizeof(COMMAND_TYPE_OPCODE_OFFSET16);
 }
 
 VOID	cmdSet_Reg_Block(PARSER_TEMP_DATA STACK_BASED * pParserTempData)
 {
-    pParserTempData->CurrentRegBlock = ((COMMAND_TYPE_1*)pParserTempData->pWorkingTableData->IP)->Parameters.WordXX.PA_Destination;
+    pParserTempData->CurrentRegBlock = UINT16LE_TO_CPU(((COMMAND_TYPE_1*)pParserTempData->pWorkingTableData->IP)->Parameters.WordXX.PA_Destination);
     pParserTempData->pWorkingTableData->IP+=sizeof(COMMAND_TYPE_OPCODE_OFFSET16);
 }
 
@@ -754,19 +759,23 @@ VOID ProcessDebug(PARSER_TEMP_DATA STACK_BASED * pParserTempData)
 
 VOID ProcessDS(PARSER_TEMP_DATA STACK_BASED * pParserTempData)
 {
-    pParserTempData->pWorkingTableData->IP+=((COMMAND_TYPE_1*)pParserTempData->pWorkingTableData->IP)->Parameters.WordXX.PA_Destination+sizeof(COMMAND_TYPE_OPCODE_OFFSET16);
+    pParserTempData->pWorkingTableData->IP+=UINT16LE_TO_CPU(((COMMAND_TYPE_1*)pParserTempData->pWorkingTableData->IP)->Parameters.WordXX.PA_Destination)+sizeof(COMMAND_TYPE_OPCODE_OFFSET16);
 }
 
 
-VOID	cmdCall_Table(PARSER_TEMP_DATA STACK_BASED * pParserTempData){
+VOID	cmdCall_Table(PARSER_TEMP_DATA STACK_BASED * pParserTempData)
+{
     UINT16*	MasterTableOffset;
     pParserTempData->pWorkingTableData->IP+=sizeof(COMMAND_TYPE_OPCODE_VALUE_BYTE);
     MasterTableOffset = GetCommandMasterTablePointer(pParserTempData->pDeviceData);
     if(((PTABLE_UNIT_TYPE)MasterTableOffset)[((COMMAND_TYPE_OPCODE_VALUE_BYTE*)pParserTempData->pCmd)->Value]!=0 )  // if the offset is not ZERO
     {
+	ATOM_TABLE_ATTRIBUTE lTableAttr;
+
 	pParserTempData->CommandSpecific.IndexInMasterTable=GetTrueIndexInMasterTable(pParserTempData,((COMMAND_TYPE_OPCODE_VALUE_BYTE*)pParserTempData->pCmd)->Value);
-	pParserTempData->Multipurpose.PS_SizeInDwordsUsedByCallingTable =
-	    (((ATOM_COMMON_ROM_COMMAND_TABLE_HEADER *)pParserTempData->pWorkingTableData->pTableHead)->TableAttribute.PS_SizeInBytes>>2);
+
+	lTableAttr = GetCommandTableAttribute(pParserTempData->pWorkingTableData->pTableHead);
+	pParserTempData->Multipurpose.PS_SizeInDwordsUsedByCallingTable = (lTableAttr.PS_SizeInBytes >>2);
 	pParserTempData->pDeviceData->pParameterSpace+=
 	    pParserTempData->Multipurpose.PS_SizeInDwordsUsedByCallingTable;
 	pParserTempData->Status=CD_CALL_TABLE;
@@ -792,7 +801,7 @@ VOID ProcessJump(PARSER_TEMP_DATA STACK_BASED * pParserTempData)
 	(pParserTempData->ParametersType.Destination == pParserTempData->CompareFlags ))
     {
 
-	pParserTempData->pWorkingTableData->IP= RELATIVE_TO_TABLE(((COMMAND_TYPE_OPCODE_OFFSET16*)pParserTempData->pWorkingTableData->IP)->CD_Offset16);
+      pParserTempData->pWorkingTableData->IP= RELATIVE_TO_TABLE(UINT16LE_TO_CPU(((COMMAND_TYPE_OPCODE_OFFSET16*)pParserTempData->pWorkingTableData->IP)->CD_Offset16));
     } else
     {
 	pParserTempData->pWorkingTableData->IP+=sizeof(COMMAND_TYPE_OPCODE_OFFSET16);
@@ -805,7 +814,7 @@ VOID ProcessJumpE(PARSER_TEMP_DATA STACK_BASED * pParserTempData)
 	(pParserTempData->CompareFlags == pParserTempData->ParametersType.Destination))
     {
 
-	pParserTempData->pWorkingTableData->IP= RELATIVE_TO_TABLE(((COMMAND_TYPE_OPCODE_OFFSET16*)pParserTempData->pWorkingTableData->IP)->CD_Offset16);
+      pParserTempData->pWorkingTableData->IP= RELATIVE_TO_TABLE(UINT16LE_TO_CPU(((COMMAND_TYPE_OPCODE_OFFSET16*)pParserTempData->pWorkingTableData->IP)->CD_Offset16));
     } else
     {
 	pParserTempData->pWorkingTableData->IP+=sizeof(COMMAND_TYPE_OPCODE_OFFSET16);
@@ -817,7 +826,7 @@ VOID ProcessJumpNE(PARSER_TEMP_DATA STACK_BASED * pParserTempData)
     if (pParserTempData->CompareFlags != Equal)
     {
 
-	pParserTempData->pWorkingTableData->IP= RELATIVE_TO_TABLE(((COMMAND_TYPE_OPCODE_OFFSET16*)pParserTempData->pWorkingTableData->IP)->CD_Offset16);
+      pParserTempData->pWorkingTableData->IP= RELATIVE_TO_TABLE(UINT16LE_TO_CPU(((COMMAND_TYPE_OPCODE_OFFSET16*)pParserTempData->pWorkingTableData->IP)->CD_Offset16));
     } else
     {
 	pParserTempData->pWorkingTableData->IP+=sizeof(COMMAND_TYPE_OPCODE_OFFSET16);
diff --git a/src/AtomBios/Decoder.c b/src/AtomBios/Decoder.c
index e8b3b6e..73aac94 100644
--- a/src/AtomBios/Decoder.c
+++ b/src/AtomBios/Decoder.c
@@ -40,12 +40,9 @@ Revision History:
 #endif
 
 #include <X11/Xos.h>
-
+#include "xorg-server.h"
 
 #include "Decoder.h"
-#include "atombios.h"
-#include "CD_binding.h"
-#include "CD_Common_Types.h"
 
 #ifndef DISABLE_EASF
 	#include "easf.h"
@@ -77,13 +74,13 @@ UINT16* GetCommandMasterTablePointer(DEVICE_DATA STACK_BASED*  pDeviceData)
     /*
     make MasterTableOffset point to EASF_ASIC_SETUP_TABLE structure, including usSize.
     */
-		MasterTableOffset = (UINT16 *) (pDeviceData->pBIOS_Image+((EASF_ASIC_DESCRIPTOR*)pDeviceData->pBIOS_Image)->usAsicSetupTable_Offset);
+		MasterTableOffset = (UINT16 *) (pDeviceData->pBIOS_Image+(UINT16LE_TO_CPU(((EASF_ASIC_DESCRIPTOR*)pDeviceData->pBIOS_Image)->usAsicSetupTable_Offset));
 	} else
 #endif
 	{
 #ifndef		UEFI_BUILD
-		MasterTableOffset = (UINT16 *)(*(UINT16 *)(pDeviceData->pBIOS_Image+OFFSET_TO_POINTER_TO_ATOM_ROM_HEADER) + pDeviceData->pBIOS_Image);
-		MasterTableOffset = (UINT16 *)((ULONG)((ATOM_ROM_HEADER *)MasterTableOffset)->usMasterCommandTableOffset + pDeviceData->pBIOS_Image );
+		MasterTableOffset = (UINT16 *)(UINT16LE_TO_CPU(*(UINT16 *)(pDeviceData->pBIOS_Image+OFFSET_TO_POINTER_TO_ATOM_ROM_HEADER)) + pDeviceData->pBIOS_Image);
+		MasterTableOffset = (UINT16 *)((ULONG)UINT16LE_TO_CPU(((ATOM_ROM_HEADER *)MasterTableOffset)->usMasterCommandTableOffset) + pDeviceData->pBIOS_Image );
 		MasterTableOffset =(UINT16 *) &(((ATOM_MASTER_COMMAND_TABLE *)MasterTableOffset)->ListOfCommandTables);
 #else
 	MasterTableOffset = (UINT16 *)(&(GetCommandMasterTable( )->ListOfCommandTables));
@@ -97,8 +94,8 @@ UINT16* GetDataMasterTablePointer(DEVICE_DATA STACK_BASED*  pDeviceData)
 	UINT16		*MasterTableOffset;
 	
 #ifndef		UEFI_BUILD
-	MasterTableOffset = (UINT16 *)(*(UINT16 *)(pDeviceData->pBIOS_Image+OFFSET_TO_POINTER_TO_ATOM_ROM_HEADER) + pDeviceData->pBIOS_Image);
-	MasterTableOffset = (UINT16 *)((ULONG)((ATOM_ROM_HEADER *)MasterTableOffset)->usMasterDataTableOffset + pDeviceData->pBIOS_Image );
+	MasterTableOffset = (UINT16 *)(UINT16LE_TO_CPU(*(UINT16 *)(pDeviceData->pBIOS_Image+OFFSET_TO_POINTER_TO_ATOM_ROM_HEADER)) + pDeviceData->pBIOS_Image);
+	MasterTableOffset = (UINT16 *)((ULONG)(UINT16LE_TO_CPU(((ATOM_ROM_HEADER *)MasterTableOffset)->usMasterDataTableOffset)) + pDeviceData->pBIOS_Image );
 	MasterTableOffset =(UINT16 *) &(((ATOM_MASTER_DATA_TABLE *)MasterTableOffset)->ListOfDataTables);
 #else
 	MasterTableOffset = (UINT16 *)(&(GetDataMasterTable( )->ListOfDataTables));
@@ -129,11 +126,29 @@ UINT8 GetTrueIndexInMasterTable(PARSER_TEMP_DATA STACK_BASED * pParserTempData,
 	}
 }
 
+ATOM_TABLE_ATTRIBUTE GetCommandTableAttribute(UINT8 *pTableHeader)
+{
+  ATOM_TABLE_ATTRIBUTE_ACCESS lTableAccess;
+
+  /* It's unclear whether this union trick breaks C aliasing rules,
+   * however, it's explicitely permitted by gcc, and we have other
+   * case where the code relies on a union being accessed by either
+   * of the "ways" and stay consistent so if a compiler breaks this
+   * assumption, it will probably need us to compile without strict
+   * aliasing enforcement
+	 */
+	lTableAccess.sbfAccess = ((ATOM_COMMON_ROM_COMMAND_TABLE_HEADER *)pTableHeader)->TableAttribute;
+	lTableAccess.susAccess = UINT16LE_TO_CPU(lTableAccess.susAccess);
+
+	return lTableAccess.sbfAccess;
+}
+
 CD_STATUS ParseTable(DEVICE_DATA STACK_BASED* pDeviceData, UINT8 IndexInMasterTable)
 {
 	PARSER_TEMP_DATA	ParserTempData;
   WORKING_TABLE_DATA STACK_BASED* prevWorkingTableData;
 
+  memset(&ParserTempData, 0, sizeof(PARSER_TEMP_DATA));
   ParserTempData.pDeviceData=(DEVICE_DATA*)pDeviceData;
 #ifndef DISABLE_EASF
   if (pDeviceData->format == TABLE_FORMAT_EASF)
@@ -143,7 +158,7 @@ CD_STATUS ParseTable(DEVICE_DATA STACK_BASED* pDeviceData, UINT8 IndexInMasterTa
 #endif
   {
     ParserTempData.pCmd=(GENERIC_ATTRIBUTE_COMMAND*)GetDataMasterTablePointer(pDeviceData);
-    ParserTempData.IndirectIOTablePointer=(UINT8*)((ULONG)(((PTABLE_UNIT_TYPE)ParserTempData.pCmd)[INDIRECT_IO_TABLE]) + pDeviceData->pBIOS_Image);
+    ParserTempData.IndirectIOTablePointer=(UINT8*)((ULONG)(UINT16LE_TO_CPU(((PTABLE_UNIT_TYPE)ParserTempData.pCmd)[INDIRECT_IO_TABLE])) + pDeviceData->pBIOS_Image);
     ParserTempData.IndirectIOTablePointer+=sizeof(ATOM_COMMON_TABLE_HEADER);
   }
 
@@ -160,65 +175,66 @@ CD_STATUS ParseTable(DEVICE_DATA STACK_BASED* pDeviceData, UINT8 IndexInMasterTa
 		ParserTempData.Status=CD_CALL_TABLE;
 
 		do{
-
+			
 			if (ParserTempData.Status==CD_CALL_TABLE)
-      {
+			{
 				IndexInMasterTable=ParserTempData.CommandSpecific.IndexInMasterTable;
 				if(((PTABLE_UNIT_TYPE)ParserTempData.pCmd)[IndexInMasterTable]!=0)  // if the offset is not ZERO
-					{
+				{
+				  ATOM_TABLE_ATTRIBUTE lTableAttr;
+				  lTableAttr = GetCommandTableAttribute(UINT16LE_TO_CPU(((PTABLE_UNIT_TYPE)ParserTempData.pCmd)[IndexInMasterTable])+pDeviceData->pBIOS_Image);
 #ifndef		UEFI_BUILD
   					ParserTempData.pWorkingTableData =(WORKING_TABLE_DATA STACK_BASED*) AllocateWorkSpace(pDeviceData,
-								((ATOM_COMMON_ROM_COMMAND_TABLE_HEADER*)(((PTABLE_UNIT_TYPE)ParserTempData.pCmd)[IndexInMasterTable]+pDeviceData->pBIOS_Image))->TableAttribute.WS_SizeInBytes+sizeof(WORKING_TABLE_DATA));
+															      lTableAttr.WS_SizeInBytes+sizeof(WORKING_TABLE_DATA));
 #else
-  					ParserTempData.pWorkingTableData =(WORKING_TABLE_DATA STACK_BASED*) AllocateWorkSpace(pDeviceData,
-								((ATOM_COMMON_ROM_COMMAND_TABLE_HEADER*)(((PTABLE_UNIT_TYPE)ParserTempData.pCmd)[IndexInMasterTable]))->TableAttribute.WS_SizeInBytes+sizeof(WORKING_TABLE_DATA));
+				  ParserTempData.pWorkingTableData =(WORKING_TABLE_DATA STACK_BASED*) AllocateWorkSpace(pDeviceData,
+															lTableAttr.WS_SizeInBytes+sizeof(WORKING_TABLE_DATA));
 #endif
-            if (ParserTempData.pWorkingTableData!=NULL)
-            {
-						  ParserTempData.pWorkingTableData->pWorkSpace=(WORKSPACE_POINTER STACK_BASED*)((UINT8*)ParserTempData.pWorkingTableData+sizeof(WORKING_TABLE_DATA));
+					if (ParserTempData.pWorkingTableData!=NULL)
+					{
+						ParserTempData.pWorkingTableData->pWorkSpace=(WORKSPACE_POINTER STACK_BASED*)((UINT8*)ParserTempData.pWorkingTableData+sizeof(WORKING_TABLE_DATA));
 #ifndef		UEFI_BUILD
-						  ParserTempData.pWorkingTableData->pTableHead  = (UINT8 *)(((PTABLE_UNIT_TYPE)ParserTempData.pCmd)[IndexInMasterTable]+pDeviceData->pBIOS_Image);
+				      ParserTempData.pWorkingTableData->pTableHead  = (UINT8 *)(UINT16LE_TO_CPU(((PTABLE_UNIT_TYPE)ParserTempData.pCmd)[IndexInMasterTable])+pDeviceData->pBIOS_Image);
 #else
-						  ParserTempData.pWorkingTableData->pTableHead  = (UINT8 *)(((PTABLE_UNIT_TYPE)ParserTempData.pCmd)[IndexInMasterTable]);
+				      ParserTempData.pWorkingTableData->pTableHead  = (UINT8 *)(UINT16LE_TO_CPU(((PTABLE_UNIT_TYPE)ParserTempData.pCmd)[IndexInMasterTable]));
 #endif
-	 					  ParserTempData.pWorkingTableData->IP=((UINT8*)ParserTempData.pWorkingTableData->pTableHead)+sizeof(ATOM_COMMON_ROM_COMMAND_TABLE_HEADER);
-              ParserTempData.pWorkingTableData->prevWorkingTableData=prevWorkingTableData;
-              prevWorkingTableData=ParserTempData.pWorkingTableData;
-              ParserTempData.Status = CD_SUCCESS;
-            } else ParserTempData.Status = CD_UNEXPECTED_BEHAVIOR;
-					} else ParserTempData.Status = CD_EXEC_TABLE_NOT_FOUND;
+						ParserTempData.pWorkingTableData->IP=((UINT8*)ParserTempData.pWorkingTableData->pTableHead)+sizeof(ATOM_COMMON_ROM_COMMAND_TABLE_HEADER);
+						ParserTempData.pWorkingTableData->prevWorkingTableData=prevWorkingTableData;
+						prevWorkingTableData=ParserTempData.pWorkingTableData;
+						ParserTempData.Status = CD_SUCCESS;
+					} else ParserTempData.Status = CD_UNEXPECTED_BEHAVIOR;
+				} else ParserTempData.Status = CD_EXEC_TABLE_NOT_FOUND;
 			}
 			if (!CD_ERROR(ParserTempData.Status))
 			{
-        ParserTempData.Status = CD_SUCCESS;
+				ParserTempData.Status = CD_SUCCESS;
 				while (!CD_ERROR_OR_COMPLETED(ParserTempData.Status))  
-        {
-
+				{
 					if (IS_COMMAND_VALID(((COMMAND_HEADER*)ParserTempData.pWorkingTableData->IP)->Opcode))
-          {
+					{
 						ParserTempData.pCmd = (GENERIC_ATTRIBUTE_COMMAND*)ParserTempData.pWorkingTableData->IP;
-
+						
 						if (IS_END_OF_TABLE(((COMMAND_HEADER*)ParserTempData.pWorkingTableData->IP)->Opcode))
 						{
 							ParserTempData.Status=CD_COMPLETED;
-              prevWorkingTableData=ParserTempData.pWorkingTableData->prevWorkingTableData;
-
+							prevWorkingTableData=ParserTempData.pWorkingTableData->prevWorkingTableData;
+							
 							FreeWorkSpace(pDeviceData, ParserTempData.pWorkingTableData);
-              ParserTempData.pWorkingTableData=prevWorkingTableData;
-              if (prevWorkingTableData!=NULL)
-              {
-							  ParserTempData.pDeviceData->pParameterSpace-=
-								  		(((ATOM_COMMON_ROM_COMMAND_TABLE_HEADER*)ParserTempData.pWorkingTableData->
-									  		pTableHead)->TableAttribute.PS_SizeInBytes>>2);
-              } 
-						// if there is a parent table where to return, then restore PS_pointer to the original state
+							ParserTempData.pWorkingTableData=prevWorkingTableData;
+							if (prevWorkingTableData!=NULL)
+							{
+								ATOM_TABLE_ATTRIBUTE lTableAttr;
+								lTableAttr = GetCommandTableAttribute(ParserTempData.pWorkingTableData->pTableHead);
+								ParserTempData.pDeviceData->pParameterSpace-=(lTableAttr.PS_SizeInBytes>>2);
+							} 
+							// if there is a parent table where to return, then restore PS_pointer to the original state
 						}
 						else
 						{
-              IndexInMasterTable=ProcessCommandProperties((PARSER_TEMP_DATA STACK_BASED *)&ParserTempData);
+							IndexInMasterTable=ProcessCommandProperties((PARSER_TEMP_DATA STACK_BASED *)&ParserTempData);
 							(*CallTable[IndexInMasterTable].function)((PARSER_TEMP_DATA STACK_BASED *)&ParserTempData);
 #if (PARSER_TYPE!=DRIVER_TYPE_PARSER)
-              BIOS_STACK_MODIFIER();
+							BIOS_STACK_MODIFIER();
 #endif
 						}
 					}
@@ -227,13 +243,13 @@ CD_STATUS ParseTable(DEVICE_DATA STACK_BASED* pDeviceData, UINT8 IndexInMasterTa
 						ParserTempData.Status=CD_INVALID_OPCODE;
 						break;
 					}
-
+					
 				}	// while
 			}	// if
 			else
 				break;
 		} while (prevWorkingTableData!=NULL);
-    if (ParserTempData.Status == CD_COMPLETED) return CD_SUCCESS;
+		if (ParserTempData.Status == CD_COMPLETED) return CD_SUCCESS;
 		return ParserTempData.Status;
 	} else return CD_SUCCESS;
 }
diff --git a/src/AtomBios/hwserv_drv.c b/src/AtomBios/hwserv_drv.c
index a5f5a5b..9f2b6b9 100644
--- a/src/AtomBios/hwserv_drv.c
+++ b/src/AtomBios/hwserv_drv.c
@@ -34,8 +34,14 @@ Revision History:
 
 	NEG:27.09.2002	Initiated.
 --*/
-#include "CD_binding.h"
-#include "CD_hw_services.h"
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <X11/Xos.h>
+#include "xorg-server.h"
+
+#include "Decoder.h"
 
 //trace settings
 #if DEBUG_OUTPUT_DEVICE & 1
@@ -249,12 +255,12 @@ VOID	WriteReg32(PARSER_TEMP_DATA STACK_BASED * pWorkingTableData)
 
 VOID	ReadIndReg32 (PARSER_TEMP_DATA STACK_BASED * pWorkingTableData)
 {
-    pWorkingTableData->IndirectData = CailReadATIRegister(pWorkingTableData->pDeviceData->CAIL,*(UINT16*)(pWorkingTableData->IndirectIOTablePointer+1));
+    pWorkingTableData->IndirectData = CailReadATIRegister(pWorkingTableData->pDeviceData->CAIL,UINT16LE_TO_CPU(*(UINT16*)(pWorkingTableData->IndirectIOTablePointer+1)));
 }
 
 VOID	WriteIndReg32(PARSER_TEMP_DATA STACK_BASED * pWorkingTableData)
 {
-    CailWriteATIRegister(pWorkingTableData->pDeviceData->CAIL,*(UINT16*)(pWorkingTableData->IndirectIOTablePointer+1),pWorkingTableData->IndirectData );
+    CailWriteATIRegister(pWorkingTableData->pDeviceData->CAIL,UINT16LE_TO_CPU(*(UINT16*)(pWorkingTableData->IndirectIOTablePointer+1)),pWorkingTableData->IndirectData);
 }
 
 #endif
diff --git a/src/AtomBios/includes/CD_Common_Types.h b/src/AtomBios/includes/CD_Common_Types.h
index c60b652..071b8fd 100644
--- a/src/AtomBios/includes/CD_Common_Types.h
+++ b/src/AtomBios/includes/CD_Common_Types.h
@@ -155,6 +155,18 @@ typedef unsigned long ULONG_PTR;
 #ifndef FGL_LINUX
 #pragma warning ( default : 4142 )
 #endif
+
+#ifndef ATOM_BIG_ENDIAN
+#ifdef X_BYTE_ORDER
+#if X_BYTE_ORDER == X_BIG_ENDIAN
+#define ATOM_BIG_ENDIAN		1
+#endif
+#endif
+#endif
+#ifndef ATOM_BIG_ENDIAN
+#define ATOM_BIG_ENDIAN		0
+#endif
+
 #endif // _COMMON_TYPES_H_
 
 // EOF
diff --git a/src/AtomBios/includes/CD_Definitions.h b/src/AtomBios/includes/CD_Definitions.h
index 98fd495..c00e93e 100644
--- a/src/AtomBios/includes/CD_Definitions.h
+++ b/src/AtomBios/includes/CD_Definitions.h
@@ -39,11 +39,12 @@ NEG:27.08.2002	Initiated.
 #ifndef _CD_DEFINITIONS_H
 #define _CD_DEFINITIONS_H_
 #ifdef DRIVER_PARSER
-VOID *AllocateMemory(VOID *, UINT16);
+VOID *AllocateMemory(DEVICE_DATA *, UINT16);
 VOID ReleaseMemory(DEVICE_DATA * , WORKING_TABLE_DATA* );
 #endif
 CD_STATUS ParseTable(DEVICE_DATA* pDeviceData, UINT8 IndexInMasterTable);
 //CD_STATUS CD_MainLoop(PARSER_TEMP_DATA_POINTER pParserTempData);
 CD_STATUS Main_Loop(DEVICE_DATA* pDeviceData,UINT16 *MasterTableOffset,UINT8 IndexInMasterTable);
 UINT16* GetCommandMasterTablePointer(DEVICE_DATA*  pDeviceData);
+ATOM_TABLE_ATTRIBUTE GetCommandTableAttribute(UINT8 *pTableHeader);
 #endif //CD_DEFINITIONS
diff --git a/src/AtomBios/includes/CD_Structs.h b/src/AtomBios/includes/CD_Structs.h
index c43f81d..01fb80e 100644
--- a/src/AtomBios/includes/CD_Structs.h
+++ b/src/AtomBios/includes/CD_Structs.h
@@ -35,10 +35,18 @@ Revision History:
 NEG:26.08.2002	Initiated.
 --*/
 
-#include "CD_binding.h"
 #ifndef _CD_STRUCTS_H_
 #define _CD_STRUCTS_H_
 
+#include "CD_binding.h"
+
+/* Endaianness should be specified before inclusion,
+ * default to little endian
+ */
+#ifndef ATOM_BIG_ENDIAN
+#error Endian not specified
+#endif
+
 #ifdef		UEFI_BUILD
 typedef	UINT16**	PTABLE_UNIT_TYPE;
 typedef	UINTN		TABLE_UNIT_TYPE;
@@ -304,9 +312,15 @@ typedef union _PARAMETER_ACCESS {
 }PARAMETER_ACCESS;
 
 typedef	struct _COMMAND_ATTRIBUTE {
+#if ATOM_BIG_ENDIAN
+    UINT8		DestinationAlignment:2;
+    UINT8		SourceAlignment:3;
+    UINT8		Source:3;
+#else
     UINT8		Source:3;
     UINT8		SourceAlignment:3;
     UINT8		DestinationAlignment:2;
+#endif
 }COMMAND_ATTRIBUTE;
 
 typedef struct _SOURCE_DESTINATION_ALIGNMENT{
@@ -363,11 +377,19 @@ typedef union  _COMMAND_SPECIFIC_UNION{
 
 
 typedef struct _CD_GENERIC_BYTE{
+#if ATOM_BIG_ENDIAN
+    UINT16					PS_SizeInDwordsUsedByCallingTable:5;
+    UINT16					CurrentPort:2;
+    UINT16					CommandAccessType:3;
+    UINT16					CurrentParameterSize:3;
+    UINT16					CommandType:3;
+#else
     UINT16					CommandType:3;
     UINT16					CurrentParameterSize:3;
     UINT16					CommandAccessType:3;
     UINT16					CurrentPort:2;
     UINT16					PS_SizeInDwordsUsedByCallingTable:5;
+#endif
 }CD_GENERIC_BYTE;
 
 typedef UINT8	COMMAND_TYPE_OPCODE_ONLY;
diff --git a/src/AtomBios/includes/Decoder.h b/src/AtomBios/includes/Decoder.h
index 24c25fc..1e143f0 100644
--- a/src/AtomBios/includes/Decoder.h
+++ b/src/AtomBios/includes/Decoder.h
@@ -47,12 +47,32 @@ NEG:27.08.2002	Initiated.
 #define PARSER_VERSION_MAJOR                   0x00000000
 #define PARSER_VERSION_MINOR                   0x0000000E
 #define PARSER_VERSION                         (PARSER_VERSION_MAJOR | PARSER_VERSION_MINOR)
-#include "CD_binding.h"
+
 #include "CD_Common_Types.h"
+
+#include "atombios.h"
+
+/* these depends on some struct defined in atombios.h */
+#include "CD_binding.h"
 #include "CD_hw_services.h"
 #include "CD_Structs.h"
-#include "CD_Definitions.h"
 #include "CD_Opcodes.h"
+#include "CD_Definitions.h"
+
+#if ATOM_BIG_ENDIAN
+extern UINT16 ATOM_BSWAP16(UINT16 x);
+extern UINT32 ATOM_BSWAP32(UINT32 x);
+
+#define CPU_TO_UINT16LE(x)	ATOM_BSWAP16(x)
+#define CPU_TO_UINT32LE(x)	ATOM_BSWAP32(x)
+#define UINT16LE_TO_CPU(x)	ATOM_BSWAP16(x)
+#define UINT32LE_TO_CPU(x)	ATOM_BSWAP32(x)
+#else
+#define CPU_TO_UINT16LE(x)	(x)
+#define CPU_TO_UINT32LE(x)	(x)
+#define UINT16LE_TO_CPU(x)	(x)
+#define UINT32LE_TO_CPU(x)	(x)
+#endif
 
 #define	SOURCE_ONLY_CMD_TYPE		0//0xFE
 #define SOURCE_DESTINATION_CMD_TYPE	1//0xFD
diff --git a/src/AtomBios/includes/atombios.h b/src/AtomBios/includes/atombios.h
index 17483a6..2e7dc6c 100644
--- a/src/AtomBios/includes/atombios.h
+++ b/src/AtomBios/includes/atombios.h
@@ -34,6 +34,12 @@
 
 #define ATOM_HEADER_VERSION (ATOM_VERSION_MAJOR | ATOM_VERSION_MINOR)
 
+/* Endianness should be specified before inclusion,
+ * default to little endian
+ */
+#ifndef ATOM_BIG_ENDIAN
+#error Endian not specified
+#endif
 
 #ifdef _H2INC
   #ifndef ULONG 
@@ -304,7 +310,7 @@ typedef struct _ATOM_MASTER_COMMAND_TABLE
 
 typedef struct _ATOM_TABLE_ATTRIBUTE
 {
-#if X_BYTE_ORDER == X_BIG_ENDIAN
+#if ATOM_BIG_ENDIAN
   USHORT  UpdatedByUtility:1;         //[15]=Table updated by utility flag
   USHORT  PS_SizeInBytes:7;           //[14:8]=Size of parameter space in Bytes (multiple of a dword), 
   USHORT  WS_SizeInBytes:8;           //[7:0]=Size of workspace in Bytes (in multiple of a dword), 
@@ -315,6 +321,12 @@ typedef struct _ATOM_TABLE_ATTRIBUTE
 #endif
 }ATOM_TABLE_ATTRIBUTE;
 
+typedef union _ATOM_TABLE_ATTRIBUTE_ACCESS
+{
+  ATOM_TABLE_ATTRIBUTE sbfAccess;
+  USHORT               susAccess;
+}ATOM_TABLE_ATTRIBUTE_ACCESS;
+
 // Common header for all command tables.
 //Every table pointed by _ATOM_MASTER_COMMAND_TABLE has this common header. 
 //And the pointer actually points to this header.
@@ -1258,7 +1270,7 @@ typedef struct _ATOM_MULTIMEDIA_CONFIG_INFO
 //Please don't add or expand this bitfield structure below, this one will retire soon.!
 typedef struct _ATOM_FIRMWARE_CAPABILITY
 {
-#if X_BYTE_ORDER == X_BIG_ENDIAN
+#if ATOM_BIG_ENDIAN
   USHORT Reserved:3;
   USHORT HyperMemory_Size:4;
   USHORT HyperMemory_Support:1;
@@ -1767,7 +1779,7 @@ for Griffin or Greyhound. SBIOS needs to convert to actual time by:
 
 typedef struct _ATOM_I2C_ID_CONFIG
 {
-#if X_BYTE_ORDER == X_BIG_ENDIAN
+#if ATOM_BIG_ENDIAN
   UCHAR   bfHW_Capable:1;
   UCHAR   bfHW_EngineID:3;
   UCHAR   bfI2C_LineMux:4;
@@ -1820,7 +1832,7 @@ typedef struct _ATOM_GPIO_I2C_INFO
 //Please don't add or expand this bitfield structure below, this one will retire soon.!
 typedef struct _ATOM_MODE_MISC_INFO
 { 
-#if X_BYTE_ORDER == X_BIG_ENDIAN
+#if ATOM_BIG_ENDIAN
   USHORT Reserved:6;
   USHORT RGB888:1;
   USHORT DoubleClock:1;
@@ -3426,7 +3438,7 @@ typedef struct _ATOM_MEMORY_VENDOR_BLOCK{
 
 
 typedef struct _ATOM_MEMORY_SETTING_ID_CONFIG{
-#if X_BYTE_ORDER == X_BIG_ENDIAN
+#if ATOM_BIG_ENDIAN
 	ULONG												ucMemBlkId:8;
 	ULONG												ulMemClockRange:24;
 #else
@@ -4072,7 +4084,7 @@ typedef struct  _COMPASSIONATE_DATA
 
 typedef struct _ATOM_CONNECTOR_INFO
 {
-#if X_BYTE_ORDER == X_BIG_ENDIAN
+#if ATOM_BIG_ENDIAN
   UCHAR   bfConnectorType:4;
   UCHAR   bfAssociatedDAC:4;
 #else
diff --git a/src/Makefile.am b/src/Makefile.am
index 5333495..c79b635 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -26,8 +26,11 @@
 # _ladir passes a dummy rpath to libtool so the thing will actually link
 # TODO: -nostdlib/-Bstatic/-lgcc platform magic, not installing the .a, etc.
 
+radeon_drv_la_LIBADD =
+
 if DRI
 RADEON_DRI_SRCS = radeon_dri.c
+radeon_drv_la_LIBADD += $(DRI_LIBS)
 endif
 
 RADEON_ATOMBIOS_SOURCES = \
@@ -70,6 +73,11 @@ AM_CFLAGS = @XORG_CFLAGS@ @DRI_CFLAGS@ @XMODES_CFLAGS@ -DDISABLE_EASF -DENABLE_A
 
 INCLUDES = -I$(srcdir)/AtomBios/includes
 
+if XSERVER_LIBPCIACCESS
+ati_drv_la_LIBADD = $(PCIACCESS_LIBS)
+radeon_drv_la_LIBADD += $(PCIACCESS_LIBS)
+endif
+
 ati_drv_la_LTLIBRARIES = ati_drv.la
 ati_drv_la_LDFLAGS = -module -avoid-version
 ati_drv_ladir = @moduledir@/drivers
@@ -80,7 +88,7 @@ radeon_drv_la_LTLIBRARIES = radeon_drv.la
 radeon_drv_la_LDFLAGS = -module -avoid-version
 radeon_drv_ladir = @moduledir@/drivers
 radeon_drv_la_SOURCES = \
-	radeon_accel.c radeon_cursor.c radeon_dga.c \
+	radeon_accel.c radeon_cursor.c radeon_dga.c radeon_memory.c \
 	radeon_driver.c radeon_video.c radeon_bios.c radeon_mm_i2c.c \
 	radeon_vip.c radeon_misc.c radeon_probe.c \
 	legacy_crtc.c legacy_output.c \
@@ -120,7 +128,6 @@ EXTRA_DIST = \
 	radeon_render.c \
 	radeon_accelfuncs.c \
 	radeon_textured_videofuncs.c \
-	\
 	ati.h \
 	ativersion.h \
 	generic_bus.h \
diff --git a/src/ati_pciids_gen.h b/src/ati_pciids_gen.h
index a740df8..633c5d3 100644
--- a/src/ati_pciids_gen.h
+++ b/src/ati_pciids_gen.h
@@ -1,4 +1,5 @@
 #define PCI_CHIP_RV380_3150 0x3150
+#define PCI_CHIP_RV380_3151 0x3151
 #define PCI_CHIP_RV380_3152 0x3152
 #define PCI_CHIP_RV380_3154 0x3154
 #define PCI_CHIP_RV380_3E50 0x3E50
@@ -330,6 +331,9 @@
 #define PCI_CHIP_R600_940A 0x940A
 #define PCI_CHIP_R600_940B 0x940B
 #define PCI_CHIP_R600_940F 0x940F
+#define PCI_CHIP_RV770_9440 0x9440
+#define PCI_CHIP_RV770_9441 0x9441
+#define PCI_CHIP_RV770_9442 0x9442
 #define PCI_CHIP_RV610_94C0 0x94C0
 #define PCI_CHIP_RV610_94C1 0x94C1
 #define PCI_CHIP_RV610_94C3 0x94C3
@@ -347,6 +351,7 @@
 #define PCI_CHIP_RV670_9507 0x9507
 #define PCI_CHIP_RV670_950F 0x950F
 #define PCI_CHIP_RV670_9511 0x9511
+#define PCI_CHIP_RV670_9515 0x9515
 #define PCI_CHIP_RV630_9580 0x9580
 #define PCI_CHIP_RV630_9581 0x9581
 #define PCI_CHIP_RV630_9583 0x9583
diff --git a/src/atombios_crtc.c b/src/atombios_crtc.c
index 363addf..412a181 100644
--- a/src/atombios_crtc.c
+++ b/src/atombios_crtc.c
@@ -43,11 +43,33 @@
 
 #ifdef XF86DRI
 #define _XF86DRI_SERVER_
-#include "radeon_dri.h"
-#include "radeon_sarea.h"
+#include "radeon_drm.h"
 #include "sarea.h"
 #endif
 
+AtomBiosResult
+atombios_lock_crtc(atomBiosHandlePtr atomBIOS, int crtc, int lock)
+{
+    ENABLE_CRTC_PS_ALLOCATION crtc_data;
+    AtomBiosArgRec data;
+    unsigned char *space;
+
+    crtc_data.ucCRTC = crtc;
+    crtc_data.ucEnable = lock;
+
+    data.exec.index = GetIndexIntoMasterTable(COMMAND, UpdateCRTC_DoubleBufferRegisters);
+    data.exec.dataSpace = (void *)&space;
+    data.exec.pspace = &crtc_data;
+
+    if (RHDAtomBiosFunc(atomBIOS->scrnIndex, atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
+	ErrorF("%s CRTC %d success\n", lock? "Lock":"Unlock", crtc);
+	return ATOM_SUCCESS ;
+    }
+
+    ErrorF("Lock CRTC failed\n");
+    return ATOM_NOT_IMPLEMENTED;
+}
+
 static AtomBiosResult
 atombios_enable_crtc(atomBiosHandlePtr atomBIOS, int crtc, int state)
 {
@@ -105,7 +127,7 @@ atombios_blank_crtc(atomBiosHandlePtr atomBIOS, int crtc, int state)
     crtc_data.ucCRTC = crtc;
     crtc_data.ucBlanking = state;
 
-    data.exec.index = offsetof(ATOM_MASTER_LIST_OF_COMMAND_TABLES, BlankCRTC) / sizeof(unsigned short);
+    data.exec.index = GetIndexIntoMasterTable(COMMAND, BlankCRTC);
     data.exec.dataSpace = (void *)&space;
     data.exec.pspace = &crtc_data;
 
@@ -146,10 +168,27 @@ atombios_set_crtc_timing(atomBiosHandlePtr atomBIOS, SET_CRTC_TIMING_PARAMETERS_
 {
     AtomBiosArgRec data;
     unsigned char *space;
+    SET_CRTC_TIMING_PARAMETERS_PS_ALLOCATION conv_param;
+
+    conv_param.usH_Total		= cpu_to_le16(crtc_param->usH_Total);
+    conv_param.usH_Disp			= cpu_to_le16(crtc_param->usH_Disp);
+    conv_param.usH_SyncStart		= cpu_to_le16(crtc_param->usH_SyncStart);
+    conv_param.usH_SyncWidth		= cpu_to_le16(crtc_param->usH_SyncWidth);
+    conv_param.usV_Total		= cpu_to_le16(crtc_param->usV_Total);
+    conv_param.usV_Disp			= cpu_to_le16(crtc_param->usV_Disp);
+    conv_param.usV_SyncStart		= cpu_to_le16(crtc_param->usV_SyncStart);
+    conv_param.usV_SyncWidth		= cpu_to_le16(crtc_param->usV_SyncWidth);
+    conv_param.susModeMiscInfo.usAccess = cpu_to_le16(crtc_param->susModeMiscInfo.usAccess);
+    conv_param.ucCRTC			= crtc_param->ucCRTC;
+    conv_param.ucOverscanRight		= crtc_param->ucOverscanRight;
+    conv_param.ucOverscanLeft		= crtc_param->ucOverscanLeft;
+    conv_param.ucOverscanBottom		= crtc_param->ucOverscanBottom;
+    conv_param.ucOverscanTop		= crtc_param->ucOverscanTop; 
+    conv_param.ucReserved		= crtc_param->ucReserved;
 
     data.exec.index = GetIndexIntoMasterTable(COMMAND, SetCRTC_Timing);
     data.exec.dataSpace = (void *)&space;
-    data.exec.pspace = crtc_param;
+    data.exec.pspace = &conv_param;
 
     if (RHDAtomBiosFunc(atomBIOS->scrnIndex, atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
 	ErrorF("Set CRTC Timing success\n");
@@ -185,7 +224,11 @@ atombios_crtc_set_pll(xf86CrtcPtr crtc, DisplayModePtr mode, int pll_flags)
     if (IS_AVIVO_VARIANT) {
 	uint32_t temp;
 
-	pll_flags |= RADEON_PLL_PREFER_LOW_REF_DIV;
+	if (mode->Clock > 120000) /* range limits??? */
+	    pll_flags |= RADEON_PLL_PREFER_HIGH_FB_DIV;
+	else
+	    pll_flags |= RADEON_PLL_PREFER_LOW_REF_DIV;
+
 
 	RADEONComputePLL(&info->pll, mode->Clock, &temp, &fb_div, &ref_div, &post_div, pll_flags);
 	sclock = temp;
@@ -235,9 +278,9 @@ atombios_crtc_set_pll(xf86CrtcPtr crtc, DisplayModePtr mode, int pll_flags)
 	case 1:
 	case 2:
 	    spc2_ptr = (PIXEL_CLOCK_PARAMETERS_V2*)&spc_param.sPCLKInput;
-	    spc2_ptr->usPixelClock = sclock;
-	    spc2_ptr->usRefDiv = ref_div;
-	    spc2_ptr->usFbDiv = fb_div;
+	    spc2_ptr->usPixelClock = cpu_to_le16(sclock);
+	    spc2_ptr->usRefDiv = cpu_to_le16(ref_div);
+	    spc2_ptr->usFbDiv = cpu_to_le16(fb_div);
 	    spc2_ptr->ucPostDiv = post_div;
 	    spc2_ptr->ucPpll = radeon_crtc->crtc_id ? ATOM_PPLL2 : ATOM_PPLL1;
 	    spc2_ptr->ucCRTC = radeon_crtc->crtc_id;
@@ -246,9 +289,9 @@ atombios_crtc_set_pll(xf86CrtcPtr crtc, DisplayModePtr mode, int pll_flags)
 	    break;
 	case 3:
 	    spc3_ptr = (PIXEL_CLOCK_PARAMETERS_V3*)&spc_param.sPCLKInput;
-	    spc3_ptr->usPixelClock = sclock;
-	    spc3_ptr->usRefDiv = ref_div;
-	    spc3_ptr->usFbDiv = fb_div;
+	    spc3_ptr->usPixelClock = cpu_to_le16(sclock);
+	    spc3_ptr->usRefDiv = cpu_to_le16(ref_div);
+	    spc3_ptr->usFbDiv = cpu_to_le16(fb_div);
 	    spc3_ptr->ucPostDiv = post_div;
 	    spc3_ptr->ucPpll = radeon_crtc->crtc_id ? ATOM_PPLL2 : ATOM_PPLL1;
 	    spc3_ptr->ucMiscInfo = (radeon_crtc->crtc_id << 2);
@@ -442,9 +485,6 @@ atombios_crtc_mode_set(xf86CrtcPtr crtc,
 	    fb_location = fb_location + (char *)crtc->rotatedData - (char *)info->FB;
 	}
 
-	/* lock the grph regs */
-	OUTREG(AVIVO_D1GRPH_UPDATE + radeon_crtc->crtc_offset, AVIVO_D1GRPH_UPDATE_LOCK);
-
 	OUTREG(AVIVO_D1GRPH_PRIMARY_SURFACE_ADDRESS + radeon_crtc->crtc_offset, fb_location);
 	OUTREG(AVIVO_D1GRPH_SECONDARY_SURFACE_ADDRESS + radeon_crtc->crtc_offset, fb_location);
 	OUTREG(AVIVO_D1GRPH_CONTROL + radeon_crtc->crtc_offset, fb_format);
@@ -459,26 +499,27 @@ atombios_crtc_mode_set(xf86CrtcPtr crtc,
 	       crtc->scrn->displayWidth);
 	OUTREG(AVIVO_D1GRPH_ENABLE + radeon_crtc->crtc_offset, 1);
 
-	/* unlock the grph regs */
-	OUTREG(AVIVO_D1GRPH_UPDATE + radeon_crtc->crtc_offset, 0);
-
-	/* lock the mode regs */
-	OUTREG(AVIVO_D1SCL_UPDATE + radeon_crtc->crtc_offset, AVIVO_D1SCL_UPDATE_LOCK);
-
 	OUTREG(AVIVO_D1MODE_DESKTOP_HEIGHT + radeon_crtc->crtc_offset,
 	       		mode->VDisplay);
 	OUTREG(AVIVO_D1MODE_VIEWPORT_START + radeon_crtc->crtc_offset, (x << 16) | y);
 	OUTREG(AVIVO_D1MODE_VIEWPORT_SIZE + radeon_crtc->crtc_offset,
 	       (mode->HDisplay << 16) | mode->VDisplay);
-	/* unlock the mode regs */
-	OUTREG(AVIVO_D1SCL_UPDATE + radeon_crtc->crtc_offset, 0);
 
+	if (adjusted_mode->Flags & V_INTERLACE)
+	    OUTREG(AVIVO_D1MODE_DATA_FORMAT + radeon_crtc->crtc_offset,
+		   AVIVO_D1MODE_INTERLEAVE_EN);
+	else
+	    OUTREG(AVIVO_D1MODE_DATA_FORMAT + radeon_crtc->crtc_offset,
+		   0);
     }
 
     atombios_crtc_set_pll(crtc, adjusted_mode, pll_flags);
 
     atombios_set_crtc_timing(info->atomBIOS, &crtc_timing);
 
+    if (info->DispPriority)
+	RADEONInitDispBandwidth(pScrn);
+
     if (tilingChanged) {
 	/* need to redraw front buffer, I guess this can be considered a hack ? */
 	/* if this is called during ScreenInit() we don't have pScrn->pScreen yet */
@@ -492,3 +533,126 @@ atombios_crtc_mode_set(xf86CrtcPtr crtc,
 
 }
 
+/* Calculate display buffer watermark to prevent buffer underflow */
+void
+RADEONInitDispBandwidthAVIVO(ScrnInfoPtr pScrn,
+			      DisplayModePtr mode1, int pixel_bytes1,
+			      DisplayModePtr mode2, int pixel_bytes2)
+{
+    RADEONInfoPtr info = RADEONPTR(pScrn);
+    RADEONEntPtr pRADEONEnt   = RADEONEntPriv(pScrn);
+    unsigned char *RADEONMMIO = info->MMIO;
+
+    uint32_t dc_lb_memory_split;
+    float mem_bw, peak_disp_bw;
+    float min_mem_eff = 0.8; /* XXX: taken from legacy method */
+    float pix_clk, pix_clk2; /* in MHz */
+
+    /*
+     * Set display0/1 priority up in the memory controller for
+     * modes if the user specifies HIGH for displaypriority
+     * option.
+     */
+    if (info->DispPriority == 2) {
+	uint32_t mc_init_misc_lat_timer = 0;
+	if (info->ChipFamily == CHIP_FAMILY_RV515)
+	    mc_init_misc_lat_timer = INMC(pScrn, RV515_MC_INIT_MISC_LAT_TIMER);
+	else if (info->ChipFamily == CHIP_FAMILY_RS690)
+	    mc_init_misc_lat_timer = INMC(pScrn, RS690_MC_INIT_MISC_LAT_TIMER);
+
+	mc_init_misc_lat_timer &= ~(R300_MC_DISP1R_INIT_LAT_MASK << R300_MC_DISP1R_INIT_LAT_SHIFT);
+	mc_init_misc_lat_timer &= ~(R300_MC_DISP0R_INIT_LAT_MASK << R300_MC_DISP0R_INIT_LAT_SHIFT);
+
+	if (pRADEONEnt->pCrtc[1]->enabled)
+	    mc_init_misc_lat_timer |= (1 << R300_MC_DISP1R_INIT_LAT_SHIFT); /* display 1 */
+	if (pRADEONEnt->pCrtc[0]->enabled)
+	    mc_init_misc_lat_timer |= (1 << R300_MC_DISP0R_INIT_LAT_SHIFT); /* display 0 */
+
+	if (info->ChipFamily == CHIP_FAMILY_RV515)
+	    OUTMC(pScrn, RV515_MC_INIT_MISC_LAT_TIMER, mc_init_misc_lat_timer);
+	else if (info->ChipFamily == CHIP_FAMILY_RS690)
+	    OUTMC(pScrn, RS690_MC_INIT_MISC_LAT_TIMER, mc_init_misc_lat_timer);
+    }
+
+    /* XXX: fix me for AVIVO
+     * Determine if there is enough bandwidth for current display mode
+     */
+    mem_bw = info->mclk * (info->RamWidth / 8) * (info->IsDDR ? 2 : 1);
+
+    pix_clk = 0;
+    pix_clk2 = 0;
+    peak_disp_bw = 0;
+    if (mode1) {
+	pix_clk = mode1->Clock/1000.0;
+	peak_disp_bw += (pix_clk * pixel_bytes1);
+    }
+    if (mode2) {
+	pix_clk2 = mode2->Clock/1000.0;
+	peak_disp_bw += (pix_clk2 * pixel_bytes2);
+    }
+
+    if (peak_disp_bw >= mem_bw * min_mem_eff) {
+	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+		   "You may not have enough display bandwidth for current mode\n"
+		   "If you have flickering problem, try to lower resolution, refresh rate, or color depth\n");
+    }
+
+    /*
+     * Line Buffer Setup
+     * There is a single line buffer shared by both display controllers.
+     * DC_LB_MEMORY_SPLIT controls how that line buffer is shared between the display
+     * controllers.  The paritioning can either be done manually or via one of four
+     * preset allocations specified in bits 1:0:
+     * 0 - line buffer is divided in half and shared between each display controller
+     * 1 - D1 gets 3/4 of the line buffer, D2 gets 1/4
+     * 2 - D1 gets the whole buffer
+     * 3 - D1 gets 1/4 of the line buffer, D2 gets 3/4
+     * Setting bit 2 of DC_LB_MEMORY_SPLIT controls switches to manual allocation mode.
+     * In manual allocation mode, D1 always starts at 0, D1 end/2 is specified in bits
+     * 14:4; D2 allocation follows D1.
+     */
+
+    /* is auto or manual better ? */
+    dc_lb_memory_split = INREG(AVIVO_DC_LB_MEMORY_SPLIT) & ~AVIVO_DC_LB_MEMORY_SPLIT_MASK;
+    dc_lb_memory_split &= ~AVIVO_DC_LB_MEMORY_SPLIT_SHIFT_MODE;
+#if 1
+    /* auto */
+    if (mode1 && mode2) {
+	if (mode1->HDisplay > mode2->HDisplay) {
+	    if (mode1->HDisplay > 2560)
+		dc_lb_memory_split |= AVIVO_DC_LB_MEMORY_SPLIT_D1_3Q_D2_1Q;
+	    else
+		dc_lb_memory_split |= AVIVO_DC_LB_MEMORY_SPLIT_D1HALF_D2HALF;
+	} else if (mode2->HDisplay > mode1->HDisplay) {
+	    if (mode2->HDisplay > 2560)
+		dc_lb_memory_split |= AVIVO_DC_LB_MEMORY_SPLIT_D1_1Q_D2_3Q;
+	    else
+		dc_lb_memory_split |= AVIVO_DC_LB_MEMORY_SPLIT_D1HALF_D2HALF;
+	} else
+	    dc_lb_memory_split |= AVIVO_DC_LB_MEMORY_SPLIT_D1HALF_D2HALF;
+    } else if (mode1) {
+	dc_lb_memory_split |= AVIVO_DC_LB_MEMORY_SPLIT_D1_ONLY;
+    } else if (mode2) {
+	dc_lb_memory_split |= AVIVO_DC_LB_MEMORY_SPLIT_D1_1Q_D2_3Q;
+    }
+#else
+    /* manual */
+    dc_lb_memory_split |= AVIVO_DC_LB_MEMORY_SPLIT_SHIFT_MODE;
+    dc_lb_memory_split &= ~(AVIVO_DC_LB_DISP1_END_ADR_MASK << AVIVO_DC_LB_DISP1_END_ADR_SHIFT);
+    if (mode1) {
+	dc_lb_memory_split |= ((((mode1->HDisplay / 2) + 64 /*???*/) & AVIVO_DC_LB_DISP1_END_ADR_MASK)
+			       << AVIVO_DC_LB_DISP1_END_ADR_SHIFT);
+    } else if (mode2) {
+	dc_lb_memory_split |= (0 << AVIVO_DC_LB_DISP1_END_ADR_SHIFT);
+    }
+    OUTREG(AVIVO_DC_LB_MEMORY_SPLIT, dc_lb_memory_split);
+#endif
+
+    /*
+     * Watermark setup
+     * TODO...
+     * Unforunately, I haven't been able to dig up the avivo watermark programming
+     * guide yet. -AGD
+     */
+
+}
diff --git a/src/atombios_output.c b/src/atombios_output.c
index 51be301..83b86a7 100644
--- a/src/atombios_output.c
+++ b/src/atombios_output.c
@@ -78,7 +78,7 @@ atombios_output_dac1_setup(xf86OutputPtr output, DisplayModePtr mode)
 	}
     }
 
-    disp_data.usPixelClock = mode->Clock / 10;
+    disp_data.usPixelClock = cpu_to_le16(mode->Clock / 10);
     data.exec.index = GetIndexIntoMasterTable(COMMAND, DAC1EncoderControl);
     data.exec.dataSpace = (void *)&space;
     data.exec.pspace = &disp_data;
@@ -128,7 +128,7 @@ atombios_output_dac2_setup(xf86OutputPtr output, DisplayModePtr mode)
 	}
     }
 
-    disp_data.usPixelClock = mode->Clock / 10;
+    disp_data.usPixelClock = cpu_to_le16(mode->Clock / 10);
     data.exec.index = GetIndexIntoMasterTable(COMMAND, DAC2EncoderControl);
     data.exec.dataSpace = (void *)&space;
     data.exec.pspace = &disp_data;
@@ -188,7 +188,7 @@ atombios_output_tv1_setup(xf86OutputPtr output, DisplayModePtr mode)
 	}
     }
 
-    disp_data.sTVEncoder.usPixelClock = mode->Clock / 10;
+    disp_data.sTVEncoder.usPixelClock = cpu_to_le16(mode->Clock / 10);
     data.exec.index = GetIndexIntoMasterTable(COMMAND, TVEncoderControl);
     data.exec.dataSpace = (void *)&space;
     data.exec.pspace = &disp_data;
@@ -243,7 +243,7 @@ atombios_output_ddia_setup(xf86OutputPtr output, DisplayModePtr mode)
     unsigned char *space;
 
     disp_data.sDVOEncoder.ucAction = ATOM_ENABLE;
-    disp_data.sDVOEncoder.usPixelClock = mode->Clock / 10;
+    disp_data.sDVOEncoder.usPixelClock = cpu_to_le16(mode->Clock / 10);
 
     if (mode->Clock > 165000)
 	disp_data.sDVOEncoder.usDevAttr.sDigAttrib.ucAttribute = PANEL_ENCODER_MISC_DUAL;
@@ -276,7 +276,7 @@ atombios_output_tmds1_setup(xf86OutputPtr output, DisplayModePtr mode)
 	disp_data.ucMisc = 1;
     else
 	disp_data.ucMisc = 0;
-    disp_data.usPixelClock = mode->Clock / 10;
+    disp_data.usPixelClock = cpu_to_le16(mode->Clock / 10);
     data.exec.index = GetIndexIntoMasterTable(COMMAND, TMDS1EncoderControl);
     data.exec.dataSpace = (void *)&space;
     data.exec.pspace = &disp_data;
@@ -304,7 +304,7 @@ atombios_output_tmds2_setup(xf86OutputPtr output, DisplayModePtr mode)
 	disp_data.ucMisc = 1;
     else
 	disp_data.ucMisc = 0;
-    disp_data.usPixelClock = mode->Clock / 10;
+    disp_data.usPixelClock = cpu_to_le16(mode->Clock / 10);
     data.exec.index = GetIndexIntoMasterTable(COMMAND, TMDS2EncoderControl);
     data.exec.dataSpace = (void *)&space;
     data.exec.pspace = &disp_data;
@@ -331,7 +331,7 @@ atombios_output_lvds_setup(xf86OutputPtr output, DisplayModePtr mode)
 	disp_data.ucMisc = 1;
     else
 	disp_data.ucMisc = 0;
-    disp_data.usPixelClock = mode->Clock / 10;
+    disp_data.usPixelClock = cpu_to_le16(mode->Clock / 10);
     data.exec.index = GetIndexIntoMasterTable(COMMAND, LVDSEncoderControl);
     data.exec.dataSpace = (void *)&space;
     data.exec.pspace = &disp_data;
@@ -355,7 +355,7 @@ atombios_output_dig1_setup(xf86OutputPtr output, DisplayModePtr mode)
     unsigned char *space;
 
     disp_data.ucAction = 1;
-    disp_data.usPixelClock = mode->Clock / 10;
+    disp_data.usPixelClock = cpu_to_le16(mode->Clock / 10);
     disp_data.ucConfig = ATOM_ENCODER_CONFIG_TRANSMITTER1;
     if (OUTPUT_IS_DVI || (radeon_output->type == OUTPUT_HDMI)) {
 	if (radeon_output->coherent_mode) {
@@ -406,7 +406,7 @@ atombios_output_dig1_transmitter_setup(xf86OutputPtr output, DisplayModePtr mode
     unsigned char *space;
 
     disp_data.ucAction = ATOM_TRANSMITTER_ACTION_ENABLE;
-    disp_data.usPixelClock = mode->Clock / 10;
+    disp_data.usPixelClock = cpu_to_le16(mode->Clock / 10);
     disp_data.ucConfig = ATOM_TRANSMITTER_CONFIG_DIG1_ENCODER | ATOM_TRANSMITTER_CONFIG_CLKSRC_PPLL;
 
     if (info->IsIGP && (radeon_output->TMDSType == TMDS_UNIPHY)) {
@@ -464,7 +464,7 @@ atombios_output_dig2_setup(xf86OutputPtr output, DisplayModePtr mode)
     unsigned char *space;
 
     disp_data.ucAction = 1;
-    disp_data.usPixelClock = mode->Clock / 10;
+    disp_data.usPixelClock = cpu_to_le16(mode->Clock / 10);
     disp_data.ucConfig = ATOM_ENCODER_CONFIG_TRANSMITTER2;
     if (OUTPUT_IS_DVI || (radeon_output->type == OUTPUT_HDMI)) {
 	if (radeon_output->coherent_mode) {
@@ -515,7 +515,7 @@ atombios_output_dig2_transmitter_setup(xf86OutputPtr output, DisplayModePtr mode
     unsigned char *space;
 
     disp_data.ucAction = ATOM_TRANSMITTER_ACTION_ENABLE;
-    disp_data.usPixelClock = mode->Clock / 10;
+    disp_data.usPixelClock = cpu_to_le16(mode->Clock / 10);
     disp_data.ucConfig = ATOM_TRANSMITTER_CONFIG_DIG2_ENCODER | ATOM_TRANSMITTER_CONFIG_CLKSRC_PPLL;
 
     if (info->IsIGP && (radeon_output->TMDSType == TMDS_UNIPHY)) {
@@ -979,19 +979,19 @@ atom_bios_dac_load_detect(atomBiosHandlePtr atomBIOS, xf86OutputPtr output)
     dac_data.sDacload.ucMisc = 0;
 
     if (radeon_output->devices & ATOM_DEVICE_CRT1_SUPPORT) {
-	dac_data.sDacload.usDeviceID = ATOM_DEVICE_CRT1_SUPPORT;
+	dac_data.sDacload.usDeviceID = cpu_to_le16(ATOM_DEVICE_CRT1_SUPPORT);
 	if (radeon_output->DACType == DAC_PRIMARY)
 	    dac_data.sDacload.ucDacType = ATOM_DAC_A;
 	else if (radeon_output->DACType == DAC_TVDAC)
 	    dac_data.sDacload.ucDacType = ATOM_DAC_B;
     } else if (radeon_output->devices & ATOM_DEVICE_CRT2_SUPPORT) {
-	dac_data.sDacload.usDeviceID = ATOM_DEVICE_CRT2_SUPPORT;
+	dac_data.sDacload.usDeviceID = cpu_to_le16(ATOM_DEVICE_CRT2_SUPPORT);
 	if (radeon_output->DACType == DAC_PRIMARY)
 	    dac_data.sDacload.ucDacType = ATOM_DAC_A;
 	else if (radeon_output->DACType == DAC_TVDAC)
 	    dac_data.sDacload.ucDacType = ATOM_DAC_B;
     } else if (radeon_output->devices & ATOM_DEVICE_CV_SUPPORT) {
-	dac_data.sDacload.usDeviceID = ATOM_DEVICE_CV_SUPPORT;
+	dac_data.sDacload.usDeviceID = cpu_to_le16(ATOM_DEVICE_CV_SUPPORT);
 	if (radeon_output->DACType == DAC_PRIMARY)
 	    dac_data.sDacload.ucDacType = ATOM_DAC_A;
 	else if (radeon_output->DACType == DAC_TVDAC)
@@ -999,7 +999,7 @@ atom_bios_dac_load_detect(atomBiosHandlePtr atomBIOS, xf86OutputPtr output)
 	if (IS_DCE3_VARIANT)
 	    dac_data.sDacload.ucMisc = 1;
     } else if (radeon_output->devices & ATOM_DEVICE_TV1_SUPPORT) {
-	dac_data.sDacload.usDeviceID = ATOM_DEVICE_TV1_SUPPORT;
+	dac_data.sDacload.usDeviceID = cpu_to_le16(ATOM_DEVICE_TV1_SUPPORT);
 	if (radeon_output->DACType == DAC_PRIMARY)
 	    dac_data.sDacload.ucDacType = ATOM_DAC_A;
 	else if (radeon_output->DACType == DAC_TVDAC)
diff --git a/src/bicubic_table.h b/src/bicubic_table.h
new file mode 100644
index 0000000..765cfff
--- /dev/null
+++ b/src/bicubic_table.h
@@ -0,0 +1,646 @@
+static const uint16_t bicubic_tex_512[] = {
+	0xb266, 0x3c00, 0x3aaa, 0x3155,
+	0xb287, 0x3bf0, 0x3aa2, 0x3175,
+	0xb2a9, 0x3be0, 0x3a9a, 0x3196,
+	0xb2cc, 0x3bd0, 0x3a92, 0x31b7,
+	0xb2ee, 0x3bc0, 0x3a89, 0x31d9,
+	0xb312, 0x3bb0, 0x3a81, 0x31fb,
+	0xb335, 0x3ba0, 0x3a78, 0x321e,
+	0xb359, 0x3b90, 0x3a6f, 0x3241,
+	0xb37d, 0x3b80, 0x3a66, 0x3264,
+	0xb3a2, 0x3b70, 0x3a5d, 0x3288,
+	0xb3c7, 0x3b60, 0x3a54, 0x32ad,
+	0xb3ed, 0x3b51, 0x3a4b, 0x32d1,
+	0xb409, 0x3b41, 0x3a42, 0x32f7,
+	0xb41c, 0x3b31, 0x3a38, 0x331c,
+	0xb42f, 0x3b21, 0x3a2f, 0x3342,
+	0xb443, 0x3b12, 0x3a25, 0x3369,
+	0xb456, 0x3b02, 0x3a1c, 0x3390,
+	0xb46a, 0x3af3, 0x3a12, 0x33b7,
+	0xb47e, 0x3ae3, 0x3a08, 0x33de,
+	0xb492, 0x3ad4, 0x39fe, 0x3403,
+	0xb4a6, 0x3ac5, 0x39f4, 0x3417,
+	0xb4bb, 0x3ab5, 0x39ea, 0x342b,
+	0xb4cf, 0x3aa6, 0x39df, 0x3440,
+	0xb4e4, 0x3a97, 0x39d5, 0x3454,
+	0xb4f9, 0x3a88, 0x39cb, 0x3469,
+	0xb50e, 0x3a79, 0x39c0, 0x347e,
+	0xb523, 0x3a6a, 0x39b6, 0x3493,
+	0xb539, 0x3a5a, 0x39ab, 0x34a8,
+	0xb54e, 0x3a4c, 0x39a0, 0x34be,
+	0xb564, 0x3a3d, 0x3996, 0x34d3,
+	0xb57a, 0x3a2e, 0x398b, 0x34e9,
+	0xb590, 0x3a1f, 0x3980, 0x34ff,
+	0xb5a6, 0x3a10, 0x3975, 0x3515,
+	0xb5bc, 0x3a02, 0x396a, 0x352b,
+	0xb5d2, 0x39f3, 0x395f, 0x3541,
+	0xb5e9, 0x39e4, 0x3954, 0x3557,
+	0xb5ff, 0x39d6, 0x3948, 0x356e,
+	0xb616, 0x39c7, 0x393d, 0x3584,
+	0xb62d, 0x39b9, 0x3932, 0x359b,
+	0xb644, 0x39ab, 0x3926, 0x35b2,
+	0xb65b, 0x399c, 0x391b, 0x35c9,
+	0xb672, 0x398e, 0x3910, 0x35df,
+	0xb68a, 0x3980, 0x3904, 0x35f6,
+	0xb6a1, 0x3972, 0x38f8, 0x360e,
+	0xb6b9, 0x3964, 0x38ed, 0x3625,
+	0xb6d1, 0x3956, 0x38e1, 0x363c,
+	0xb6e8, 0x3948, 0x38d6, 0x3653,
+	0xb700, 0x393a, 0x38ca, 0x366b,
+	0xb719, 0x392c, 0x38be, 0x3682,
+	0xb731, 0x391e, 0x38b2, 0x369a,
+	0xb749, 0x3910, 0x38a7, 0x36b1,
+	0xb762, 0x3902, 0x389b, 0x36c9,
+	0xb77a, 0x38f5, 0x388f, 0x36e1,
+	0xb793, 0x38e7, 0x3883, 0x36f8,
+	0xb7ac, 0x38da, 0x3877, 0x3710,
+	0xb7c5, 0x38cc, 0x386b, 0x3728,
+	0xb7de, 0x38bf, 0x385f, 0x3740,
+	0xb7f7, 0x38b1, 0x3853, 0x3758,
+	0xb808, 0x38a4, 0x3847, 0x3770,
+	0xb815, 0x3897, 0x383b, 0x3788,
+	0xb821, 0x3889, 0x382f, 0x37a0,
+	0xb82e, 0x387c, 0x3823, 0x37b8,
+	0xb83b, 0x386f, 0x3817, 0x37d0,
+	0xb848, 0x3862, 0x380b, 0x37e8,
+	0xb855, 0x3855, 0x3800, 0x3800,
+	0xb862, 0x3848, 0x37e8, 0x380b,
+	0xb86f, 0x383b, 0x37d0, 0x3817,
+	0xb87c, 0x382e, 0x37b8, 0x3823,
+	0xb889, 0x3821, 0x37a0, 0x382f,
+	0xb897, 0x3815, 0x3788, 0x383b,
+	0xb8a4, 0x3808, 0x3770, 0x3847,
+	0xb8b1, 0x37f7, 0x3758, 0x3853,
+	0xb8bf, 0x37de, 0x3740, 0x385f,
+	0xb8cc, 0x37c5, 0x3728, 0x386b,
+	0xb8da, 0x37ac, 0x3710, 0x3877,
+	0xb8e7, 0x3793, 0x36f8, 0x3883,
+	0xb8f5, 0x377a, 0x36e1, 0x388f,
+	0xb902, 0x3762, 0x36c9, 0x389b,
+	0xb910, 0x3749, 0x36b1, 0x38a7,
+	0xb91e, 0x3731, 0x369a, 0x38b2,
+	0xb92c, 0x3719, 0x3682, 0x38be,
+	0xb93a, 0x3700, 0x366b, 0x38ca,
+	0xb948, 0x36e8, 0x3653, 0x38d6,
+	0xb956, 0x36d1, 0x363c, 0x38e1,
+	0xb964, 0x36b9, 0x3625, 0x38ed,
+	0xb972, 0x36a1, 0x360e, 0x38f8,
+	0xb980, 0x368a, 0x35f6, 0x3904,
+	0xb98e, 0x3672, 0x35df, 0x3910,
+	0xb99c, 0x365b, 0x35c9, 0x391b,
+	0xb9ab, 0x3644, 0x35b2, 0x3926,
+	0xb9b9, 0x362d, 0x359b, 0x3932,
+	0xb9c7, 0x3616, 0x3584, 0x393d,
+	0xb9d6, 0x35ff, 0x356e, 0x3948,
+	0xb9e4, 0x35e9, 0x3557, 0x3954,
+	0xb9f3, 0x35d2, 0x3541, 0x395f,
+	0xba02, 0x35bc, 0x352b, 0x396a,
+	0xba10, 0x35a6, 0x3515, 0x3975,
+	0xba1f, 0x3590, 0x34ff, 0x3980,
+	0xba2e, 0x357a, 0x34e9, 0x398b,
+	0xba3d, 0x3564, 0x34d3, 0x3996,
+	0xba4c, 0x354e, 0x34be, 0x39a0,
+	0xba5a, 0x3539, 0x34a8, 0x39ab,
+	0xba6a, 0x3523, 0x3493, 0x39b6,
+	0xba79, 0x350e, 0x347e, 0x39c0,
+	0xba88, 0x34f9, 0x3469, 0x39cb,
+	0xba97, 0x34e4, 0x3454, 0x39d5,
+	0xbaa6, 0x34cf, 0x3440, 0x39df,
+	0xbab5, 0x34bb, 0x342b, 0x39ea,
+	0xbac5, 0x34a6, 0x3417, 0x39f4,
+	0xbad4, 0x3492, 0x3403, 0x39fe,
+	0xbae3, 0x347e, 0x33de, 0x3a08,
+	0xbaf3, 0x346a, 0x33b7, 0x3a12,
+	0xbb02, 0x3456, 0x3390, 0x3a1c,
+	0xbb12, 0x3443, 0x3369, 0x3a25,
+	0xbb21, 0x342f, 0x3342, 0x3a2f,
+	0xbb31, 0x341c, 0x331c, 0x3a38,
+	0xbb41, 0x3409, 0x32f7, 0x3a42,
+	0xbb51, 0x33ed, 0x32d1, 0x3a4b,
+	0xbb60, 0x33c7, 0x32ad, 0x3a54,
+	0xbb70, 0x33a2, 0x3288, 0x3a5d,
+	0xbb80, 0x337d, 0x3264, 0x3a66,
+	0xbb90, 0x3359, 0x3241, 0x3a6f,
+	0xbba0, 0x3335, 0x321e, 0x3a78,
+	0xbbb0, 0x3312, 0x31fb, 0x3a81,
+	0xbbc0, 0x32ee, 0x31d9, 0x3a89,
+	0xbbd0, 0x32cc, 0x31b7, 0x3a92,
+	0xbbe0, 0x32a9, 0x3196, 0x3a9a,
+	0xbbf0, 0x3287, 0x3175, 0x3aa2,
+	0 };
+
+static const uint16_t bicubic_tex_2048[] = {
+	0xb266, 0x3c00, 0x3aaa, 0x3155,
+	0xb26e, 0x3bfc, 0x3aa8, 0x315d,
+	0xb277, 0x3bf8, 0x3aa6, 0x3165,
+	0xb27f, 0x3bf4, 0x3aa4, 0x316d,
+	0xb287, 0x3bf0, 0x3aa2, 0x3175,
+	0xb290, 0x3bec, 0x3aa0, 0x317d,
+	0xb298, 0x3be8, 0x3a9e, 0x3185,
+	0xb2a1, 0x3be4, 0x3a9c, 0x318e,
+	0xb2a9, 0x3be0, 0x3a9a, 0x3196,
+	0xb2b2, 0x3bdc, 0x3a98, 0x319e,
+	0xb2ba, 0x3bd8, 0x3a96, 0x31a6,
+	0xb2c3, 0x3bd4, 0x3a94, 0x31af,
+	0xb2cc, 0x3bd0, 0x3a92, 0x31b7,
+	0xb2d4, 0x3bcc, 0x3a90, 0x31bf,
+	0xb2dd, 0x3bc8, 0x3a8d, 0x31c8,
+	0xb2e6, 0x3bc4, 0x3a8b, 0x31d0,
+	0xb2ee, 0x3bc0, 0x3a89, 0x31d9,
+	0xb2f7, 0x3bbc, 0x3a87, 0x31e1,
+	0xb300, 0x3bb8, 0x3a85, 0x31ea,
+	0xb309, 0x3bb4, 0x3a83, 0x31f2,
+	0xb312, 0x3bb0, 0x3a81, 0x31fb,
+	0xb31a, 0x3bac, 0x3a7e, 0x3204,
+	0xb323, 0x3ba8, 0x3a7c, 0x320c,
+	0xb32c, 0x3ba4, 0x3a7a, 0x3215,
+	0xb335, 0x3ba0, 0x3a78, 0x321e,
+	0xb33e, 0x3b9c, 0x3a76, 0x3226,
+	0xb347, 0x3b98, 0x3a74, 0x322f,
+	0xb350, 0x3b94, 0x3a71, 0x3238,
+	0xb359, 0x3b90, 0x3a6f, 0x3241,
+	0xb362, 0x3b8c, 0x3a6d, 0x3249,
+	0xb36b, 0x3b88, 0x3a6b, 0x3252,
+	0xb374, 0x3b84, 0x3a69, 0x325b,
+	0xb37d, 0x3b80, 0x3a66, 0x3264,
+	0xb387, 0x3b7c, 0x3a64, 0x326d,
+	0xb390, 0x3b78, 0x3a62, 0x3276,
+	0xb399, 0x3b74, 0x3a60, 0x327f,
+	0xb3a2, 0x3b70, 0x3a5d, 0x3288,
+	0xb3ab, 0x3b6c, 0x3a5b, 0x3291,
+	0xb3b5, 0x3b68, 0x3a59, 0x329a,
+	0xb3be, 0x3b64, 0x3a57, 0x32a3,
+	0xb3c7, 0x3b60, 0x3a54, 0x32ad,
+	0xb3d0, 0x3b5c, 0x3a52, 0x32b6,
+	0xb3da, 0x3b58, 0x3a50, 0x32bf,
+	0xb3e3, 0x3b54, 0x3a4d, 0x32c8,
+	0xb3ed, 0x3b51, 0x3a4b, 0x32d1,
+	0xb3f6, 0x3b4d, 0x3a49, 0x32db,
+	0xb3ff, 0x3b49, 0x3a46, 0x32e4,
+	0xb404, 0x3b45, 0x3a44, 0x32ed,
+	0xb409, 0x3b41, 0x3a42, 0x32f7,
+	0xb40e, 0x3b3d, 0x3a3f, 0x3300,
+	0xb412, 0x3b39, 0x3a3d, 0x3309,
+	0xb417, 0x3b35, 0x3a3b, 0x3313,
+	0xb41c, 0x3b31, 0x3a38, 0x331c,
+	0xb421, 0x3b2d, 0x3a36, 0x3326,
+	0xb426, 0x3b29, 0x3a34, 0x332f,
+	0xb42a, 0x3b25, 0x3a31, 0x3339,
+	0xb42f, 0x3b21, 0x3a2f, 0x3342,
+	0xb434, 0x3b1e, 0x3a2c, 0x334c,
+	0xb439, 0x3b1a, 0x3a2a, 0x3355,
+	0xb43e, 0x3b16, 0x3a28, 0x335f,
+	0xb443, 0x3b12, 0x3a25, 0x3369,
+	0xb448, 0x3b0e, 0x3a23, 0x3372,
+	0xb44d, 0x3b0a, 0x3a20, 0x337c,
+	0xb451, 0x3b06, 0x3a1e, 0x3386,
+	0xb456, 0x3b02, 0x3a1c, 0x3390,
+	0xb45b, 0x3afe, 0x3a19, 0x3399,
+	0xb460, 0x3afb, 0x3a17, 0x33a3,
+	0xb465, 0x3af7, 0x3a14, 0x33ad,
+	0xb46a, 0x3af3, 0x3a12, 0x33b7,
+	0xb46f, 0x3aef, 0x3a0f, 0x33c1,
+	0xb474, 0x3aeb, 0x3a0d, 0x33ca,
+	0xb479, 0x3ae7, 0x3a0a, 0x33d4,
+	0xb47e, 0x3ae3, 0x3a08, 0x33de,
+	0xb483, 0x3ae0, 0x3a05, 0x33e8,
+	0xb488, 0x3adc, 0x3a03, 0x33f2,
+	0xb48d, 0x3ad8, 0x3a00, 0x33fc,
+	0xb492, 0x3ad4, 0x39fe, 0x3403,
+	0xb497, 0x3ad0, 0x39fb, 0x3408,
+	0xb49c, 0x3acc, 0x39f9, 0x340d,
+	0xb4a1, 0x3ac8, 0x39f6, 0x3412,
+	0xb4a6, 0x3ac5, 0x39f4, 0x3417,
+	0xb4ac, 0x3ac1, 0x39f1, 0x341c,
+	0xb4b1, 0x3abd, 0x39ef, 0x3421,
+	0xb4b6, 0x3ab9, 0x39ec, 0x3426,
+	0xb4bb, 0x3ab5, 0x39ea, 0x342b,
+	0xb4c0, 0x3ab1, 0x39e7, 0x3430,
+	0xb4c5, 0x3aae, 0x39e5, 0x3435,
+	0xb4ca, 0x3aaa, 0x39e2, 0x343b,
+	0xb4cf, 0x3aa6, 0x39df, 0x3440,
+	0xb4d5, 0x3aa2, 0x39dd, 0x3445,
+	0xb4da, 0x3a9e, 0x39da, 0x344a,
+	0xb4df, 0x3a9b, 0x39d8, 0x344f,
+	0xb4e4, 0x3a97, 0x39d5, 0x3454,
+	0xb4e9, 0x3a93, 0x39d2, 0x345a,
+	0xb4ef, 0x3a8f, 0x39d0, 0x345f,
+	0xb4f4, 0x3a8b, 0x39cd, 0x3464,
+	0xb4f9, 0x3a88, 0x39cb, 0x3469,
+	0xb4fe, 0x3a84, 0x39c8, 0x346e,
+	0xb504, 0x3a80, 0x39c5, 0x3474,
+	0xb509, 0x3a7c, 0x39c3, 0x3479,
+	0xb50e, 0x3a79, 0x39c0, 0x347e,
+	0xb513, 0x3a75, 0x39be, 0x3483,
+	0xb519, 0x3a71, 0x39bb, 0x3489,
+	0xb51e, 0x3a6d, 0x39b8, 0x348e,
+	0xb523, 0x3a6a, 0x39b6, 0x3493,
+	0xb529, 0x3a66, 0x39b3, 0x3499,
+	0xb52e, 0x3a62, 0x39b0, 0x349e,
+	0xb533, 0x3a5e, 0x39ae, 0x34a3,
+	0xb539, 0x3a5a, 0x39ab, 0x34a8,
+	0xb53e, 0x3a57, 0x39a8, 0x34ae,
+	0xb543, 0x3a53, 0x39a6, 0x34b3,
+	0xb549, 0x3a4f, 0x39a3, 0x34b9,
+	0xb54e, 0x3a4c, 0x39a0, 0x34be,
+	0xb554, 0x3a48, 0x399e, 0x34c3,
+	0xb559, 0x3a44, 0x399b, 0x34c9,
+	0xb55e, 0x3a40, 0x3998, 0x34ce,
+	0xb564, 0x3a3d, 0x3996, 0x34d3,
+	0xb569, 0x3a39, 0x3993, 0x34d9,
+	0xb56f, 0x3a35, 0x3990, 0x34de,
+	0xb574, 0x3a32, 0x398d, 0x34e4,
+	0xb57a, 0x3a2e, 0x398b, 0x34e9,
+	0xb57f, 0x3a2a, 0x3988, 0x34ef,
+	0xb585, 0x3a26, 0x3985, 0x34f4,
+	0xb58a, 0x3a23, 0x3983, 0x34f9,
+	0xb590, 0x3a1f, 0x3980, 0x34ff,
+	0xb595, 0x3a1b, 0x397d, 0x3504,
+	0xb59b, 0x3a18, 0x397a, 0x350a,
+	0xb5a0, 0x3a14, 0x3978, 0x350f,
+	0xb5a6, 0x3a10, 0x3975, 0x3515,
+	0xb5ab, 0x3a0d, 0x3972, 0x351a,
+	0xb5b1, 0x3a09, 0x396f, 0x3520,
+	0xb5b6, 0x3a05, 0x396d, 0x3525,
+	0xb5bc, 0x3a02, 0x396a, 0x352b,
+	0xb5c1, 0x39fe, 0x3967, 0x3530,
+	0xb5c7, 0x39fa, 0x3964, 0x3536,
+	0xb5cd, 0x39f7, 0x3961, 0x353c,
+	0xb5d2, 0x39f3, 0x395f, 0x3541,
+	0xb5d8, 0x39ef, 0x395c, 0x3547,
+	0xb5dd, 0x39ec, 0x3959, 0x354c,
+	0xb5e3, 0x39e8, 0x3956, 0x3552,
+	0xb5e9, 0x39e4, 0x3954, 0x3557,
+	0xb5ee, 0x39e1, 0x3951, 0x355d,
+	0xb5f4, 0x39dd, 0x394e, 0x3563,
+	0xb5fa, 0x39d9, 0x394b, 0x3568,
+	0xb5ff, 0x39d6, 0x3948, 0x356e,
+	0xb605, 0x39d2, 0x3946, 0x3573,
+	0xb60b, 0x39cf, 0x3943, 0x3579,
+	0xb610, 0x39cb, 0x3940, 0x357f,
+	0xb616, 0x39c7, 0x393d, 0x3584,
+	0xb61c, 0x39c4, 0x393a, 0x358a,
+	0xb621, 0x39c0, 0x3937, 0x3590,
+	0xb627, 0x39bd, 0x3935, 0x3595,
+	0xb62d, 0x39b9, 0x3932, 0x359b,
+	0xb633, 0x39b5, 0x392f, 0x35a1,
+	0xb638, 0x39b2, 0x392c, 0x35a6,
+	0xb63e, 0x39ae, 0x3929, 0x35ac,
+	0xb644, 0x39ab, 0x3926, 0x35b2,
+	0xb64a, 0x39a7, 0x3924, 0x35b7,
+	0xb64f, 0x39a3, 0x3921, 0x35bd,
+	0xb655, 0x39a0, 0x391e, 0x35c3,
+	0xb65b, 0x399c, 0x391b, 0x35c9,
+	0xb661, 0x3999, 0x3918, 0x35ce,
+	0xb667, 0x3995, 0x3915, 0x35d4,
+	0xb66c, 0x3992, 0x3912, 0x35da,
+	0xb672, 0x398e, 0x3910, 0x35df,
+	0xb678, 0x398a, 0x390d, 0x35e5,
+	0xb67e, 0x3987, 0x390a, 0x35eb,
+	0xb684, 0x3983, 0x3907, 0x35f1,
+	0xb68a, 0x3980, 0x3904, 0x35f6,
+	0xb68f, 0x397c, 0x3901, 0x35fc,
+	0xb695, 0x3979, 0x38fe, 0x3602,
+	0xb69b, 0x3975, 0x38fb, 0x3608,
+	0xb6a1, 0x3972, 0x38f8, 0x360e,
+	0xb6a7, 0x396e, 0x38f6, 0x3613,
+	0xb6ad, 0x396b, 0x38f3, 0x3619,
+	0xb6b3, 0x3967, 0x38f0, 0x361f,
+	0xb6b9, 0x3964, 0x38ed, 0x3625,
+	0xb6bf, 0x3960, 0x38ea, 0x362b,
+	0xb6c5, 0x395d, 0x38e7, 0x3630,
+	0xb6cb, 0x3959, 0x38e4, 0x3636,
+	0xb6d1, 0x3956, 0x38e1, 0x363c,
+	0xb6d6, 0x3952, 0x38de, 0x3642,
+	0xb6dc, 0x394f, 0x38db, 0x3648,
+	0xb6e2, 0x394b, 0x38d9, 0x364d,
+	0xb6e8, 0x3948, 0x38d6, 0x3653,
+	0xb6ee, 0x3944, 0x38d3, 0x3659,
+	0xb6f4, 0x3941, 0x38d0, 0x365f,
+	0xb6fa, 0x393d, 0x38cd, 0x3665,
+	0xb700, 0x393a, 0x38ca, 0x366b,
+	0xb706, 0x3936, 0x38c7, 0x3671,
+	0xb70c, 0x3933, 0x38c4, 0x3676,
+	0xb712, 0x392f, 0x38c1, 0x367c,
+	0xb719, 0x392c, 0x38be, 0x3682,
+	0xb71f, 0x3928, 0x38bb, 0x3688,
+	0xb725, 0x3925, 0x38b8, 0x368e,
+	0xb72b, 0x3921, 0x38b5, 0x3694,
+	0xb731, 0x391e, 0x38b2, 0x369a,
+	0xb737, 0x391a, 0x38af, 0x36a0,
+	0xb73d, 0x3917, 0x38ad, 0x36a5,
+	0xb743, 0x3914, 0x38aa, 0x36ab,
+	0xb749, 0x3910, 0x38a7, 0x36b1,
+	0xb74f, 0x390d, 0x38a4, 0x36b7,
+	0xb755, 0x3909, 0x38a1, 0x36bd,
+	0xb75b, 0x3906, 0x389e, 0x36c3,
+	0xb762, 0x3902, 0x389b, 0x36c9,
+	0xb768, 0x38ff, 0x3898, 0x36cf,
+	0xb76e, 0x38fc, 0x3895, 0x36d5,
+	0xb774, 0x38f8, 0x3892, 0x36db,
+	0xb77a, 0x38f5, 0x388f, 0x36e1,
+	0xb780, 0x38f1, 0x388c, 0x36e7,
+	0xb787, 0x38ee, 0x3889, 0x36ec,
+	0xb78d, 0x38eb, 0x3886, 0x36f2,
+	0xb793, 0x38e7, 0x3883, 0x36f8,
+	0xb799, 0x38e4, 0x3880, 0x36fe,
+	0xb79f, 0x38e0, 0x387d, 0x3704,
+	0xb7a5, 0x38dd, 0x387a, 0x370a,
+	0xb7ac, 0x38da, 0x3877, 0x3710,
+	0xb7b2, 0x38d6, 0x3874, 0x3716,
+	0xb7b8, 0x38d3, 0x3871, 0x371c,
+	0xb7be, 0x38cf, 0x386e, 0x3722,
+	0xb7c5, 0x38cc, 0x386b, 0x3728,
+	0xb7cb, 0x38c9, 0x3868, 0x372e,
+	0xb7d1, 0x38c5, 0x3865, 0x3734,
+	0xb7d7, 0x38c2, 0x3862, 0x373a,
+	0xb7de, 0x38bf, 0x385f, 0x3740,
+	0xb7e4, 0x38bb, 0x385c, 0x3746,
+	0xb7ea, 0x38b8, 0x3859, 0x374c,
+	0xb7f1, 0x38b5, 0x3856, 0x3752,
+	0xb7f7, 0x38b1, 0x3853, 0x3758,
+	0xb7fd, 0x38ae, 0x3850, 0x375e,
+	0xb801, 0x38aa, 0x384d, 0x3764,
+	0xb805, 0x38a7, 0x384a, 0x376a,
+	0xb808, 0x38a4, 0x3847, 0x3770,
+	0xb80b, 0x38a0, 0x3844, 0x3776,
+	0xb80e, 0x389d, 0x3841, 0x377c,
+	0xb811, 0x389a, 0x383e, 0x3782,
+	0xb815, 0x3897, 0x383b, 0x3788,
+	0xb818, 0x3893, 0x3838, 0x378e,
+	0xb81b, 0x3890, 0x3835, 0x3794,
+	0xb81e, 0x388d, 0x3832, 0x379a,
+	0xb821, 0x3889, 0x382f, 0x37a0,
+	0xb824, 0x3886, 0x382c, 0x37a6,
+	0xb828, 0x3883, 0x3829, 0x37ac,
+	0xb82b, 0x387f, 0x3826, 0x37b2,
+	0xb82e, 0x387c, 0x3823, 0x37b8,
+	0xb831, 0x3879, 0x3820, 0x37be,
+	0xb835, 0x3876, 0x381d, 0x37c4,
+	0xb838, 0x3872, 0x381a, 0x37ca,
+	0xb83b, 0x386f, 0x3817, 0x37d0,
+	0xb83e, 0x386c, 0x3814, 0x37d6,
+	0xb841, 0x3868, 0x3811, 0x37dc,
+	0xb845, 0x3865, 0x380e, 0x37e2,
+	0xb848, 0x3862, 0x380b, 0x37e8,
+	0xb84b, 0x385f, 0x3808, 0x37ee,
+	0xb84e, 0x385b, 0x3806, 0x37f4,
+	0xb852, 0x3858, 0x3803, 0x37fa,
+	0xb855, 0x3855, 0x3800, 0x3800,
+	0xb858, 0x3852, 0x37fa, 0x3803,
+	0xb85b, 0x384e, 0x37f4, 0x3806,
+	0xb85f, 0x384b, 0x37ee, 0x3808,
+	0xb862, 0x3848, 0x37e8, 0x380b,
+	0xb865, 0x3845, 0x37e2, 0x380e,
+	0xb868, 0x3841, 0x37dc, 0x3811,
+	0xb86c, 0x383e, 0x37d6, 0x3814,
+	0xb86f, 0x383b, 0x37d0, 0x3817,
+	0xb872, 0x3838, 0x37ca, 0x381a,
+	0xb876, 0x3835, 0x37c4, 0x381d,
+	0xb879, 0x3831, 0x37be, 0x3820,
+	0xb87c, 0x382e, 0x37b8, 0x3823,
+	0xb87f, 0x382b, 0x37b2, 0x3826,
+	0xb883, 0x3828, 0x37ac, 0x3829,
+	0xb886, 0x3824, 0x37a6, 0x382c,
+	0xb889, 0x3821, 0x37a0, 0x382f,
+	0xb88d, 0x381e, 0x379a, 0x3832,
+	0xb890, 0x381b, 0x3794, 0x3835,
+	0xb893, 0x3818, 0x378e, 0x3838,
+	0xb897, 0x3815, 0x3788, 0x383b,
+	0xb89a, 0x3811, 0x3782, 0x383e,
+	0xb89d, 0x380e, 0x377c, 0x3841,
+	0xb8a0, 0x380b, 0x3776, 0x3844,
+	0xb8a4, 0x3808, 0x3770, 0x3847,
+	0xb8a7, 0x3805, 0x376a, 0x384a,
+	0xb8aa, 0x3801, 0x3764, 0x384d,
+	0xb8ae, 0x37fd, 0x375e, 0x3850,
+	0xb8b1, 0x37f7, 0x3758, 0x3853,
+	0xb8b5, 0x37f1, 0x3752, 0x3856,
+	0xb8b8, 0x37ea, 0x374c, 0x3859,
+	0xb8bb, 0x37e4, 0x3746, 0x385c,
+	0xb8bf, 0x37de, 0x3740, 0x385f,
+	0xb8c2, 0x37d7, 0x373a, 0x3862,
+	0xb8c5, 0x37d1, 0x3734, 0x3865,
+	0xb8c9, 0x37cb, 0x372e, 0x3868,
+	0xb8cc, 0x37c5, 0x3728, 0x386b,
+	0xb8cf, 0x37be, 0x3722, 0x386e,
+	0xb8d3, 0x37b8, 0x371c, 0x3871,
+	0xb8d6, 0x37b2, 0x3716, 0x3874,
+	0xb8da, 0x37ac, 0x3710, 0x3877,
+	0xb8dd, 0x37a5, 0x370a, 0x387a,
+	0xb8e0, 0x379f, 0x3704, 0x387d,
+	0xb8e4, 0x3799, 0x36fe, 0x3880,
+	0xb8e7, 0x3793, 0x36f8, 0x3883,
+	0xb8eb, 0x378d, 0x36f2, 0x3886,
+	0xb8ee, 0x3787, 0x36ec, 0x3889,
+	0xb8f1, 0x3780, 0x36e7, 0x388c,
+	0xb8f5, 0x377a, 0x36e1, 0x388f,
+	0xb8f8, 0x3774, 0x36db, 0x3892,
+	0xb8fc, 0x376e, 0x36d5, 0x3895,
+	0xb8ff, 0x3768, 0x36cf, 0x3898,
+	0xb902, 0x3762, 0x36c9, 0x389b,
+	0xb906, 0x375b, 0x36c3, 0x389e,
+	0xb909, 0x3755, 0x36bd, 0x38a1,
+	0xb90d, 0x374f, 0x36b7, 0x38a4,
+	0xb910, 0x3749, 0x36b1, 0x38a7,
+	0xb914, 0x3743, 0x36ab, 0x38aa,
+	0xb917, 0x373d, 0x36a5, 0x38ad,
+	0xb91a, 0x3737, 0x36a0, 0x38af,
+	0xb91e, 0x3731, 0x369a, 0x38b2,
+	0xb921, 0x372b, 0x3694, 0x38b5,
+	0xb925, 0x3725, 0x368e, 0x38b8,
+	0xb928, 0x371f, 0x3688, 0x38bb,
+	0xb92c, 0x3719, 0x3682, 0x38be,
+	0xb92f, 0x3712, 0x367c, 0x38c1,
+	0xb933, 0x370c, 0x3676, 0x38c4,
+	0xb936, 0x3706, 0x3671, 0x38c7,
+	0xb93a, 0x3700, 0x366b, 0x38ca,
+	0xb93d, 0x36fa, 0x3665, 0x38cd,
+	0xb941, 0x36f4, 0x365f, 0x38d0,
+	0xb944, 0x36ee, 0x3659, 0x38d3,
+	0xb948, 0x36e8, 0x3653, 0x38d6,
+	0xb94b, 0x36e2, 0x364d, 0x38d9,
+	0xb94f, 0x36dc, 0x3648, 0x38db,
+	0xb952, 0x36d6, 0x3642, 0x38de,
+	0xb956, 0x36d1, 0x363c, 0x38e1,
+	0xb959, 0x36cb, 0x3636, 0x38e4,
+	0xb95d, 0x36c5, 0x3630, 0x38e7,
+	0xb960, 0x36bf, 0x362b, 0x38ea,
+	0xb964, 0x36b9, 0x3625, 0x38ed,
+	0xb967, 0x36b3, 0x361f, 0x38f0,
+	0xb96b, 0x36ad, 0x3619, 0x38f3,
+	0xb96e, 0x36a7, 0x3613, 0x38f6,
+	0xb972, 0x36a1, 0x360e, 0x38f8,
+	0xb975, 0x369b, 0x3608, 0x38fb,
+	0xb979, 0x3695, 0x3602, 0x38fe,
+	0xb97c, 0x368f, 0x35fc, 0x3901,
+	0xb980, 0x368a, 0x35f6, 0x3904,
+	0xb983, 0x3684, 0x35f1, 0x3907,
+	0xb987, 0x367e, 0x35eb, 0x390a,
+	0xb98a, 0x3678, 0x35e5, 0x390d,
+	0xb98e, 0x3672, 0x35df, 0x3910,
+	0xb992, 0x366c, 0x35da, 0x3912,
+	0xb995, 0x3667, 0x35d4, 0x3915,
+	0xb999, 0x3661, 0x35ce, 0x3918,
+	0xb99c, 0x365b, 0x35c9, 0x391b,
+	0xb9a0, 0x3655, 0x35c3, 0x391e,
+	0xb9a3, 0x364f, 0x35bd, 0x3921,
+	0xb9a7, 0x364a, 0x35b7, 0x3924,
+	0xb9ab, 0x3644, 0x35b2, 0x3926,
+	0xb9ae, 0x363e, 0x35ac, 0x3929,
+	0xb9b2, 0x3638, 0x35a6, 0x392c,
+	0xb9b5, 0x3633, 0x35a1, 0x392f,
+	0xb9b9, 0x362d, 0x359b, 0x3932,
+	0xb9bd, 0x3627, 0x3595, 0x3935,
+	0xb9c0, 0x3621, 0x3590, 0x3937,
+	0xb9c4, 0x361c, 0x358a, 0x393a,
+	0xb9c7, 0x3616, 0x3584, 0x393d,
+	0xb9cb, 0x3610, 0x357f, 0x3940,
+	0xb9cf, 0x360b, 0x3579, 0x3943,
+	0xb9d2, 0x3605, 0x3573, 0x3946,
+	0xb9d6, 0x35ff, 0x356e, 0x3948,
+	0xb9d9, 0x35fa, 0x3568, 0x394b,
+	0xb9dd, 0x35f4, 0x3563, 0x394e,
+	0xb9e1, 0x35ee, 0x355d, 0x3951,
+	0xb9e4, 0x35e9, 0x3557, 0x3954,
+	0xb9e8, 0x35e3, 0x3552, 0x3956,
+	0xb9ec, 0x35dd, 0x354c, 0x3959,
+	0xb9ef, 0x35d8, 0x3547, 0x395c,
+	0xb9f3, 0x35d2, 0x3541, 0x395f,
+	0xb9f7, 0x35cd, 0x353c, 0x3961,
+	0xb9fa, 0x35c7, 0x3536, 0x3964,
+	0xb9fe, 0x35c1, 0x3530, 0x3967,
+	0xba02, 0x35bc, 0x352b, 0x396a,
+	0xba05, 0x35b6, 0x3525, 0x396d,
+	0xba09, 0x35b1, 0x3520, 0x396f,
+	0xba0d, 0x35ab, 0x351a, 0x3972,
+	0xba10, 0x35a6, 0x3515, 0x3975,
+	0xba14, 0x35a0, 0x350f, 0x3978,
+	0xba18, 0x359b, 0x350a, 0x397a,
+	0xba1b, 0x3595, 0x3504, 0x397d,
+	0xba1f, 0x3590, 0x34ff, 0x3980,
+	0xba23, 0x358a, 0x34f9, 0x3983,
+	0xba26, 0x3585, 0x34f4, 0x3985,
+	0xba2a, 0x357f, 0x34ef, 0x3988,
+	0xba2e, 0x357a, 0x34e9, 0x398b,
+	0xba32, 0x3574, 0x34e4, 0x398d,
+	0xba35, 0x356f, 0x34de, 0x3990,
+	0xba39, 0x3569, 0x34d9, 0x3993,
+	0xba3d, 0x3564, 0x34d3, 0x3996,
+	0xba40, 0x355e, 0x34ce, 0x3998,
+	0xba44, 0x3559, 0x34c9, 0x399b,
+	0xba48, 0x3554, 0x34c3, 0x399e,
+	0xba4c, 0x354e, 0x34be, 0x39a0,
+	0xba4f, 0x3549, 0x34b9, 0x39a3,
+	0xba53, 0x3543, 0x34b3, 0x39a6,
+	0xba57, 0x353e, 0x34ae, 0x39a8,
+	0xba5a, 0x3539, 0x34a8, 0x39ab,
+	0xba5e, 0x3533, 0x34a3, 0x39ae,
+	0xba62, 0x352e, 0x349e, 0x39b0,
+	0xba66, 0x3529, 0x3499, 0x39b3,
+	0xba6a, 0x3523, 0x3493, 0x39b6,
+	0xba6d, 0x351e, 0x348e, 0x39b8,
+	0xba71, 0x3519, 0x3489, 0x39bb,
+	0xba75, 0x3513, 0x3483, 0x39be,
+	0xba79, 0x350e, 0x347e, 0x39c0,
+	0xba7c, 0x3509, 0x3479, 0x39c3,
+	0xba80, 0x3504, 0x3474, 0x39c5,
+	0xba84, 0x34fe, 0x346e, 0x39c8,
+	0xba88, 0x34f9, 0x3469, 0x39cb,
+	0xba8b, 0x34f4, 0x3464, 0x39cd,
+	0xba8f, 0x34ef, 0x345f, 0x39d0,
+	0xba93, 0x34e9, 0x345a, 0x39d2,
+	0xba97, 0x34e4, 0x3454, 0x39d5,
+	0xba9b, 0x34df, 0x344f, 0x39d8,
+	0xba9e, 0x34da, 0x344a, 0x39da,
+	0xbaa2, 0x34d5, 0x3445, 0x39dd,
+	0xbaa6, 0x34cf, 0x3440, 0x39df,
+	0xbaaa, 0x34ca, 0x343b, 0x39e2,
+	0xbaae, 0x34c5, 0x3435, 0x39e5,
+	0xbab1, 0x34c0, 0x3430, 0x39e7,
+	0xbab5, 0x34bb, 0x342b, 0x39ea,
+	0xbab9, 0x34b6, 0x3426, 0x39ec,
+	0xbabd, 0x34b1, 0x3421, 0x39ef,
+	0xbac1, 0x34ac, 0x341c, 0x39f1,
+	0xbac5, 0x34a6, 0x3417, 0x39f4,
+	0xbac8, 0x34a1, 0x3412, 0x39f6,
+	0xbacc, 0x349c, 0x340d, 0x39f9,
+	0xbad0, 0x3497, 0x3408, 0x39fb,
+	0xbad4, 0x3492, 0x3403, 0x39fe,
+	0xbad8, 0x348d, 0x33fc, 0x3a00,
+	0xbadc, 0x3488, 0x33f2, 0x3a03,
+	0xbae0, 0x3483, 0x33e8, 0x3a05,
+	0xbae3, 0x347e, 0x33de, 0x3a08,
+	0xbae7, 0x3479, 0x33d4, 0x3a0a,
+	0xbaeb, 0x3474, 0x33ca, 0x3a0d,
+	0xbaef, 0x346f, 0x33c1, 0x3a0f,
+	0xbaf3, 0x346a, 0x33b7, 0x3a12,
+	0xbaf7, 0x3465, 0x33ad, 0x3a14,
+	0xbafb, 0x3460, 0x33a3, 0x3a17,
+	0xbafe, 0x345b, 0x3399, 0x3a19,
+	0xbb02, 0x3456, 0x3390, 0x3a1c,
+	0xbb06, 0x3451, 0x3386, 0x3a1e,
+	0xbb0a, 0x344d, 0x337c, 0x3a20,
+	0xbb0e, 0x3448, 0x3372, 0x3a23,
+	0xbb12, 0x3443, 0x3369, 0x3a25,
+	0xbb16, 0x343e, 0x335f, 0x3a28,
+	0xbb1a, 0x3439, 0x3355, 0x3a2a,
+	0xbb1e, 0x3434, 0x334c, 0x3a2c,
+	0xbb21, 0x342f, 0x3342, 0x3a2f,
+	0xbb25, 0x342a, 0x3339, 0x3a31,
+	0xbb29, 0x3426, 0x332f, 0x3a34,
+	0xbb2d, 0x3421, 0x3326, 0x3a36,
+	0xbb31, 0x341c, 0x331c, 0x3a38,
+	0xbb35, 0x3417, 0x3313, 0x3a3b,
+	0xbb39, 0x3412, 0x3309, 0x3a3d,
+	0xbb3d, 0x340e, 0x3300, 0x3a3f,
+	0xbb41, 0x3409, 0x32f7, 0x3a42,
+	0xbb45, 0x3404, 0x32ed, 0x3a44,
+	0xbb49, 0x33ff, 0x32e4, 0x3a46,
+	0xbb4d, 0x33f6, 0x32db, 0x3a49,
+	0xbb51, 0x33ed, 0x32d1, 0x3a4b,
+	0xbb54, 0x33e3, 0x32c8, 0x3a4d,
+	0xbb58, 0x33da, 0x32bf, 0x3a50,
+	0xbb5c, 0x33d0, 0x32b6, 0x3a52,
+	0xbb60, 0x33c7, 0x32ad, 0x3a54,
+	0xbb64, 0x33be, 0x32a3, 0x3a57,
+	0xbb68, 0x33b5, 0x329a, 0x3a59,
+	0xbb6c, 0x33ab, 0x3291, 0x3a5b,
+	0xbb70, 0x33a2, 0x3288, 0x3a5d,
+	0xbb74, 0x3399, 0x327f, 0x3a60,
+	0xbb78, 0x3390, 0x3276, 0x3a62,
+	0xbb7c, 0x3387, 0x326d, 0x3a64,
+	0xbb80, 0x337d, 0x3264, 0x3a66,
+	0xbb84, 0x3374, 0x325b, 0x3a69,
+	0xbb88, 0x336b, 0x3252, 0x3a6b,
+	0xbb8c, 0x3362, 0x3249, 0x3a6d,
+	0xbb90, 0x3359, 0x3241, 0x3a6f,
+	0xbb94, 0x3350, 0x3238, 0x3a71,
+	0xbb98, 0x3347, 0x322f, 0x3a74,
+	0xbb9c, 0x333e, 0x3226, 0x3a76,
+	0xbba0, 0x3335, 0x321e, 0x3a78,
+	0xbba4, 0x332c, 0x3215, 0x3a7a,
+	0xbba8, 0x3323, 0x320c, 0x3a7c,
+	0xbbac, 0x331a, 0x3204, 0x3a7e,
+	0xbbb0, 0x3312, 0x31fb, 0x3a81,
+	0xbbb4, 0x3309, 0x31f2, 0x3a83,
+	0xbbb8, 0x3300, 0x31ea, 0x3a85,
+	0xbbbc, 0x32f7, 0x31e1, 0x3a87,
+	0xbbc0, 0x32ee, 0x31d9, 0x3a89,
+	0xbbc4, 0x32e6, 0x31d0, 0x3a8b,
+	0xbbc8, 0x32dd, 0x31c8, 0x3a8d,
+	0xbbcc, 0x32d4, 0x31bf, 0x3a90,
+	0xbbd0, 0x32cc, 0x31b7, 0x3a92,
+	0xbbd4, 0x32c3, 0x31af, 0x3a94,
+	0xbbd8, 0x32ba, 0x31a6, 0x3a96,
+	0xbbdc, 0x32b2, 0x319e, 0x3a98,
+	0xbbe0, 0x32a9, 0x3196, 0x3a9a,
+	0xbbe4, 0x32a1, 0x318e, 0x3a9c,
+	0xbbe8, 0x3298, 0x3185, 0x3a9e,
+	0xbbec, 0x3290, 0x317d, 0x3aa0,
+	0xbbf0, 0x3287, 0x3175, 0x3aa2,
+	0xbbf4, 0x327f, 0x316d, 0x3aa4,
+	0xbbf8, 0x3277, 0x3165, 0x3aa6,
+	0xbbfc, 0x326e, 0x315d, 0x3aa8,
+	0 };
+
diff --git a/src/bicubic_table.py b/src/bicubic_table.py
new file mode 100755
index 0000000..232ccb7
--- /dev/null
+++ b/src/bicubic_table.py
@@ -0,0 +1,72 @@
+#!/usr/bin/python
+
+import struct
+
+def half(i):
+ fs, fe, fm = ((i >> 31) & 0x1, (i >> 23) & 0xff, i & 0x7fffff)
+ s, e, m = (fs, 0, 0)
+
+ if (fe == 0x0):
+  pass
+ if ((fe == 0xff) and (fm == 0x0)):
+  e = 31
+ elif (fe == 0xff):
+  m = 1
+  e = 31
+ else:
+  exp = fe - 127;
+  if (exp < -24):
+   pass
+  elif (exp < -14):
+   temp = 10 - (-14 - exp)
+   m = 2**temp + (m >> (23 - temp))
+  elif (exp > 15):
+   e = 31
+  else:
+   e = exp + 15
+   m = fm >> 13
+
+ return ((s << 15) | (e << 10) | m)
+
+def texgen(pix):
+
+ tex = []
+
+ for i in range(0,pix,4):
+
+  a = i / float(pix)
+  a2 = a ** 2
+  a3 = a ** 3
+
+  w0 = 1 / 6.0 * (-a3 + 3 * a2 + -3 * a + 1)
+  w1 = 1 / 6.0 * (3 * a3 + -6 * a2 + 4)
+  w2 = 1 / 6.0 * (-3 * a3 + 3 * a2 + 3 * a + 1)
+  w3 = 1 / 6.0 * a3
+
+  tex.append(-(1 - (w1 / (w0 + w1)) + a))
+  tex.append(1 + (w3 / (w2 + w3)) - a)
+  tex.append(w0 + w1)
+  tex.append(w2 + w3)
+
+ return tex
+
+def printrow(l, offset):
+
+ seq = [ struct.unpack('<I',struct.pack('f',i))[0] for i in l[offset:offset+4] ]
+ seq = [ hex(half(i)) for i in seq ]
+ return "\t" + ", ".join(seq) + ","
+
+def maketable(pix):
+
+ l = texgen(pix)
+
+ print "static const uint16_t bicubic_tex_" + str(pix) + "[] = {"
+
+ for i in range(0, pix, 4):
+
+  print printrow(l, i)
+
+ print "\t0 };\n"
+
+maketable(512)
+maketable(2048)
diff --git a/src/legacy_crtc.c b/src/legacy_crtc.c
index 3df61a7..c16d0a3 100644
--- a/src/legacy_crtc.c
+++ b/src/legacy_crtc.c
@@ -48,8 +48,7 @@
 
 #ifdef XF86DRI
 #define _XF86DRI_SERVER_
-#include "radeon_dri.h"
-#include "radeon_sarea.h"
+#include "radeon_drm.h"
 #include "sarea.h"
 #ifdef DRM_IOCTL_MODESET_CTL
 #include <sys/ioctl.h>
@@ -625,10 +624,13 @@ radeon_crtc_modeset_ioctl(xf86CrtcPtr crtc, Bool post)
     RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
     struct drm_modeset_ctl modeset;
 
+    if (!info->directRenderingEnabled)
+	return;
+
     modeset.crtc = radeon_crtc->crtc_id;
     modeset.cmd = post ? _DRM_POST_MODESET : _DRM_PRE_MODESET;
 
-    ioctl(info->drmFD, DRM_IOCTL_MODESET_CTL, &modeset);
+    ioctl(info->dri->drmFD, DRM_IOCTL_MODESET_CTL, &modeset);
 #endif
 }
 
@@ -752,13 +754,13 @@ RADEONInitCrtcBase(xf86CrtcPtr crtc, RADEONSavePtr save,
     RADEONInfoPtr  info       = RADEONPTR(pScrn);
     int    Base;
 #ifdef XF86DRI
-    RADEONSAREAPrivPtr pSAREAPriv;
+    drm_radeon_sarea_t *pSAREAPriv;
     XF86DRISAREAPtr pSAREA;
 #endif
 
     save->crtc_offset      = pScrn->fbOffset;
 #ifdef XF86DRI
-    if (info->allowPageFlip)
+    if (info->dri && info->dri->allowPageFlip)
 	save->crtc_offset_cntl = RADEON_CRTC_OFFSET_FLIP_CNTL;
     else
 #endif
@@ -851,7 +853,7 @@ RADEONInitCrtcBase(xf86CrtcPtr crtc, RADEONSavePtr save,
 	pSAREA->frame.height = pScrn->frameY1 - y + 1;
 
 	if (pSAREAPriv->pfCurrentPage == 1) {
-	    Base += info->backOffset - info->frontOffset;
+	    Base += info->dri->backOffset - info->dri->frontOffset;
 	}
     }
 #endif
@@ -970,7 +972,7 @@ RADEONInitCrtc2Base(xf86CrtcPtr crtc, RADEONSavePtr save,
     RADEONInfoPtr  info       = RADEONPTR(pScrn);
     int    Base;
 #ifdef XF86DRI
-    RADEONSAREAPrivPtr pSAREAPriv;
+    drm_radeon_sarea_t *pSAREAPriv;
     XF86DRISAREAPtr pSAREA;
 #endif
 
@@ -978,7 +980,7 @@ RADEONInitCrtc2Base(xf86CrtcPtr crtc, RADEONSavePtr save,
      */
     save->crtc2_offset      = pScrn->fbOffset;
 #ifdef XF86DRI
-    if (info->allowPageFlip)
+    if (info->dri && info->dri->allowPageFlip)
 	save->crtc2_offset_cntl = RADEON_CRTC_OFFSET_FLIP_CNTL;
     else
 #endif
@@ -1065,7 +1067,7 @@ RADEONInitCrtc2Base(xf86CrtcPtr crtc, RADEONSavePtr save,
 	pSAREAPriv->crtc2_base = Base;
 
 	if (pSAREAPriv->pfCurrentPage == 1) {
-	    Base += info->backOffset - info->frontOffset;
+	    Base += info->dri->backOffset - info->dri->frontOffset;
 	}
     }
 #endif
@@ -1327,9 +1329,12 @@ radeon_update_tv_routing(ScrnInfoPtr pScrn, RADEONSavePtr restore)
 }
 
 /* Calculate display buffer watermark to prevent buffer underflow */
-static void
-RADEONInitDispBandwidth2(ScrnInfoPtr pScrn, RADEONInfoPtr info, int pixel_bytes2, DisplayModePtr mode1, DisplayModePtr mode2)
+void
+RADEONInitDispBandwidthLegacy(ScrnInfoPtr pScrn,
+			      DisplayModePtr mode1, int pixel_bytes1,
+			      DisplayModePtr mode2, int pixel_bytes2)
 {
+    RADEONInfoPtr info = RADEONPTR(pScrn);
     RADEONEntPtr pRADEONEnt   = RADEONEntPriv(pScrn);
     unsigned char *RADEONMMIO = info->MMIO;
 
@@ -1352,10 +1357,10 @@ RADEONInitDispBandwidth2(ScrnInfoPtr pScrn, RADEONInfoPtr info, int pixel_bytes2
     float min_mem_eff = 0.8;
     float sclk_eff, sclk_delay;
     float mc_latency_mclk, mc_latency_sclk, cur_latency_mclk, cur_latency_sclk;
-    float disp_latency, disp_latency_overhead, disp_drain_rate, disp_drain_rate2;
+    float disp_latency, disp_latency_overhead, disp_drain_rate = 0, disp_drain_rate2;
     float pix_clk, pix_clk2; /* in MHz */
     int cur_size = 16;       /* in octawords */
-    int critical_point, critical_point2;
+    int critical_point = 0, critical_point2;
     int stop_req, max_stop_req;
     float read_return_rate, time_disp1_drop_priority;
 
@@ -1366,15 +1371,15 @@ RADEONInitDispBandwidth2(ScrnInfoPtr pScrn, RADEONInfoPtr info, int pixel_bytes2
      */
     if ((info->DispPriority == 2) && IS_R300_VARIANT) {
 	uint32_t mc_init_misc_lat_timer = INREG(R300_MC_INIT_MISC_LAT_TIMER);
-	if (pRADEONEnt->pCrtc[1]->enabled) {
-	    mc_init_misc_lat_timer |= 0x1100; /* display 0 and 1 */
-	} else {
-	    mc_init_misc_lat_timer |= 0x0100; /* display 0 only */
-	}
+	mc_init_misc_lat_timer &= ~(R300_MC_DISP1R_INIT_LAT_MASK << R300_MC_DISP1R_INIT_LAT_SHIFT);
+	mc_init_misc_lat_timer &= ~(R300_MC_DISP0R_INIT_LAT_MASK << R300_MC_DISP0R_INIT_LAT_SHIFT);
+	if (pRADEONEnt->pCrtc[1]->enabled)
+	    mc_init_misc_lat_timer |= (1 << R300_MC_DISP1R_INIT_LAT_SHIFT); /* display 1 */
+	if (pRADEONEnt->pCrtc[0]->enabled)
+	    mc_init_misc_lat_timer |= (1 << R300_MC_DISP0R_INIT_LAT_SHIFT); /* display 0 */
 	OUTREG(R300_MC_INIT_MISC_LAT_TIMER, mc_init_misc_lat_timer);
     }
 
-
     /* R420 and RV410 family not supported yet */
     if (info->ChipFamily == CHIP_FAMILY_R420 || info->ChipFamily == CHIP_FAMILY_RV410) return; 
 
@@ -1383,15 +1388,17 @@ RADEONInitDispBandwidth2(ScrnInfoPtr pScrn, RADEONInfoPtr info, int pixel_bytes2
      */
     mem_bw = info->mclk * (info->RamWidth / 8) * (info->IsDDR ? 2 : 1);
 
-    pix_clk = mode1->Clock/1000.0;
-    if (mode2)
+    pix_clk = 0;
+    pix_clk2 = 0;
+    peak_disp_bw = 0;
+    if (mode1) {
+	pix_clk = mode1->Clock/1000.0;
+	peak_disp_bw += (pix_clk * pixel_bytes1);
+    }
+    if (mode2) {
 	pix_clk2 = mode2->Clock/1000.0;
-    else
-	pix_clk2 = 0;
-
-    peak_disp_bw = (pix_clk * info->CurrentLayout.pixel_bytes);
-    if (pixel_bytes2)
-      peak_disp_bw += (pix_clk2 * pixel_bytes2);
+	peak_disp_bw += (pix_clk2 * pixel_bytes2);
+    }
 
     if (peak_disp_bw >= mem_bw * min_mem_eff) {
 	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
@@ -1399,20 +1406,6 @@ RADEONInitDispBandwidth2(ScrnInfoPtr pScrn, RADEONInfoPtr info, int pixel_bytes2
 		   "If you have flickering problem, try to lower resolution, refresh rate, or color depth\n");
     }
 
-    /*  CRTC1
-        Set GRPH_BUFFER_CNTL register using h/w defined optimal values.
-	GRPH_STOP_REQ <= MIN[ 0x7C, (CRTC_H_DISP + 1) * (bit depth) / 0x10 ]
-    */
-    stop_req = mode1->HDisplay * info->CurrentLayout.pixel_bytes / 16;
-
-    /* setup Max GRPH_STOP_REQ default value */
-    if (IS_RV100_VARIANT)
-	max_stop_req = 0x5c;
-    else
-	max_stop_req  = 0x7c;
-    if (stop_req > max_stop_req)
-	stop_req = max_stop_req;
-
     /*  Get values from the EXT_MEM_CNTL register...converting its contents. */
     temp = INREG(RADEON_MEM_TIMING_CNTL);
     if ((info->ChipFamily == CHIP_FAMILY_RV100) || info->IsIGP) { /* RV100, M6, IGPs */
@@ -1435,9 +1428,8 @@ RADEONInitDispBandwidth2(ScrnInfoPtr pScrn, RADEONInfoPtr info, int pixel_bytes2
     }
 
     if (IS_R300_VARIANT) {
-
 	/* on the R300, Tcas is included in Trbs.
-	*/
+	 */
 	temp = INREG(RADEON_MEM_CNTL);
 	data = (R300_MEM_NUM_CHANNELS_MASK & temp);
 	if (data == 1) {
@@ -1467,13 +1459,14 @@ RADEONInitDispBandwidth2(ScrnInfoPtr pScrn, RADEONInfoPtr info, int pixel_bytes2
     } else {
 #ifdef XF86DRI
 	if (info->directRenderingEnabled)
-	    sclk_eff = info->sclk - (info->agpMode * 50.0 / 3.0);
+	    sclk_eff = info->sclk - (info->dri->agpMode * 50.0 / 3.0);
 	else
 #endif
 	    sclk_eff = info->sclk;
     }
 
-    /* Find the memory controller latency for the display client.
+    /*
+      Find the memory controller latency for the display client.
     */
     if (IS_R300_VARIANT) {
 	/*not enough for R350 ???*/
@@ -1527,89 +1520,107 @@ RADEONInitDispBandwidth2(ScrnInfoPtr pScrn, RADEONInfoPtr info, int pixel_bytes2
     mc_latency_sclk = mc_latency_sclk + disp_latency_overhead + cur_latency_sclk;
     disp_latency = MAX(mc_latency_mclk, mc_latency_sclk);
 
-    /*
-      Find the drain rate of the display buffer.
-    */
-    disp_drain_rate = pix_clk / (16.0/info->CurrentLayout.pixel_bytes);
-    if (pixel_bytes2)
-	disp_drain_rate2 = pix_clk2 / (16.0/pixel_bytes2);
+    /* setup Max GRPH_STOP_REQ default value */
+    if (IS_RV100_VARIANT)
+	max_stop_req = 0x5c;
     else
-	disp_drain_rate2 = 0;
+	max_stop_req  = 0x7c;
 
-    /*
-      Find the critical point of the display buffer.
-    */
-    critical_point= (uint32_t)(disp_drain_rate * disp_latency + 0.5);
+    if (mode1) {
+	/*  CRTC1
+	    Set GRPH_BUFFER_CNTL register using h/w defined optimal values.
+	    GRPH_STOP_REQ <= MIN[ 0x7C, (CRTC_H_DISP + 1) * (bit depth) / 0x10 ]
+	*/
+	stop_req = mode1->HDisplay * pixel_bytes1 / 16;
 
-    /* ???? */
-    /*
-    temp = (info->SavedReg.grph_buffer_cntl & RADEON_GRPH_CRITICAL_POINT_MASK) >> RADEON_GRPH_CRITICAL_POINT_SHIFT;
-    if (critical_point < temp) critical_point = temp;
-    */
-    if (info->DispPriority == 2) {
-	critical_point = 0;
-    }
+	if (stop_req > max_stop_req)
+	    stop_req = max_stop_req;
 
-    /*
-      The critical point should never be above max_stop_req-4.  Setting
-      GRPH_CRITICAL_CNTL = 0 will thus force high priority all the time.
-    */
-    if (max_stop_req - critical_point < 4) critical_point = 0;
+	/*
+	  Find the drain rate of the display buffer.
+	*/
+	disp_drain_rate = pix_clk / (16.0/pixel_bytes1);
 
-    if (critical_point == 0 && mode2 && info->ChipFamily == CHIP_FAMILY_R300) {
-	/* some R300 cards have problem with this set to 0, when CRTC2 is enabled.*/
-	critical_point = 0x10;
-    }
+	/*
+	  Find the critical point of the display buffer.
+	*/
+	critical_point= (uint32_t)(disp_drain_rate * disp_latency + 0.5);
 
-    temp = info->SavedReg->grph_buffer_cntl;
-    temp &= ~(RADEON_GRPH_STOP_REQ_MASK);
-    temp |= (stop_req << RADEON_GRPH_STOP_REQ_SHIFT);
-    temp &= ~(RADEON_GRPH_START_REQ_MASK);
-    if ((info->ChipFamily == CHIP_FAMILY_R350) &&
-	(stop_req > 0x15)) {
-	stop_req -= 0x10;
-    }
-    temp |= (stop_req << RADEON_GRPH_START_REQ_SHIFT);
+	/* ???? */
+	/*
+	  temp = (info->SavedReg.grph_buffer_cntl & RADEON_GRPH_CRITICAL_POINT_MASK) >> RADEON_GRPH_CRITICAL_POINT_SHIFT;
+	  if (critical_point < temp) critical_point = temp;
+	*/
+	if (info->DispPriority == 2) {
+	    critical_point = 0;
+	}
 
-    temp |= RADEON_GRPH_BUFFER_SIZE;
-    temp &= ~(RADEON_GRPH_CRITICAL_CNTL   |
-	      RADEON_GRPH_CRITICAL_AT_SOF |
-	      RADEON_GRPH_STOP_CNTL);
-    /*
-      Write the result into the register.
-    */
-    OUTREG(RADEON_GRPH_BUFFER_CNTL, ((temp & ~RADEON_GRPH_CRITICAL_POINT_MASK) |
-				     (critical_point << RADEON_GRPH_CRITICAL_POINT_SHIFT)));
+	/*
+	  The critical point should never be above max_stop_req-4.  Setting
+	  GRPH_CRITICAL_CNTL = 0 will thus force high priority all the time.
+	*/
+	if (max_stop_req - critical_point < 4) critical_point = 0;
+
+	if (critical_point == 0 && mode2 && info->ChipFamily == CHIP_FAMILY_R300) {
+	    /* some R300 cards have problem with this set to 0, when CRTC2 is enabled.*/
+	    critical_point = 0x10;
+	}
+
+	temp = info->SavedReg->grph_buffer_cntl;
+	temp &= ~(RADEON_GRPH_STOP_REQ_MASK);
+	temp |= (stop_req << RADEON_GRPH_STOP_REQ_SHIFT);
+	temp &= ~(RADEON_GRPH_START_REQ_MASK);
+	if ((info->ChipFamily == CHIP_FAMILY_R350) &&
+	    (stop_req > 0x15)) {
+	    stop_req -= 0x10;
+	}
+	temp |= (stop_req << RADEON_GRPH_START_REQ_SHIFT);
+
+	temp |= RADEON_GRPH_BUFFER_SIZE;
+	temp &= ~(RADEON_GRPH_CRITICAL_CNTL   |
+		  RADEON_GRPH_CRITICAL_AT_SOF |
+		  RADEON_GRPH_STOP_CNTL);
+	/*
+	  Write the result into the register.
+	*/
+	OUTREG(RADEON_GRPH_BUFFER_CNTL, ((temp & ~RADEON_GRPH_CRITICAL_POINT_MASK) |
+					 (critical_point << RADEON_GRPH_CRITICAL_POINT_SHIFT)));
 
 #if 0
-    if ((info->ChipFamily == CHIP_FAMILY_RS400) ||
-	(info->ChipFamily == CHIP_FAMILY_RS480)) {
-	/* attempt to program RS400 disp regs correctly ??? */
-	temp = info->SavedReg->disp1_req_cntl1;
-	temp &= ~(RS400_DISP1_START_REQ_LEVEL_MASK |
-		  RS400_DISP1_STOP_REQ_LEVEL_MASK);
-	OUTREG(RS400_DISP1_REQ_CNTL1, (temp |
-				       (critical_point << RS400_DISP1_START_REQ_LEVEL_SHIFT) |
-				       (critical_point << RS400_DISP1_STOP_REQ_LEVEL_SHIFT)));
-	temp = info->SavedReg->dmif_mem_cntl1;
-	temp &= ~(RS400_DISP1_CRITICAL_POINT_START_MASK |
-		  RS400_DISP1_CRITICAL_POINT_STOP_MASK);
-	OUTREG(RS400_DMIF_MEM_CNTL1, (temp |
-				      (critical_point << RS400_DISP1_CRITICAL_POINT_START_SHIFT) |
-				      (critical_point << RS400_DISP1_CRITICAL_POINT_STOP_SHIFT)));
-    }
+	if ((info->ChipFamily == CHIP_FAMILY_RS400) ||
+	    (info->ChipFamily == CHIP_FAMILY_RS480)) {
+	    /* attempt to program RS400 disp regs correctly ??? */
+	    temp = info->SavedReg->disp1_req_cntl1;
+	    temp &= ~(RS400_DISP1_START_REQ_LEVEL_MASK |
+		      RS400_DISP1_STOP_REQ_LEVEL_MASK);
+	    OUTREG(RS400_DISP1_REQ_CNTL1, (temp |
+					   (critical_point << RS400_DISP1_START_REQ_LEVEL_SHIFT) |
+					   (critical_point << RS400_DISP1_STOP_REQ_LEVEL_SHIFT)));
+	    temp = info->SavedReg->dmif_mem_cntl1;
+	    temp &= ~(RS400_DISP1_CRITICAL_POINT_START_MASK |
+		      RS400_DISP1_CRITICAL_POINT_STOP_MASK);
+	    OUTREG(RS400_DMIF_MEM_CNTL1, (temp |
+					  (critical_point << RS400_DISP1_CRITICAL_POINT_START_SHIFT) |
+					  (critical_point << RS400_DISP1_CRITICAL_POINT_STOP_SHIFT)));
+	}
 #endif
 
-    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
-		   "GRPH_BUFFER_CNTL from %x to %x\n",
-		   (unsigned int)info->SavedReg->grph_buffer_cntl,
-		   (unsigned int)INREG(RADEON_GRPH_BUFFER_CNTL));
+	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
+		       "GRPH_BUFFER_CNTL from %x to %x\n",
+		       (unsigned int)info->SavedReg->grph_buffer_cntl,
+		       (unsigned int)INREG(RADEON_GRPH_BUFFER_CNTL));
+    }
 
     if (mode2) {
 	stop_req = mode2->HDisplay * pixel_bytes2 / 16;
 
 	if (stop_req > max_stop_req) stop_req = max_stop_req;
 
+	/*
+	  Find the drain rate of the display buffer.
+	*/
+	disp_drain_rate2 = pix_clk2 / (16.0/pixel_bytes2);
+
 	temp = info->SavedReg->grph2_buffer_cntl;
 	temp &= ~(RADEON_GRPH_STOP_REQ_MASK);
 	temp |= (stop_req << RADEON_GRPH_STOP_REQ_SHIFT);
@@ -1629,7 +1640,10 @@ RADEONInitDispBandwidth2(ScrnInfoPtr pScrn, RADEONInfoPtr info, int pixel_bytes2
 	    critical_point2 = 0;
 	else {
 	    read_return_rate = MIN(info->sclk, info->mclk*(info->RamWidth*(info->IsDDR+1)/128));
-	    time_disp1_drop_priority = critical_point / (read_return_rate - disp_drain_rate);
+	    if (mode1)
+		time_disp1_drop_priority = critical_point / (read_return_rate - disp_drain_rate);
+	    else
+		time_disp1_drop_priority = 0;
 
 	    critical_point2 = (uint32_t)((disp_latency + time_disp1_drop_priority + 
 					disp_latency) * disp_drain_rate2 + 0.5);
@@ -1681,45 +1695,6 @@ RADEONInitDispBandwidth2(ScrnInfoPtr pScrn, RADEONInfoPtr info, int pixel_bytes2
 }
 
 void
-RADEONInitDispBandwidth(ScrnInfoPtr pScrn)
-{
-    RADEONInfoPtr info = RADEONPTR(pScrn);
-    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
-    DisplayModePtr mode1, mode2;
-    int pixel_bytes2 = 0;
-
-    if (info->IsPrimary || info->IsSecondary)
-	mode1 = &xf86_config->crtc[0]->mode;
-    else
-	mode1 = info->CurrentLayout.mode;
-    mode2 = NULL;
-    pixel_bytes2 = info->CurrentLayout.pixel_bytes;
-
-    if (xf86_config->num_crtc == 2) {
-      pixel_bytes2 = 0;
-      mode2 = NULL;
-
-      if (xf86_config->crtc[1]->enabled && xf86_config->crtc[0]->enabled) {
-	pixel_bytes2 = info->CurrentLayout.pixel_bytes;
-	mode1 = &xf86_config->crtc[0]->mode;
-	mode2 = &xf86_config->crtc[1]->mode;
-      } else if (xf86_config->crtc[0]->enabled) {
-	mode1 = &xf86_config->crtc[0]->mode;
-      } else if (xf86_config->crtc[1]->enabled) {
-	mode1 = &xf86_config->crtc[1]->mode;
-      } else
-	return;
-    } else {
-	if (xf86_config->crtc[0]->enabled)
-	    mode1 = &xf86_config->crtc[0]->mode;
-	else
-	    return;
-    }
-
-    RADEONInitDispBandwidth2(pScrn, info, pixel_bytes2, mode1, mode2);
-}
-
-void
 legacy_crtc_mode_set(xf86CrtcPtr crtc, DisplayModePtr mode,
 		     DisplayModePtr adjusted_mode, int x, int y)
 {
@@ -1729,10 +1704,15 @@ legacy_crtc_mode_set(xf86CrtcPtr crtc, DisplayModePtr mode,
     RADEONInfoPtr info = RADEONPTR(pScrn);
     int i = 0;
     double dot_clock = 0;
-    int pll_flags = RADEON_PLL_LEGACY | RADEON_PLL_PREFER_LOW_REF_DIV;
+    int pll_flags = RADEON_PLL_LEGACY;
     Bool update_tv_routing = FALSE;
     Bool tilingChanged = FALSE;
 
+    if (adjusted_mode->Clock > 120000) /* range limits??? */
+	pll_flags |= RADEON_PLL_PREFER_HIGH_FB_DIV;
+    else
+	pll_flags |= RADEON_PLL_PREFER_LOW_REF_DIV;
+
     if (info->allowColorTiling) {
 	radeon_crtc->can_tile = (adjusted_mode->Flags & (V_DBLSCAN | V_INTERLACE)) ? FALSE : TRUE;
 	tilingChanged = RADEONSetTiling(pScrn);
diff --git a/src/legacy_output.c b/src/legacy_output.c
index 9c9ebb9..e5ddf1f 100644
--- a/src/legacy_output.c
+++ b/src/legacy_output.c
@@ -48,6 +48,8 @@
 #include "radeon_tv.h"
 #include "radeon_atombios.h"
 
+#include "ati_pciids_gen.h"
+
 static RADEONMonitorType radeon_detect_tv(ScrnInfoPtr pScrn);
 static RADEONMonitorType radeon_detect_primary_dac(ScrnInfoPtr pScrn, Bool color);
 static RADEONMonitorType radeon_detect_tv_dac(ScrnInfoPtr pScrn, Bool color);
@@ -277,16 +279,12 @@ static void
 RADEONRestoreDVOChip(ScrnInfoPtr pScrn, xf86OutputPtr output)
 {
     RADEONInfoPtr info = RADEONPTR(pScrn);
-    unsigned char *RADEONMMIO = info->MMIO;
     RADEONOutputPrivatePtr radeon_output = output->driver_private;
 
     if (!radeon_output->DVOChip)
 	return;
 
-    OUTREG(radeon_output->dvo_i2c.mask_clk_reg,
-	   INREG(radeon_output->dvo_i2c.mask_clk_reg) &
-	   (uint32_t)~(RADEON_GPIO_A_0 | RADEON_GPIO_A_1));
-
+    RADEONI2CDoLock(output, TRUE);
     if (!RADEONInitExtTMDSInfoFromBIOS(output)) {
 	if (radeon_output->DVOChip) {
 	    switch(info->ext_tmds_chip) {
@@ -316,6 +314,7 @@ RADEONRestoreDVOChip(ScrnInfoPtr pScrn, xf86OutputPtr output)
 	    }
 	}
     }
+    RADEONI2CDoLock(output, FALSE);
 }
 
 #if 0
@@ -727,14 +726,6 @@ RADEONEnableDisplay(xf86OutputPtr output, BOOL bEnable)
 		    save->crtc2_gen_cntl |= RADEON_CRTC2_CRT2_ON;
 		}
 		tv_dac_change = 1;
-		/* IGP chips seem to use a mix of Primary and TVDAC controls */
-		if (info->IsIGP) {
-		    tmp = INREG(RADEON_CRTC_EXT_CNTL);
-		    tmp |= RADEON_CRTC_CRT_ON;
-		    OUTREG(RADEON_CRTC_EXT_CNTL, tmp);
-		    save->crtc_ext_cntl |= RADEON_CRTC_CRT_ON;
-		    RADEONDacPowerSet(pScrn, bEnable, TRUE);
-		}
 	    }
 	} else if (radeon_output->MonType == MT_DFP) {
 	    if (radeon_output->TMDSType == TMDS_INT) {
@@ -815,14 +806,6 @@ RADEONEnableDisplay(xf86OutputPtr output, BOOL bEnable)
 			save->crtc2_gen_cntl &= ~RADEON_CRTC2_CRT2_ON;
 		    }
 		}
-		/* IGP chips seem to use a mix of Primary and TVDAC controls */
-		if (info->IsIGP) {
-		    tmp = INREG(RADEON_CRTC_EXT_CNTL);
-		    tmp &= ~RADEON_CRTC_CRT_ON;
-		    OUTREG(RADEON_CRTC_EXT_CNTL, tmp);
-		    save->crtc_ext_cntl &= ~RADEON_CRTC_CRT_ON;
-		    RADEONDacPowerSet(pScrn, bEnable, TRUE);
-		}
 	    }
 	} else if (radeon_output->MonType == MT_DFP) {
 	    if (radeon_output->TMDSType == TMDS_INT) {
@@ -1033,9 +1016,14 @@ RADEONInitFP2Registers(xf86OutputPtr output, RADEONSavePtr save,
 			    RADEON_FP2_DVO_RATE_SEL_SDR);
 
 
-    /* XXX: these may be oem specific */
+    /* XXX: these are oem specific */
     if (IS_R300_VARIANT) {
-	save->fp2_gen_cntl |= RADEON_FP2_PAD_FLOP_EN | R300_FP2_DVO_CLOCK_MODE_SINGLE;
+	if ((info->Chipset == PCI_CHIP_RV350_NP) &&
+	    (PCI_SUB_VENDOR_ID(info->PciInfo) == 0x1028) &&
+	    (PCI_SUB_DEVICE_ID(info->PciInfo) == 0x2001))
+	    save->fp2_gen_cntl |= R300_FP2_DVO_CLOCK_MODE_SINGLE; /* Dell Inspiron 8600 */
+	else
+	    save->fp2_gen_cntl |= RADEON_FP2_PAD_FLOP_EN | R300_FP2_DVO_CLOCK_MODE_SINGLE;
 #if 0
 	if (mode->Clock > 165000)
 	    save->fp2_gen_cntl |= R300_FP2_DVO_DUAL_CHANNEL_EN;
@@ -1383,7 +1371,6 @@ RADEONInitOutputRegisters(ScrnInfoPtr pScrn, RADEONSavePtr save,
 {
     Bool IsPrimary = crtc_num == 0 ? TRUE : FALSE;
     RADEONOutputPrivatePtr radeon_output = output->driver_private;
-    RADEONInfoPtr info = RADEONPTR(pScrn);
 
     if (crtc_num == 0)
 	RADEONInitRMXRegisters(output, save, mode);
@@ -1393,9 +1380,6 @@ RADEONInitOutputRegisters(ScrnInfoPtr pScrn, RADEONSavePtr save,
 	    RADEONInitDACRegisters(output, save, mode, IsPrimary);
 	} else {
 	    RADEONInitDAC2Registers(output, save, mode, IsPrimary);
-	    /* IGP chips seem to use a mix of primary and TVDAC controls */
-	    if (info->IsIGP)
-		RADEONInitDACRegisters(output, save, mode, IsPrimary);
 	}
     } else if (radeon_output->MonType == MT_LCD) {
 	RADEONInitLVDSRegisters(output, save, mode, IsPrimary);
@@ -1456,8 +1440,8 @@ legacy_output_mode_set(xf86OutputPtr output, DisplayModePtr mode,
 		}
 		OUTREG(RADEON_FP2_GEN_CNTL, fp2_gen_cntl);
 	    } else {
-		RADEONRestoreDVOChip(pScrn, output);
 		RADEONRestoreFP2Registers(pScrn, info->ModeReg);
+		RADEONRestoreDVOChip(pScrn, output);
 	    }
 	}
 	break;
diff --git a/src/pcidb/ati_pciids.csv b/src/pcidb/ati_pciids.csv
index 1f6fa82..07e71a3 100644
--- a/src/pcidb/ati_pciids.csv
+++ b/src/pcidb/ati_pciids.csv
@@ -1,5 +1,6 @@
 "#pciid","define","family","mobility","igp","nocrtc2","Nointtvout","singledac","name"
 "0x3150","RV380_3150","RV380",1,,,,,"ATI Radeon Mobility X600 (M24) 3150 (PCIE)"
+"0x3151","RV380_3151","RV380",,,,,,"ATI FireMV 2400 (PCI)"
 "0x3152","RV380_3152","RV380",1,,,,,"ATI Radeon Mobility X300 (M24) 3152 (PCIE)"
 "0x3154","RV380_3154","RV380",1,,,,,"ATI FireGL M24 GL 3154 (PCIE)"
 "0x3E50","RV380_3E50","RV380",,,,,,"ATI Radeon X600 (RV380) 3E50 (PCIE)"
@@ -331,6 +332,9 @@
 "0x940A","R600_940A","R600",,,,,,"ATI FireGL V8650"
 "0x940B","R600_940B","R600",,,,,,"ATI FireGL V8600"
 "0x940F","R600_940F","R600",,,,,,"ATI FireGL V7600"
+"0x9440","RV770_9440","RV770",,,,,,"ATI Radeon 4800 Series"
+"0x9441","RV770_9441","RV770",,,,,,"ATI Radeon HD 4870 x2"
+"0x9442","RV770_9442","RV770",,,,,,"ATI Radeon 4800 Series"
 "0x94C0","RV610_94C0","RV610",,,,,,"ATI RV610"
 "0x94C1","RV610_94C1","RV610",,,,,,"ATI Radeon HD 2400 XT"
 "0x94C3","RV610_94C3","RV610",,,,,,"ATI Radeon HD 2400 Pro"
@@ -348,6 +352,7 @@
 "0x9507","RV670_9507","RV670",,,,,,"ATI RV670"
 "0x950F","RV670_950F","RV670",,,,,,"ATI Radeon HD3870 X2"
 "0x9511","RV670_9511","RV670",,,,,,"ATI FireGL V7700"
+"0x9515","RV670_9515","RV670",,,,,,"ATI Radeon HD3850"
 "0x9580","RV630_9580","RV630",,,,,,"ATI RV630"
 "0x9581","RV630_9581","RV630",1,,,,,"ATI Mobility Radeon HD 2600"
 "0x9583","RV630_9583","RV630",1,,,,,"ATI Mobility Radeon HD 2600 XT"
diff --git a/src/radeon.h b/src/radeon.h
index 4f77c3b..6cce736 100644
--- a/src/radeon.h
+++ b/src/radeon.h
@@ -72,9 +72,10 @@
 				/* DRI support */
 #ifdef XF86DRI
 #define _XF86DRI_SERVER_
-#include "radeon_dripriv.h"
 #include "dri.h"
 #include "GL/glxint.h"
+#include "xf86drm.h"
+
 #ifdef DAMAGE
 #include "damage.h"
 #include "globals.h"
@@ -98,6 +99,36 @@
 #define MIN(a,b) ((a)>(b)?(b):(a))
 #endif
 
+#if HAVE_BYTESWAP_H
+#include <byteswap.h>
+#elif defined(USE_SYS_ENDIAN_H)
+#include <sys/endian.h>
+#else
+#define bswap_16(value)  \
+        ((((value) & 0xff) << 8) | ((value) >> 8))
+
+#define bswap_32(value) \
+        (((uint32_t)bswap_16((uint16_t)((value) & 0xffff)) << 16) | \
+        (uint32_t)bswap_16((uint16_t)((value) >> 16)))
+ 
+#define bswap_64(value) \
+        (((uint64_t)bswap_32((uint32_t)((value) & 0xffffffff)) \
+            << 32) | \
+        (uint64_t)bswap_32((uint32_t)((value) >> 32)))
+#endif
+
+#if X_BYTE_ORDER == X_BIG_ENDIAN
+#define le32_to_cpu(x) bswap_32(x)
+#define le16_to_cpu(x) bswap_16(x)
+#define cpu_to_le32(x) bswap_32(x)
+#define cpu_to_le16(x) bswap_16(x)
+#else
+#define le32_to_cpu(x) (x)
+#define le16_to_cpu(x) (x)
+#define cpu_to_le32(x) (x)
+#define cpu_to_le16(x) (x)
+#endif
+
 /* Provide substitutes for gcc's __FUNCTION__ on other compilers */
 #if !defined(__GNUC__) && !defined(__FUNCTION__)
 # define __FUNCTION__ __func__		/* C99 */
@@ -220,7 +251,12 @@ typedef struct {
 #define RADEON_PLL_NO_ODD_POST_DIV (1 << 1)
 #define RADEON_PLL_USE_REF_DIV     (1 << 2)
 #define RADEON_PLL_LEGACY          (1 << 3)
-#define RADEON_PLL_PREFER_LOW_REF_DIV (1 << 4)
+#define RADEON_PLL_PREFER_LOW_REF_DIV   (1 << 4)
+#define RADEON_PLL_PREFER_HIGH_REF_DIV  (1 << 5)
+#define RADEON_PLL_PREFER_LOW_FB_DIV    (1 << 6)
+#define RADEON_PLL_PREFER_HIGH_FB_DIV   (1 << 7)
+#define RADEON_PLL_PREFER_LOW_POST_DIV  (1 << 8)
+#define RADEON_PLL_PREFER_HIGH_POST_DIV (1 << 9)
 
 typedef struct {
     uint16_t          reference_freq;
@@ -287,6 +323,7 @@ typedef enum {
     CHIP_FAMILY_RV620,
     CHIP_FAMILY_RV635,
     CHIP_FAMILY_RS780,
+    CHIP_FAMILY_RV770,
     CHIP_FAMILY_LAST
 } RADEONChipFamily;
 
@@ -377,156 +414,45 @@ typedef struct {
     int singledac;
 } RADEONCardInfo;
 
-typedef struct {
-    EntityInfoPtr     pEnt;
-    pciVideoPtr       PciInfo;
-    PCITAG            PciTag;
-    int               Chipset;
-    RADEONChipFamily  ChipFamily;
-    RADEONErrata      ChipErrata;
-
-    unsigned long     LinearAddr;       /* Frame buffer physical address     */
-    unsigned long     MMIOAddr;         /* MMIO region physical address      */
-    unsigned long     BIOSAddr;         /* BIOS physical address             */
-    uint32_t          fbLocation;
-    uint32_t          gartLocation;
-    uint32_t          mc_fb_location;
-    uint32_t          mc_agp_location;
-    uint32_t          mc_agp_location_hi;
-
-    void              *MMIO;            /* Map of MMIO region                */
-    void              *FB;              /* Map of frame buffer               */
-    uint8_t           *VBIOS;           /* Video BIOS pointer                */
-
-    Bool              IsAtomBios;       /* New BIOS used in R420 etc.        */
-    int               ROMHeaderStart;   /* Start of the ROM Info Table       */
-    int               MasterDataStart;  /* Offset for Master Data Table for ATOM BIOS */
-
-    uint32_t          MemCntl;
-    uint32_t          BusCntl;
-    unsigned long     MMIOSize;         /* MMIO region physical address      */
-    unsigned long     FbMapSize;        /* Size of frame buffer, in bytes    */
-    unsigned long     FbSecureSize;     /* Size of secured fb area at end of
-                                           framebuffer */
-
-    Bool              IsMobility;       /* Mobile chips for laptops */
-    Bool              IsIGP;            /* IGP chips */
-    Bool              HasSingleDAC;     /* only TVDAC on chip */
-    Bool              ddc_mode;         /* Validate mode by matching exactly
-					 * the modes supported in DDC data
-					 */
-    Bool              R300CGWorkaround;
-
-				/* EDID or BIOS values for FPs */
-    int               RefDivider;
-    int               FeedbackDivider;
-    int               PostDivider;
-    Bool              UseBiosDividers;
-				/* EDID data using DDC interface */
-    Bool              ddc_bios;
-    Bool              ddc1;
-    Bool              ddc2;
-
-    RADEONPLLRec      pll;
-
-    int               RamWidth;
-    float	      sclk;		/* in MHz */
-    float	      mclk;		/* in MHz */
-    Bool	      IsDDR;
-    int               DispPriority;
-
-    RADEONSavePtr     SavedReg;         /* Original (text) mode              */
-    RADEONSavePtr     ModeReg;          /* Current mode                      */
-    Bool              (*CloseScreen)(int, ScreenPtr);
-
-    void              (*BlockHandler)(int, pointer, pointer, pointer);
-
-    Bool              PaletteSavedOnVT; /* Palette saved on last VT switch   */
-
-#ifdef USE_EXA
-    ExaDriverPtr      exa;
-    int               exaSyncMarker;
-    int               exaMarkerSynced;
-    int               engineMode;
-#define EXA_ENGINEMODE_UNKNOWN 0
-#define EXA_ENGINEMODE_2D      1
-#define EXA_ENGINEMODE_3D      2
 #ifdef XF86DRI
-    Bool              accelDFS;
-#endif
-#endif
-#ifdef USE_XAA
-    XAAInfoRecPtr     accel;
-#endif
-    Bool              accelOn;
-    xf86CursorInfoPtr cursor;
-    Bool              allowColorTiling;
-    Bool              tilingEnabled; /* mirror of sarea->tiling_enabled */
-#ifdef ARGB_CURSOR
-    Bool	      cursor_argb;
-#endif
-    int               cursor_fg;
-    int               cursor_bg;
+struct radeon_cp {
+    Bool              CPRuns;           /* CP is running */
+    Bool              CPInUse;          /* CP has been used by X server */
+    Bool              CPStarted;        /* CP has started */
+    int               CPMode;           /* CP mode that server/clients use */
+    int               CPFifoSize;       /* Size of the CP command FIFO */
+    int               CPusecTimeout;    /* CP timeout in usecs */
+    Bool              needCacheFlush;
 
-#ifdef USE_XAA
-    /*
-     * XAAForceTransBlit is used to change the behavior of the XAA
-     * SetupForScreenToScreenCopy function, to make it DGA-friendly.
-     */
-    Bool              XAAForceTransBlit;
-#endif
+    /* CP accleration */
+    drmBufPtr         indirectBuffer;
+    int               indirectStart;
 
-    int               fifo_slots;       /* Free slots in the FIFO (64 max)   */
-    int               pix24bpp;         /* Depth of pixmap for 24bpp fb      */
-    Bool              dac6bits;         /* Use 6 bit DAC?                    */
+    /* Debugging info for BEGIN_RING/ADVANCE_RING pairs. */
+    int               dma_begin_count;
+    char              *dma_debug_func;
+    int               dma_debug_lineno;
 
-				/* Computed values for Radeon */
-    int               pitch;
-    int               datatype;
-    uint32_t          dp_gui_master_cntl;
-    uint32_t          dp_gui_master_cntl_clip;
-    uint32_t          trans_color;
+    };
 
-				/* Saved values for ScreenToScreenCopy */
-    int               xdir;
-    int               ydir;
+typedef struct {
+    /* Nothing here yet */
+    int dummy;
+} RADEONConfigPrivRec, *RADEONConfigPrivPtr;
 
-#ifdef USE_XAA
-				/* ScanlineScreenToScreenColorExpand support */
-    unsigned char     *scratch_buffer[1];
-    unsigned char     *scratch_save;
-    int               scanline_x;
-    int               scanline_y;
-    int               scanline_w;
-    int               scanline_h;
-    int               scanline_h_w;
-    int               scanline_words;
-    int               scanline_direct;
-    int               scanline_bpp;     /* Only used for ImageWrite */
-    int               scanline_fg;
-    int               scanline_bg;
-    int               scanline_hpass;
-    int               scanline_x1clip;
-    int               scanline_x2clip;
+typedef struct {
+#ifdef PER_CONTEXT_SAREA
+    drm_context_t ctx_id;
+    drm_handle_t sarea_handle;
+#else
+    /* Nothing here yet */
+    int dummy;
 #endif
-				/* Saved values for DashedTwoPointLine */
-    int               dashLen;
-    uint32_t          dashPattern;
-    int               dash_fg;
-    int               dash_bg;
+} RADEONDRIContextRec, *RADEONDRIContextPtr;
 
-    DGAModePtr        DGAModes;
-    int               numDGAModes;
-    Bool              DGAactive;
-    int               DGAViewportStatus;
-    DGAFunctionRec    DGAFuncs;
+struct radeon_dri {
+    Bool              noBackBuffer;
 
-    RADEONFBLayout    CurrentLayout;
-    uint32_t          dst_pitch_offset;
-#ifdef XF86DRI
-    Bool              noBackBuffer;	
-    Bool              directRenderingEnabled;
-    Bool              directRenderingInited;
     Bool              newMemoryMap;
     drmVersionPtr     pLibDRMVersion;
     drmVersionPtr     pKernelDRMVersion;
@@ -542,7 +468,6 @@ typedef struct {
     drmSize           registerSize;
     drm_handle_t      registerHandle;
 
-    RADEONCardType    cardType;            /* Current card is a PCI card */
     drmSize           pciSize;
     drm_handle_t      pciMemHandle;
     unsigned char     *PCI;             /* Map */
@@ -564,15 +489,7 @@ typedef struct {
 
     uint32_t          pciCommand;
 
-    Bool              CPRuns;           /* CP is running */
-    Bool              CPInUse;          /* CP has been used by X server */
-    Bool              CPStarted;        /* CP has started */
-    int               CPMode;           /* CP mode that server/clients use */
-    int               CPFifoSize;       /* Size of the CP command FIFO */
-    int               CPusecTimeout;    /* CP timeout in usecs */
-    Bool              needCacheFlush;
-
-				/* CP ring buffer data */
+    /* CP ring buffer data */
     unsigned long     ringStart;        /* Offset into GART space */
     drm_handle_t      ringHandle;       /* Handle from drmAddMap */
     drmSize           ringMapSize;      /* Size of map */
@@ -585,7 +502,7 @@ typedef struct {
     drmSize           ringReadMapSize;  /* Size of map */
     drmAddress        ringReadPtr;      /* Map */
 
-				/* CP vertex/indirect buffer data */
+    /* CP vertex/indirect buffer data */
     unsigned long     bufStart;         /* Offset into GART space */
     drm_handle_t      bufHandle;        /* Handle from drmAddMap */
     drmSize           bufMapSize;       /* Size of map */
@@ -594,7 +511,7 @@ typedef struct {
     int               bufNumBufs;       /* Number of buffers */
     drmBufMapPtr      buffers;          /* Buffer map */
 
-				/* CP GART Texture data */
+    /* CP GART Texture data */
     unsigned long     gartTexStart;      /* Offset into GART space */
     drm_handle_t      gartTexHandle;     /* Handle from drmAddMap */
     drmSize           gartTexMapSize;    /* Size of map */
@@ -602,11 +519,7 @@ typedef struct {
     drmAddress        gartTex;           /* Map */
     int               log2GARTTexGran;
 
-				/* CP accleration */
-    drmBufPtr         indirectBuffer;
-    int               indirectStart;
-
-				/* DRI screen private data */
+    /* DRI screen private data */
     int               fbX;
     int               fbY;
     int               backX;
@@ -628,43 +541,215 @@ typedef struct {
     int               pciGartSize;
     uint32_t          pciGartOffset;
     void              *pciGartBackup;
+
+    int               irq;
+
+#ifdef PER_CONTEXT_SAREA
+    int               perctx_sarea_size;
+#endif
+
 #ifdef USE_XAA
     uint32_t          frontPitchOffset;
     uint32_t          backPitchOffset;
     uint32_t          depthPitchOffset;
 
-				/* offscreen memory management */
+    /* offscreen memory management */
     int               backLines;
     FBAreaPtr         backArea;
     int               depthTexLines;
     FBAreaPtr         depthTexArea;
 #endif
 
-				/* Saved scissor values */
-    uint32_t          sc_left;
-    uint32_t          sc_right;
-    uint32_t          sc_top;
-    uint32_t          sc_bottom;
+};
+#endif
 
-    uint32_t          re_top_left;
-    uint32_t          re_width_height;
+struct radeon_accel_state {
+    /* common accel data */
+    int               fifo_slots;       /* Free slots in the FIFO (64 max)   */
+				/* Computed values for Radeon */
+    uint32_t          dp_gui_master_cntl;
+    uint32_t          dp_gui_master_cntl_clip;
+    uint32_t          trans_color;
+				/* Saved values for ScreenToScreenCopy */
+    int               xdir;
+    int               ydir;
+    uint32_t          dst_pitch_offset;
 
-    uint32_t          aux_sc_cntl;
+    /* render accel */
+    unsigned short    texW[2];
+    unsigned short    texH[2];
+    Bool              XInited3D; /* X itself has the 3D context */
+    int               num_gb_pipes;
+    Bool              has_tcl;
 
-    int               irq;
+#ifdef USE_EXA
+    /* EXA */
+    ExaDriverPtr      exa;
+    int               exaSyncMarker;
+    int               exaMarkerSynced;
+    int               engineMode;
+#define EXA_ENGINEMODE_UNKNOWN 0
+#define EXA_ENGINEMODE_2D      1
+#define EXA_ENGINEMODE_3D      2
 
-    Bool              DMAForXv;
+    Bool              is_transform[2];
+    PictTransform     *transform[2];
+    Bool              has_mask;
+    /* Whether we are tiling horizontally and vertically */
+    Bool              need_src_tile_x;
+    Bool              need_src_tile_y;
+    /* Size of tiles ... set to 65536x65536 if not tiling in that direction */
+    Bool              src_tile_width;
+    Bool              src_tile_height;
+#endif
 
-#ifdef PER_CONTEXT_SAREA
-    int               perctx_sarea_size;
+#ifdef USE_XAA
+    /* XAA */
+    XAAInfoRecPtr     accel;
+				/* ScanlineScreenToScreenColorExpand support */
+    unsigned char     *scratch_buffer[1];
+    unsigned char     *scratch_save;
+    int               scanline_x;
+    int               scanline_y;
+    int               scanline_w;
+    int               scanline_h;
+    int               scanline_h_w;
+    int               scanline_words;
+    int               scanline_direct;
+    int               scanline_bpp;     /* Only used for ImageWrite */
+    int               scanline_fg;
+    int               scanline_bg;
+    int               scanline_hpass;
+    int               scanline_x1clip;
+    int               scanline_x2clip;
+				/* Saved values for DashedTwoPointLine */
+    int               dashLen;
+    uint32_t          dashPattern;
+    int               dash_fg;
+    int               dash_bg;
+
+    FBLinearPtr       RenderTex;
+    void              (*RenderCallback)(ScrnInfoPtr);
+    Time              RenderTimeout;
+    /*
+     * XAAForceTransBlit is used to change the behavior of the XAA
+     * SetupForScreenToScreenCopy function, to make it DGA-friendly.
+     */
+    Bool              XAAForceTransBlit;
 #endif
 
-    /* Debugging info for BEGIN_RING/ADVANCE_RING pairs. */
-    int               dma_begin_count;
-    char              *dma_debug_func;
-    int               dma_debug_lineno;
+};
+
+typedef struct {
+    EntityInfoPtr     pEnt;
+    pciVideoPtr       PciInfo;
+    PCITAG            PciTag;
+    int               Chipset;
+    RADEONChipFamily  ChipFamily;
+    RADEONErrata      ChipErrata;
+
+    unsigned long     LinearAddr;       /* Frame buffer physical address     */
+    unsigned long     MMIOAddr;         /* MMIO region physical address      */
+    unsigned long     BIOSAddr;         /* BIOS physical address             */
+    uint32_t          fbLocation;
+    uint32_t          gartLocation;
+    uint32_t          mc_fb_location;
+    uint32_t          mc_agp_location;
+    uint32_t          mc_agp_location_hi;
+
+    void              *MMIO;            /* Map of MMIO region                */
+    void              *FB;              /* Map of frame buffer               */
+    uint8_t           *VBIOS;           /* Video BIOS pointer                */
+
+    Bool              IsAtomBios;       /* New BIOS used in R420 etc.        */
+    int               ROMHeaderStart;   /* Start of the ROM Info Table       */
+    int               MasterDataStart;  /* Offset for Master Data Table for ATOM BIOS */
+
+    uint32_t          MemCntl;
+    uint32_t          BusCntl;
+    unsigned long     MMIOSize;         /* MMIO region physical address      */
+    unsigned long     FbMapSize;        /* Size of frame buffer, in bytes    */
+    unsigned long     FbSecureSize;     /* Size of secured fb area at end of
+                                           framebuffer */
+
+    Bool              IsMobility;       /* Mobile chips for laptops */
+    Bool              IsIGP;            /* IGP chips */
+    Bool              HasSingleDAC;     /* only TVDAC on chip */
+    Bool              ddc_mode;         /* Validate mode by matching exactly
+					 * the modes supported in DDC data
+					 */
+    Bool              R300CGWorkaround;
+
+				/* EDID or BIOS values for FPs */
+    int               RefDivider;
+    int               FeedbackDivider;
+    int               PostDivider;
+    Bool              UseBiosDividers;
+				/* EDID data using DDC interface */
+    Bool              ddc_bios;
+    Bool              ddc1;
+    Bool              ddc2;
+
+    RADEONPLLRec      pll;
+
+    int               RamWidth;
+    float	      sclk;		/* in MHz */
+    float	      mclk;		/* in MHz */
+    Bool	      IsDDR;
+    int               DispPriority;
+
+    RADEONSavePtr     SavedReg;         /* Original (text) mode              */
+    RADEONSavePtr     ModeReg;          /* Current mode                      */
+    Bool              (*CloseScreen)(int, ScreenPtr);
+
+    void              (*BlockHandler)(int, pointer, pointer, pointer);
+
+    Bool              PaletteSavedOnVT; /* Palette saved on last VT switch   */
+
+    xf86CursorInfoPtr cursor;
+#ifdef ARGB_CURSOR
+    Bool	      cursor_argb;
+#endif
+    int               cursor_fg;
+    int               cursor_bg;
+
+    int               pix24bpp;         /* Depth of pixmap for 24bpp fb      */
+    Bool              dac6bits;         /* Use 6 bit DAC?                    */
+
+    DGAModePtr        DGAModes;
+    int               numDGAModes;
+    Bool              DGAactive;
+    int               DGAViewportStatus;
+    DGAFunctionRec    DGAFuncs;
+
+    RADEONFBLayout    CurrentLayout;
+
+#ifdef XF86DRI
+    Bool              directRenderingEnabled;
+    Bool              directRenderingInited;
+    RADEONCardType    cardType;            /* Current card is a PCI card */
+    struct radeon_cp  *cp;
+    struct radeon_dri  *dri;
+#ifdef USE_EXA
+    Bool              accelDFS;
+#endif
+    Bool              DMAForXv;
 #endif /* XF86DRI */
 
+    /* accel */
+    Bool              RenderAccel; /* Render */
+    Bool              allowColorTiling;
+    Bool              tilingEnabled; /* mirror of sarea->tiling_enabled */
+    struct radeon_accel_state *accel_state;
+    Bool              accelOn;
+    Bool              useEXA;
+#ifdef USE_EXA
+    XF86ModReqInfo    exaReq;
+#endif
+#ifdef USE_XAA
+    XF86ModReqInfo    xaaReq;
+#endif
+
 				/* XVideo */
     XF86VideoAdaptorPtr adaptor;
     void              (*VideoTimerCallback)(ScrnInfoPtr, Time);
@@ -693,31 +778,10 @@ typedef struct {
     int overlay_scaler_buffer_width;
     int ecp_div;
 
-    /* Render */
-    Bool              RenderAccel;
-    unsigned short    texW[2];
-    unsigned short    texH[2];
-#ifdef USE_XAA
-    FBLinearPtr       RenderTex;
-    void              (*RenderCallback)(ScrnInfoPtr);
-    Time              RenderTimeout;
-#endif
-
     /* general */
     Bool              showCache;
     OptionInfoPtr     Options;
 
-    Bool              useEXA;
-#ifdef USE_EXA
-    XF86ModReqInfo    exaReq;
-#endif
-#ifdef USE_XAA
-    XF86ModReqInfo    xaaReq;
-#endif
-
-    /* X itself has the 3D context */
-    Bool              XInited3D;
-
     DisplayModePtr currentMode, savedCurrentMode;
 
     /* special handlings for DELL triple-head server */
@@ -772,22 +836,19 @@ typedef struct {
     Bool              r600_shadow_fb;
     void *fb_shadow;
 
-    int num_gb_pipes;
-    Bool has_tcl;
 } RADEONInfoRec, *RADEONInfoPtr;
 
 #define RADEONWaitForFifo(pScrn, entries)				\
 do {									\
-    if (info->fifo_slots < entries)					\
+    if (info->accel_state->fifo_slots < entries)			\
 	RADEONWaitForFifoFunction(pScrn, entries);			\
-    info->fifo_slots -= entries;					\
+    info->accel_state->fifo_slots -= entries;				\
 } while (0)
 
 /* legacy_crtc.c */
 extern void legacy_crtc_dpms(xf86CrtcPtr crtc, int mode);
 extern void legacy_crtc_mode_set(xf86CrtcPtr crtc, DisplayModePtr mode,
 				 DisplayModePtr adjusted_mode, int x, int y);
-extern void RADEONInitDispBandwidth(ScrnInfoPtr pScrn);
 extern void RADEONRestoreCommonRegisters(ScrnInfoPtr pScrn,
 					 RADEONSavePtr restore);
 extern void RADEONRestoreCrtcRegisters(ScrnInfoPtr pScrn,
@@ -872,6 +933,7 @@ extern Bool RADEONGetTMDSInfoFromBIOS(xf86OutputPtr output);
 extern Bool RADEONGetTVInfoFromBIOS(xf86OutputPtr output);
 extern Bool RADEONInitExtTMDSInfoFromBIOS (xf86OutputPtr output);
 extern Bool RADEONPostCardFromBIOSTables(ScrnInfoPtr pScrn);
+extern Bool radeon_card_posted(ScrnInfoPtr pScrn);
 
 /* radeon_commonfuncs.c */
 #ifdef XF86DRI
@@ -894,6 +956,7 @@ extern DisplayModePtr RADEONCrtcFindClosestMode(xf86CrtcPtr crtc,
 						DisplayModePtr pMode);
 extern void RADEONUnblank(ScrnInfoPtr pScrn);
 extern Bool RADEONSetTiling(ScrnInfoPtr pScrn);
+extern void RADEONInitDispBandwidth(ScrnInfoPtr pScrn);
 
 /* radeon_cursor.c */
 extern Bool RADEONCursorInit(ScreenPtr pScreen);
@@ -983,6 +1046,8 @@ extern void RADEONPrintPortMap(ScrnInfoPtr pScrn);
 extern void RADEONSetOutputType(ScrnInfoPtr pScrn,
 				RADEONOutputPrivatePtr radeon_output);
 extern Bool RADEONSetupConnectors(ScrnInfoPtr pScrn);
+extern Bool RADEONI2CDoLock(xf86OutputPtr output, Bool lock_state);
+
 
 /* radeon_tv.c */
 extern void RADEONSaveTVRegisters(ScrnInfoPtr pScrn, RADEONSavePtr save);
@@ -1003,6 +1068,16 @@ extern void RADEONUpdateHVPosition(xf86OutputPtr output, DisplayModePtr mode);
 extern void RADEONInitVideo(ScreenPtr pScreen);
 extern void RADEONResetVideo(ScrnInfoPtr pScrn);
 
+/* radeon_memory.c */
+extern uint32_t
+radeon_allocate_memory(ScrnInfoPtr pScrn,
+		       void **mem_struct,
+		       int size,
+		       int align);
+extern void
+radeon_free_memory(ScrnInfoPtr pScrn,
+		   void *mem_struct);
+
 #ifdef XF86DRI
 #  ifdef USE_XAA
 /* radeon_accelfuncs.c */
@@ -1011,72 +1086,58 @@ extern void RADEONAccelInitCP(ScreenPtr pScreen, XAAInfoRecPtr a);
 
 #define RADEONCP_START(pScrn, info)					\
 do {									\
-    int _ret = drmCommandNone(info->drmFD, DRM_RADEON_CP_START);	\
+    int _ret = drmCommandNone(info->dri->drmFD, DRM_RADEON_CP_START);	\
     if (_ret) {								\
 	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,				\
 		   "%s: CP start %d\n", __FUNCTION__, _ret);		\
     }									\
-    info->CPStarted = TRUE;                                             \
+    info->cp->CPStarted = TRUE;                                         \
 } while (0)
 
 #define RADEONCP_RELEASE(pScrn, info)					\
 do {									\
-    if (info->CPInUse) {						\
+    if (info->cp->CPInUse) {						\
 	RADEON_PURGE_CACHE();						\
 	RADEON_WAIT_UNTIL_IDLE();					\
 	RADEONCPReleaseIndirect(pScrn);					\
-	info->CPInUse = FALSE;						\
+	info->cp->CPInUse = FALSE;				        \
     }									\
 } while (0)
 
 #define RADEONCP_STOP(pScrn, info)					\
 do {									\
     int _ret;								\
-     if (info->CPStarted) {						\
+     if (info->cp->CPStarted) {						\
         _ret = RADEONCPStop(pScrn, info);				\
         if (_ret) {							\
 	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,			\
 		   "%s: CP stop %d\n", __FUNCTION__, _ret);		\
         }								\
-        info->CPStarted = FALSE;                                        \
+        info->cp->CPStarted = FALSE;                                    \
    }									\
     RADEONEngineRestore(pScrn);						\
-    info->CPRuns = FALSE;						\
+    info->cp->CPRuns = FALSE;						\
 } while (0)
 
 #define RADEONCP_RESET(pScrn, info)					\
 do {									\
-    if (RADEONCP_USE_RING_BUFFER(info->CPMode)) {			\
-	int _ret = drmCommandNone(info->drmFD, DRM_RADEON_CP_RESET);	\
+	int _ret = drmCommandNone(info->dri->drmFD, DRM_RADEON_CP_RESET);	\
 	if (_ret) {							\
 	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,			\
 		       "%s: CP reset %d\n", __FUNCTION__, _ret);	\
 	}								\
-    }									\
 } while (0)
 
 #define RADEONCP_REFRESH(pScrn, info)					\
 do {									\
-    if (!info->CPInUse) {						\
-	if (info->needCacheFlush) {					\
+    if (!info->cp->CPInUse) {						\
+	if (info->cp->needCacheFlush) {					\
 	    RADEON_PURGE_CACHE();					\
 	    RADEON_PURGE_ZCACHE();					\
-	    info->needCacheFlush = FALSE;				\
+	    info->cp->needCacheFlush = FALSE;				\
 	}								\
 	RADEON_WAIT_UNTIL_IDLE();					\
-        if (info->ChipFamily <= CHIP_FAMILY_RV280) {                    \
-	    BEGIN_RING(6);						\
-	    OUT_RING_REG(RADEON_RE_TOP_LEFT,     info->re_top_left);	\
-	    OUT_RING_REG(RADEON_RE_WIDTH_HEIGHT, info->re_width_height); \
-	    OUT_RING_REG(RADEON_AUX_SC_CNTL,     info->aux_sc_cntl);	\
-	    ADVANCE_RING();						\
-        } else {                                                        \
-            BEGIN_RING(4);                                              \
-            OUT_RING_REG(R300_SC_SCISSOR0, info->re_top_left);          \
-	    OUT_RING_REG(R300_SC_SCISSOR1, info->re_width_height);      \
-            ADVANCE_RING();                                             \
-	}                                                               \
-	info->CPInUse = TRUE;						\
+	info->cp->CPInUse = TRUE;					\
     }									\
 } while (0)
 
@@ -1100,33 +1161,33 @@ do {									\
 	xf86DrvMsg(pScrn->scrnIndex, X_INFO,				\
 		   "BEGIN_RING(%d) in %s\n", (unsigned int)n, __FUNCTION__);\
     }									\
-    if (++info->dma_begin_count != 1) {					\
+    if (++info->cp->dma_begin_count != 1) {				\
 	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,				\
 		   "BEGIN_RING without end at %s:%d\n",			\
-		   info->dma_debug_func, info->dma_debug_lineno);	\
-	info->dma_begin_count = 1;					\
+		   info->cp->dma_debug_func, info->cp->dma_debug_lineno);	\
+	info->cp->dma_begin_count = 1;					\
     }									\
-    info->dma_debug_func = __FILE__;					\
-    info->dma_debug_lineno = __LINE__;					\
-    if (!info->indirectBuffer) {					\
-	info->indirectBuffer = RADEONCPGetBuffer(pScrn);		\
-	info->indirectStart = 0;					\
-    } else if (info->indirectBuffer->used + (n) * (int)sizeof(uint32_t) >	\
-	       info->indirectBuffer->total) {				\
+    info->cp->dma_debug_func = __FILE__;				\
+    info->cp->dma_debug_lineno = __LINE__;				\
+    if (!info->cp->indirectBuffer) {					\
+	info->cp->indirectBuffer = RADEONCPGetBuffer(pScrn);		\
+	info->cp->indirectStart = 0;					\
+    } else if (info->cp->indirectBuffer->used + (n) * (int)sizeof(uint32_t) >	\
+	       info->cp->indirectBuffer->total) {		        \
 	RADEONCPFlushIndirect(pScrn, 1);				\
     }									\
     __expected = n;							\
-    __head = (pointer)((char *)info->indirectBuffer->address +		\
-		       info->indirectBuffer->used);			\
+    __head = (pointer)((char *)info->cp->indirectBuffer->address +	\
+		       info->cp->indirectBuffer->used);			\
     __count = 0;							\
 } while (0)
 
 #define ADVANCE_RING() do {						\
-    if (info->dma_begin_count-- != 1) {					\
+    if (info->cp->dma_begin_count-- != 1) {				\
 	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,				\
 		   "ADVANCE_RING without begin at %s:%d\n",		\
 		   __FILE__, __LINE__);					\
-	info->dma_begin_count = 0;					\
+	info->cp->dma_begin_count = 0;					\
     }									\
     if (__count != __expected) {					\
 	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,				\
@@ -1136,11 +1197,11 @@ do {									\
     if (RADEON_VERBOSE) {						\
 	xf86DrvMsg(pScrn->scrnIndex, X_INFO,				\
 		   "ADVANCE_RING() start: %d used: %d count: %d\n",	\
-		   info->indirectStart,					\
-		   info->indirectBuffer->used,				\
+		   info->cp->indirectStart,				\
+		   info->cp->indirectBuffer->used,			\
 		   __count * (int)sizeof(uint32_t));			\
     }									\
-    info->indirectBuffer->used += __count * (int)sizeof(uint32_t);	\
+    info->cp->indirectBuffer->used += __count * (int)sizeof(uint32_t);	\
 } while (0)
 
 #define OUT_RING(x) do {						\
@@ -1162,7 +1223,7 @@ do {									\
     if (RADEON_VERBOSE)							\
 	xf86DrvMsg(pScrn->scrnIndex, X_INFO,				\
 		   "FLUSH_RING in %s\n", __FUNCTION__);			\
-    if (info->indirectBuffer) {						\
+    if (info->cp->indirectBuffer) {					\
 	RADEONCPFlushIndirect(pScrn, 0);				\
     }									\
 } while (0)
@@ -1236,7 +1297,7 @@ static __inline__ void RADEON_MARK_SYNC(RADEONInfoPtr info, ScrnInfoPtr pScrn)
 #endif
 #ifdef USE_XAA
     if (!info->useEXA)
-	SET_SYNC_FLAG(info->accel);
+	SET_SYNC_FLAG(info->accel_state->accel);
 #endif
 }
 
@@ -1247,8 +1308,8 @@ static __inline__ void RADEON_SYNC(RADEONInfoPtr info, ScrnInfoPtr pScrn)
 	exaWaitSync(pScrn->pScreen);
 #endif
 #ifdef USE_XAA
-    if (!info->useEXA && info->accel)
-	info->accel->Sync(pScrn);
+    if (!info->useEXA && info->accel_state->accel)
+	info->accel_state->accel->Sync(pScrn);
 #endif
 }
 
diff --git a/src/radeon_accel.c b/src/radeon_accel.c
index 65ad33d..a6e332d 100644
--- a/src/radeon_accel.c
+++ b/src/radeon_accel.c
@@ -83,9 +83,7 @@
 #include "radeon_version.h"
 #ifdef XF86DRI
 #define _XF86DRI_SERVER_
-#include "radeon_dri.h"
-#include "radeon_common.h"
-#include "radeon_sarea.h"
+#include "radeon_drm.h"
 #endif
 
 				/* Line support */
@@ -130,9 +128,9 @@ void RADEONWaitForFifoFunction(ScrnInfoPtr pScrn, int entries)
 
     for (;;) {
 	for (i = 0; i < RADEON_TIMEOUT; i++) {
-	    info->fifo_slots =
+	    info->accel_state->fifo_slots =
 		INREG(RADEON_RBBM_STATUS) & RADEON_RBBM_FIFOCNT_MASK;
-	    if (info->fifo_slots >= entries) return;
+	    if (info->accel_state->fifo_slots >= entries) return;
 	}
 	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
 		       "FIFO timed out: %u entries, stat=0x%08x\n",
@@ -324,8 +322,8 @@ void RADEONEngineRestore(ScrnInfoPtr pScrn)
      * in the wrong place (happened).
      */
     RADEONWaitForFifo(pScrn, 2);
-    OUTREG(RADEON_DST_PITCH_OFFSET, info->dst_pitch_offset);
-    OUTREG(RADEON_SRC_PITCH_OFFSET, info->dst_pitch_offset);
+    OUTREG(RADEON_DST_PITCH_OFFSET, info->accel_state->dst_pitch_offset);
+    OUTREG(RADEON_SRC_PITCH_OFFSET, info->accel_state->dst_pitch_offset);
 
     RADEONWaitForFifo(pScrn, 1);
 #if X_BYTE_ORDER == X_BIG_ENDIAN
@@ -343,7 +341,7 @@ void RADEONEngineRestore(ScrnInfoPtr pScrn)
     OUTREG(RADEON_DEFAULT_SC_BOTTOM_RIGHT, (RADEON_DEFAULT_SC_RIGHT_MAX
 					    | RADEON_DEFAULT_SC_BOTTOM_MAX));
     RADEONWaitForFifo(pScrn, 1);
-    OUTREG(RADEON_DP_GUI_MASTER_CNTL, (info->dp_gui_master_cntl
+    OUTREG(RADEON_DP_GUI_MASTER_CNTL, (info->accel_state->dp_gui_master_cntl
 				       | RADEON_GMC_BRUSH_SOLID_COLOR
 				       | RADEON_GMC_SRC_DATATYPE_COLOR));
 
@@ -356,7 +354,7 @@ void RADEONEngineRestore(ScrnInfoPtr pScrn)
 
     RADEONWaitForIdleMMIO(pScrn);
 
-    info->XInited3D = FALSE;
+    info->accel_state->XInited3D = FALSE;
 }
 
 /* Initialize the acceleration hardware */
@@ -364,6 +362,7 @@ void RADEONEngineInit(ScrnInfoPtr pScrn)
 {
     RADEONInfoPtr  info       = RADEONPTR(pScrn);
     unsigned char *RADEONMMIO = info->MMIO;
+    int datatype = 0;
 
     xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
 		   "EngineInit (%d/%d)\n",
@@ -372,21 +371,21 @@ void RADEONEngineInit(ScrnInfoPtr pScrn)
 
 #ifdef XF86DRI
     if (info->directRenderingEnabled && (IS_R300_3D || IS_R500_3D)) {
-	drmRadeonGetParam np;
+	drm_radeon_getparam_t np;
 	int num_pipes;
 
 	memset(&np, 0, sizeof(np));
 	np.param = RADEON_PARAM_NUM_GB_PIPES;
 	np.value = &num_pipes;
 
-	if (drmCommandWriteRead(info->drmFD, DRM_RADEON_GETPARAM, &np,
+	if (drmCommandWriteRead(info->dri->drmFD, DRM_RADEON_GETPARAM, &np,
 				sizeof(np)) < 0) {
 	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
 		       "Failed to determine num pipes from DRM, falling back to "
 		       "manual look-up!\n");
-	    info->num_gb_pipes = 0;
+	    info->accel_state->num_gb_pipes = 0;
 	} else {
-	    info->num_gb_pipes = num_pipes;
+	    info->accel_state->num_gb_pipes = num_pipes;
 	}
     }
 #endif
@@ -399,34 +398,34 @@ void RADEONEngineInit(ScrnInfoPtr pScrn)
 	(info->ChipFamily == CHIP_FAMILY_RS400) ||
 	(info->ChipFamily == CHIP_FAMILY_RS480) ||
 	IS_R500_3D) {
-	if (info->num_gb_pipes == 0) {
+	if (info->accel_state->num_gb_pipes == 0) {
 	    uint32_t gb_pipe_sel = INREG(R400_GB_PIPE_SELECT);
 
-	    info->num_gb_pipes = ((gb_pipe_sel >> 12) & 0x3) + 1;
+	    info->accel_state->num_gb_pipes = ((gb_pipe_sel >> 12) & 0x3) + 1;
 	    if (IS_R500_3D)
 		OUTPLL(pScrn, R500_DYN_SCLK_PWMEM_PIPE, (1 | ((gb_pipe_sel >> 8) & 0xf) << 4));
 	}
     } else {
-	if (info->num_gb_pipes == 0) {
+	if (info->accel_state->num_gb_pipes == 0) {
 	    if ((info->ChipFamily == CHIP_FAMILY_R300) ||
 		(info->ChipFamily == CHIP_FAMILY_R350)) {
 		/* R3xx chips */
-		info->num_gb_pipes = 2;
+		info->accel_state->num_gb_pipes = 2;
 	    } else {
 		/* RV3xx chips */
-		info->num_gb_pipes = 1;
+		info->accel_state->num_gb_pipes = 1;
 	    }
 	}
     }
 
     if (IS_R300_3D || IS_R500_3D)
 	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-		   "num pipes is %d\n", info->num_gb_pipes);
+		   "num quad-pipes is %d\n", info->accel_state->num_gb_pipes);
 
     if (IS_R300_3D || IS_R500_3D) {
 	uint32_t gb_tile_config = (R300_ENABLE_TILING | R300_TILE_SIZE_16 | R300_SUBPIXEL_1_16);
 
-	switch(info->num_gb_pipes) {
+	switch(info->accel_state->num_gb_pipes) {
 	case 2: gb_tile_config |= R300_PIPE_COUNT_R300; break;
 	case 3: gb_tile_config |= R300_PIPE_COUNT_R420_3P; break;
 	case 4: gb_tile_config |= R300_PIPE_COUNT_R420; break;
@@ -446,11 +445,11 @@ void RADEONEngineInit(ScrnInfoPtr pScrn)
     RADEONEngineReset(pScrn);
 
     switch (info->CurrentLayout.pixel_code) {
-    case 8:  info->datatype = 2; break;
-    case 15: info->datatype = 3; break;
-    case 16: info->datatype = 4; break;
-    case 24: info->datatype = 5; break;
-    case 32: info->datatype = 6; break;
+    case 8:  datatype = 2; break;
+    case 15: datatype = 3; break;
+    case 16: datatype = 4; break;
+    case 24: datatype = 5; break;
+    case 32: datatype = 6; break;
     default:
 	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
 		       "Unknown depth/bpp = %d/%d (code = %d)\n",
@@ -458,34 +457,12 @@ void RADEONEngineInit(ScrnInfoPtr pScrn)
 		       info->CurrentLayout.bitsPerPixel,
 		       info->CurrentLayout.pixel_code);
     }
-    info->pitch = ((info->CurrentLayout.displayWidth / 8) *
-		   (info->CurrentLayout.pixel_bytes == 3 ? 3 : 1));
 
-    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
-		   "Pitch for acceleration = %d\n", info->pitch);
-
-    info->dp_gui_master_cntl =
-	((info->datatype << RADEON_GMC_DST_DATATYPE_SHIFT)
+    info->accel_state->dp_gui_master_cntl =
+	((datatype << RADEON_GMC_DST_DATATYPE_SHIFT)
 	 | RADEON_GMC_CLR_CMP_CNTL_DIS
 	 | RADEON_GMC_DST_PITCH_OFFSET_CNTL);
 
-#ifdef XF86DRI
-    info->sc_left         = 0x00000000;
-    info->sc_right        = RADEON_DEFAULT_SC_RIGHT_MAX;
-    info->sc_top          = 0x00000000;
-    info->sc_bottom       = RADEON_DEFAULT_SC_BOTTOM_MAX;
-
-    info->re_top_left     = 0x00000000;
-    if (info->ChipFamily <= CHIP_FAMILY_RV280)
-	info->re_width_height = ((0x7ff << RADEON_RE_WIDTH_SHIFT) |
-				 (0x7ff << RADEON_RE_HEIGHT_SHIFT));
-    else
-	info->re_width_height = ((8191 << R300_SCISSOR_X_SHIFT) |
-				 (8191 << R300_SCISSOR_Y_SHIFT));
-
-    info->aux_sc_cntl     = 0x00000000;
-#endif
-
     RADEONEngineRestore(pScrn);
 }
 
@@ -534,14 +511,14 @@ void RADEONEngineInit(ScrnInfoPtr pScrn)
 /* Stop the CP */
 int RADEONCPStop(ScrnInfoPtr pScrn, RADEONInfoPtr info)
 {
-    drmRadeonCPStop  stop;
+    drm_radeon_cp_stop_t  stop;
     int              ret, i;
 
     stop.flush = 1;
     stop.idle  = 1;
 
-    ret = drmCommandWrite(info->drmFD, DRM_RADEON_CP_STOP, &stop,
-			  sizeof(drmRadeonCPStop));
+    ret = drmCommandWrite(info->dri->drmFD, DRM_RADEON_CP_STOP, &stop,
+			  sizeof(drm_radeon_cp_stop_t));
 
     if (ret == 0) {
 	return 0;
@@ -553,8 +530,8 @@ int RADEONCPStop(ScrnInfoPtr pScrn, RADEONInfoPtr info)
 
     i = 0;
     do {
-	ret = drmCommandWrite(info->drmFD, DRM_RADEON_CP_STOP, &stop,
-			      sizeof(drmRadeonCPStop));
+	ret = drmCommandWrite(info->dri->drmFD, DRM_RADEON_CP_STOP, &stop,
+			      sizeof(drm_radeon_cp_stop_t));
     } while (ret && errno == EBUSY && i++ < RADEON_IDLE_RETRY);
 
     if (ret == 0) {
@@ -565,8 +542,8 @@ int RADEONCPStop(ScrnInfoPtr pScrn, RADEONInfoPtr info)
 
     stop.idle = 0;
 
-    if (drmCommandWrite(info->drmFD, DRM_RADEON_CP_STOP,
-			&stop, sizeof(drmRadeonCPStop))) {
+    if (drmCommandWrite(info->dri->drmFD, DRM_RADEON_CP_STOP,
+			&stop, sizeof(drm_radeon_cp_stop_t))) {
 	return -errno;
     } else {
 	return 0;
@@ -608,7 +585,7 @@ drmBufPtr RADEONCPGetBuffer(ScrnInfoPtr pScrn)
 
     while (1) {
 	do {
-	    ret = drmDMA(info->drmFD, &dma);
+	    ret = drmDMA(info->dri->drmFD, &dma);
 	    if (ret && ret != -EBUSY) {
 		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 			   "%s: CP GetBuffer %d\n", __FUNCTION__, ret);
@@ -616,7 +593,7 @@ drmBufPtr RADEONCPGetBuffer(ScrnInfoPtr pScrn)
 	} while ((ret == -EBUSY) && (i++ < RADEON_TIMEOUT));
 
 	if (ret == 0) {
-	    buf = &info->buffers->list[indx];
+	    buf = &info->dri->buffers->list[indx];
 	    buf->used = 0;
 	    if (RADEON_VERBOSE) {
 		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
@@ -641,9 +618,9 @@ drmBufPtr RADEONCPGetBuffer(ScrnInfoPtr pScrn)
 void RADEONCPFlushIndirect(ScrnInfoPtr pScrn, int discard)
 {
     RADEONInfoPtr      info   = RADEONPTR(pScrn);
-    drmBufPtr          buffer = info->indirectBuffer;
-    int                start  = info->indirectStart;
-    drmRadeonIndirect  indirect;
+    drmBufPtr          buffer = info->cp->indirectBuffer;
+    int                start  = info->cp->indirectStart;
+    drm_radeon_indirect_t  indirect;
 
     if (!buffer) return;
     if (start == buffer->used && !discard) return;
@@ -658,18 +635,18 @@ void RADEONCPFlushIndirect(ScrnInfoPtr pScrn, int discard)
     indirect.end     = buffer->used;
     indirect.discard = discard;
 
-    drmCommandWriteRead(info->drmFD, DRM_RADEON_INDIRECT,
-			&indirect, sizeof(drmRadeonIndirect));
+    drmCommandWriteRead(info->dri->drmFD, DRM_RADEON_INDIRECT,
+			&indirect, sizeof(drm_radeon_indirect_t));
 
     if (discard) {
-	info->indirectBuffer = RADEONCPGetBuffer(pScrn);
-	info->indirectStart  = 0;
+	info->cp->indirectBuffer = RADEONCPGetBuffer(pScrn);
+	info->cp->indirectStart  = 0;
     } else {
 	/* Start on a double word boundary */
-	info->indirectStart  = buffer->used = (buffer->used + 7) & ~7;
+	info->cp->indirectStart  = buffer->used = (buffer->used + 7) & ~7;
 	if (RADEON_VERBOSE) {
 	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "   Starting at %d\n",
-		       info->indirectStart);
+		       info->cp->indirectStart);
 	}
     }
 }
@@ -678,12 +655,12 @@ void RADEONCPFlushIndirect(ScrnInfoPtr pScrn, int discard)
 void RADEONCPReleaseIndirect(ScrnInfoPtr pScrn)
 {
     RADEONInfoPtr      info   = RADEONPTR(pScrn);
-    drmBufPtr          buffer = info->indirectBuffer;
-    int                start  = info->indirectStart;
-    drmRadeonIndirect  indirect;
+    drmBufPtr          buffer = info->cp->indirectBuffer;
+    int                start  = info->cp->indirectStart;
+    drm_radeon_indirect_t  indirect;
 
-    info->indirectBuffer = NULL;
-    info->indirectStart  = 0;
+    info->cp->indirectBuffer = NULL;
+    info->cp->indirectStart  = 0;
 
     if (!buffer) return;
 
@@ -697,8 +674,8 @@ void RADEONCPReleaseIndirect(ScrnInfoPtr pScrn)
     indirect.end     = buffer->used;
     indirect.discard = 1;
 
-    drmCommandWriteRead(info->drmFD, DRM_RADEON_INDIRECT,
-			&indirect, sizeof(drmRadeonIndirect));
+    drmCommandWriteRead(info->dri->drmFD, DRM_RADEON_INDIRECT,
+			&indirect, sizeof(drm_radeon_indirect_t));
 }
 
 /** \brief Calculate HostDataBlit parameters from pointer and pitch
@@ -964,7 +941,7 @@ Bool RADEONAccelInit(ScreenPtr pScreen)
     if (!info->useEXA) {
 	XAAInfoRecPtr  a;
 
-	if (!(a = info->accel = XAACreateInfoRec())) {
+	if (!(a = info->accel_state->accel = XAACreateInfoRec())) {
 	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "XAACreateInfoRec Error\n");
 	    return FALSE;
 	}
@@ -993,16 +970,16 @@ void RADEONInit3DEngine(ScrnInfoPtr pScrn)
 
 #ifdef XF86DRI
     if (info->directRenderingEnabled) {
-	RADEONSAREAPrivPtr pSAREAPriv;
+	drm_radeon_sarea_t *pSAREAPriv;
 
 	pSAREAPriv = DRIGetSAREAPrivate(pScrn->pScreen);
-	pSAREAPriv->ctxOwner = DRIGetContext(pScrn->pScreen);
+	pSAREAPriv->ctx_owner = DRIGetContext(pScrn->pScreen);
 	RADEONInit3DEngineCP(pScrn);
     } else
 #endif
 	RADEONInit3DEngineMMIO(pScrn);
 
-    info->XInited3D = TRUE;
+    info->accel_state->XInited3D = TRUE;
 }
 
 #ifdef USE_XAA
@@ -1013,7 +990,7 @@ RADEONSetupMemXAA_DRI(int scrnIndex, ScreenPtr pScreen)
     ScrnInfoPtr    pScrn = xf86Screens[pScreen->myNum];
     RADEONInfoPtr  info  = RADEONPTR(pScrn);
     int            cpp = info->CurrentLayout.pixel_bytes;
-    int            depthCpp = (info->depthBits - 8) / 4;
+    int            depthCpp = (info->dri->depthBits - 8) / 4;
     int            width_bytes = pScrn->displayWidth * cpp;
     int            bufferSize;
     int            depthSize;
@@ -1023,9 +1000,9 @@ RADEONSetupMemXAA_DRI(int scrnIndex, ScreenPtr pScreen)
     BoxRec         MemBox;
     FBAreaPtr      fbarea;
 
-    info->frontOffset = 0;
-    info->frontPitch = pScrn->displayWidth;
-    info->backPitch = pScrn->displayWidth;
+    info->dri->frontOffset = 0;
+    info->dri->frontPitch = pScrn->displayWidth;
+    info->dri->backPitch = pScrn->displayWidth;
 
     /* make sure we use 16 line alignment for tiling (8 might be enough).
      * Might need that for non-XF86DRI too?
@@ -1042,30 +1019,18 @@ RADEONSetupMemXAA_DRI(int scrnIndex, ScreenPtr pScreen)
      * which is always the case if color tiling is used due to color pitch
      * but not necessarily otherwise, and its height a multiple of 16 lines.
      */
-    info->depthPitch = (pScrn->displayWidth + 31) & ~31;
-    depthSize = ((((pScrn->virtualY + 15) & ~15) * info->depthPitch
+    info->dri->depthPitch = (pScrn->displayWidth + 31) & ~31;
+    depthSize = ((((pScrn->virtualY + 15) & ~15) * info->dri->depthPitch
 		  * depthCpp + RADEON_BUFFER_ALIGN) & ~RADEON_BUFFER_ALIGN);
 
-    switch (info->CPMode) {
-    case RADEON_DEFAULT_CP_PIO_MODE:
-	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CP in PIO mode\n");
-	break;
-    case RADEON_DEFAULT_CP_BM_MODE:
-	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CP in BM mode\n");
-	break;
-    default:
-        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CP in UNKNOWN mode\n");
-	break;
-    }
-
     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-	       "Using %d MB GART aperture\n", info->gartSize);
+	       "Using %d MB GART aperture\n", info->dri->gartSize);
     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-	       "Using %d MB for the ring buffer\n", info->ringSize);
+	       "Using %d MB for the ring buffer\n", info->dri->ringSize);
     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-	       "Using %d MB for vertex/indirect buffers\n", info->bufSize);
+	       "Using %d MB for vertex/indirect buffers\n", info->dri->bufSize);
     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-	       "Using %d MB for GART textures\n", info->gartTexSize);
+	       "Using %d MB for GART textures\n", info->dri->gartTexSize);
 
     /* Try for front, back, depth, and three framebuffers worth of
      * pixmap cache.  Should be enough for a fullscreen background
@@ -1075,35 +1040,35 @@ RADEONSetupMemXAA_DRI(int scrnIndex, ScreenPtr pScreen)
      * otherwise probably), and never reserve more than 3 offscreen buffers as it's
      * probably useless for XAA.
      */
-    if (info->textureSize >= 0) {
+    if (info->dri->textureSize >= 0) {
 	texsizerequest = ((int)info->FbMapSize - 2 * bufferSize - depthSize
 			 - 2 * width_bytes - 16384 - info->FbSecureSize)
 	/* first divide, then multiply or we'll get an overflow (been there...) */
-			 / 100 * info->textureSize;
+			 / 100 * info->dri->textureSize;
     }
     else {
 	texsizerequest = (int)info->FbMapSize / 2;
     }
-    info->textureSize = info->FbMapSize - info->FbSecureSize - 5 * bufferSize - depthSize;
+    info->dri->textureSize = info->FbMapSize - info->FbSecureSize - 5 * bufferSize - depthSize;
 
     /* If that gives us less than the requested memory, let's
      * be greedy and grab some more.  Sorry, I care more about 3D
      * performance than playing nicely, and you'll get around a full
      * framebuffer's worth of pixmap cache anyway.
      */
-    if (info->textureSize < texsizerequest) {
-        info->textureSize = info->FbMapSize - 4 * bufferSize - depthSize;
+    if (info->dri->textureSize < texsizerequest) {
+        info->dri->textureSize = info->FbMapSize - 4 * bufferSize - depthSize;
     }
-    if (info->textureSize < texsizerequest) {
-        info->textureSize = info->FbMapSize - 3 * bufferSize - depthSize;
+    if (info->dri->textureSize < texsizerequest) {
+        info->dri->textureSize = info->FbMapSize - 3 * bufferSize - depthSize;
     }
 
     /* If there's still no space for textures, try without pixmap cache, but
      * never use the reserved space, the space hw cursor and PCIGART table might
      * use.
      */
-    if (info->textureSize < 0) {
-	info->textureSize = info->FbMapSize - 2 * bufferSize - depthSize
+    if (info->dri->textureSize < 0) {
+	info->dri->textureSize = info->FbMapSize - 2 * bufferSize - depthSize
 	                    - 2 * width_bytes - 16384 - info->FbSecureSize;
     }
 
@@ -1112,14 +1077,14 @@ RADEONSetupMemXAA_DRI(int scrnIndex, ScreenPtr pScreen)
      */
     /* FIXME: what's this good for? condition is pretty much impossible to meet */
     if ((int)info->FbMapSize - 8192*width_bytes - bufferSize - depthSize
-	> info->textureSize) {
-	info->textureSize =
+	> info->dri->textureSize) {
+	info->dri->textureSize =
 		info->FbMapSize - 8192*width_bytes - bufferSize - depthSize;
     }
 
     /* If backbuffer is disabled, don't allocate memory for it */
-    if (info->noBackBuffer) {
-	info->textureSize += bufferSize;
+    if (info->dri->noBackBuffer) {
+	info->dri->textureSize += bufferSize;
     }
 
     /* RADEON_BUFFER_ALIGN is not sufficient for backbuffer!
@@ -1131,61 +1096,61 @@ RADEONSetupMemXAA_DRI(int scrnIndex, ScreenPtr pScreen)
        can't be used (?) due to that log_tex_granularity thing???
        Could use different copyscreentoscreen function for the pageflip copies
        (which would use different src and dst offsets) to avoid this. */   
-    if (info->allowColorTiling && !info->noBackBuffer) {
-	info->textureSize = info->FbMapSize - ((info->FbMapSize - info->textureSize +
+    if (info->allowColorTiling && !info->dri->noBackBuffer) {
+	info->dri->textureSize = info->FbMapSize - ((info->FbMapSize - info->dri->textureSize +
 			  width_bytes * 16 - 1) / (width_bytes * 16)) * (width_bytes * 16);
     }
-    if (info->textureSize > 0) {
-	l = RADEONMinBits((info->textureSize-1) / RADEON_NR_TEX_REGIONS);
+    if (info->dri->textureSize > 0) {
+	l = RADEONMinBits((info->dri->textureSize-1) / RADEON_NR_TEX_REGIONS);
 	if (l < RADEON_LOG_TEX_GRANULARITY)
 	    l = RADEON_LOG_TEX_GRANULARITY;
 	/* Round the texture size up to the nearest whole number of
 	 * texture regions.  Again, be greedy about this, don't
 	 * round down.
 	 */
-	info->log2TexGran = l;
-	info->textureSize = (info->textureSize >> l) << l;
+	info->dri->log2TexGran = l;
+	info->dri->textureSize = (info->dri->textureSize >> l) << l;
     } else {
-	info->textureSize = 0;
+	info->dri->textureSize = 0;
     }
 
     /* Set a minimum usable local texture heap size.  This will fit
      * two 256x256x32bpp textures.
      */
-    if (info->textureSize < 512 * 1024) {
-	info->textureOffset = 0;
-	info->textureSize = 0;
+    if (info->dri->textureSize < 512 * 1024) {
+	info->dri->textureOffset = 0;
+	info->dri->textureSize = 0;
     }
 
-    if (info->allowColorTiling && !info->noBackBuffer) {
-	info->textureOffset = ((info->FbMapSize - info->textureSize) /
-			       (width_bytes * 16)) * (width_bytes * 16);
+    if (info->allowColorTiling && !info->dri->noBackBuffer) {
+	info->dri->textureOffset = ((info->FbMapSize - info->dri->textureSize) /
+				    (width_bytes * 16)) * (width_bytes * 16);
     }
     else {
 	/* Reserve space for textures */
-	info->textureOffset = ((info->FbMapSize - info->textureSize +
-				RADEON_BUFFER_ALIGN) &
-			       ~(uint32_t)RADEON_BUFFER_ALIGN);
+	info->dri->textureOffset = ((info->FbMapSize - info->dri->textureSize +
+				     RADEON_BUFFER_ALIGN) &
+				    ~(uint32_t)RADEON_BUFFER_ALIGN);
     }
 
     /* Reserve space for the shared depth
      * buffer.
      */
-    info->depthOffset = ((info->textureOffset - depthSize +
-			  RADEON_BUFFER_ALIGN) &
-			 ~(uint32_t)RADEON_BUFFER_ALIGN);
+    info->dri->depthOffset = ((info->dri->textureOffset - depthSize +
+			       RADEON_BUFFER_ALIGN) &
+			      ~(uint32_t)RADEON_BUFFER_ALIGN);
 
     /* Reserve space for the shared back buffer */
-    if (info->noBackBuffer) {
-       info->backOffset = info->depthOffset;
+    if (info->dri->noBackBuffer) {
+       info->dri->backOffset = info->dri->depthOffset;
     } else {
-       info->backOffset = ((info->depthOffset - bufferSize +
-			    RADEON_BUFFER_ALIGN) &
-			   ~(uint32_t)RADEON_BUFFER_ALIGN);
+       info->dri->backOffset = ((info->dri->depthOffset - bufferSize +
+				 RADEON_BUFFER_ALIGN) &
+				~(uint32_t)RADEON_BUFFER_ALIGN);
     }
 
-    info->backY = info->backOffset / width_bytes;
-    info->backX = (info->backOffset - (info->backY * width_bytes)) / cpp;
+    info->dri->backY = info->dri->backOffset / width_bytes;
+    info->dri->backX = (info->dri->backOffset - (info->dri->backY * width_bytes)) / cpp;
 
     scanlines = (info->FbMapSize-info->FbSecureSize) / width_bytes;
     if (scanlines > 8191)
@@ -1236,12 +1201,12 @@ RADEONSetupMemXAA_DRI(int scrnIndex, ScreenPtr pScreen)
 	    /* Lines in offscreen area needed for depth buffer and
 	     * textures
 	     */
-	    info->depthTexLines = (scanlines
-				   - info->depthOffset / width_bytes);
-	    info->backLines	    = (scanlines
-				       - info->backOffset / width_bytes
-				       - info->depthTexLines);
-	    info->backArea	    = NULL;
+	    info->dri->depthTexLines = (scanlines
+					- info->dri->depthOffset / width_bytes);
+	    info->dri->backLines	    = (scanlines
+					       - info->dri->backOffset / width_bytes
+					       - info->dri->depthTexLines);
+	    info->dri->backArea	    = NULL;
 	} else {
 	    xf86DrvMsg(scrnIndex, X_ERROR,
 		       "Unable to determine largest offscreen area "
@@ -1252,30 +1217,30 @@ RADEONSetupMemXAA_DRI(int scrnIndex, ScreenPtr pScreen)
 
     xf86DrvMsg(scrnIndex, X_INFO,
 	       "Will use front buffer at offset 0x%x\n",
-	       info->frontOffset);
+	       info->dri->frontOffset);
 
     xf86DrvMsg(scrnIndex, X_INFO,
 	       "Will use back buffer at offset 0x%x\n",
-	       info->backOffset);
+	       info->dri->backOffset);
     xf86DrvMsg(scrnIndex, X_INFO,
 	       "Will use depth buffer at offset 0x%x\n",
-	       info->depthOffset);
+	       info->dri->depthOffset);
     if (info->cardType==CARD_PCIE)
     	xf86DrvMsg(scrnIndex, X_INFO,
 	           "Will use %d kb for PCI GART table at offset 0x%x\n",
-		   info->pciGartSize/1024, (unsigned)info->pciGartOffset);
+		   info->dri->pciGartSize/1024, (unsigned)info->dri->pciGartOffset);
     xf86DrvMsg(scrnIndex, X_INFO,
 	       "Will use %d kb for textures at offset 0x%x\n",
-	       info->textureSize/1024, info->textureOffset);
+	       info->dri->textureSize/1024, info->dri->textureOffset);
 
-    info->frontPitchOffset = (((info->frontPitch * cpp / 64) << 22) |
-			      ((info->frontOffset + info->fbLocation) >> 10));
+    info->dri->frontPitchOffset = (((info->dri->frontPitch * cpp / 64) << 22) |
+				   ((info->dri->frontOffset + info->fbLocation) >> 10));
 
-    info->backPitchOffset = (((info->backPitch * cpp / 64) << 22) |
-			     ((info->backOffset + info->fbLocation) >> 10));
+    info->dri->backPitchOffset = (((info->dri->backPitch * cpp / 64) << 22) |
+				  ((info->dri->backOffset + info->fbLocation) >> 10));
 
-    info->depthPitchOffset = (((info->depthPitch * depthCpp / 64) << 22) |
-			      ((info->depthOffset + info->fbLocation) >> 10));
+    info->dri->depthPitchOffset = (((info->dri->depthPitch * depthCpp / 64) << 22) |
+				   ((info->dri->depthOffset + info->fbLocation) >> 10));
     return TRUE;
 }
 #endif /* XF86DRI */
diff --git a/src/radeon_accelfuncs.c b/src/radeon_accelfuncs.c
index 56793cd..45eb6d5 100644
--- a/src/radeon_accelfuncs.c
+++ b/src/radeon_accelfuncs.c
@@ -137,14 +137,14 @@ FUNC_NAME(RADEONSetupForSolidFill)(ScrnInfoPtr pScrn,
     ACCEL_PREAMBLE();
 
     /* Save for later clipping */
-    info->dp_gui_master_cntl_clip = (info->dp_gui_master_cntl
-				     | RADEON_GMC_BRUSH_SOLID_COLOR
-				     | RADEON_GMC_SRC_DATATYPE_COLOR
-				     | RADEON_ROP[rop].pattern);
+    info->accel_state->dp_gui_master_cntl_clip = (info->accel_state->dp_gui_master_cntl
+						  | RADEON_GMC_BRUSH_SOLID_COLOR
+						  | RADEON_GMC_SRC_DATATYPE_COLOR
+						  | RADEON_ROP[rop].pattern);
 
     BEGIN_ACCEL(4);
 
-    OUT_ACCEL_REG(RADEON_DP_GUI_MASTER_CNTL, info->dp_gui_master_cntl_clip);
+    OUT_ACCEL_REG(RADEON_DP_GUI_MASTER_CNTL, info->accel_state->dp_gui_master_cntl_clip);
     OUT_ACCEL_REG(RADEON_DP_BRUSH_FRGD_CLR,  color);
     OUT_ACCEL_REG(RADEON_DP_WRITE_MASK,      planemask);
     OUT_ACCEL_REG(RADEON_DP_CNTL,            (RADEON_DST_X_LEFT_TO_RIGHT
@@ -172,7 +172,7 @@ FUNC_NAME(RADEONSubsequentSolidFillRect)(ScrnInfoPtr pScrn,
 
     BEGIN_ACCEL(3);
 
-    OUT_ACCEL_REG(RADEON_DST_PITCH_OFFSET, info->dst_pitch_offset |
+    OUT_ACCEL_REG(RADEON_DST_PITCH_OFFSET, info->accel_state->dst_pitch_offset |
     	((info->tilingEnabled && (y <= pScrn->virtualY)) ? RADEON_DST_TILE_MACRO : 0));
     OUT_ACCEL_REG(RADEON_DST_Y_X,          (y << 16) | x);
     OUT_ACCEL_REG(RADEON_DST_WIDTH_HEIGHT, (w << 16) | h);
@@ -191,10 +191,10 @@ FUNC_NAME(RADEONSetupForSolidLine)(ScrnInfoPtr pScrn,
     ACCEL_PREAMBLE();
 
     /* Save for later clipping */
-    info->dp_gui_master_cntl_clip = (info->dp_gui_master_cntl
-				     | RADEON_GMC_BRUSH_SOLID_COLOR
-				     | RADEON_GMC_SRC_DATATYPE_COLOR
-				     | RADEON_ROP[rop].pattern);
+    info->accel_state->dp_gui_master_cntl_clip = (info->accel_state->dp_gui_master_cntl
+						  | RADEON_GMC_BRUSH_SOLID_COLOR
+						  | RADEON_GMC_SRC_DATATYPE_COLOR
+						  | RADEON_ROP[rop].pattern);
 
     if (info->ChipFamily >= CHIP_FAMILY_RV200) {
 	BEGIN_ACCEL(1);
@@ -205,7 +205,7 @@ FUNC_NAME(RADEONSetupForSolidLine)(ScrnInfoPtr pScrn,
 
     BEGIN_ACCEL(3);
 
-    OUT_ACCEL_REG(RADEON_DP_GUI_MASTER_CNTL, info->dp_gui_master_cntl_clip);
+    OUT_ACCEL_REG(RADEON_DP_GUI_MASTER_CNTL, info->accel_state->dp_gui_master_cntl_clip);
     OUT_ACCEL_REG(RADEON_DP_BRUSH_FRGD_CLR,  color);
     OUT_ACCEL_REG(RADEON_DP_WRITE_MASK,      planemask);
 
@@ -236,7 +236,7 @@ FUNC_NAME(RADEONSubsequentSolidHorVertLine)(ScrnInfoPtr pScrn,
 
     OUT_ACCEL_REG(RADEON_DP_CNTL,          (RADEON_DST_X_LEFT_TO_RIGHT
 					    | RADEON_DST_Y_TOP_TO_BOTTOM));
-    OUT_ACCEL_REG(RADEON_DST_PITCH_OFFSET, info->dst_pitch_offset |
+    OUT_ACCEL_REG(RADEON_DST_PITCH_OFFSET, info->accel_state->dst_pitch_offset |
     	((info->tilingEnabled && (y <= pScrn->virtualY)) ? RADEON_DST_TILE_MACRO : 0));
     OUT_ACCEL_REG(RADEON_DST_Y_X,          (y << 16) | x);
     OUT_ACCEL_REG(RADEON_DST_WIDTH_HEIGHT, (w << 16) | h);
@@ -269,7 +269,7 @@ FUNC_NAME(RADEONSubsequentSolidTwoPointLine)(ScrnInfoPtr pScrn,
 
     BEGIN_ACCEL(3);
 
-    OUT_ACCEL_REG(RADEON_DST_PITCH_OFFSET, info->dst_pitch_offset |
+    OUT_ACCEL_REG(RADEON_DST_PITCH_OFFSET, info->accel_state->dst_pitch_offset |
     	((info->tilingEnabled && (ya <= pScrn->virtualY)) ? RADEON_DST_TILE_MACRO : 0));
     OUT_ACCEL_REG(RADEON_DST_LINE_START, (ya << 16) | xa);
     OUT_ACCEL_REG(RADEON_DST_LINE_END,   (yb << 16) | xb);
@@ -298,8 +298,8 @@ FUNC_NAME(RADEONSetupForDashedLine)(ScrnInfoPtr pScrn,
     ACCEL_PREAMBLE();
 
     /* Save for determining whether or not to draw last pixel */
-    info->dashLen = length;
-    info->dashPattern = pat;
+    info->accel_state->dashLen = length;
+    info->accel_state->dashPattern = pat;
 
 #if X_BYTE_ORDER == X_BIG_ENDIAN
 # define PAT_SHIFT(pat, shift) (pat >> shift)
@@ -315,18 +315,18 @@ FUNC_NAME(RADEONSetupForDashedLine)(ScrnInfoPtr pScrn,
     }
 
     /* Save for later clipping */
-    info->dp_gui_master_cntl_clip = (info->dp_gui_master_cntl
-				     | (bg == -1
-					? RADEON_GMC_BRUSH_32x1_MONO_FG_LA
-					: RADEON_GMC_BRUSH_32x1_MONO_FG_BG)
-				     | RADEON_ROP[rop].pattern
-				     | RADEON_GMC_BYTE_LSB_TO_MSB);
-    info->dash_fg = fg;
-    info->dash_bg = bg;
+    info->accel_state->dp_gui_master_cntl_clip = (info->accel_state->dp_gui_master_cntl
+						  | (bg == -1
+						     ? RADEON_GMC_BRUSH_32x1_MONO_FG_LA
+						     : RADEON_GMC_BRUSH_32x1_MONO_FG_BG)
+						  | RADEON_ROP[rop].pattern
+						  | RADEON_GMC_BYTE_LSB_TO_MSB);
+    info->accel_state->dash_fg = fg;
+    info->accel_state->dash_bg = bg;
 
     BEGIN_ACCEL((bg == -1) ? 4 : 5);
 
-    OUT_ACCEL_REG(RADEON_DP_GUI_MASTER_CNTL, info->dp_gui_master_cntl_clip);
+    OUT_ACCEL_REG(RADEON_DP_GUI_MASTER_CNTL, info->accel_state->dp_gui_master_cntl_clip);
     OUT_ACCEL_REG(RADEON_DP_WRITE_MASK,      planemask);
     OUT_ACCEL_REG(RADEON_DP_BRUSH_FRGD_CLR,  fg);
     if (bg != -1)
@@ -348,7 +348,7 @@ FUNC_NAME(RADEONDashedLastPel)(ScrnInfoPtr pScrn,
 			       int fg)
 {
     RADEONInfoPtr  info = RADEONPTR(pScrn);
-    uint32_t dp_gui_master_cntl = info->dp_gui_master_cntl_clip;
+    uint32_t dp_gui_master_cntl = info->accel_state->dp_gui_master_cntl_clip;
     ACCEL_PREAMBLE();
 
     dp_gui_master_cntl &= ~RADEON_GMC_BRUSH_DATATYPE_MASK;
@@ -362,15 +362,15 @@ FUNC_NAME(RADEONDashedLastPel)(ScrnInfoPtr pScrn,
     OUT_ACCEL_REG(RADEON_DP_GUI_MASTER_CNTL, dp_gui_master_cntl);
     OUT_ACCEL_REG(RADEON_DP_CNTL,            (RADEON_DST_X_LEFT_TO_RIGHT
 					      | RADEON_DST_Y_TOP_TO_BOTTOM));
-    OUT_ACCEL_REG(RADEON_DST_PITCH_OFFSET, info->dst_pitch_offset |
+    OUT_ACCEL_REG(RADEON_DST_PITCH_OFFSET, info->accel_state->dst_pitch_offset |
     	((info->tilingEnabled && (y <= pScrn->virtualY)) ? RADEON_DST_TILE_MACRO : 0));
     OUT_ACCEL_REG(RADEON_DP_BRUSH_FRGD_CLR,  fg);
     OUT_ACCEL_REG(RADEON_DST_Y_X,            (y << 16) | x);
     OUT_ACCEL_REG(RADEON_DST_WIDTH_HEIGHT,   (1 << 16) | 1);
 
     /* Restore old values */
-    OUT_ACCEL_REG(RADEON_DP_GUI_MASTER_CNTL, info->dp_gui_master_cntl_clip);
-    OUT_ACCEL_REG(RADEON_DP_BRUSH_FRGD_CLR,  info->dash_fg);
+    OUT_ACCEL_REG(RADEON_DP_GUI_MASTER_CNTL, info->accel_state->dp_gui_master_cntl_clip);
+    OUT_ACCEL_REG(RADEON_DP_BRUSH_FRGD_CLR,  info->accel_state->dash_fg);
 
     FINISH_ACCEL();
     BEGIN_ACCEL(2);
@@ -402,17 +402,17 @@ FUNC_NAME(RADEONSubsequentDashedTwoPointLine)(ScrnInfoPtr pScrn,
 	else                 shift = deltay;
 
 	shift += phase;
-	shift %= info->dashLen;
+	shift %= info->accel_state->dashLen;
 
-	if ((info->dashPattern >> shift) & 1)
-	    FUNC_NAME(RADEONDashedLastPel)(pScrn, xb, yb, info->dash_fg);
-	else if (info->dash_bg != -1)
-	    FUNC_NAME(RADEONDashedLastPel)(pScrn, xb, yb, info->dash_bg);
+	if ((info->accel_state->dashPattern >> shift) & 1)
+	    FUNC_NAME(RADEONDashedLastPel)(pScrn, xb, yb, info->accel_state->dash_fg);
+	else if (info->accel_state->dash_bg != -1)
+	    FUNC_NAME(RADEONDashedLastPel)(pScrn, xb, yb, info->accel_state->dash_bg);
     }
 
     BEGIN_ACCEL(4);
 
-    OUT_ACCEL_REG(RADEON_DST_PITCH_OFFSET, info->dst_pitch_offset |
+    OUT_ACCEL_REG(RADEON_DST_PITCH_OFFSET, info->accel_state->dst_pitch_offset |
     	((info->tilingEnabled && (ya <= pScrn->virtualY)) ? RADEON_DST_TILE_MACRO : 0));
     OUT_ACCEL_REG(RADEON_DST_LINE_START,   (ya << 16) | xa);
     OUT_ACCEL_REG(RADEON_DST_LINE_PATCOUNT, phase);
@@ -433,7 +433,7 @@ FUNC_NAME(RADEONSetTransparency)(ScrnInfoPtr pScrn,
 {
     RADEONInfoPtr  info = RADEONPTR(pScrn);
 
-    if ((trans_color != -1) || (info->XAAForceTransBlit == TRUE)) {
+    if ((trans_color != -1) || (info->accel_state->XAAForceTransBlit == TRUE)) {
 	ACCEL_PREAMBLE();
 
 	BEGIN_ACCEL(3);
@@ -461,20 +461,20 @@ FUNC_NAME(RADEONSetupForScreenToScreenCopy)(ScrnInfoPtr pScrn,
     RADEONInfoPtr  info = RADEONPTR(pScrn);
     ACCEL_PREAMBLE();
 
-    info->xdir = xdir;
-    info->ydir = ydir;
+    info->accel_state->xdir = xdir;
+    info->accel_state->ydir = ydir;
 
     /* Save for later clipping */
-    info->dp_gui_master_cntl_clip = (info->dp_gui_master_cntl
-				     | RADEON_GMC_BRUSH_NONE
-				     | RADEON_GMC_SRC_DATATYPE_COLOR
-				     | RADEON_ROP[rop].rop
-				     | RADEON_DP_SRC_SOURCE_MEMORY
-				     | RADEON_GMC_SRC_PITCH_OFFSET_CNTL);
+    info->accel_state->dp_gui_master_cntl_clip = (info->accel_state->dp_gui_master_cntl
+						  | RADEON_GMC_BRUSH_NONE
+						  | RADEON_GMC_SRC_DATATYPE_COLOR
+						  | RADEON_ROP[rop].rop
+						  | RADEON_DP_SRC_SOURCE_MEMORY
+						  | RADEON_GMC_SRC_PITCH_OFFSET_CNTL);
 
     BEGIN_ACCEL(3);
 
-    OUT_ACCEL_REG(RADEON_DP_GUI_MASTER_CNTL, info->dp_gui_master_cntl_clip);
+    OUT_ACCEL_REG(RADEON_DP_GUI_MASTER_CNTL, info->accel_state->dp_gui_master_cntl_clip);
     OUT_ACCEL_REG(RADEON_DP_WRITE_MASK,      planemask);
     OUT_ACCEL_REG(RADEON_DP_CNTL,
 		  ((xdir >= 0 ? RADEON_DST_X_LEFT_TO_RIGHT : 0) |
@@ -487,7 +487,7 @@ FUNC_NAME(RADEONSetupForScreenToScreenCopy)(ScrnInfoPtr pScrn,
                   RADEON_WAIT_2D_IDLECLEAN | RADEON_WAIT_DMA_GUI_IDLE);
     FINISH_ACCEL();
 
-    info->trans_color = trans_color;
+    info->accel_state->trans_color = trans_color;
     FUNC_NAME(RADEONSetTransparency)(pScrn, trans_color);
 }
 
@@ -501,14 +501,14 @@ FUNC_NAME(RADEONSubsequentScreenToScreenCopy)(ScrnInfoPtr pScrn,
     RADEONInfoPtr  info = RADEONPTR(pScrn);
     ACCEL_PREAMBLE();
 
-    if (info->xdir < 0) xa += w - 1, xb += w - 1;
-    if (info->ydir < 0) ya += h - 1, yb += h - 1;
+    if (info->accel_state->xdir < 0) xa += w - 1, xb += w - 1;
+    if (info->accel_state->ydir < 0) ya += h - 1, yb += h - 1;
 
     BEGIN_ACCEL(5);
 
-    OUT_ACCEL_REG(RADEON_SRC_PITCH_OFFSET, info->dst_pitch_offset |
+    OUT_ACCEL_REG(RADEON_SRC_PITCH_OFFSET, info->accel_state->dst_pitch_offset |
     	((info->tilingEnabled && (ya <= pScrn->virtualY)) ? RADEON_DST_TILE_MACRO : 0));
-    OUT_ACCEL_REG(RADEON_DST_PITCH_OFFSET, info->dst_pitch_offset |
+    OUT_ACCEL_REG(RADEON_DST_PITCH_OFFSET, info->accel_state->dst_pitch_offset |
     	((info->tilingEnabled && (yb <= pScrn->virtualY)) ? RADEON_DST_TILE_MACRO : 0));
     OUT_ACCEL_REG(RADEON_SRC_Y_X,          (ya << 16) | xa);
     OUT_ACCEL_REG(RADEON_DST_Y_X,          (yb << 16) | xb);
@@ -552,19 +552,19 @@ FUNC_NAME(RADEONSetupForMono8x8PatternFill)(ScrnInfoPtr pScrn,
 #endif
 
     /* Save for later clipping */
-    info->dp_gui_master_cntl_clip = (info->dp_gui_master_cntl
-				     | (bg == -1
-					? RADEON_GMC_BRUSH_8X8_MONO_FG_LA
-					: RADEON_GMC_BRUSH_8X8_MONO_FG_BG)
-				     | RADEON_ROP[rop].pattern
+    info->accel_state->dp_gui_master_cntl_clip = (info->accel_state->dp_gui_master_cntl
+						  | (bg == -1
+						     ? RADEON_GMC_BRUSH_8X8_MONO_FG_LA
+						     : RADEON_GMC_BRUSH_8X8_MONO_FG_BG)
+						  | RADEON_ROP[rop].pattern
 #if X_BYTE_ORDER == X_LITTLE_ENDIAN
-				     | RADEON_GMC_BYTE_MSB_TO_LSB
+						  | RADEON_GMC_BYTE_MSB_TO_LSB
 #endif
-				    );
+						  );
 
     BEGIN_ACCEL((bg == -1) ? 5 : 6);
 
-    OUT_ACCEL_REG(RADEON_DP_GUI_MASTER_CNTL, info->dp_gui_master_cntl_clip);
+    OUT_ACCEL_REG(RADEON_DP_GUI_MASTER_CNTL, info->accel_state->dp_gui_master_cntl_clip);
     OUT_ACCEL_REG(RADEON_DP_WRITE_MASK,      planemask);
     OUT_ACCEL_REG(RADEON_DP_BRUSH_FRGD_CLR,  fg);
     if (bg != -1)
@@ -600,7 +600,7 @@ FUNC_NAME(RADEONSubsequentMono8x8PatternFillRect)(ScrnInfoPtr pScrn,
 
     BEGIN_ACCEL(4);
 
-    OUT_ACCEL_REG(RADEON_DST_PITCH_OFFSET, info->dst_pitch_offset |
+    OUT_ACCEL_REG(RADEON_DST_PITCH_OFFSET, info->accel_state->dst_pitch_offset |
     	((info->tilingEnabled && (y <= pScrn->virtualY)) ? RADEON_DST_TILE_MACRO : 0));
     OUT_ACCEL_REG(RADEON_BRUSH_Y_X,        (patterny << 8) | patternx);
     OUT_ACCEL_REG(RADEON_DST_Y_X,          (y << 16) | x);
@@ -625,21 +625,21 @@ FUNC_NAME(RADEONSetupForColor8x8PatternFill)(ScrnInfoPtr pScrn,
     ACCEL_PREAMBLE();
 
     /* Save for later clipping */
-    info->dp_gui_master_cntl_clip = (info->dp_gui_master_cntl
-				     | RADEON_GMC_BRUSH_8x8_COLOR
-				     | RADEON_GMC_SRC_DATATYPE_COLOR
-				     | RADEON_ROP[rop].pattern
-				     | RADEON_DP_SRC_SOURCE_MEMORY);
+    info->accel_state->dp_gui_master_cntl_clip = (info->accel_state->dp_gui_master_cntl
+						  | RADEON_GMC_BRUSH_8x8_COLOR
+						  | RADEON_GMC_SRC_DATATYPE_COLOR
+						  | RADEON_ROP[rop].pattern
+						  | RADEON_DP_SRC_SOURCE_MEMORY);
 
     BEGIN_ACCEL(3);
 
-    OUT_ACCEL_REG(RADEON_DP_GUI_MASTER_CNTL, info->dp_gui_master_cntl_clip);
+    OUT_ACCEL_REG(RADEON_DP_GUI_MASTER_CNTL, info->accel_state->dp_gui_master_cntl_clip);
     OUT_ACCEL_REG(RADEON_DP_WRITE_MASK,      planemask);
     OUT_ACCEL_REG(RADEON_SRC_Y_X,            (paty << 16) | patx);
 
     FINISH_ACCEL();
 
-    info->trans_color = trans_color;
+    info->accel_state->trans_color = trans_color;
     FUNC_NAME(RADEONSetTransparency)(pScrn, trans_color);
 }
 
@@ -655,7 +655,7 @@ FUNC_NAME(RADEONSubsequentColor8x8PatternFillRect)(ScrnInfoPtr pScrn,
 
     BEGIN_ACCEL(4);
 
-    OUT_ACCEL_REG(RADEON_DST_PITCH_OFFSET, info->dst_pitch_offset |
+    OUT_ACCEL_REG(RADEON_DST_PITCH_OFFSET, info->accel_state->dst_pitch_offset |
     	((info->tilingEnabled && (y <= pScrn->virtualY)) ? RADEON_DST_TILE_MACRO : 0));
     OUT_ACCEL_REG(RADEON_BRUSH_Y_X,        (paty << 16) | patx);
     OUT_ACCEL_REG(RADEON_DST_Y_X,          (y << 16) | x);
@@ -666,7 +666,7 @@ FUNC_NAME(RADEONSubsequentColor8x8PatternFillRect)(ScrnInfoPtr pScrn,
 #endif
 
 #ifdef ACCEL_CP
-#define CP_BUFSIZE (info->indirectBuffer->total/4-10)
+#define CP_BUFSIZE (info->cp->indirectBuffer->total/4-10)
 
 /* Helper function to write out a HOSTDATA_BLT packet into the indirect
  * buffer and set the XAA scratch buffer address appropriately.
@@ -675,41 +675,41 @@ static void
 RADEONCPScanlinePacket(ScrnInfoPtr pScrn, int bufno)
 {
     RADEONInfoPtr info = RADEONPTR(pScrn);
-    int           chunk_words = info->scanline_hpass * info->scanline_words;
+    int           chunk_words = info->accel_state->scanline_hpass * info->accel_state->scanline_words;
     ACCEL_PREAMBLE();
 
     if (RADEON_VERBOSE) {
 	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 		   "CPScanline Packet h=%d hpass=%d chunkwords=%d\n",
-		   info->scanline_h, info->scanline_hpass, chunk_words);
+		   info->accel_state->scanline_h, info->accel_state->scanline_hpass, chunk_words);
     }
     BEGIN_RING(chunk_words+10);
 
     OUT_RING(CP_PACKET3(RADEON_CP_PACKET3_CNTL_HOSTDATA_BLT,chunk_words+10-2));
-    OUT_RING(info->dp_gui_master_cntl_clip);
-    OUT_RING(info->dst_pitch_offset |
-    	((info->tilingEnabled && (info->scanline_y <= pScrn->virtualY)) ? RADEON_DST_TILE_MACRO : 0));
-    OUT_RING((info->scanline_y << 16) |
-	     (info->scanline_x1clip & 0xffff));
-    OUT_RING(((info->scanline_y+info->scanline_hpass) << 16) |
-	     (info->scanline_x2clip & 0xffff));
-    OUT_RING(info->scanline_fg);
-    OUT_RING(info->scanline_bg);
-    OUT_RING((info->scanline_y << 16) |
-	     (info->scanline_x & 0xffff));
-    OUT_RING((info->scanline_hpass << 16) |
-	     (info->scanline_w & 0xffff));
+    OUT_RING(info->accel_state->dp_gui_master_cntl_clip);
+    OUT_RING(info->accel_state->dst_pitch_offset |
+    	((info->tilingEnabled && (info->accel_state->scanline_y <= pScrn->virtualY)) ? RADEON_DST_TILE_MACRO : 0));
+    OUT_RING((info->accel_state->scanline_y << 16) |
+	     (info->accel_state->scanline_x1clip & 0xffff));
+    OUT_RING(((info->accel_state->scanline_y+info->accel_state->scanline_hpass) << 16) |
+	     (info->accel_state->scanline_x2clip & 0xffff));
+    OUT_RING(info->accel_state->scanline_fg);
+    OUT_RING(info->accel_state->scanline_bg);
+    OUT_RING((info->accel_state->scanline_y << 16) |
+	     (info->accel_state->scanline_x & 0xffff));
+    OUT_RING((info->accel_state->scanline_hpass << 16) |
+	     (info->accel_state->scanline_w & 0xffff));
     OUT_RING(chunk_words);
 
-    info->scratch_buffer[bufno] = (unsigned char *)&__head[__count];
+    info->accel_state->scratch_buffer[bufno] = (unsigned char *)&__head[__count];
     __count += chunk_words;
 
     /* The ring can only be advanced after the __head and __count have
        been adjusted above */
     FINISH_ACCEL();
 
-    info->scanline_y += info->scanline_hpass;
-    info->scanline_h -= info->scanline_hpass;
+    info->accel_state->scanline_y += info->accel_state->scanline_hpass;
+    info->accel_state->scanline_h -= info->accel_state->scanline_hpass;
 }
 #endif
 
@@ -729,22 +729,22 @@ FUNC_NAME(RADEONSetupForScanlineCPUToScreenColorExpandFill)(ScrnInfoPtr pScrn,
     RADEONInfoPtr  info = RADEONPTR(pScrn);
     ACCEL_PREAMBLE();
 
-    info->scanline_bpp = 0;
+    info->accel_state->scanline_bpp = 0;
 
     /* Save for later clipping */
-    info->dp_gui_master_cntl_clip = (info->dp_gui_master_cntl
-				     | RADEON_GMC_DST_CLIPPING
-				     | RADEON_GMC_BRUSH_NONE
-				     | (bg == -1
-					? RADEON_GMC_SRC_DATATYPE_MONO_FG_LA
-					: RADEON_GMC_SRC_DATATYPE_MONO_FG_BG)
-				     | RADEON_ROP[rop].rop
+    info->accel_state->dp_gui_master_cntl_clip = (info->accel_state->dp_gui_master_cntl
+						  | RADEON_GMC_DST_CLIPPING
+						  | RADEON_GMC_BRUSH_NONE
+						  | (bg == -1
+						     ? RADEON_GMC_SRC_DATATYPE_MONO_FG_LA
+						     : RADEON_GMC_SRC_DATATYPE_MONO_FG_BG)
+						  | RADEON_ROP[rop].rop
 #if X_BYTE_ORDER == X_LITTLE_ENDIAN
-				     | RADEON_GMC_BYTE_LSB_TO_MSB
+						  | RADEON_GMC_BYTE_LSB_TO_MSB
 #else
-				     | RADEON_GMC_BYTE_MSB_TO_LSB
+						  | RADEON_GMC_BYTE_MSB_TO_LSB
 #endif
-				     | RADEON_DP_SRC_SOURCE_HOST_DATA);
+						  | RADEON_DP_SRC_SOURCE_HOST_DATA);
 
 #ifdef ACCEL_MMIO
 
@@ -755,15 +755,15 @@ FUNC_NAME(RADEONSetupForScanlineCPUToScreenColorExpandFill)(ScrnInfoPtr pScrn,
 
     OUT_ACCEL_REG(RADEON_RBBM_GUICNTL,       RADEON_HOST_DATA_SWAP_NONE);
 #endif
-    OUT_ACCEL_REG(RADEON_DP_GUI_MASTER_CNTL, info->dp_gui_master_cntl_clip);
+    OUT_ACCEL_REG(RADEON_DP_GUI_MASTER_CNTL, info->accel_state->dp_gui_master_cntl_clip);
     OUT_ACCEL_REG(RADEON_DP_WRITE_MASK,      planemask);
     OUT_ACCEL_REG(RADEON_DP_SRC_FRGD_CLR,    fg);
     OUT_ACCEL_REG(RADEON_DP_SRC_BKGD_CLR,    bg);
 
 #else /* ACCEL_CP */
 
-    info->scanline_fg = fg;
-    info->scanline_bg = bg;
+    info->accel_state->scanline_fg = fg;
+    info->accel_state->scanline_bg = bg;
 
 #if X_BYTE_ORDER == X_LITTLE_ENDIAN
     BEGIN_ACCEL(1);
@@ -796,31 +796,31 @@ FUNC_NAME(RADEONSubsequentScanlineCPUToScreenColorExpandFill)(ScrnInfoPtr
 #ifdef ACCEL_MMIO
     ACCEL_PREAMBLE();
 
-    info->scanline_h      = h;
-    info->scanline_words  = (w + 31) >> 5;
+    info->accel_state->scanline_h      = h;
+    info->accel_state->scanline_words  = (w + 31) >> 5;
 
 #ifdef __alpha__
     /* Always use indirect for Alpha */
     if (0)
 #else
-    if ((info->scanline_words * h) <= 9)
+    if ((info->accel_state->scanline_words * h) <= 9)
 #endif
     {
 	/* Turn on direct for less than 9 dword colour expansion */
-	info->scratch_buffer[0] =
+	info->accel_state->scratch_buffer[0] =
 	    (unsigned char *)(ADDRREG(RADEON_HOST_DATA_LAST)
-			      - (info->scanline_words - 1));
-	info->scanline_direct   = 1;
+			      - (info->accel_state->scanline_words - 1));
+	info->accel_state->scanline_direct   = 1;
     } else {
 	/* Use indirect for anything else */
-	info->scratch_buffer[0] = info->scratch_save;
-	info->scanline_direct   = 0;
+	info->accel_state->scratch_buffer[0] = info->accel_state->scratch_save;
+	info->accel_state->scanline_direct   = 0;
     }
 
-    BEGIN_ACCEL(5 + (info->scanline_direct ?
-		     (info->scanline_words * h) : 0));
+    BEGIN_ACCEL(5 + (info->accel_state->scanline_direct ?
+		     (info->accel_state->scanline_words * h) : 0));
 
-    OUT_ACCEL_REG(RADEON_DST_PITCH_OFFSET, info->dst_pitch_offset |
+    OUT_ACCEL_REG(RADEON_DST_PITCH_OFFSET, info->accel_state->dst_pitch_offset |
     	((info->tilingEnabled && (y <= pScrn->virtualY)) ? RADEON_DST_TILE_MACRO : 0));
     OUT_ACCEL_REG(RADEON_SC_TOP_LEFT,      (y << 16)     | ((x+skipleft)
 							    & 0xffff));
@@ -833,17 +833,17 @@ FUNC_NAME(RADEONSubsequentScanlineCPUToScreenColorExpandFill)(ScrnInfoPtr
 
 #else /* ACCEL_CP */
 
-    info->scanline_x      = x;
-    info->scanline_y      = y;
+    info->accel_state->scanline_x      = x;
+    info->accel_state->scanline_y      = y;
     /* Have to pad the width here and use clipping engine */
-    info->scanline_w      = (w + 31) & ~31;
-    info->scanline_h      = h;
+    info->accel_state->scanline_w      = (w + 31) & ~31;
+    info->accel_state->scanline_h      = h;
 
-    info->scanline_x1clip = x + skipleft;
-    info->scanline_x2clip = x + w;
+    info->accel_state->scanline_x1clip = x + skipleft;
+    info->accel_state->scanline_x2clip = x + w;
 
-    info->scanline_words  = info->scanline_w / 32;
-    info->scanline_hpass  = min(h,(CP_BUFSIZE/info->scanline_words));
+    info->accel_state->scanline_words  = info->accel_state->scanline_w / 32;
+    info->accel_state->scanline_hpass  = min(h,(CP_BUFSIZE/info->accel_state->scanline_words));
 
     RADEONCPScanlinePacket(pScrn, 0);
 
@@ -859,21 +859,21 @@ FUNC_NAME(RADEONSubsequentScanline)(ScrnInfoPtr pScrn,
 {
     RADEONInfoPtr    info = RADEONPTR(pScrn);
 #ifdef ACCEL_MMIO
-    uint32_t        *p    = (pointer)info->scratch_buffer[bufno];
+    uint32_t        *p    = (pointer)info->accel_state->scratch_buffer[bufno];
     int              i;
-    int              left = info->scanline_words;
+    int              left = info->accel_state->scanline_words;
     volatile uint32_t *d;
     ACCEL_PREAMBLE();
 
-    if (info->scanline_direct) return;
+    if (info->accel_state->scanline_direct) return;
 
-    --info->scanline_h;
+    --info->accel_state->scanline_h;
 
     while (left) {
 	write_mem_barrier();
 	if (left <= 8) {
 	  /* Last scanline - finish write to DATA_LAST */
-	  if (info->scanline_h == 0) {
+	  if (info->accel_state->scanline_h == 0) {
 	    BEGIN_ACCEL(left);
 				/* Unrolling doesn't improve performance */
 	    for (d = ADDRREG(RADEON_HOST_DATA_LAST) - (left - 1); left; --left)
@@ -900,25 +900,25 @@ FUNC_NAME(RADEONSubsequentScanline)(ScrnInfoPtr pScrn,
 
 #if X_BYTE_ORDER == X_BIG_ENDIAN
     if (info->ChipFamily >= CHIP_FAMILY_R300) {
-	if (info->scanline_bpp == 16) {
-	    RADEONCopySwap(info->scratch_buffer[bufno],
-			   info->scratch_buffer[bufno],
-			   info->scanline_words << 2,
+	if (info->accel_state->scanline_bpp == 16) {
+	    RADEONCopySwap(info->accel_state->scratch_buffer[bufno],
+			   info->accel_state->scratch_buffer[bufno],
+			   info->accel_state->scanline_words << 2,
 			   RADEON_HOST_DATA_SWAP_HDW);
-	} else if (info->scanline_bpp < 15) {
-	    RADEONCopySwap(info->scratch_buffer[bufno],
-			   info->scratch_buffer[bufno],
-			   info->scanline_words << 2,
+	} else if (info->accel_state->scanline_bpp < 15) {
+	    RADEONCopySwap(info->accel_state->scratch_buffer[bufno],
+			   info->accel_state->scratch_buffer[bufno],
+			   info->accel_state->scanline_words << 2,
 			   RADEON_HOST_DATA_SWAP_32BIT);
 	}
     }
 #endif
 
-    if (--info->scanline_hpass) {
-	info->scratch_buffer[bufno] += 4 * info->scanline_words;
-    } else if (info->scanline_h) {
-	info->scanline_hpass =
-	    min(info->scanline_h,(CP_BUFSIZE/info->scanline_words));
+    if (--info->accel_state->scanline_hpass) {
+	info->accel_state->scratch_buffer[bufno] += 4 * info->accel_state->scanline_words;
+    } else if (info->accel_state->scanline_h) {
+	info->accel_state->scanline_hpass =
+	    min(info->accel_state->scanline_h,(CP_BUFSIZE/info->accel_state->scanline_words));
 	RADEONCPScanlinePacket(pScrn, bufno);
     }
 
@@ -937,16 +937,16 @@ FUNC_NAME(RADEONSetupForScanlineImageWrite)(ScrnInfoPtr pScrn,
     RADEONInfoPtr  info = RADEONPTR(pScrn);
     ACCEL_PREAMBLE();
 
-    info->scanline_bpp = bpp;
+    info->accel_state->scanline_bpp = bpp;
 
     /* Save for later clipping */
-    info->dp_gui_master_cntl_clip = (info->dp_gui_master_cntl
-				     | RADEON_GMC_DST_CLIPPING
-				     | RADEON_GMC_BRUSH_NONE
-				     | RADEON_GMC_SRC_DATATYPE_COLOR
-				     | RADEON_ROP[rop].rop
-				     | RADEON_GMC_BYTE_MSB_TO_LSB
-				     | RADEON_DP_SRC_SOURCE_HOST_DATA);
+    info->accel_state->dp_gui_master_cntl_clip = (info->accel_state->dp_gui_master_cntl
+						  | RADEON_GMC_DST_CLIPPING
+						  | RADEON_GMC_BRUSH_NONE
+						  | RADEON_GMC_SRC_DATATYPE_COLOR
+						  | RADEON_ROP[rop].rop
+						  | RADEON_GMC_BYTE_MSB_TO_LSB
+						  | RADEON_DP_SRC_SOURCE_HOST_DATA);
 
 #ifdef ACCEL_MMIO
 
@@ -962,7 +962,7 @@ FUNC_NAME(RADEONSetupForScanlineImageWrite)(ScrnInfoPtr pScrn,
     else
 	OUT_ACCEL_REG(RADEON_RBBM_GUICNTL,   RADEON_HOST_DATA_SWAP_NONE);
 #endif
-    OUT_ACCEL_REG(RADEON_DP_GUI_MASTER_CNTL, info->dp_gui_master_cntl_clip);
+    OUT_ACCEL_REG(RADEON_DP_GUI_MASTER_CNTL, info->accel_state->dp_gui_master_cntl_clip);
 
 #else /* ACCEL_CP */
 
@@ -984,7 +984,7 @@ FUNC_NAME(RADEONSetupForScanlineImageWrite)(ScrnInfoPtr pScrn,
 
     FINISH_ACCEL();
 
-    info->trans_color = trans_color;
+    info->accel_state->trans_color = trans_color;
     FUNC_NAME(RADEONSetTransparency)(pScrn, trans_color);
 }
 
@@ -1007,31 +1007,31 @@ FUNC_NAME(RADEONSubsequentScanlineImageWriteRect)(ScrnInfoPtr pScrn,
     if (pScrn->bitsPerPixel == 8) shift = 3;
     else if (pScrn->bitsPerPixel == 16) shift = 1;
 
-    info->scanline_h      = h;
-    info->scanline_words  = (w * info->scanline_bpp + 31) >> 5;
+    info->accel_state->scanline_h      = h;
+    info->accel_state->scanline_words  = (w * info->accel_state->scanline_bpp + 31) >> 5;
 
 #ifdef __alpha__
     /* Always use indirect for Alpha */
     if (0)
 #else
-    if ((info->scanline_words * h) <= 9)
+    if ((info->accel_state->scanline_words * h) <= 9)
 #endif
     {
 	/* Turn on direct for less than 9 dword colour expansion */
-	info->scratch_buffer[0]
+	info->accel_state->scratch_buffer[0]
 	    = (unsigned char *)(ADDRREG(RADEON_HOST_DATA_LAST)
-				- (info->scanline_words - 1));
-	info->scanline_direct = 1;
+				- (info->accel_state->scanline_words - 1));
+	info->accel_state->scanline_direct = 1;
     } else {
 	/* Use indirect for anything else */
-	info->scratch_buffer[0] = info->scratch_save;
-	info->scanline_direct = 0;
+	info->accel_state->scratch_buffer[0] = info->accel_state->scratch_save;
+	info->accel_state->scanline_direct = 0;
     }
 
-    BEGIN_ACCEL(5 + (info->scanline_direct ?
-		     (info->scanline_words * h) : 0));
+    BEGIN_ACCEL(5 + (info->accel_state->scanline_direct ?
+		     (info->accel_state->scanline_words * h) : 0));
 
-    OUT_ACCEL_REG(RADEON_DST_PITCH_OFFSET, info->dst_pitch_offset |
+    OUT_ACCEL_REG(RADEON_DST_PITCH_OFFSET, info->accel_state->dst_pitch_offset |
     	((info->tilingEnabled && (y <= pScrn->virtualY)) ? RADEON_DST_TILE_MACRO : 0));
     OUT_ACCEL_REG(RADEON_SC_TOP_LEFT,      (y << 16)     | ((x+skipleft)
 							    & 0xffff));
@@ -1050,17 +1050,17 @@ FUNC_NAME(RADEONSubsequentScanlineImageWriteRect)(ScrnInfoPtr pScrn,
     if (pScrn->bitsPerPixel == 8)       pad = 3;
     else if (pScrn->bitsPerPixel == 16) pad = 1;
 
-    info->scanline_x      = x;
-    info->scanline_y      = y;
+    info->accel_state->scanline_x      = x;
+    info->accel_state->scanline_y      = y;
     /* Have to pad the width here and use clipping engine */
-    info->scanline_w      = (w + pad) & ~pad;
-    info->scanline_h      = h;
+    info->accel_state->scanline_w      = (w + pad) & ~pad;
+    info->accel_state->scanline_h      = h;
 
-    info->scanline_x1clip = x + skipleft;
-    info->scanline_x2clip = x + w;
+    info->accel_state->scanline_x1clip = x + skipleft;
+    info->accel_state->scanline_x2clip = x + w;
 
-    info->scanline_words  = (w * info->scanline_bpp + 31) / 32;
-    info->scanline_hpass  = min(h,(CP_BUFSIZE/info->scanline_words));
+    info->accel_state->scanline_words  = (w * info->accel_state->scanline_bpp + 31) / 32;
+    info->accel_state->scanline_hpass  = min(h,(CP_BUFSIZE/info->accel_state->scanline_words));
 
     RADEONCPScanlinePacket(pScrn, 0);
 
@@ -1110,7 +1110,7 @@ FUNC_NAME(RADEONSetClippingRectangle)(ScrnInfoPtr pScrn,
 
     BEGIN_ACCEL(3);
 
-    OUT_ACCEL_REG(RADEON_DP_GUI_MASTER_CNTL, (info->dp_gui_master_cntl_clip
+    OUT_ACCEL_REG(RADEON_DP_GUI_MASTER_CNTL, (info->accel_state->dp_gui_master_cntl_clip
 					      | RADEON_GMC_DST_CLIPPING));
     OUT_ACCEL_REG(RADEON_SC_TOP_LEFT,        tmp1);
     OUT_ACCEL_REG(RADEON_SC_BOTTOM_RIGHT,    tmp2);
@@ -1122,7 +1122,7 @@ FUNC_NAME(RADEONSetClippingRectangle)(ScrnInfoPtr pScrn,
                   RADEON_WAIT_2D_IDLECLEAN | RADEON_WAIT_DMA_GUI_IDLE);
     FINISH_ACCEL();
 
-    FUNC_NAME(RADEONSetTransparency)(pScrn, info->trans_color);
+    FUNC_NAME(RADEONSetTransparency)(pScrn, info->accel_state->trans_color);
 }
 
 /* Disable the clipping rectangle */
@@ -1134,7 +1134,7 @@ FUNC_NAME(RADEONDisableClipping)(ScrnInfoPtr pScrn)
 
     BEGIN_ACCEL(3);
 
-    OUT_ACCEL_REG(RADEON_DP_GUI_MASTER_CNTL, info->dp_gui_master_cntl_clip);
+    OUT_ACCEL_REG(RADEON_DP_GUI_MASTER_CNTL, info->accel_state->dp_gui_master_cntl_clip);
     OUT_ACCEL_REG(RADEON_SC_TOP_LEFT,        0);
     OUT_ACCEL_REG(RADEON_SC_BOTTOM_RIGHT,    (RADEON_DEFAULT_SC_RIGHT_MAX |
 					      RADEON_DEFAULT_SC_BOTTOM_MAX));
@@ -1146,7 +1146,7 @@ FUNC_NAME(RADEONDisableClipping)(ScrnInfoPtr pScrn)
                   RADEON_WAIT_2D_IDLECLEAN | RADEON_WAIT_DMA_GUI_IDLE);
     FINISH_ACCEL();
 
-    FUNC_NAME(RADEONSetTransparency)(pScrn, info->trans_color);
+    FUNC_NAME(RADEONSetTransparency)(pScrn, info->accel_state->trans_color);
 }
 
 void
@@ -1203,12 +1203,12 @@ FUNC_NAME(RADEONAccelInit)(ScreenPtr pScreen, XAAInfoRecPtr a)
 	   | ROP_NEEDS_SOURCE
 	   | LEFT_EDGE_CLIPPING_NEGATIVE_X);
     a->NumScanlineColorExpandBuffers    = 1;
-    a->ScanlineColorExpandBuffers       = info->scratch_buffer;
-    if (!info->scratch_save)
-	info->scratch_save
+    a->ScanlineColorExpandBuffers       = info->accel_state->scratch_buffer;
+    if (!info->accel_state->scratch_save)
+	info->accel_state->scratch_save
 	    = xalloc(((pScrn->virtualX+31)/32*4)
 		     + (pScrn->virtualX * info->CurrentLayout.pixel_bytes));
-    info->scratch_buffer[0]             = info->scratch_save;
+    info->accel_state->scratch_buffer[0]             = info->accel_state->scratch_save;
     a->SetupForScanlineCPUToScreenColorExpandFill
 	= FUNC_NAME(RADEONSetupForScanlineCPUToScreenColorExpandFill);
     a->SubsequentScanlineCPUToScreenColorExpandFill
@@ -1299,7 +1299,7 @@ FUNC_NAME(RADEONAccelInit)(ScreenPtr pScreen, XAAInfoRecPtr a)
 
 				/* ImageWrite */
     a->NumScanlineImageWriteBuffers     = 1;
-    a->ScanlineImageWriteBuffers        = info->scratch_buffer;
+    a->ScanlineImageWriteBuffers        = info->accel_state->scratch_buffer;
     a->SetupForScanlineImageWrite
 	= FUNC_NAME(RADEONSetupForScanlineImageWrite);
     a->SubsequentScanlineImageWriteRect
diff --git a/src/radeon_atombios.c b/src/radeon_atombios.c
index 20aa722..f0a3a31 100644
--- a/src/radeon_atombios.c
+++ b/src/radeon_atombios.c
@@ -501,11 +501,11 @@ rhdAtomASICInit(atomBiosHandlePtr handle)
     RHDAtomBiosFunc(handle->scrnIndex, handle,
 		    GET_DEFAULT_ENGINE_CLOCK,
 		    &data);
-    asicInit.sASICInitClocks.ulDefaultEngineClock = data.val / 10;/*in 10 Khz*/
+    asicInit.sASICInitClocks.ulDefaultEngineClock = cpu_to_le32(data.val / 10);/*in 10 Khz*/
     RHDAtomBiosFunc(handle->scrnIndex, handle,
 		    GET_DEFAULT_MEMORY_CLOCK,
 		    &data);
-    asicInit.sASICInitClocks.ulDefaultMemoryClock = data.val / 10;/*in 10 Khz*/
+    asicInit.sASICInitClocks.ulDefaultMemoryClock = cpu_to_le32(data.val / 10);/*in 10 Khz*/
     data.exec.dataSpace = NULL;
     data.exec.index = 0x0;
     data.exec.pspace = &asicInit;
@@ -609,17 +609,6 @@ rhdAtomInit(atomBiosHandlePtr unused1, AtomBiosRequestID unused2,
 #endif
     handle->BIOSImageSize = BIOSImageSize;
 
-# if ATOM_BIOS_PARSER
-    /* Try to find out if BIOS has been posted (either by system or int10 */
-    if (!rhdAtomGetFbBaseAndSize(handle, NULL, NULL)) {
-	/* run AsicInit */
-	if (!rhdAtomASICInit(handle))
-	    xf86DrvMsg(scrnIndex, X_WARNING,
-		       "%s: AsicInit failed. Won't be able to obtain in VRAM "
-		       "FB scratch space\n",__func__);
-    }
-# endif
-
     data->atomhandle = handle;
     return ATOM_SUCCESS;
 
@@ -654,12 +643,18 @@ rhdAtomVramInfoQuery(atomBiosHandlePtr handle, AtomBiosRequestID func,
 
     switch (func) {
 	case GET_FW_FB_START:
-	    *val = le32_to_cpu(atomDataPtr->VRAM_UsageByFirmware
-			       ->asFirmwareVramReserveInfo[0].ulStartAddrUsedByFirmware);
+	    if (atomDataPtr->VRAM_UsageByFirmware)
+		*val = le32_to_cpu(atomDataPtr->VRAM_UsageByFirmware
+				   ->asFirmwareVramReserveInfo[0].ulStartAddrUsedByFirmware);
+	    else
+		return ATOM_NOT_IMPLEMENTED;
 	    break;
 	case GET_FW_FB_SIZE:
-	    *val =  le16_to_cpu(atomDataPtr->VRAM_UsageByFirmware
-				->asFirmwareVramReserveInfo[0].usFirmwareUseInKb);
+	    if (atomDataPtr->VRAM_UsageByFirmware)
+		*val =  le16_to_cpu(atomDataPtr->VRAM_UsageByFirmware
+				    ->asFirmwareVramReserveInfo[0].usFirmwareUseInKb);
+	    else
+		return ATOM_NOT_IMPLEMENTED;
 	    break;
 	default:
 	    return ATOM_NOT_IMPLEMENTED;
@@ -1391,36 +1386,6 @@ const int object_connector_convert[] =
       CONNECTOR_DISPLAY_PORT,
     };
 
-static void
-rhdAtomParseI2CRecord(atomBiosHandlePtr handle,
-			ATOM_I2C_RECORD *Record, int *ddc_line)
-{
-    ErrorF(" %s:  I2C Record: %s[%x] EngineID: %x I2CAddr: %x\n",
-	     __func__,
-	     Record->sucI2cId.bfHW_Capable ? "HW_Line" : "GPIO_ID",
-	     Record->sucI2cId.bfI2C_LineMux,
-	     Record->sucI2cId.bfHW_EngineID,
-	     Record->ucI2CAddr);
-
-    if (!*(unsigned char *)&(Record->sucI2cId))
-	*ddc_line = 0;
-    else {
-	if (Record->ucI2CAddr != 0)
-	    return;
-
-	if (Record->sucI2cId.bfHW_Capable) {
-	    switch(Record->sucI2cId.bfI2C_LineMux) {
-	    case 0: *ddc_line = 0x7e40; break;
-	    case 1: *ddc_line = 0x7e50; break;
-	    case 2: *ddc_line = 0x7e30; break;
-	    default: break;
-	    }
-	    return;
-	} else {
-	    /* add GPIO pin parsing */
-	}
-    }
-}
 
 static RADEONI2CBusRec
 RADEONLookupGPIOLineForDDC(ScrnInfoPtr pScrn, uint8_t id)
@@ -1450,12 +1415,16 @@ RADEONLookupGPIOLineForDDC(ScrnInfoPtr pScrn, uint8_t id)
     i2c.put_data_reg = le16_to_cpu(gpio.usDataEnRegisterIndex) * 4;
     i2c.get_clk_reg = le16_to_cpu(gpio.usClkY_RegisterIndex) * 4;
     i2c.get_data_reg = le16_to_cpu(gpio.usDataY_RegisterIndex) * 4;
+    i2c.a_clk_reg = le16_to_cpu(gpio.usClkA_RegisterIndex) * 4;
+    i2c.a_data_reg = le16_to_cpu(gpio.usDataA_RegisterIndex) * 4;
     i2c.mask_clk_mask = (1 << gpio.ucClkMaskShift);
     i2c.mask_data_mask = (1 << gpio.ucDataMaskShift);
     i2c.put_clk_mask = (1 << gpio.ucClkEnShift);
     i2c.put_data_mask = (1 << gpio.ucDataEnShift);
     i2c.get_clk_mask = (1 << gpio.ucClkY_Shift);
     i2c.get_data_mask = (1 <<  gpio.ucDataY_Shift);
+    i2c.a_clk_mask = (1 << gpio.ucClkA_Shift);
+    i2c.a_data_mask = (1 <<  gpio.ucDataA_Shift);
     i2c.valid = TRUE;
 
 #if 0
@@ -1465,21 +1434,28 @@ RADEONLookupGPIOLineForDDC(ScrnInfoPtr pScrn, uint8_t id)
     ErrorF("put_data_reg: 0x%x\n", gpio.usDataEnRegisterIndex * 4);
     ErrorF("get_clk_reg: 0x%x\n", gpio.usClkY_RegisterIndex * 4);
     ErrorF("get_data_reg: 0x%x\n", gpio.usDataY_RegisterIndex * 4);
-    ErrorF("other_clk_reg: 0x%x\n", gpio.usClkA_RegisterIndex * 4);
-    ErrorF("other_data_reg: 0x%x\n", gpio.usDataA_RegisterIndex * 4);
+    ErrorF("a_clk_reg: 0x%x\n", gpio.usClkA_RegisterIndex * 4);
+    ErrorF("a_data_reg: 0x%x\n", gpio.usDataA_RegisterIndex * 4);
     ErrorF("mask_clk_mask: %d\n", gpio.ucClkMaskShift);
     ErrorF("mask_data_mask: %d\n", gpio.ucDataMaskShift);
     ErrorF("put_clk_mask: %d\n", gpio.ucClkEnShift);
     ErrorF("put_data_mask: %d\n", gpio.ucDataEnShift);
     ErrorF("get_clk_mask: %d\n", gpio.ucClkY_Shift);
     ErrorF("get_data_mask: %d\n", gpio.ucDataY_Shift);
-    ErrorF("other_clk_mask: %d\n", gpio.ucClkA_Shift);
-    ErrorF("other_data_mask: %d\n", gpio.ucDataA_Shift);
+    ErrorF("a_clk_mask: %d\n", gpio.ucClkA_Shift);
+    ErrorF("a_data_mask: %d\n", gpio.ucDataA_Shift);
 #endif
 
     return i2c;
 }
 
+static RADEONI2CBusRec
+rhdAtomParseI2CRecord(ScrnInfoPtr pScrn, atomBiosHandlePtr handle,
+			ATOM_I2C_RECORD *Record)
+{
+    return RADEONLookupGPIOLineForDDC(pScrn, Record->sucI2cId.bfI2C_LineMux);
+}
+
 Bool
 RADEONGetATOMConnectorInfoFromBIOSObject (ScrnInfoPtr pScrn)
 {
@@ -1489,7 +1465,7 @@ RADEONGetATOMConnectorInfoFromBIOSObject (ScrnInfoPtr pScrn)
     atomDataTablesPtr atomDataPtr;
     ATOM_CONNECTOR_OBJECT_TABLE *con_obj;
     ATOM_INTEGRATED_SYSTEM_INFO_V2 *igp_obj = NULL;
-    int i, j, ddc_line = 0;
+    int i, j;
 
     atomDataPtr = info->atomBIOS->atomDataPtr;
     if (!rhdAtomGetTableRevisionAndSize((ATOM_COMMON_TABLE_HEADER *)(atomDataPtr->Object_Header), &crev, &frev, &size))
@@ -1617,10 +1593,8 @@ RADEONGetATOMConnectorInfoFromBIOSObject (ScrnInfoPtr pScrn)
 	    ErrorF("record type %d\n", Record->ucRecordType);
 	    switch (Record->ucRecordType) {
 		case ATOM_I2C_RECORD_TYPE:
-		    rhdAtomParseI2CRecord(info->atomBIOS,
-					  (ATOM_I2C_RECORD *)Record,
-					  &ddc_line);
-		    info->BiosConnector[i].ddc_i2c = atom_setup_i2c_bus(ddc_line);
+		    info->BiosConnector[i].ddc_i2c = rhdAtomParseI2CRecord(pScrn, info->atomBIOS,
+									   (ATOM_I2C_RECORD *)Record);
 		    break;
 		case ATOM_HPD_INT_RECORD_TYPE:
 		    break;
@@ -1751,6 +1725,15 @@ static void RADEONApplyATOMQuirks(ScrnInfoPtr pScrn, int index)
 	}
     }
 
+    /* Falcon NW laptop lists vga ddc line for LVDS */
+    if ((info->Chipset == PCI_CHIP_RV410_5653) &&
+	(PCI_SUB_VENDOR_ID(info->PciInfo) == 0x1462) &&
+	(PCI_SUB_DEVICE_ID(info->PciInfo) == 0x0291)) {
+	if (info->BiosConnector[index].ConnectorType == CONNECTOR_LVDS) {
+	    info->BiosConnector[index].ddc_i2c.valid = FALSE;
+	}
+    }
+
 }
 
 Bool
@@ -2027,9 +2010,12 @@ RHDAtomBiosFunc(int scrnIndex, atomBiosHandlePtr handle,
 VOID*
 CailAllocateMemory(VOID *CAIL,UINT16 size)
 {
+    void *ret;
     CAILFUNC(CAIL);
 
-    return malloc(size);
+    ret = malloc(size);
+    memset(ret, 0, size);
+    return ret;
 }
 
 VOID
@@ -2256,4 +2242,15 @@ atombios_get_command_table_version(atomBiosHandlePtr atomBIOS, int index, int *m
 }
 
 
+UINT16 ATOM_BSWAP16(UINT16 x)
+{
+    return bswap_16(x);
+}
+
+UINT32 ATOM_BSWAP32(UINT32 x)
+{
+    return bswap_32(x);
+}
+
+
 #endif /* ATOM_BIOS */
diff --git a/src/radeon_atomwrapper.c b/src/radeon_atomwrapper.c
index 3e7ae01..bed1471 100644
--- a/src/radeon_atomwrapper.c
+++ b/src/radeon_atomwrapper.c
@@ -31,6 +31,7 @@
 
 #define INT32 INT32
 #include "CD_Common_Types.h"
+#include "atombios.h"
 #include "CD_Definitions.h"
 
 
diff --git a/src/radeon_bios.c b/src/radeon_bios.c
index 529dda7..b34a421 100644
--- a/src/radeon_bios.c
+++ b/src/radeon_bios.c
@@ -266,6 +266,26 @@ radeon_read_unposted_bios(ScrnInfoPtr pScrn)
     return ret;
 }
 
+Bool
+radeon_card_posted(ScrnInfoPtr pScrn)
+{
+    RADEONInfoPtr info     = RADEONPTR(pScrn);
+    unsigned char *RADEONMMIO = info->MMIO;
+    uint32_t reg;
+
+    if (IS_AVIVO_VARIANT) {
+	reg = INREG(AVIVO_D1CRTC_CONTROL) | INREG(AVIVO_D2CRTC_CONTROL);
+	if (reg & AVIVO_CRTC_EN)
+	    return TRUE;
+    } else {
+	reg = INREG(RADEON_CRTC_GEN_CNTL) | INREG(RADEON_CRTC2_GEN_CNTL);
+	if (reg & RADEON_CRTC_EN)
+	    return TRUE;
+    }
+
+    return FALSE;
+}
+
 /* Read the Video BIOS block and the FP registers (if applicable). */
 Bool
 RADEONGetBIOSInfo(ScrnInfoPtr pScrn, xf86Int10InfoPtr  pInt10)
@@ -273,6 +293,7 @@ RADEONGetBIOSInfo(ScrnInfoPtr pScrn, xf86Int10InfoPtr  pInt10)
     RADEONInfoPtr info     = RADEONPTR(pScrn);
     int tmp;
     unsigned short dptr;
+    Bool posted = TRUE;
 
 #ifdef XSERVER_LIBPCIACCESS
     int size = info->PciInfo->rom_size > RADEON_VBIOS_SIZE ? info->PciInfo->rom_size : RADEON_VBIOS_SIZE;
@@ -291,6 +312,7 @@ RADEONGetBIOSInfo(ScrnInfoPtr pScrn, xf86Int10InfoPtr  pInt10)
 			 RADEON_VBIOS_SIZE);
 	} else if (!radeon_read_bios(pScrn)) {
 	    (void)radeon_read_unposted_bios(pScrn);
+	    posted = FALSE;
 	}
     }
 
@@ -326,7 +348,7 @@ RADEONGetBIOSInfo(ScrnInfoPtr pScrn, xf86Int10InfoPtr  pInt10)
 	info->VBIOS = NULL;
 	return FALSE;
     }
- 
+
     tmp = info->ROMHeaderStart + 4;
     if ((RADEON_BIOS8(tmp)   == 'A' &&
 	 RADEON_BIOS8(tmp+1) == 'T' &&
@@ -344,51 +366,65 @@ RADEONGetBIOSInfo(ScrnInfoPtr pScrn, xf86Int10InfoPtr  pInt10)
 	       info->IsAtomBios ? "ATOM":"Legacy");
 
     if (info->IsAtomBios) {
-        AtomBiosArgRec atomBiosArg;
+	AtomBiosArgRec atomBiosArg;
 
-        if (RHDAtomBiosFunc(pScrn->scrnIndex, NULL, ATOMBIOS_INIT, &atomBiosArg)
-            == ATOM_SUCCESS) {
-            info->atomBIOS = atomBiosArg.atomhandle;
-        }
+	if (RHDAtomBiosFunc(pScrn->scrnIndex, NULL, ATOMBIOS_INIT, &atomBiosArg)
+	    == ATOM_SUCCESS) {
+	    info->atomBIOS = atomBiosArg.atomhandle;
+	}
 
-        atomBiosArg.fb.start = info->FbFreeStart;
-        atomBiosArg.fb.size = info->FbFreeSize;
-        if (RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS, ATOMBIOS_ALLOCATE_FB_SCRATCH,
+	atomBiosArg.fb.start = info->FbFreeStart;
+	atomBiosArg.fb.size = info->FbFreeSize;
+	if (RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS, ATOMBIOS_ALLOCATE_FB_SCRATCH,
 			    &atomBiosArg) == ATOM_SUCCESS) {
 
 	    info->FbFreeStart = atomBiosArg.fb.start;
 	    info->FbFreeSize = atomBiosArg.fb.size;
-        }
-
-        RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS, GET_DEFAULT_ENGINE_CLOCK,
-                        &atomBiosArg);
-        RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS, GET_DEFAULT_MEMORY_CLOCK,
-                        &atomBiosArg);
-        RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS,
-                        GET_MAX_PIXEL_CLOCK_PLL_OUTPUT, &atomBiosArg);
-        RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS,
-                        GET_MIN_PIXEL_CLOCK_PLL_OUTPUT, &atomBiosArg);
-        RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS,
-                        GET_MAX_PIXEL_CLOCK_PLL_INPUT, &atomBiosArg);
-        RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS,
+	}
+
+	RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS, GET_DEFAULT_ENGINE_CLOCK,
+			&atomBiosArg);
+	RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS, GET_DEFAULT_MEMORY_CLOCK,
+			&atomBiosArg);
+	RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS,
+			GET_MAX_PIXEL_CLOCK_PLL_OUTPUT, &atomBiosArg);
+	RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS,
+			GET_MIN_PIXEL_CLOCK_PLL_OUTPUT, &atomBiosArg);
+	RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS,
+			GET_MAX_PIXEL_CLOCK_PLL_INPUT, &atomBiosArg);
+	RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS,
 			GET_MIN_PIXEL_CLOCK_PLL_INPUT, &atomBiosArg);
-        RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS,
+	RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS,
 			GET_MAX_PIXEL_CLK, &atomBiosArg);
-        RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS,
-                        GET_REF_CLOCK, &atomBiosArg);
+	RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS,
+			GET_REF_CLOCK, &atomBiosArg);
 
 	info->MasterDataStart = RADEON_BIOS16 (info->ROMHeaderStart + 32);
     }
+
+    /* We are a bit too quick at using this "unposted" to re-post the
+     * card. This causes some problems with VT switch on some machines,
+     * so let's work around this for now by only POSTing if none of the
+     * CRTCs are enabled
+     */
+    if ((!posted) && info->VBIOS) {
+	posted = radeon_card_posted(pScrn);
+    }
+
+    if ((!posted) && info->VBIOS) {
+	if (info->IsAtomBios) {
+	    if (!rhdAtomASICInit(info->atomBIOS))
+		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+			   "%s: AsicInit failed.\n",__func__);
+	} else {
 #if 0
-    else {
-	/* non-primary card may need posting */
-	if (!pInt10) {
-	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Attempting to POST via BIOS tables\n");
+	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Attempting to POST via legacy BIOS tables\n");
 	    RADEONGetBIOSInitTableOffsets(pScrn);
 	    RADEONPostCardFromBIOSTables(pScrn);
+#endif
 	}
     }
-#endif
+
     return TRUE;
 }
 
@@ -397,7 +433,7 @@ static Bool RADEONGetATOMConnectorInfoFromBIOS (ScrnInfoPtr pScrn)
     RADEONInfoPtr info = RADEONPTR (pScrn);
 
     if (!info->VBIOS) return FALSE;
-    
+
     if (RADEONGetATOMConnectorInfoFromBIOSObject(pScrn))
 	return TRUE;
 
@@ -411,28 +447,41 @@ static void RADEONApplyLegacyQuirks(ScrnInfoPtr pScrn, int index)
 {
     RADEONInfoPtr info = RADEONPTR (pScrn);
 
-    /* on XPRESS chips, CRT2_DDC and MONID_DCC both use the 
-     * MONID gpio, but use different pins.
-     * CRT2_DDC uses the standard pinout, MONID_DDC uses
-     * something else.
+    /* For RS300/RS350/RS400 chips, there is no primary DAC. Force VGA port to use TVDAC
+     * Also there is no internal TMDS
      */
+    if ((info->ChipFamily == CHIP_FAMILY_RS300) ||
+	(info->ChipFamily == CHIP_FAMILY_RS400) ||
+	(info->ChipFamily == CHIP_FAMILY_RS480)) {
+	info->BiosConnector[index].DACType = DAC_TVDAC;
+	info->BiosConnector[index].TMDSType = TMDS_EXT;
+    }
+
+    /* XPRESS DDC quirks */
     if ((info->ChipFamily == CHIP_FAMILY_RS400 ||
 	 info->ChipFamily == CHIP_FAMILY_RS480) &&
-	info->BiosConnector[index].ConnectorType == CONNECTOR_VGA &&
 	info->BiosConnector[index].ddc_i2c.mask_clk_reg == RADEON_GPIO_CRT2_DDC) {
 	info->BiosConnector[index].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_MONID);
-    }
-
-    /* XPRESS desktop chips seem to have a proprietary connector listed for
-     * DVI-D, try and do the right thing here.
-     */
-    if ((!info->IsMobility) &&
-	(info->BiosConnector[index].ConnectorType == CONNECTOR_LVDS)) {
-	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-		   "Proprietary connector found, assuming DVI-D\n");
-	info->BiosConnector[index].DACType = DAC_NONE;
-	info->BiosConnector[index].TMDSType = TMDS_EXT;
-	info->BiosConnector[index].ConnectorType = CONNECTOR_DVI_D;
+    } else if ((info->ChipFamily == CHIP_FAMILY_RS400 ||
+		info->ChipFamily == CHIP_FAMILY_RS480) &&
+	       info->BiosConnector[index].ddc_i2c.mask_clk_reg == RADEON_GPIO_MONID) {
+	info->BiosConnector[index].ddc_i2c.valid = TRUE;
+	info->BiosConnector[index].ddc_i2c.mask_clk_mask = (0x20 << 8);
+	info->BiosConnector[index].ddc_i2c.mask_data_mask = 0x80;
+	info->BiosConnector[index].ddc_i2c.a_clk_mask = (0x20 << 8);
+	info->BiosConnector[index].ddc_i2c.a_data_mask = 0x80;
+	info->BiosConnector[index].ddc_i2c.put_clk_mask = (0x20 << 8);
+	info->BiosConnector[index].ddc_i2c.put_data_mask = 0x80;
+	info->BiosConnector[index].ddc_i2c.get_clk_mask = (0x20 << 8);
+	info->BiosConnector[index].ddc_i2c.get_data_mask = 0x80;
+	info->BiosConnector[index].ddc_i2c.mask_clk_reg = RADEON_GPIOPAD_MASK;
+	info->BiosConnector[index].ddc_i2c.mask_data_reg = RADEON_GPIOPAD_MASK;
+	info->BiosConnector[index].ddc_i2c.a_clk_reg = RADEON_GPIOPAD_A;
+	info->BiosConnector[index].ddc_i2c.a_data_reg = RADEON_GPIOPAD_A;
+	info->BiosConnector[index].ddc_i2c.put_clk_reg = RADEON_GPIOPAD_EN;
+	info->BiosConnector[index].ddc_i2c.put_data_reg = RADEON_GPIOPAD_EN;
+	info->BiosConnector[index].ddc_i2c.get_clk_reg = RADEON_LCD_GPIO_Y_REG;
+	info->BiosConnector[index].ddc_i2c.get_data_reg = RADEON_LCD_GPIO_Y_REG;
     }
 
     /* Certain IBM chipset RN50s have a BIOS reporting two VGAs,
@@ -454,6 +503,16 @@ static void RADEONApplyLegacyQuirks(ScrnInfoPtr pScrn, int index)
 	}
     }
 
+    /* X300 card with extra non-existent DVI port */
+    if (info->Chipset == PCI_CHIP_RV370_5B60 &&
+	PCI_SUB_VENDOR_ID(info->PciInfo) == 0x17af &&
+	PCI_SUB_DEVICE_ID(info->PciInfo) == 0x201e &&
+	index == 2) {
+	if (info->BiosConnector[index].ConnectorType == CONNECTOR_DVI_I) {
+	    info->BiosConnector[index].valid = FALSE;
+	}
+    }
+
 }
 
 static Bool RADEONGetLegacyConnectorInfoFromBIOS (ScrnInfoPtr pScrn)
@@ -479,7 +538,7 @@ static Bool RADEONGetLegacyConnectorInfoFromBIOS (ScrnInfoPtr pScrn)
 	    ConnectorType = (tmp >> 12) & 0xf;
 	    switch (ConnectorType) {
 	    case CONNECTOR_PROPRIETARY_LEGACY:
-		info->BiosConnector[i].ConnectorType = CONNECTOR_LVDS;
+		info->BiosConnector[i].ConnectorType = CONNECTOR_DVI_D;
 		break;
 	    case CONNECTOR_CRT_LEGACY:
 		info->BiosConnector[i].ConnectorType = CONNECTOR_VGA;
@@ -528,10 +587,6 @@ static Bool RADEONGetLegacyConnectorInfoFromBIOS (ScrnInfoPtr pScrn)
 	    else
 		info->BiosConnector[i].DACType = DAC_PRIMARY;
 
-	    /* For RS300/RS350/RS400 chips, there is no primary DAC. Force VGA port to use TVDAC*/
-	    if (info->IsIGP)
-		info->BiosConnector[i].DACType = DAC_TVDAC;
-
 	    if ((tmp >> 4) & 0x1)
 		info->BiosConnector[i].TMDSType = TMDS_EXT;
 	    else
@@ -560,7 +615,10 @@ static Bool RADEONGetLegacyConnectorInfoFromBIOS (ScrnInfoPtr pScrn)
     }
 
     /* check LVDS table */
-    if (info->IsMobility) {
+    /* RS4xx can be mobile or desktop so check the connectors */
+    if (info->IsMobility ||
+	info->ChipFamily == CHIP_FAMILY_RS400 ||
+	info->ChipFamily == CHIP_FAMILY_RS480) {
 	offset = RADEON_BIOS16(info->ROMHeaderStart + 0x40);
 	if (offset) {
 	    info->BiosConnector[4].valid = TRUE;
@@ -591,10 +649,10 @@ static Bool RADEONGetLegacyConnectorInfoFromBIOS (ScrnInfoPtr pScrn)
 			    break;
 			case DDC_LCD:
 			    info->BiosConnector[4].ddc_i2c = legacy_setup_i2c_bus(RADEON_LCD_GPIO_MASK);
-			    info->BiosConnector[4].ddc_i2c.mask_clk_mask =
-				RADEON_BIOS32(tmp0 + 0x03) | RADEON_BIOS32(tmp0 + 0x07);
-			    info->BiosConnector[4].ddc_i2c.mask_data_mask =
-				RADEON_BIOS32(tmp0 + 0x03) | RADEON_BIOS32(tmp0 + 0x07);
+			    info->BiosConnector[4].ddc_i2c.mask_clk_mask = RADEON_BIOS32(tmp0 + 0x03);
+			    info->BiosConnector[4].ddc_i2c.mask_data_mask = RADEON_BIOS32(tmp0 + 0x07);
+			    info->BiosConnector[4].ddc_i2c.a_clk_mask = RADEON_BIOS32(tmp0 + 0x03);
+			    info->BiosConnector[4].ddc_i2c.a_data_mask = RADEON_BIOS32(tmp0 + 0x07);
 			    info->BiosConnector[4].ddc_i2c.put_clk_mask = RADEON_BIOS32(tmp0 + 0x03);
 			    info->BiosConnector[4].ddc_i2c.put_data_mask = RADEON_BIOS32(tmp0 + 0x07);
 			    info->BiosConnector[4].ddc_i2c.get_clk_mask = RADEON_BIOS32(tmp0 + 0x03);
@@ -602,10 +660,10 @@ static Bool RADEONGetLegacyConnectorInfoFromBIOS (ScrnInfoPtr pScrn)
 			    break;
 			case DDC_GPIO:
 			    info->BiosConnector[4].ddc_i2c = legacy_setup_i2c_bus(RADEON_MDGPIO_EN_REG);
-			    info->BiosConnector[4].ddc_i2c.mask_clk_mask =
-				RADEON_BIOS32(tmp0 + 0x03) | RADEON_BIOS32(tmp0 + 0x07);
-			    info->BiosConnector[4].ddc_i2c.mask_data_mask =
-				RADEON_BIOS32(tmp0 + 0x03) | RADEON_BIOS32(tmp0 + 0x07);
+			    info->BiosConnector[4].ddc_i2c.mask_clk_mask =  RADEON_BIOS32(tmp0 + 0x03);
+			    info->BiosConnector[4].ddc_i2c.mask_data_mask = RADEON_BIOS32(tmp0 + 0x07);
+			    info->BiosConnector[4].ddc_i2c.a_clk_mask = RADEON_BIOS32(tmp0 + 0x03);
+			    info->BiosConnector[4].ddc_i2c.a_data_mask = RADEON_BIOS32(tmp0 + 0x07);
 			    info->BiosConnector[4].ddc_i2c.put_clk_mask = RADEON_BIOS32(tmp0 + 0x03);
 			    info->BiosConnector[4].ddc_i2c.put_data_mask = RADEON_BIOS32(tmp0 + 0x07);
 			    info->BiosConnector[4].ddc_i2c.get_clk_mask = RADEON_BIOS32(tmp0 + 0x03);
@@ -1118,6 +1176,50 @@ Bool RADEONGetTMDSInfoFromBIOS (xf86OutputPtr output)
     return FALSE;
 }
 
+static RADEONI2CBusRec
+RADEONLookupI2CBlock(ScrnInfoPtr pScrn, int id)
+{
+    RADEONInfoPtr info = RADEONPTR (pScrn);
+    int offset, blocks, i;
+    RADEONI2CBusRec i2c;
+
+    memset(&i2c, 0, sizeof(RADEONI2CBusRec));
+    i2c.valid = FALSE;
+
+    offset = RADEON_BIOS16(info->ROMHeaderStart + 0x70);
+    if (offset) {
+	blocks = RADEON_BIOS8(offset + 2);
+	for (i = 0; i < blocks; i++) {
+	    int i2c_id = RADEON_BIOS8(offset + 3 + (i * 5) + 0);
+	    if (id == i2c_id) {
+		int reg = RADEON_BIOS16(offset + 3 + (i * 5) + 1) * 4;
+		int clock_shift = RADEON_BIOS8(offset + 3 + (i * 5) + 3);
+		int data_shift = RADEON_BIOS8(offset + 3 + (i * 5) + 4);
+
+		i2c.mask_clk_mask = (1 << clock_shift);
+		i2c.mask_data_mask = (1 << data_shift);
+		i2c.a_clk_mask = (1 << clock_shift);
+		i2c.a_data_mask = (1 << data_shift);
+		i2c.put_clk_mask = (1 << clock_shift);
+		i2c.put_data_mask = (1 << data_shift);
+		i2c.get_clk_mask = (1 << clock_shift);
+		i2c.get_data_mask = (1 << data_shift);
+		i2c.mask_clk_reg = reg;
+		i2c.mask_data_reg = reg;
+		i2c.a_clk_reg = reg;
+		i2c.a_data_reg = reg;
+		i2c.put_clk_reg = reg;
+		i2c.put_data_reg = reg;
+		i2c.get_clk_reg = reg;
+		i2c.get_data_reg = reg;
+		i2c.valid = TRUE;
+		break;
+	    }
+	}
+    }
+    return i2c;
+}
+
 Bool RADEONGetExtTMDSInfoFromBIOS (xf86OutputPtr output)
 {
     ScrnInfoPtr pScrn = output->scrn;
@@ -1129,6 +1231,52 @@ Bool RADEONGetExtTMDSInfoFromBIOS (xf86OutputPtr output)
 
     if (info->IsAtomBios) {
 	return FALSE;
+    } else if (info->IsIGP) {
+	/* RS4xx TMDS stuff is in the mobile table */
+	offset = RADEON_BIOS16(info->ROMHeaderStart + 0x42);
+	if (offset) {
+	    int rev = RADEON_BIOS8(offset);
+	    if (rev >= 6) {
+		offset = RADEON_BIOS16(offset + 0x17);
+		if (offset) {
+		    offset = RADEON_BIOS16(offset + 2);
+		    rev = RADEON_BIOS8(offset);
+		    if (offset && (rev > 1)) {
+			int blocks = RADEON_BIOS8(offset + 3);
+			int index = offset + 4;
+			radeon_output->dvo_i2c.valid = FALSE;
+			while (blocks > 0) {
+			    int id = RADEON_BIOS16(index);
+			    index += 2;
+			    switch (id >> 13) {
+			    case 0:
+				index += 6;
+				break;
+			    case 2:
+				index += 10;
+				break;
+			    case 3:
+				index += 2;
+				break;
+			    case 4:
+				index += 2;
+				break;
+			    case 6:
+				radeon_output->dvo_i2c_slave_addr =
+				    RADEON_BIOS16(index) & 0xff;
+				index += 2;
+				radeon_output->dvo_i2c =
+				    RADEONLookupI2CBlock(pScrn, RADEON_BIOS8(index));
+				return TRUE;
+			    default:
+				break;
+			    }
+			    blocks--;
+			}
+		    }
+		}
+	    }
+	}
     } else {
 	offset = RADEON_BIOS16(info->ROMHeaderStart + 0x58);
 	if (offset) {
@@ -1148,10 +1296,11 @@ Bool RADEONGetExtTMDSInfoFromBIOS (xf86OutputPtr output)
 		radeon_output->dvo_i2c = legacy_setup_i2c_bus(RADEON_GPIO_VGA_DDC);
 	    else if (gpio_reg == 4)
 		radeon_output->dvo_i2c = legacy_setup_i2c_bus(RADEON_GPIO_CRT2_DDC);
-	    else if (gpio_reg == 5)
+	    else if (gpio_reg == 5) {
 		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 			   "unsupported MM gpio_reg\n");
-	    else {
+		return FALSE;
+	    } else {
 		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 			   "Unknown gpio reg: %d\n", gpio_reg);
 		return FALSE;
@@ -1179,12 +1328,82 @@ Bool RADEONInitExtTMDSInfoFromBIOS (xf86OutputPtr output)
     unsigned char *RADEONMMIO = info->MMIO;
     RADEONOutputPrivatePtr radeon_output = output->driver_private;
     int offset, index, id;
-    uint32_t val, reg, andmask, ormask;
+    uint32_t val, reg, and_mask, or_mask;
 
     if (!info->VBIOS) return FALSE;
 
     if (info->IsAtomBios) {
 	return FALSE;
+    } else if (info->IsIGP) {
+	/* RS4xx TMDS stuff is in the mobile table */
+	offset = RADEON_BIOS16(info->ROMHeaderStart + 0x42);
+	if (offset) {
+	    int rev = RADEON_BIOS8(offset);
+	    if (rev >= 6) {
+		offset = RADEON_BIOS16(offset + 0x17);
+		if (offset) {
+		    offset = RADEON_BIOS16(offset + 2);
+		    rev = RADEON_BIOS8(offset);
+		    if (offset && (rev > 1)) {
+			int blocks = RADEON_BIOS8(offset + 3);
+			index = offset + 4;
+			while (blocks > 0) {
+			    id = RADEON_BIOS16(index);
+			    index += 2;
+			    switch (id >> 13) {
+			    case 0:
+				reg = (id & 0x1fff) * 4;
+				val = RADEON_BIOS32(index);
+				index += 4;
+				ErrorF("MMIO: 0x%x 0x%x\n",
+				       (unsigned)reg, (unsigned)val);
+				OUTREG(reg, val);
+				break;
+			    case 2:
+				reg = (id & 0x1fff) * 4;
+				and_mask = RADEON_BIOS32(index);
+				index += 4;
+				or_mask = RADEON_BIOS32(index);
+				index += 4;
+				ErrorF("MMIO mask: 0x%x 0x%x 0x%x\n",
+				       (unsigned)reg, (unsigned)and_mask, (unsigned)or_mask);
+				val = INREG(reg);
+				val = (val & and_mask) | or_mask;
+				OUTREG(reg, val);
+				break;
+			    case 3:
+				val = RADEON_BIOS16(index);
+				index += 2;
+				ErrorF("delay: %u\n", (unsigned)val);
+				usleep(val);
+				break;
+			    case 4:
+				val = RADEON_BIOS16(index);
+				index += 2;
+				ErrorF("delay: %u\n", (unsigned)val * 1000);
+				usleep(val * 1000);
+				break;
+			    case 6:
+				index++;
+				reg = RADEON_BIOS8(index);
+				index++;
+				val = RADEON_BIOS8(index);
+				index++;
+				ErrorF("i2c write: 0x%x, 0x%x\n", (unsigned)reg,
+				       (unsigned)val);
+				RADEONDVOWriteByte(radeon_output->DVOChip, reg, val);
+				break;
+			    default:
+				ErrorF("unknown id %d\n", id>>13);
+				return FALSE;
+			    }
+			    blocks--;
+			}
+			return TRUE;
+		    }
+		}
+	    }
+	}
     } else {
 	offset = RADEON_BIOS16(info->ROMHeaderStart + 0x58);
 	if (offset) {
@@ -1194,24 +1413,24 @@ Bool RADEONInitExtTMDSInfoFromBIOS (xf86OutputPtr output)
 		index += 2;
 		switch(id >> 13) {
 		case 0:
-		    reg = id & 0x1fff;
+		    reg = (id & 0x1fff) * 4;
 		    val = RADEON_BIOS32(index);
 		    index += 4;
-		    ErrorF("WRITE INDEXED: 0x%x 0x%x\n",
+		    ErrorF("MMIO: 0x%x 0x%x\n",
 			   (unsigned)reg, (unsigned)val);
-		    /*OUTREG(reg, val);*/
+		    OUTREG(reg, val);
 		    break;
 		case 2:
-		    reg = id & 0x1fff;
-		    andmask = RADEON_BIOS32(index);
+		    reg = (id & 0x1fff) * 4;
+		    and_mask = RADEON_BIOS32(index);
 		    index += 4;
-		    ormask = RADEON_BIOS32(index);
+		    or_mask = RADEON_BIOS32(index);
 		    index += 4;
 		    val = INREG(reg);
-		    val = (val & andmask) | ormask;
-		    ErrorF("MASK DIRECT: 0x%x 0x%x 0x%x\n",
-			   (unsigned)reg, (unsigned)andmask, (unsigned)ormask);
-		    /*OUTREG(reg, val);*/
+		    val = (val & and_mask) | or_mask;
+		    ErrorF("MMIO mask: 0x%x 0x%x 0x%x\n",
+			   (unsigned)reg, (unsigned)and_mask, (unsigned)or_mask);
+		    OUTREG(reg, val);
 		    break;
 		case 4:
 		    val = RADEON_BIOS16(index);
@@ -1221,15 +1440,15 @@ Bool RADEONInitExtTMDSInfoFromBIOS (xf86OutputPtr output)
 		    break;
 		case 5:
 		    reg = id & 0x1fff;
-		    andmask = RADEON_BIOS32(index);
+		    and_mask = RADEON_BIOS32(index);
 		    index += 4;
-		    ormask = RADEON_BIOS32(index);
+		    or_mask = RADEON_BIOS32(index);
 		    index += 4;
-		    ErrorF("MASK PLL: 0x%x 0x%x 0x%x\n",
-			   (unsigned)reg, (unsigned)andmask, (unsigned)ormask);
-		    /*val = INPLL(pScrn, reg);
-		    val = (val & andmask) | ormask;
-		    OUTPLL(pScrn, reg, val);*/
+		    ErrorF("PLL mask: 0x%x 0x%x 0x%x\n",
+			   (unsigned)reg, (unsigned)and_mask, (unsigned)or_mask);
+		    val = INPLL(pScrn, reg);
+		    val = (val & and_mask) | or_mask;
+		    OUTPLL(pScrn, reg, val);
 		    break;
 		case 6:
 		    reg = id & 0x1fff;
diff --git a/src/radeon_chipinfo_gen.h b/src/radeon_chipinfo_gen.h
index ed3174a..daaf717 100644
--- a/src/radeon_chipinfo_gen.h
+++ b/src/radeon_chipinfo_gen.h
@@ -1,6 +1,7 @@
 /* This file is autogenerated please do not edit */
 RADEONCardInfo RADEONCards[] = {
  { 0x3150, CHIP_FAMILY_RV380, 1, 0, 0, 0, 0 },
+ { 0x3151, CHIP_FAMILY_RV380, 0, 0, 0, 0, 0 },
  { 0x3152, CHIP_FAMILY_RV380, 1, 0, 0, 0, 0 },
  { 0x3154, CHIP_FAMILY_RV380, 1, 0, 0, 0, 0 },
  { 0x3E50, CHIP_FAMILY_RV380, 0, 0, 0, 0, 0 },
@@ -250,6 +251,9 @@ RADEONCardInfo RADEONCards[] = {
  { 0x940A, CHIP_FAMILY_R600, 0, 0, 0, 0, 0 },
  { 0x940B, CHIP_FAMILY_R600, 0, 0, 0, 0, 0 },
  { 0x940F, CHIP_FAMILY_R600, 0, 0, 0, 0, 0 },
+ { 0x9440, CHIP_FAMILY_RV770, 0, 0, 0, 0, 0 },
+ { 0x9441, CHIP_FAMILY_RV770, 0, 0, 0, 0, 0 },
+ { 0x9442, CHIP_FAMILY_RV770, 0, 0, 0, 0, 0 },
  { 0x94C0, CHIP_FAMILY_RV610, 0, 0, 0, 0, 0 },
  { 0x94C1, CHIP_FAMILY_RV610, 0, 0, 0, 0, 0 },
  { 0x94C3, CHIP_FAMILY_RV610, 0, 0, 0, 0, 0 },
@@ -267,6 +271,7 @@ RADEONCardInfo RADEONCards[] = {
  { 0x9507, CHIP_FAMILY_RV670, 0, 0, 0, 0, 0 },
  { 0x950F, CHIP_FAMILY_RV670, 0, 0, 0, 0, 0 },
  { 0x9511, CHIP_FAMILY_RV670, 0, 0, 0, 0, 0 },
+ { 0x9515, CHIP_FAMILY_RV670, 0, 0, 0, 0, 0 },
  { 0x9580, CHIP_FAMILY_RV630, 0, 0, 0, 0, 0 },
  { 0x9581, CHIP_FAMILY_RV630, 1, 0, 0, 0, 0 },
  { 0x9583, CHIP_FAMILY_RV630, 1, 0, 0, 0, 0 },
diff --git a/src/radeon_chipset_gen.h b/src/radeon_chipset_gen.h
index d1761d2..79b094a 100644
--- a/src/radeon_chipset_gen.h
+++ b/src/radeon_chipset_gen.h
@@ -1,6 +1,7 @@
 /* This file is autogenerated please do not edit */
 static SymTabRec RADEONChipsets[] = {
   { PCI_CHIP_RV380_3150, "ATI Radeon Mobility X600 (M24) 3150 (PCIE)" },
+  { PCI_CHIP_RV380_3151, "ATI FireMV 2400 (PCI)" },
   { PCI_CHIP_RV380_3152, "ATI Radeon Mobility X300 (M24) 3152 (PCIE)" },
   { PCI_CHIP_RV380_3154, "ATI FireGL M24 GL 3154 (PCIE)" },
   { PCI_CHIP_RV380_3E50, "ATI Radeon X600 (RV380) 3E50 (PCIE)" },
@@ -250,6 +251,9 @@ static SymTabRec RADEONChipsets[] = {
   { PCI_CHIP_R600_940A, "ATI FireGL V8650" },
   { PCI_CHIP_R600_940B, "ATI FireGL V8600" },
   { PCI_CHIP_R600_940F, "ATI FireGL V7600" },
+  { PCI_CHIP_RV770_9440, "ATI Radeon 4800 Series" },
+  { PCI_CHIP_RV770_9441, "ATI Radeon HD 4870 x2" },
+  { PCI_CHIP_RV770_9442, "ATI Radeon 4800 Series" },
   { PCI_CHIP_RV610_94C0, "ATI RV610" },
   { PCI_CHIP_RV610_94C1, "ATI Radeon HD 2400 XT" },
   { PCI_CHIP_RV610_94C3, "ATI Radeon HD 2400 Pro" },
@@ -267,6 +271,7 @@ static SymTabRec RADEONChipsets[] = {
   { PCI_CHIP_RV670_9507, "ATI RV670" },
   { PCI_CHIP_RV670_950F, "ATI Radeon HD3870 X2" },
   { PCI_CHIP_RV670_9511, "ATI FireGL V7700" },
+  { PCI_CHIP_RV670_9515, "ATI Radeon HD3850" },
   { PCI_CHIP_RV630_9580, "ATI RV630" },
   { PCI_CHIP_RV630_9581, "ATI Mobility Radeon HD 2600" },
   { PCI_CHIP_RV630_9583, "ATI Mobility Radeon HD 2600 XT" },
diff --git a/src/radeon_common.h b/src/radeon_common.h
deleted file mode 100644
index 193c1f9..0000000
--- a/src/radeon_common.h
+++ /dev/null
@@ -1,496 +0,0 @@
-/* radeon_common.h -- common header definitions for Radeon 2D/3D/DRM suite
- *
- * Copyright 2000 VA Linux Systems, Inc., Fremont, California.
- * Copyright 2002 Tungsten Graphics, Inc., Cedar Park, Texas.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Author:
- *   Gareth Hughes <gareth@valinux.com>
- *   Kevin E. Martin <martin@valinux.com>
- *   Keith Whitwell <keith@tungstengraphics.com>
- *
- * Converted to common header format:
- *   Jens Owen <jens@tungstengraphics.com>
- *
- */
-
-#ifndef _RADEON_COMMON_H_
-#define _RADEON_COMMON_H_
-
-#include <inttypes.h>
-#include "xf86drm.h"
-
-/* WARNING: If you change any of these defines, make sure to change
- * the kernel include file as well (radeon_drm.h)
- */
-
-/* Driver specific DRM command indices
- * NOTE: these are not OS specific, but they are driver specific
- */
-#define DRM_RADEON_CP_INIT                0x00
-#define DRM_RADEON_CP_START               0x01
-#define DRM_RADEON_CP_STOP                0x02
-#define DRM_RADEON_CP_RESET               0x03
-#define DRM_RADEON_CP_IDLE                0x04
-#define DRM_RADEON_RESET                  0x05
-#define DRM_RADEON_FULLSCREEN             0x06
-#define DRM_RADEON_SWAP                   0x07
-#define DRM_RADEON_CLEAR                  0x08
-#define DRM_RADEON_VERTEX                 0x09
-#define DRM_RADEON_INDICES                0x0a
-#define DRM_RADEON_STIPPLE                0x0c
-#define DRM_RADEON_INDIRECT               0x0d
-#define DRM_RADEON_TEXTURE                0x0e
-#define DRM_RADEON_VERTEX2                0x0f
-#define DRM_RADEON_CMDBUF                 0x10
-#define DRM_RADEON_GETPARAM               0x11
-#define DRM_RADEON_FLIP                   0x12
-#define DRM_RADEON_ALLOC                  0x13
-#define DRM_RADEON_FREE                   0x14
-#define DRM_RADEON_INIT_HEAP              0x15
-#define DRM_RADEON_IRQ_EMIT               0x16
-#define DRM_RADEON_IRQ_WAIT               0x17
-#define DRM_RADEON_CP_RESUME              0x18
-#define DRM_RADEON_SETPARAM               0x19
-#define DRM_RADEON_SURF_ALLOC             0x1a
-#define DRM_RADEON_SURF_FREE              0x1b
-#define DRM_RADEON_MAX_DRM_COMMAND_INDEX  0x39
-
-
-#define RADEON_FRONT	0x1
-#define RADEON_BACK	0x2
-#define RADEON_DEPTH	0x4
-#define RADEON_STENCIL	0x8
-
-#define RADEON_CLEAR_X1        0
-#define RADEON_CLEAR_Y1        1
-#define RADEON_CLEAR_X2        2
-#define RADEON_CLEAR_Y2        3
-#define RADEON_CLEAR_DEPTH     4
-
-
-typedef struct {
-   enum {
-      DRM_RADEON_INIT_CP    = 0x01,
-      DRM_RADEON_CLEANUP_CP = 0x02,
-      DRM_RADEON_INIT_R200_CP = 0x03,
-      DRM_RADEON_INIT_R300_CP = 0x04
-   } func;
-   unsigned long sarea_priv_offset;
-   int is_pci;
-   int cp_mode;
-   int gart_size;
-   int ring_size;
-   int usec_timeout;
-
-   unsigned int fb_bpp;
-   unsigned int front_offset, front_pitch;
-   unsigned int back_offset, back_pitch;
-   unsigned int depth_bpp;
-   unsigned int depth_offset, depth_pitch;
-
-   unsigned long fb_offset;
-   unsigned long mmio_offset;
-   unsigned long ring_offset;
-   unsigned long ring_rptr_offset;
-   unsigned long buffers_offset;
-   unsigned long gart_textures_offset;
-} drmRadeonInit;
-
-typedef struct {
-   int flush;
-   int idle;
-} drmRadeonCPStop;
-
-typedef struct {
-   int idx;
-   int start;
-   int end;
-   int discard;
-} drmRadeonIndirect;
-
-typedef union drmRadeonClearR {
-        float f[5];
-        unsigned int ui[5];
-} drmRadeonClearRect;
-
-typedef struct drmRadeonClearT {
-        unsigned int flags;
-        unsigned int clear_color;
-        unsigned int clear_depth;
-        unsigned int color_mask;
-        unsigned int depth_mask;   /* misnamed field:  should be stencil */
-        drmRadeonClearRect *depth_boxes;
-} drmRadeonClearType;
-
-typedef struct drmRadeonFullscreenT {
-        enum {
-                RADEON_INIT_FULLSCREEN    = 0x01,
-                RADEON_CLEANUP_FULLSCREEN = 0x02
-        } func;
-} drmRadeonFullscreenType;
-
-typedef struct {
-        unsigned int *mask;
-} drmRadeonStipple;
-
-typedef struct {
-        unsigned int x;
-        unsigned int y;
-        unsigned int width;
-        unsigned int height;
-        const void *data;
-} drmRadeonTexImage;
-
-typedef struct {
-        unsigned int offset;
-        int pitch;
-        int format;
-        int width;                      /* Texture image coordinates */
-        int height;
-        drmRadeonTexImage *image;
-} drmRadeonTexture;
-
-
-#define RADEON_MAX_TEXTURE_UNITS 3
-
-/* Layout matches drm_radeon_state_t in linux drm_radeon.h.
- */
-typedef struct {
-	struct {
-		unsigned int pp_misc;				/* 0x1c14 */
-		unsigned int pp_fog_color;
-		unsigned int re_solid_color;
-		unsigned int rb3d_blendcntl;
-		unsigned int rb3d_depthoffset;
-		unsigned int rb3d_depthpitch;
-		unsigned int rb3d_zstencilcntl;
-		unsigned int pp_cntl;				/* 0x1c38 */
-		unsigned int rb3d_cntl;
-		unsigned int rb3d_coloroffset;
-		unsigned int re_width_height;
-		unsigned int rb3d_colorpitch;
-	} context;
-	struct {
-		unsigned int se_cntl;
-	} setup1;
-	struct {
-		unsigned int se_coord_fmt;			/* 0x1c50 */
-	} vertex;
-	struct {
-		unsigned int re_line_pattern;			/* 0x1cd0 */
-		unsigned int re_line_state;
-		unsigned int se_line_width;			/* 0x1db8 */
-	} line;
-	struct {
-		unsigned int pp_lum_matrix;			/* 0x1d00 */
-		unsigned int pp_rot_matrix_0;			/* 0x1d58 */
-		unsigned int pp_rot_matrix_1;
-	} bumpmap;
-	struct {
-		unsigned int rb3d_stencilrefmask;		/* 0x1d7c */
-		unsigned int rb3d_ropcntl;
-		unsigned int rb3d_planemask;
-	} mask;
-	struct {
-		unsigned int se_vport_xscale;			/* 0x1d98 */
-		unsigned int se_vport_xoffset;
-		unsigned int se_vport_yscale;
-		unsigned int se_vport_yoffset;
-		unsigned int se_vport_zscale;
-		unsigned int se_vport_zoffset;
-	} viewport;
-	struct {
-		unsigned int se_cntl_status;			/* 0x2140 */
-	} setup2;
-	struct {
-		unsigned int re_top_left;	/*ignored*/	/* 0x26c0 */
-		unsigned int re_misc;
-	} misc;
-	struct {
-		unsigned int pp_txfilter;
-		unsigned int pp_txformat;
-		unsigned int pp_txoffset;
-		unsigned int pp_txcblend;
-		unsigned int pp_txablend;
-		unsigned int pp_tfactor;
-		unsigned int pp_border_color;
-	} texture[RADEON_MAX_TEXTURE_UNITS];
-	struct {
-		unsigned int se_zbias_factor;
-		unsigned int se_zbias_constant;
-	} zbias;
-	unsigned int dirty;
-} drmRadeonState;
-
-/* 1.1 vertex ioctl.  Used in compatibility modes.
- */
-typedef struct {
-	int prim;
-	int idx;			/* Index of vertex buffer */
-	int count;			/* Number of vertices in buffer */
-	int discard;			/* Client finished with buffer? */
-} drmRadeonVertex;
-
-typedef struct {
-	unsigned int start;
-	unsigned int finish;
-	unsigned int prim:8;
-	unsigned int stateidx:8;
-	unsigned int numverts:16; /* overloaded as offset/64 for elt prims */
-        unsigned int vc_format;
-} drmRadeonPrim;
-
-typedef struct {
-        int idx;                        /* Index of vertex buffer */
-        int discard;                    /* Client finished with buffer? */
-        int nr_states;
-        drmRadeonState *state;
-        int nr_prims;
-        drmRadeonPrim *prim;
-} drmRadeonVertex2;
-
-#define RADEON_MAX_STATES 16
-#define RADEON_MAX_PRIMS  64
-
-/* Command buffer.  Replace with true dma stream?
- */
-typedef struct {
-	int bufsz;
-	char *buf;
-	int nbox;
-        drm_clip_rect_t *boxes;
-} drmRadeonCmdBuffer;
-
-/* New style per-packet identifiers for use in cmd_buffer ioctl with
- * the RADEON_EMIT_PACKET command.  Comments relate new packets to old
- * state bits and the packet size:
- */
-#define RADEON_EMIT_PP_MISC                         0 /* context/7 */
-#define RADEON_EMIT_PP_CNTL                         1 /* context/3 */
-#define RADEON_EMIT_RB3D_COLORPITCH                 2 /* context/1 */
-#define RADEON_EMIT_RE_LINE_PATTERN                 3 /* line/2 */
-#define RADEON_EMIT_SE_LINE_WIDTH                   4 /* line/1 */
-#define RADEON_EMIT_PP_LUM_MATRIX                   5 /* bumpmap/1 */
-#define RADEON_EMIT_PP_ROT_MATRIX_0                 6 /* bumpmap/2 */
-#define RADEON_EMIT_RB3D_STENCILREFMASK             7 /* masks/3 */
-#define RADEON_EMIT_SE_VPORT_XSCALE                 8 /* viewport/6 */
-#define RADEON_EMIT_SE_CNTL                         9 /* setup/2 */
-#define RADEON_EMIT_SE_CNTL_STATUS                  10 /* setup/1 */
-#define RADEON_EMIT_RE_MISC                         11 /* misc/1 */
-#define RADEON_EMIT_PP_TXFILTER_0                   12 /* tex0/6 */
-#define RADEON_EMIT_PP_BORDER_COLOR_0               13 /* tex0/1 */
-#define RADEON_EMIT_PP_TXFILTER_1                   14 /* tex1/6 */
-#define RADEON_EMIT_PP_BORDER_COLOR_1               15 /* tex1/1 */
-#define RADEON_EMIT_PP_TXFILTER_2                   16 /* tex2/6 */
-#define RADEON_EMIT_PP_BORDER_COLOR_2               17 /* tex2/1 */
-#define RADEON_EMIT_SE_ZBIAS_FACTOR                 18 /* zbias/2 */
-#define RADEON_EMIT_SE_TCL_OUTPUT_VTX_FMT           19 /* tcl/11 */
-#define RADEON_EMIT_SE_TCL_MATERIAL_EMMISSIVE_RED   20 /* material/17 */
-#define R200_EMIT_PP_TXCBLEND_0                     21 /* tex0/4 */
-#define R200_EMIT_PP_TXCBLEND_1                     22 /* tex1/4 */
-#define R200_EMIT_PP_TXCBLEND_2                     23 /* tex2/4 */
-#define R200_EMIT_PP_TXCBLEND_3                     24 /* tex3/4 */
-#define R200_EMIT_PP_TXCBLEND_4                     25 /* tex4/4 */
-#define R200_EMIT_PP_TXCBLEND_5                     26 /* tex5/4 */
-#define R200_EMIT_PP_TXCBLEND_6                     27 /* /4 */
-#define R200_EMIT_PP_TXCBLEND_7                     28 /* /4 */
-#define R200_EMIT_TCL_LIGHT_MODEL_CTL_0             29 /* tcl/6 */
-#define R200_EMIT_TFACTOR_0                         30 /* tf/6 */
-#define R200_EMIT_VTX_FMT_0                         31 /* vtx/4 */
-#define R200_EMIT_VAP_CTL                           32 /* vap/1 */
-#define R200_EMIT_MATRIX_SELECT_0                   33 /* msl/5 */
-#define R200_EMIT_TEX_PROC_CTL_2                    34 /* tcg/5 */
-#define R200_EMIT_TCL_UCP_VERT_BLEND_CTL            35 /* tcl/1 */
-#define R200_EMIT_PP_TXFILTER_0                     36 /* tex0/6 */
-#define R200_EMIT_PP_TXFILTER_1                     37 /* tex1/6 */
-#define R200_EMIT_PP_TXFILTER_2                     38 /* tex2/6 */
-#define R200_EMIT_PP_TXFILTER_3                     39 /* tex3/6 */
-#define R200_EMIT_PP_TXFILTER_4                     40 /* tex4/6 */
-#define R200_EMIT_PP_TXFILTER_5                     41 /* tex5/6 */
-#define R200_EMIT_PP_TXOFFSET_0                     42 /* tex0/1 */
-#define R200_EMIT_PP_TXOFFSET_1                     43 /* tex1/1 */
-#define R200_EMIT_PP_TXOFFSET_2                     44 /* tex2/1 */
-#define R200_EMIT_PP_TXOFFSET_3                     45 /* tex3/1 */
-#define R200_EMIT_PP_TXOFFSET_4                     46 /* tex4/1 */
-#define R200_EMIT_PP_TXOFFSET_5                     47 /* tex5/1 */
-#define R200_EMIT_VTE_CNTL                          48 /* vte/1 */
-#define R200_EMIT_OUTPUT_VTX_COMP_SEL               49 /* vtx/1 */
-#define R200_EMIT_PP_TAM_DEBUG3                     50 /* tam/1 */
-#define R200_EMIT_PP_CNTL_X                         51 /* cst/1 */
-#define R200_EMIT_RB3D_DEPTHXY_OFFSET               52 /* cst/1 */
-#define R200_EMIT_RE_AUX_SCISSOR_CNTL               53 /* cst/1 */
-#define R200_EMIT_RE_SCISSOR_TL_0                   54 /* cst/2 */
-#define R200_EMIT_RE_SCISSOR_TL_1                   55 /* cst/2 */
-#define R200_EMIT_RE_SCISSOR_TL_2                   56 /* cst/2 */
-#define R200_EMIT_SE_VAP_CNTL_STATUS                57 /* cst/1 */
-#define R200_EMIT_SE_VTX_STATE_CNTL                 58 /* cst/1 */
-#define R200_EMIT_RE_POINTSIZE                      59 /* cst/1 */
-#define R200_EMIT_TCL_INPUT_VTX_VECTOR_ADDR_0       60 /* cst/4 */
-#define R200_EMIT_PP_CUBIC_FACES_0                  61
-#define R200_EMIT_PP_CUBIC_OFFSETS_0                62
-#define R200_EMIT_PP_CUBIC_FACES_1                  63
-#define R200_EMIT_PP_CUBIC_OFFSETS_1                64
-#define R200_EMIT_PP_CUBIC_FACES_2                  65
-#define R200_EMIT_PP_CUBIC_OFFSETS_2                66
-#define R200_EMIT_PP_CUBIC_FACES_3                  67
-#define R200_EMIT_PP_CUBIC_OFFSETS_3                68
-#define R200_EMIT_PP_CUBIC_FACES_4                  69
-#define R200_EMIT_PP_CUBIC_OFFSETS_4                70
-#define R200_EMIT_PP_CUBIC_FACES_5                  71
-#define R200_EMIT_PP_CUBIC_OFFSETS_5                72
-#define RADEON_EMIT_PP_TEX_SIZE_0                   73
-#define RADEON_EMIT_PP_TEX_SIZE_1                   74
-#define RADEON_EMIT_PP_TEX_SIZE_2                   75
-#define R200_EMIT_RB3D_BLENDCOLOR                   76
-#define RADEON_MAX_STATE_PACKETS                    77
-
-
-/* Commands understood by cmd_buffer ioctl.  More can be added but
- * obviously these can't be removed or changed:
- */
-#define RADEON_CMD_PACKET      1 /* emit one of the register packets above */
-#define RADEON_CMD_SCALARS     2 /* emit scalar data */
-#define RADEON_CMD_VECTORS     3 /* emit vector data */
-#define RADEON_CMD_DMA_DISCARD 4 /* discard current dma buf */
-#define RADEON_CMD_PACKET3     5 /* emit hw packet */
-#define RADEON_CMD_PACKET3_CLIP 6 /* emit hw packet wrapped in cliprects */
-#define RADEON_CMD_SCALARS2     7 /* R200 stopgap */
-#define RADEON_CMD_WAIT         8 /* synchronization */
-
-typedef union {
-	int i;
-	struct {
-	   unsigned char cmd_type, pad0, pad1, pad2;
-	} header;
-	struct {
-	   unsigned char cmd_type, packet_id, pad0, pad1;
-	} packet;
-	struct {
-	   unsigned char cmd_type, offset, stride, count;
-	} scalars;
-	struct {
-	   unsigned char cmd_type, offset, stride, count;
-	} vectors;
-	struct {
-	   unsigned char cmd_type, buf_idx, pad0, pad1;
-	} dma;
-	struct {
-	   unsigned char cmd_type, flags, pad0, pad1;
-	} wait;
-} drmRadeonCmdHeader;
-
-
-#define RADEON_WAIT_2D  0x1
-#define RADEON_WAIT_3D  0x2
-
-
-/* 1.3: An ioctl to get parameters that aren't available to the 3d
- * client any other way.  
- */
-#define RADEON_PARAM_GART_BUFFER_OFFSET    1 /* card offset of 1st GART buffer */
-#define RADEON_PARAM_LAST_FRAME            2
-#define RADEON_PARAM_LAST_DISPATCH         3
-#define RADEON_PARAM_LAST_CLEAR            4
-/* Added with DRM version 1.6. */
-#define RADEON_PARAM_IRQ_NR                5
-#define RADEON_PARAM_GART_BASE             6 /* card offset of GART base */
-/* Added with DRM version 1.8. */
-#define RADEON_PARAM_REGISTER_HANDLE       7 /* for drmMap() */
-#define RADEON_PARAM_STATUS_HANDLE         8
-#define RADEON_PARAM_SAREA_HANDLE          9
-#define RADEON_PARAM_GART_TEX_HANDLE       10
-#define RADEON_PARAM_SCRATCH_OFFSET        11
-#define RADEON_PARAM_CARD_TYPE             12
-#define RADEON_PARAM_VBLANK_CRTC           13   /* VBLANK CRTC */
-#define RADEON_PARAM_FB_LOCATION           14   /* FB location */
-#define RADEON_PARAM_NUM_GB_PIPES          15
-
-typedef struct drm_radeon_getparam {
-	int param;
-	int *value;
-} drmRadeonGetParam;
-
-
-#define RADEON_MEM_REGION_GART 1
-#define RADEON_MEM_REGION_FB   2
-
-typedef struct drm_radeon_mem_alloc {
-	int region;
-	int alignment;
-	int size;
-	int *region_offset;	/* offset from start of fb or GART */
-} drmRadeonMemAlloc;
-
-typedef struct drm_radeon_mem_free {
-	int region;
-	int region_offset;
-} drmRadeonMemFree;
-
-typedef struct drm_radeon_mem_init_heap {
-	int region;
-	int size;
-	int start;
-} drmRadeonMemInitHeap;
-
-/* 1.6: Userspace can request & wait on irq's:
- */
-typedef struct drm_radeon_irq_emit {
-	int *irq_seq;
-} drmRadeonIrqEmit;
-
-typedef struct drm_radeon_irq_wait {
-	int irq_seq;
-} drmRadeonIrqWait;
-
-
-/* 1.10: Clients tell the DRM where they think the framebuffer is located in
- * the card's address space, via a new generic ioctl to set parameters
- */
-
-typedef struct drm_radeon_set_param {
-	unsigned int param;
-	int64_t      value;
-} drmRadeonSetParam;
-
-#define RADEON_SETPARAM_FB_LOCATION     1
-#define RADEON_SETPARAM_SWITCH_TILING   2
-#define RADEON_SETPARAM_PCIGART_LOCATION 3
-#define RADEON_SETPARAM_NEW_MEMMAP 4
-#define RADEON_SETPARAM_PCIGART_TABLE_SIZE 5
-#define RADEON_SETPARAM_VBLANK_CRTC 6           /* VBLANK CRTC */
-/* 1.14: Clients can allocate/free a surface
- */
-typedef struct drm_radeon_surface_alloc {
-	unsigned int address;
-	unsigned int size;
-	unsigned int flags;
-} drmRadeonSurfaceAlloc;
-
-typedef struct drm_radeon_surface_free {
-	unsigned int address;
-} drmRadeonSurfaceFree;
-
-#define	DRM_RADEON_VBLANK_CRTC1 	1
-#define	DRM_RADEON_VBLANK_CRTC2 	2
-
-#endif
diff --git a/src/radeon_commonfuncs.c b/src/radeon_commonfuncs.c
index 58fe306..dba197e 100644
--- a/src/radeon_commonfuncs.c
+++ b/src/radeon_commonfuncs.c
@@ -58,7 +58,8 @@ static void FUNC_NAME(RADEONInit3DEngine)(ScrnInfoPtr pScrn)
     uint32_t gb_tile_config, su_reg_dest, vap_cntl;
     ACCEL_PREAMBLE();
 
-    info->texW[0] = info->texH[0] = info->texW[1] = info->texH[1] = 1;
+    info->accel_state->texW[0] = info->accel_state->texH[0] =
+	info->accel_state->texW[1] = info->accel_state->texH[1] = 1;
 
     if (IS_R300_3D || IS_R500_3D) {
 
@@ -70,7 +71,7 @@ static void FUNC_NAME(RADEONInit3DEngine)(ScrnInfoPtr pScrn)
 
 	gb_tile_config = (R300_ENABLE_TILING | R300_TILE_SIZE_16 | R300_SUBPIXEL_1_16);
 
-	switch(info->num_gb_pipes) {
+	switch(info->accel_state->num_gb_pipes) {
 	case 2: gb_tile_config |= R300_PIPE_COUNT_R300; break;
 	case 3: gb_tile_config |= R300_PIPE_COUNT_R420_3P; break;
 	case 4: gb_tile_config |= R300_PIPE_COUNT_R420; break;
@@ -87,7 +88,7 @@ static void FUNC_NAME(RADEONInit3DEngine)(ScrnInfoPtr pScrn)
 	FINISH_ACCEL();
 
 	if (IS_R500_3D) {
-	    su_reg_dest = ((1 << info->num_gb_pipes) - 1);
+	    su_reg_dest = ((1 << info->accel_state->num_gb_pipes) - 1);
 	    BEGIN_ACCEL(2);
 	    OUT_ACCEL_REG(R500_SU_REG_DEST, su_reg_dest);
 	    OUT_ACCEL_REG(R500_VAP_INDEX_OFFSET, 0);
@@ -146,7 +147,7 @@ static void FUNC_NAME(RADEONInit3DEngine)(ScrnInfoPtr pScrn)
 	FINISH_ACCEL();
 
 	/* setup the VAP */
-	if (info->has_tcl)
+	if (info->accel_state->has_tcl)
 	    vap_cntl = ((5 << R300_PVS_NUM_SLOTS_SHIFT) |
 			(5 << R300_PVS_NUM_CNTLRS_SHIFT) |
 			(9 << R300_VF_MAX_VTX_NUM_SHIFT));
@@ -158,25 +159,26 @@ static void FUNC_NAME(RADEONInit3DEngine)(ScrnInfoPtr pScrn)
 	if (info->ChipFamily == CHIP_FAMILY_RV515)
 	    vap_cntl |= (2 << R300_PVS_NUM_FPUS_SHIFT);
 	else if ((info->ChipFamily == CHIP_FAMILY_RV530) ||
-		 (info->ChipFamily == CHIP_FAMILY_RV560))
+		 (info->ChipFamily == CHIP_FAMILY_RV560) ||
+		 (info->ChipFamily == CHIP_FAMILY_RV570))
 	    vap_cntl |= (5 << R300_PVS_NUM_FPUS_SHIFT);
-	else if (info->ChipFamily == CHIP_FAMILY_R420)
+	else if ((info->ChipFamily == CHIP_FAMILY_RV410) ||
+		 (info->ChipFamily == CHIP_FAMILY_R420))
 	    vap_cntl |= (6 << R300_PVS_NUM_FPUS_SHIFT);
 	else if ((info->ChipFamily == CHIP_FAMILY_R520) ||
-		 (info->ChipFamily == CHIP_FAMILY_R580) ||
-		 (info->ChipFamily == CHIP_FAMILY_RV570))
+		 (info->ChipFamily == CHIP_FAMILY_R580))
 	    vap_cntl |= (8 << R300_PVS_NUM_FPUS_SHIFT);
 	else
 	    vap_cntl |= (4 << R300_PVS_NUM_FPUS_SHIFT);
 
-	if (info->has_tcl)
+	if (info->accel_state->has_tcl)
 	    BEGIN_ACCEL(15);
 	else
 	    BEGIN_ACCEL(9);
 	OUT_ACCEL_REG(R300_VAP_VTX_STATE_CNTL, 0);
 	OUT_ACCEL_REG(R300_VAP_PVS_STATE_FLUSH_REG, 0);
 
-	if (info->has_tcl)
+	if (info->accel_state->has_tcl)
 	    OUT_ACCEL_REG(R300_VAP_CNTL_STATUS, 0);
 	else
 	    OUT_ACCEL_REG(R300_VAP_CNTL_STATUS, R300_PVS_BYPASS);
@@ -206,7 +208,7 @@ static void FUNC_NAME(RADEONInit3DEngine)(ScrnInfoPtr pScrn)
 		       ((R300_WRITE_ENA_X | R300_WRITE_ENA_Y | R300_WRITE_ENA_Z | R300_WRITE_ENA_W)
 			<< R300_WRITE_ENA_2_SHIFT)));
 
-	if (info->has_tcl) {
+	if (info->accel_state->has_tcl) {
 	    OUT_ACCEL_REG(R300_VAP_PVS_FLOW_CNTL_OPC, 0);
 	    OUT_ACCEL_REG(R300_VAP_GB_VERT_CLIP_ADJ, 0x3f800000);
 	    OUT_ACCEL_REG(R300_VAP_GB_VERT_DISC_ADJ, 0x3f800000);
@@ -217,8 +219,8 @@ static void FUNC_NAME(RADEONInit3DEngine)(ScrnInfoPtr pScrn)
 	FINISH_ACCEL();
 
 	/* pre-load the vertex shaders */
-	if (info->has_tcl) {
-	    /* exa mask shader program */
+	if (info->accel_state->has_tcl) {
+	    /* exa mask/Xv bicubic shader program */
 	    BEGIN_ACCEL(13);
 	    OUT_ACCEL_REG(R300_VAP_PVS_VECTOR_INDX_REG, 0);
 	    /* PVS inst 0 */
@@ -498,14 +500,14 @@ static void FUNC_NAME(RADEONInit3DEngine)(ScrnInfoPtr pScrn)
 	if (IS_R300_3D) {
 	    BEGIN_ACCEL(2);
 	    /* tex inst for src texture */
-	    OUT_ACCEL_REG(R300_US_TEX_INST_0,
+	    OUT_ACCEL_REG(R300_US_TEX_INST(0),
 			  (R300_TEX_SRC_ADDR(0) |
 			   R300_TEX_DST_ADDR(0) |
 			   R300_TEX_ID(0) |
 			   R300_TEX_INST(R300_TEX_INST_LD)));
 
 	    /* tex inst for mask texture */
-	    OUT_ACCEL_REG(R300_US_TEX_INST_1,
+	    OUT_ACCEL_REG(R300_US_TEX_INST(1),
 			  (R300_TEX_SRC_ADDR(1) |
 			   R300_TEX_DST_ADDR(1) |
 			   R300_TEX_ID(1) |
@@ -514,9 +516,8 @@ static void FUNC_NAME(RADEONInit3DEngine)(ScrnInfoPtr pScrn)
 	}
 
 	if (IS_R300_3D) {
-	    BEGIN_ACCEL(9);
+	    BEGIN_ACCEL(8);
 	    OUT_ACCEL_REG(R300_US_CONFIG, (0 << R300_NLEVEL_SHIFT) | R300_FIRST_TEX);
-	    OUT_ACCEL_REG(R300_US_PIXSIZE, 1); /* highest temp used */
 	    OUT_ACCEL_REG(R300_US_CODE_ADDR_0,
 			  (R300_ALU_START(0) |
 			   R300_ALU_SIZE(0) |
@@ -533,9 +534,8 @@ static void FUNC_NAME(RADEONInit3DEngine)(ScrnInfoPtr pScrn)
 			   R300_TEX_START(0) |
 			   R300_TEX_SIZE(0)));
 	} else {
-	    BEGIN_ACCEL(7);
+	    BEGIN_ACCEL(6);
 	    OUT_ACCEL_REG(R300_US_CONFIG, R500_ZERO_TIMES_ANYTHING_EQUALS_ZERO);
-	    OUT_ACCEL_REG(R300_US_PIXSIZE, 1); /* highest temp used */
 	    OUT_ACCEL_REG(R500_US_FC_CTRL, 0);
 	}
 	OUT_ACCEL_REG(R300_US_W_FMT, 0);
@@ -687,14 +687,14 @@ void FUNC_NAME(RADEONWaitForIdle)(ScrnInfoPtr pScrn)
 
 #ifdef ACCEL_CP
     /* Make sure the CP is idle first */
-    if (info->CPStarted) {
+    if (info->cp->CPStarted) {
 	int  ret;
 
 	FLUSH_RING();
 
 	for (;;) {
 	    do {
-		ret = drmCommandNone(info->drmFD, DRM_RADEON_CP_IDLE);
+		ret = drmCommandNone(info->dri->drmFD, DRM_RADEON_CP_IDLE);
 		if (ret && ret != -EBUSY) {
 		    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 			       "%s: CP idle %d\n", __FUNCTION__, ret);
diff --git a/src/radeon_crtc.c b/src/radeon_crtc.c
index c63b650..99992fc 100644
--- a/src/radeon_crtc.c
+++ b/src/radeon_crtc.c
@@ -48,8 +48,7 @@
 
 #ifdef XF86DRI
 #define _XF86DRI_SERVER_
-#include "radeon_dri.h"
-#include "radeon_sarea.h"
+#include "radeon_drm.h"
 #include "sarea.h"
 #endif
 
@@ -58,6 +57,14 @@ extern void atombios_crtc_mode_set(xf86CrtcPtr crtc,
 				   DisplayModePtr adjusted_mode,
 				   int x, int y);
 extern void atombios_crtc_dpms(xf86CrtcPtr crtc, int mode);
+extern void
+RADEONInitDispBandwidthLegacy(ScrnInfoPtr pScrn,
+			      DisplayModePtr mode1, int pixel_bytes1,
+			      DisplayModePtr mode2, int pixel_bytes2);
+extern void
+RADEONInitDispBandwidthAVIVO(ScrnInfoPtr pScrn,
+			     DisplayModePtr mode1, int pixel_bytes1,
+			     DisplayModePtr mode2, int pixel_bytes2);
 
 void
 radeon_crtc_dpms(xf86CrtcPtr crtc, int mode)
@@ -220,7 +227,12 @@ RADEONComputePLL(RADEONPLLPtr pll,
 			best_freq = current_freq;
 			best_error = error;
 			best_vco_diff = vco_diff;
-		    } else if ((flags & RADEON_PLL_PREFER_LOW_REF_DIV) && (ref_div < best_ref_div)) {
+		    } else if (((flags & RADEON_PLL_PREFER_LOW_REF_DIV) && (ref_div < best_ref_div)) ||
+			       ((flags & RADEON_PLL_PREFER_HIGH_REF_DIV) && (ref_div > best_ref_div)) ||
+			       ((flags & RADEON_PLL_PREFER_LOW_FB_DIV) && (feedback_div < best_feedback_div)) ||
+			       ((flags & RADEON_PLL_PREFER_HIGH_FB_DIV) && (feedback_div > best_feedback_div)) ||
+			       ((flags & RADEON_PLL_PREFER_LOW_POST_DIV) && (post_div < best_post_div)) ||
+			       ((flags & RADEON_PLL_PREFER_HIGH_POST_DIV) && (post_div > best_post_div))) {
 			best_post_div = post_div;
 			best_ref_div = ref_div;
 			best_feedback_div = feedback_div;
@@ -354,7 +366,7 @@ radeon_crtc_lock(xf86CrtcPtr crtc)
     RADEONInfoPtr  info = RADEONPTR(pScrn);
 
 #ifdef XF86DRI
-    if (info->CPStarted && pScrn->pScreen) {
+    if (info->cp->CPStarted && pScrn->pScreen) {
 	DRILock(pScrn->pScreen, 0);
 	if (info->accelOn)
 	    RADEON_SYNC(info, pScrn);
@@ -375,51 +387,13 @@ radeon_crtc_unlock(xf86CrtcPtr crtc)
     RADEONInfoPtr  info = RADEONPTR(pScrn);
 
 #ifdef XF86DRI
-	if (info->CPStarted && pScrn->pScreen) DRIUnlock(pScrn->pScreen);
+	if (info->cp->CPStarted && pScrn->pScreen) DRIUnlock(pScrn->pScreen);
 #endif
 
     if (info->accelOn)
         RADEON_SYNC(info, pScrn);
 }
 
-#ifdef USE_XAA
-/**
- * Allocates memory from the XF86 linear allocator, but also purges
- * memory if possible to cause the allocation to succeed.
- */
-static FBLinearPtr
-radeon_xf86AllocateOffscreenLinear(ScreenPtr pScreen, int length,
-				 int granularity,
-				 MoveLinearCallbackProcPtr moveCB,
-				 RemoveLinearCallbackProcPtr removeCB,
-				 pointer privData)
-{
-    FBLinearPtr linear;
-    int max_size;
-
-    linear = xf86AllocateOffscreenLinear(pScreen, length, granularity, moveCB,
-					 removeCB, privData);
-    if (linear != NULL)
-	return linear;
-
-    /* The above allocation didn't succeed, so purge unlocked stuff and try
-     * again.
-     */
-    xf86QueryLargestOffscreenLinear(pScreen, &max_size, granularity,
-				    PRIORITY_EXTREME);
-
-    if (max_size < length)
-	return NULL;
-
-    xf86PurgeUnlockedOffscreenAreas(pScreen);
-
-    linear = xf86AllocateOffscreenLinear(pScreen, length, granularity, moveCB,
-					 removeCB, privData);
-
-    return linear;
-}
-#endif
-
 /**
  * Allocates memory for a locked-in-framebuffer shadow of the given
  * width and height for this CRTC's rotated shadow framebuffer.
@@ -429,8 +403,6 @@ static void *
 radeon_crtc_shadow_allocate (xf86CrtcPtr crtc, int width, int height)
 {
     ScrnInfoPtr pScrn = crtc->scrn;
-    /* if this is called during ScreenInit() we don't have pScrn->pScreen yet */
-    ScreenPtr pScreen = screenInfo.screens[pScrn->scrnIndex];
     RADEONInfoPtr  info = RADEONPTR(pScrn);
     RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
     unsigned long rotate_pitch;
@@ -441,49 +413,14 @@ radeon_crtc_shadow_allocate (xf86CrtcPtr crtc, int width, int height)
     rotate_pitch = pScrn->displayWidth * cpp;
     size = rotate_pitch * height;
 
-#ifdef USE_EXA
     /* We could get close to what we want here by just creating a pixmap like
      * normal, but we have to lock it down in framebuffer, and there is no
      * setter for offscreen area locking in EXA currently.  So, we just
      * allocate offscreen memory and fake up a pixmap header for it.
      */
-    if (info->useEXA) {
-	assert(radeon_crtc->rotate_mem_exa == NULL);
-
-	radeon_crtc->rotate_mem_exa = exaOffscreenAlloc(pScreen, size, align,
-						       TRUE, NULL, NULL);
-	if (radeon_crtc->rotate_mem_exa == NULL) {
-	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-		       "Couldn't allocate shadow memory for rotated CRTC\n");
-	    return NULL;
-	}
-	rotate_offset = radeon_crtc->rotate_mem_exa->offset;
-    }
-#endif /* USE_EXA */
-#ifdef USE_XAA
-    if (!info->useEXA) {
-	/* The XFree86 linear allocator operates in units of screen pixels,
-	 * sadly.
-	 */
-	size = (size + cpp - 1) / cpp;
-	align = (align + cpp - 1) / cpp;
-
-	assert(radeon_crtc->rotate_mem_xaa == NULL);
-
-	radeon_crtc->rotate_mem_xaa =
-	    radeon_xf86AllocateOffscreenLinear(pScreen, size, align,
-					       NULL, NULL, NULL);
-	if (radeon_crtc->rotate_mem_xaa == NULL) {
-	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-		       "Couldn't allocate shadow memory for rotated CRTC\n");
-	    return NULL;
-	}
-#ifdef XF86DRI
-	rotate_offset = info->frontOffset +
-	    radeon_crtc->rotate_mem_xaa->offset * cpp;
-#endif
-    }
-#endif /* USE_XAA */
+    rotate_offset = radeon_allocate_memory(pScrn, &radeon_crtc->crtc_rotate_mem, size, align);
+    if (rotate_offset == 0)
+	return NULL;
 
     return info->FB + rotate_offset;
 }
@@ -523,26 +460,16 @@ static void
 radeon_crtc_shadow_destroy(xf86CrtcPtr crtc, PixmapPtr rotate_pixmap, void *data)
 {
     ScrnInfoPtr pScrn = crtc->scrn;
-    RADEONInfoPtr  info = RADEONPTR(pScrn);
     RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
 
     if (rotate_pixmap)
 	FreeScratchPixmapHeader(rotate_pixmap);
-    
+
     if (data) {
-#ifdef USE_EXA
-	if (info->useEXA && radeon_crtc->rotate_mem_exa != NULL) {
-	    exaOffscreenFree(pScrn->pScreen, radeon_crtc->rotate_mem_exa);
-	    radeon_crtc->rotate_mem_exa = NULL;
-	}
-#endif /* USE_EXA */
-#ifdef USE_XAA
-	if (!info->useEXA) {
-	    xf86FreeOffscreenLinear(radeon_crtc->rotate_mem_xaa);
-	    radeon_crtc->rotate_mem_xaa = NULL;
-	}
-#endif /* USE_XAA */
+	radeon_free_memory(pScrn, radeon_crtc->crtc_rotate_mem);
+	radeon_crtc->crtc_rotate_mem = NULL;
     }
+
 }
 
 static const xf86CrtcFuncsRec radeon_crtc_funcs = {
@@ -567,6 +494,43 @@ static const xf86CrtcFuncsRec radeon_crtc_funcs = {
     .destroy = NULL, /* XXX */
 };
 
+void
+RADEONInitDispBandwidth(ScrnInfoPtr pScrn)
+{
+    RADEONInfoPtr info = RADEONPTR(pScrn);
+    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
+    DisplayModePtr mode1 = NULL, mode2 = NULL;
+    int pixel_bytes1 = info->CurrentLayout.pixel_bytes;
+    int pixel_bytes2 = info->CurrentLayout.pixel_bytes;
+
+    if (xf86_config->num_crtc == 2) {
+	if (xf86_config->crtc[1]->enabled &&
+	    xf86_config->crtc[0]->enabled) {
+	    mode1 = &xf86_config->crtc[0]->mode;
+	    mode2 = &xf86_config->crtc[1]->mode;
+	} else if (xf86_config->crtc[0]->enabled) {
+	    mode1 = &xf86_config->crtc[0]->mode;
+	} else if (xf86_config->crtc[1]->enabled) {
+	    mode2 = &xf86_config->crtc[1]->mode;
+	} else
+	    return;
+    } else {
+	if (info->IsPrimary)
+	    mode1 = &xf86_config->crtc[0]->mode;
+	else if (info->IsSecondary)
+	    mode2 = &xf86_config->crtc[0]->mode;
+	else if (xf86_config->crtc[0]->enabled)
+	    mode1 = &xf86_config->crtc[0]->mode;
+	else
+	    return;
+    }
+
+    if (IS_AVIVO_VARIANT)
+	RADEONInitDispBandwidthAVIVO(pScrn, mode1, pixel_bytes1, mode2, pixel_bytes2);
+    else
+	RADEONInitDispBandwidthLegacy(pScrn, mode1, pixel_bytes1, mode2, pixel_bytes2);
+}
+
 Bool RADEONAllocateControllers(ScrnInfoPtr pScrn, int mask)
 {
     RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
@@ -791,7 +755,7 @@ RADEONSetTiling(ScrnInfoPtr pScrn)
 
 #ifdef XF86DRI
     if (info->directRenderingEnabled && (info->tilingEnabled != can_tile)) {
-	RADEONSAREAPrivPtr pSAREAPriv;
+	drm_radeon_sarea_t *pSAREAPriv;
 	if (RADEONDRISetParam(pScrn, RADEON_SETPARAM_SWITCH_TILING, (can_tile ? 1 : 0)) < 0)
 	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		       "[drm] failed changing tiling status\n");
diff --git a/src/radeon_cursor.c b/src/radeon_cursor.c
index c4472db..22a33d6 100644
--- a/src/radeon_cursor.c
+++ b/src/radeon_cursor.c
@@ -209,21 +209,23 @@ radeon_crtc_set_cursor_position (xf86CrtcPtr crtc, int x, int y)
     if (xorigin >= CURSOR_WIDTH)  xorigin = CURSOR_WIDTH - 1;
     if (yorigin >= CURSOR_HEIGHT) yorigin = CURSOR_HEIGHT - 1;
 
-    if (mode->Flags & V_INTERLACE)
-	y /= 2;
-    else if (mode->Flags & V_DBLSCAN)
-	y *= 2;
-
     if (IS_AVIVO_VARIANT) {
 	/* avivo cursor spans the full fb width */
-	x += crtc->x;
-	y += crtc->y;
+	if (crtc->rotatedData == NULL) {
+	    x += crtc->x;
+	    y += crtc->y;
+	}
 	avivo_lock_cursor(crtc, TRUE);
 	OUTREG(AVIVO_D1CUR_POSITION + radeon_crtc->crtc_offset, ((xorigin ? 0 : x) << 16)
 	       | (yorigin ? 0 : y));
 	OUTREG(AVIVO_D1CUR_HOT_SPOT + radeon_crtc->crtc_offset, (xorigin << 16) | yorigin);
 	avivo_lock_cursor(crtc, FALSE);
     } else {
+	if (mode->Flags & V_INTERLACE)
+	    y /= 2;
+	else if (mode->Flags & V_DBLSCAN)
+	    y *= 2;
+
 	if (crtc_id == 0) {
 	    OUTREG(RADEON_CUR_HORZ_VERT_OFF,  (RADEON_CUR_LOCK
 					       | (xorigin << 16)
@@ -325,49 +327,32 @@ Bool RADEONCursorInit(ScreenPtr pScreen)
     int		       width_bytes;
     int                height;
     int                size_bytes;
-    uint32_t           cursor_offset = 0;
     int                c;
 
     size_bytes  = CURSOR_WIDTH * 4 * CURSOR_HEIGHT;
     width       = pScrn->displayWidth;
     width_bytes = width * (pScrn->bitsPerPixel / 8);
     height      = ((size_bytes * xf86_config->num_crtc) + width_bytes - 1) / width_bytes;
+    int align = IS_AVIVO_VARIANT ? 4096 : 256;
 
-#ifdef USE_XAA
     if (!info->useEXA) {
-	int align = IS_AVIVO_VARIANT ? 4096 : 256;
-	FBAreaPtr          fbarea;
-
-	fbarea = xf86AllocateOffscreenArea(pScreen, width, height,
-					   align, NULL, NULL, NULL);
-
-	if (!fbarea) {
-	    cursor_offset    = 0;
-	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-		   "Hardware cursor disabled"
-		   " due to insufficient offscreen memory\n");
-	    return FALSE;
-	} else {
-	    cursor_offset  = RADEON_ALIGN((fbarea->box.x1 +
-					   fbarea->box.y1 * width) *
-					  info->CurrentLayout.pixel_bytes,
-					  align);
-
-	    for (c = 0; c < xf86_config->num_crtc; c++) {
-		xf86CrtcPtr crtc = xf86_config->crtc[c];
-		RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
-
-		radeon_crtc->cursor_offset = cursor_offset + (c * size_bytes);
-
-		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-			   "Using hardware cursor %d (scanline %u)\n", c,
-			   (unsigned)(radeon_crtc->cursor_offset / pScrn->displayWidth
-				      / info->CurrentLayout.pixel_bytes));
-	    }
+	for (c = 0; c < xf86_config->num_crtc; c++) {
+	    xf86CrtcPtr crtc = xf86_config->crtc[c];
+	    RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
 
+	    radeon_crtc->cursor_offset =
+		radeon_allocate_memory(pScrn, &radeon_crtc->cursor_mem, size_bytes, align);
+
+	    if (radeon_crtc->cursor_offset == 0)
+		return FALSE;
+
+	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+		       "Will use %d kb for hardware cursor %d at offset 0x%08x\n",
+		       (size_bytes * xf86_config->num_crtc) / 1024,
+		       c,
+		       (unsigned int)radeon_crtc->cursor_offset);
 	}
     }
-#endif
 
     return xf86_cursors_init (pScreen, CURSOR_WIDTH, CURSOR_HEIGHT,
 			      (HARDWARE_CURSOR_TRUECOLOR_AT_8BPP |
diff --git a/src/radeon_dga.c b/src/radeon_dga.c
index d623fe4..6b0fabe 100644
--- a/src/radeon_dga.c
+++ b/src/radeon_dga.c
@@ -47,6 +47,9 @@
 				/* Driver data structures */
 #include "radeon.h"
 #include "radeon_probe.h"
+#ifdef XF86DRI
+#include "radeon_drm.h"
+#endif
 
 				/* X and server generic header files */
 #include "xf86.h"
@@ -126,12 +129,12 @@ SECOND_PASS:
 	    }
 #endif /* USE_EXA */
 #ifdef USE_XAA
-	    if (!info->useEXA && info->accel) {
-	      if (info->accel->SetupForSolidFill &&
-		  info->accel->SubsequentSolidFillRect)
+	    if (!info->useEXA && info->accel_state->accel) {
+	      if (info->accel_state->accel->SetupForSolidFill &&
+		  info->accel_state->accel->SubsequentSolidFillRect)
 		 currentMode->flags    |= DGA_FILL_RECT;
-	      if (info->accel->SetupForScreenToScreenCopy &&
-		  info->accel->SubsequentScreenToScreenCopy)
+	      if (info->accel_state->accel->SetupForScreenToScreenCopy &&
+		  info->accel_state->accel->SubsequentScreenToScreenCopy)
 		 currentMode->flags    |= DGA_BLIT_RECT | DGA_BLIT_RECT_TRANS;
 	      if (currentMode->flags &
 		  (DGA_PIXMAP_AVAILABLE | DGA_FILL_RECT |
@@ -265,13 +268,13 @@ Bool RADEONDGAInit(ScreenPtr pScreen)
     }
 #endif /* USE_EXA */
 #ifdef USE_XAA
-    if (!info->useEXA && info->accel) {
-	info->DGAFuncs.Sync              = info->accel->Sync;
-	if (info->accel->SetupForSolidFill &&
-	    info->accel->SubsequentSolidFillRect)
+    if (!info->useEXA && info->accel_state->accel) {
+	info->DGAFuncs.Sync              = info->accel_state->accel->Sync;
+	if (info->accel_state->accel->SetupForSolidFill &&
+	    info->accel_state->accel->SubsequentSolidFillRect)
 	    info->DGAFuncs.FillRect      = RADEON_FillRect;
-	if (info->accel->SetupForScreenToScreenCopy &&
-	    info->accel->SubsequentScreenToScreenCopy) {
+	if (info->accel_state->accel->SetupForScreenToScreenCopy &&
+	    info->accel_state->accel->SubsequentScreenToScreenCopy) {
 	    info->DGAFuncs.BlitRect      = RADEON_BlitRect;
 	    info->DGAFuncs.BlitTransRect = RADEON_BlitTransRect;
 	}
@@ -383,8 +386,8 @@ static void RADEON_FillRect(ScrnInfoPtr pScrn,
 #endif /* USE_EXA */
 #ifdef USE_XAA
     if (!info->useEXA) {
-	(*info->accel->SetupForSolidFill)(pScrn, color, GXcopy, (uint32_t)(~0));
-	(*info->accel->SubsequentSolidFillRect)(pScrn, x, y, w, h);
+	(*info->accel_state->accel->SetupForSolidFill)(pScrn, color, GXcopy, (uint32_t)(~0));
+	(*info->accel_state->accel->SubsequentSolidFillRect)(pScrn, x, y, w, h);
         if (pScrn->bitsPerPixel == info->CurrentLayout.bitsPerPixel)
 	    RADEON_MARK_SYNC(info, pScrn);
     }
@@ -413,10 +416,10 @@ static void RADEON_BlitRect(ScrnInfoPtr pScrn,
 #endif /* USE_EXA */
 #ifdef USE_XAA
     if (!info->useEXA) {
-	(*info->accel->SetupForScreenToScreenCopy)(pScrn, xdir, ydir,
-						   GXcopy, (uint32_t)(~0), -1);
-	(*info->accel->SubsequentScreenToScreenCopy)(pScrn, srcx, srcy,
-						     dstx, dsty, w, h);
+	(*info->accel_state->accel->SetupForScreenToScreenCopy)(pScrn, xdir, ydir,
+								GXcopy, (uint32_t)(~0), -1);
+	(*info->accel_state->accel->SubsequentScreenToScreenCopy)(pScrn, srcx, srcy,
+								  dstx, dsty, w, h);
         if (pScrn->bitsPerPixel == info->CurrentLayout.bitsPerPixel)
 	    RADEON_MARK_SYNC(info, pScrn);
     }
@@ -431,14 +434,14 @@ static void RADEON_BlitTransRect(ScrnInfoPtr pScrn,
     int            xdir = ((srcx < dstx) && (srcy == dsty)) ? -1 : 1;
     int            ydir = (srcy < dsty) ? -1 : 1;
 
-    info->XAAForceTransBlit = TRUE;
-    (*info->accel->SetupForScreenToScreenCopy)(pScrn, xdir, ydir,
-					       GXcopy, (uint32_t)(~0), color);
+    info->accel_state->XAAForceTransBlit = TRUE;
+    (*info->accel_state->accel->SetupForScreenToScreenCopy)(pScrn, xdir, ydir,
+							    GXcopy, (uint32_t)(~0), color);
 
-    info->XAAForceTransBlit = FALSE;
+    info->accel_state->XAAForceTransBlit = FALSE;
 
-    (*info->accel->SubsequentScreenToScreenCopy)(pScrn, srcx, srcy,
-						 dstx, dsty, w, h);
+    (*info->accel_state->accel->SubsequentScreenToScreenCopy)(pScrn, srcx, srcy,
+							      dstx, dsty, w, h);
 
     if (pScrn->bitsPerPixel == info->CurrentLayout.bitsPerPixel)
         RADEON_MARK_SYNC(info, pScrn);
diff --git a/src/radeon_dri.c b/src/radeon_dri.c
index 0fc03e4..5542d2b 100644
--- a/src/radeon_dri.c
+++ b/src/radeon_dri.c
@@ -46,6 +46,7 @@
 #include "radeon_video.h"
 #include "radeon_reg.h"
 #include "radeon_macros.h"
+#include "radeon_drm.h"
 #include "radeon_dri.h"
 #include "radeon_version.h"
 
@@ -58,10 +59,13 @@
 #define _XF86DRI_SERVER_
 #include "GL/glxtokens.h"
 #include "sarea.h"
-#include "radeon_sarea.h"
 
 static size_t radeon_drm_page_size;
 
+#define RADEON_MAX_DRAWABLES 256
+
+extern void GlxSetVisualConfigs(int nconfigs, __GLXvisualConfig *configs,
+				void **configprivs);
 
 static void RADEONDRITransitionTo2d(ScreenPtr pScreen);
 static void RADEONDRITransitionTo3d(ScreenPtr pScreen);
@@ -92,7 +96,7 @@ static Bool RADEONInitVisualConfigs(ScreenPtr pScreen)
     RADEONConfigPrivPtr *pRADEONConfigPtrs = 0;
     int                  i, accum, stencil, db, use_db;
 
-    use_db = !info->noBackBuffer ? 1 : 0;
+    use_db = !info->dri->noBackBuffer ? 1 : 0;
 
     switch (info->CurrentLayout.pixel_code) {
     case 8:  /* 8bpp mode is not support */
@@ -166,7 +170,7 @@ static Bool RADEONInitVisualConfigs(ScreenPtr pScreen)
 		    pConfigs[i].doubleBuffer   = FALSE;
 		pConfigs[i].stereo             = FALSE;
 		pConfigs[i].bufferSize         = 16;
-		pConfigs[i].depthSize          = info->depthBits;
+		pConfigs[i].depthSize          = info->dri->depthBits;
 		if (pConfigs[i].depthSize == 24 ? (RADEON_USE_STENCIL - stencil)
 						: stencil) {
 		    pConfigs[i].stencilSize    = 8;
@@ -252,7 +256,7 @@ static Bool RADEONInitVisualConfigs(ScreenPtr pScreen)
 		    pConfigs[i].doubleBuffer   = FALSE;
 		pConfigs[i].stereo             = FALSE;
 		pConfigs[i].bufferSize         = 32;
-		pConfigs[i].depthSize          = info->depthBits;
+		pConfigs[i].depthSize          = info->dri->depthBits;
 		if (pConfigs[i].depthSize == 24 ? (RADEON_USE_STENCIL - stencil)
 						: stencil) {
 		    pConfigs[i].stencilSize    = 8;
@@ -280,9 +284,9 @@ static Bool RADEONInitVisualConfigs(ScreenPtr pScreen)
 	break;
     }
 
-    info->numVisualConfigs   = numConfigs;
-    info->pVisualConfigs     = pConfigs;
-    info->pVisualConfigsPriv = pRADEONConfigs;
+    info->dri->numVisualConfigs   = numConfigs;
+    info->dri->pVisualConfigs     = pConfigs;
+    info->dri->pVisualConfigsPriv = pRADEONConfigs;
     GlxSetVisualConfigs(numConfigs, pConfigs, (void**)pRADEONConfigPtrs);
     return TRUE;
 }
@@ -300,8 +304,8 @@ static Bool RADEONCreateContext(ScreenPtr pScreen, VisualPtr visual,
     ctx_info = (RADEONDRIContextPtr)contextStore;
     if (!ctx_info) return FALSE;
 
-    if (drmAddMap(info->drmFD, 0,
-		  info->perctx_sarea_size,
+    if (drmAddMap(info->dri->drmFD, 0,
+		  info->dri->perctx_sarea_size,
 		  DRM_SHM,
 		  DRM_REMOVABLE,
 		  &ctx_info->sarea_handle) < 0) {
@@ -311,12 +315,12 @@ static Bool RADEONCreateContext(ScreenPtr pScreen, VisualPtr visual,
 	return FALSE;
     }
 
-    if (drmAddContextPrivateMapping(info->drmFD, hwContext,
+    if (drmAddContextPrivateMapping(info->dri->drmFD, hwContext,
 				    ctx_info->sarea_handle) < 0) {
 	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 		   "[dri] could not associate private sarea to ctx id (%d)\n",
 		   (int)hwContext);
-	drmRmMap(info->drmFD, ctx_info->sarea_handle);
+	drmRmMap(info->dri->drmFD, ctx_info->sarea_handle);
 	return FALSE;
     }
 
@@ -337,7 +341,7 @@ static void RADEONDestroyContext(ScreenPtr pScreen, drm_context_t hwContext,
     ctx_info = (RADEONDRIContextPtr)contextStore;
     if (!ctx_info) return;
 
-    if (drmRmMap(info->drmFD, ctx_info->sarea_handle) < 0) {
+    if (drmRmMap(info->dri->drmFD, ctx_info->sarea_handle) < 0) {
 	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 		   "[dri] could not remove private sarea for ctx id (%d)\n",
 		   (int)hwContext);
@@ -356,29 +360,29 @@ static void RADEONEnterServer(ScreenPtr pScreen)
 {
     ScrnInfoPtr    pScrn = xf86Screens[pScreen->myNum];
     RADEONInfoPtr  info  = RADEONPTR(pScrn);
-    RADEONSAREAPrivPtr pSAREAPriv;
+    drm_radeon_sarea_t *pSAREAPriv;
 
 
     RADEON_MARK_SYNC(info, pScrn);
 
     pSAREAPriv = DRIGetSAREAPrivate(pScrn->pScreen);
-    if (pSAREAPriv->ctxOwner != DRIGetContext(pScrn->pScreen)) {
-	info->XInited3D = FALSE;
-	info->needCacheFlush = (info->ChipFamily >= CHIP_FAMILY_R300);
+    if (pSAREAPriv->ctx_owner != DRIGetContext(pScrn->pScreen)) {
+	info->accel_state->XInited3D = FALSE;
+	info->cp->needCacheFlush = (info->ChipFamily >= CHIP_FAMILY_R300);
     }
 
 #ifdef DAMAGE
-    if (!info->pDamage && info->allowPageFlip) {
+    if (!info->dri->pDamage && info->dri->allowPageFlip) {
 	PixmapPtr pPix  = pScreen->GetScreenPixmap(pScreen);
-	info->pDamage = DamageCreate(NULL, NULL, DamageReportNone, TRUE,
-				     pScreen, pPix);
+	info->dri->pDamage = DamageCreate(NULL, NULL, DamageReportNone, TRUE,
+					  pScreen, pPix);
 
-	if (info->pDamage == NULL) {
+	if (info->dri->pDamage == NULL) {
 	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		       "No screen damage record, page flipping disabled\n");
-	    info->allowPageFlip = 0;
+	    info->dri->allowPageFlip = 0;
 	} else {
-	    DamageRegister(&pPix->drawable, info->pDamage);
+	    DamageRegister(&pPix->drawable, info->dri->pDamage);
 
 	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 		       "Damage tracking initialized for page flipping\n");
@@ -401,8 +405,8 @@ static void RADEONLeaveServer(ScreenPtr pScreen)
     RING_LOCALS;
 
 #ifdef DAMAGE
-    if (info->pDamage) {
-	RegionPtr pDamageReg = DamageRegion(info->pDamage);
+    if (info->dri->pDamage) {
+	RegionPtr pDamageReg = DamageRegion(info->dri->pDamage);
 	int nrects = pDamageReg ? REGION_NUM_RECTS(pDamageReg) : 0;
 
 	if (nrects) {
@@ -417,7 +421,7 @@ static void RADEONLeaveServer(ScreenPtr pScreen)
     RADEONCP_RELEASE(pScrn, info);
 
 #ifdef USE_EXA
-    info->engineMode = EXA_ENGINEMODE_UNKNOWN;
+    info->accel_state->engineMode = EXA_ENGINEMODE_UNKNOWN;
 #endif
 }
 
@@ -451,17 +455,17 @@ static void RADEONDRISwapContext(ScreenPtr pScreen, DRISyncType syncType,
 
 /* 16-bit depth buffer functions */
 #define WRITE_DEPTH16(_x, _y, d)					\
-    *(uint16_t *)(pointer)(buf + 2*(_x + _y*info->frontPitch)) = (d)
+    *(uint16_t *)(pointer)(buf + 2*(_x + _y*info->dri->frontPitch)) = (d)
 
 #define READ_DEPTH16(d, _x, _y)						\
-    (d) = *(uint16_t *)(pointer)(buf + 2*(_x + _y*info->frontPitch))
+    (d) = *(uint16_t *)(pointer)(buf + 2*(_x + _y*info->dri->frontPitch))
 
 /* 32-bit depth buffer (stencil and depth simultaneously) functions */
 #define WRITE_DEPTHSTENCIL32(_x, _y, d)					\
-    *(uint32_t *)(pointer)(buf + 4*(_x + _y*info->frontPitch)) = (d)
+    *(uint32_t *)(pointer)(buf + 4*(_x + _y*info->dri->frontPitch)) = (d)
 
 #define READ_DEPTHSTENCIL32(d, _x, _y)					\
-    (d) = *(uint32_t *)(pointer)(buf + 4*(_x + _y*info->frontPitch))
+    (d) = *(uint32_t *)(pointer)(buf + 4*(_x + _y*info->dri->frontPitch))
 
 /* Screen to screen copy of data in the depth buffer */
 static void RADEONScreenToScreenCopyDepth(ScrnInfoPtr pScrn,
@@ -470,7 +474,7 @@ static void RADEONScreenToScreenCopyDepth(ScrnInfoPtr pScrn,
 					  int w, int h)
 {
     RADEONInfoPtr  info = RADEONPTR(pScrn);
-    unsigned char *buf  = info->FB + info->depthOffset;
+    unsigned char *buf  = info->FB + info->dri->depthOffset;
     int            xstart, xend, xdir;
     int            ystart, yend, ydir;
     int            x, y, d;
@@ -641,12 +645,12 @@ static void RADEONDRIMoveBuffers(WindowPtr pParent, DDXPointRec ptOldOrg,
     }
 
     /* pretty much a hack. */
-    info->dst_pitch_offset = info->backPitchOffset;
+    info->accel_state->dst_pitch_offset = info->dri->backPitchOffset;
     if (info->tilingEnabled)
-       info->dst_pitch_offset |= RADEON_DST_TILE_MACRO;
+       info->accel_state->dst_pitch_offset |= RADEON_DST_TILE_MACRO;
 
-    (*info->accel->SetupForScreenToScreenCopy)(pScrn, xdir, ydir, GXcopy,
-					       (uint32_t)(-1), -1);
+    (*info->accel_state->accel->SetupForScreenToScreenCopy)(pScrn, xdir, ydir, GXcopy,
+							    (uint32_t)(-1), -1);
 
     for (; nbox-- ; pbox++) {
 	int  xa    = pbox->x1;
@@ -664,12 +668,12 @@ static void RADEONDRIMoveBuffers(WindowPtr pParent, DDXPointRec ptOldOrg,
 	if (w <= 0) continue;
 	if (h <= 0) continue;
 
-	(*info->accel->SubsequentScreenToScreenCopy)(pScrn,
-						     xa, ya,
-						     destx, desty,
-						     w, h);
+	(*info->accel_state->accel->SubsequentScreenToScreenCopy)(pScrn,
+								  xa, ya,
+								  destx, desty,
+								  w, h);
 
-	if (info->depthMoves) {
+	if (info->dri->depthMoves) {
 	    RADEONScreenToScreenCopyDepth(pScrn,
 					  xa, ya,
 					  destx, desty,
@@ -677,14 +681,14 @@ static void RADEONDRIMoveBuffers(WindowPtr pParent, DDXPointRec ptOldOrg,
 	}
     }
 
-    info->dst_pitch_offset = info->frontPitchOffset;;
+    info->accel_state->dst_pitch_offset = info->dri->frontPitchOffset;;
 
     xfree(pptNew2);
     xfree(pboxNew2);
     xfree(pptNew1);
     xfree(pboxNew1);
 
-    info->accel->NeedToSync = TRUE;
+    info->accel_state->accel->NeedToSync = TRUE;
 #endif /* USE_XAA */
 }
 
@@ -692,36 +696,36 @@ static void RADEONDRIInitGARTValues(RADEONInfoPtr info)
 {
     int            s, l;
 
-    info->gartOffset = 0;
+    info->dri->gartOffset = 0;
 
 				/* Initialize the CP ring buffer data */
-    info->ringStart       = info->gartOffset;
-    info->ringMapSize     = info->ringSize*1024*1024 + radeon_drm_page_size;
-    info->ringSizeLog2QW  = RADEONMinBits(info->ringSize*1024*1024/8)-1;
+    info->dri->ringStart       = info->dri->gartOffset;
+    info->dri->ringMapSize     = info->dri->ringSize*1024*1024 + radeon_drm_page_size;
+    info->dri->ringSizeLog2QW  = RADEONMinBits(info->dri->ringSize*1024*1024/8)-1;
 
-    info->ringReadOffset  = info->ringStart + info->ringMapSize;
-    info->ringReadMapSize = radeon_drm_page_size;
+    info->dri->ringReadOffset  = info->dri->ringStart + info->dri->ringMapSize;
+    info->dri->ringReadMapSize = radeon_drm_page_size;
 
 				/* Reserve space for vertex/indirect buffers */
-    info->bufStart        = info->ringReadOffset + info->ringReadMapSize;
-    info->bufMapSize      = info->bufSize*1024*1024;
+    info->dri->bufStart        = info->dri->ringReadOffset + info->dri->ringReadMapSize;
+    info->dri->bufMapSize      = info->dri->bufSize*1024*1024;
 
 				/* Reserve the rest for GART textures */
-    info->gartTexStart     = info->bufStart + info->bufMapSize;
-    s = (info->gartSize*1024*1024 - info->gartTexStart);
+    info->dri->gartTexStart     = info->dri->bufStart + info->dri->bufMapSize;
+    s = (info->dri->gartSize*1024*1024 - info->dri->gartTexStart);
     l = RADEONMinBits((s-1) / RADEON_NR_TEX_REGIONS);
     if (l < RADEON_LOG_TEX_GRANULARITY) l = RADEON_LOG_TEX_GRANULARITY;
-    info->gartTexMapSize   = (s >> l) << l;
-    info->log2GARTTexGran  = l;
+    info->dri->gartTexMapSize   = (s >> l) << l;
+    info->dri->log2GARTTexGran  = l;
 }
 
 /* Set AGP transfer mode according to requests and constraints */
 static Bool RADEONSetAgpMode(RADEONInfoPtr info, ScreenPtr pScreen)
 {
     unsigned char *RADEONMMIO = info->MMIO;
-    unsigned long mode   = drmAgpGetMode(info->drmFD);	/* Default mode */
-    unsigned int  vendor = drmAgpVendorId(info->drmFD);
-    unsigned int  device = drmAgpDeviceId(info->drmFD);
+    unsigned long mode   = drmAgpGetMode(info->dri->drmFD);	/* Default mode */
+    unsigned int  vendor = drmAgpVendorId(info->dri->drmFD);
+    unsigned int  device = drmAgpDeviceId(info->dri->drmFD);
     /* ignore agp 3.0 mode bit from the chip as it's buggy on some cards with
        pcie-agp rialto bridge chip - use the one from bridge which must match */
     uint32_t agp_status = (INREG(RADEON_AGP_STATUS) | RADEON_AGPv3_MODE) & mode;
@@ -739,26 +743,26 @@ static Bool RADEONSetAgpMode(RADEONInfoPtr info, ScreenPtr pScreen)
 
     from = X_DEFAULT;
 
-    if (xf86GetOptValInteger(info->Options, OPTION_AGP_MODE, &info->agpMode)) {
-	if ((info->agpMode < (is_v3 ? 4 : 1)) ||
-            (info->agpMode > (is_v3 ? 8 : 4)) ||
-	    (info->agpMode & (info->agpMode - 1))) {
+    if (xf86GetOptValInteger(info->Options, OPTION_AGP_MODE, &info->dri->agpMode)) {
+	if ((info->dri->agpMode < (is_v3 ? 4 : 1)) ||
+            (info->dri->agpMode > (is_v3 ? 8 : 4)) ||
+	    (info->dri->agpMode & (info->dri->agpMode - 1))) {
 	    xf86DrvMsg(pScreen->myNum, X_ERROR,
 		       "Illegal AGP Mode: %d (valid values: %s), leaving at "
-		       "%dx\n", info->agpMode, is_v3 ? "4, 8" : "1, 2, 4",
+		       "%dx\n", info->dri->agpMode, is_v3 ? "4, 8" : "1, 2, 4",
 		       defaultMode);
-	    info->agpMode = defaultMode;
+	    info->dri->agpMode = defaultMode;
 	} else
 	    from = X_CONFIG;
     } else
-	info->agpMode = defaultMode;
+	info->dri->agpMode = defaultMode;
 
-    xf86DrvMsg(pScreen->myNum, from, "Using AGP %dx\n", info->agpMode);
+    xf86DrvMsg(pScreen->myNum, from, "Using AGP %dx\n", info->dri->agpMode);
 
     mode &= ~RADEON_AGP_MODE_MASK;
     if (is_v3) {
 	/* only set one mode bit for AGPv3 */
-	switch (info->agpMode) {
+	switch (info->dri->agpMode) {
 	case 8:          mode |= RADEON_AGPv3_8X_MODE; break;
 	case 4: default: mode |= RADEON_AGPv3_4X_MODE;
 	}
@@ -766,7 +770,7 @@ static Bool RADEONSetAgpMode(RADEONInfoPtr info, ScreenPtr pScreen)
 	 *      currently these bits are not used in all tested cards.
 	 */
     } else {
-	switch (info->agpMode) {
+	switch (info->dri->agpMode) {
 	case 4:          mode |= RADEON_AGP_4X_MODE;
 	case 2:          mode |= RADEON_AGP_2X_MODE;
 	case 1: default: mode |= RADEON_AGP_1X_MODE;
@@ -800,9 +804,9 @@ static Bool RADEONSetAgpMode(RADEONInfoPtr info, ScreenPtr pScreen)
 	       PCI_DEV_VENDOR_ID(info->PciInfo),
 	       PCI_DEV_DEVICE_ID(info->PciInfo));
 
-    if (drmAgpEnable(info->drmFD, mode) < 0) {
+    if (drmAgpEnable(info->dri->drmFD, mode) < 0) {
 	xf86DrvMsg(pScreen->myNum, X_ERROR, "[agp] AGP not enabled\n");
-	drmAgpRelease(info->drmFD);
+	drmAgpRelease(info->dri->drmFD);
 	return FALSE;
     }
 
@@ -829,15 +833,15 @@ static void RADEONSetAgpBase(RADEONInfoPtr info, ScreenPtr pScreen)
      * agp_base_2 ?
      */
     if (info->ChipFamily == CHIP_FAMILY_RV515)
-	OUTMC(pScrn, RV515_MC_AGP_BASE, drmAgpBase(info->drmFD));
+	OUTMC(pScrn, RV515_MC_AGP_BASE, drmAgpBase(info->dri->drmFD));
     else if ((info->ChipFamily >= CHIP_FAMILY_R520) &&
 	     (info->ChipFamily <= CHIP_FAMILY_RV570))
-	OUTMC(pScrn, R520_MC_AGP_BASE, drmAgpBase(info->drmFD));
+	OUTMC(pScrn, R520_MC_AGP_BASE, drmAgpBase(info->dri->drmFD));
     else if ((info->ChipFamily == CHIP_FAMILY_RS690) ||
 	     (info->ChipFamily == CHIP_FAMILY_RS740))
-	OUTMC(pScrn, RS690_MC_AGP_BASE, drmAgpBase(info->drmFD));
+	OUTMC(pScrn, RS690_MC_AGP_BASE, drmAgpBase(info->dri->drmFD));
     else if (info->ChipFamily < CHIP_FAMILY_RV515)
-	OUTREG(RADEON_AGP_BASE, drmAgpBase(info->drmFD));
+	OUTREG(RADEON_AGP_BASE, drmAgpBase(info->dri->drmFD));
 }
 
 /* Initialize the AGP state.  Request memory for use in AGP space, and
@@ -847,7 +851,7 @@ static Bool RADEONDRIAgpInit(RADEONInfoPtr info, ScreenPtr pScreen)
 {
     int            ret;
 
-    if (drmAgpAcquire(info->drmFD) < 0) {
+    if (drmAgpAcquire(info->dri->drmFD) < 0) {
 	xf86DrvMsg(pScreen->myNum, X_WARNING, "[agp] AGP not available\n");
 	return FALSE;
     }
@@ -857,101 +861,101 @@ static Bool RADEONDRIAgpInit(RADEONInfoPtr info, ScreenPtr pScreen)
 
     RADEONDRIInitGARTValues(info);
 
-    if ((ret = drmAgpAlloc(info->drmFD, info->gartSize*1024*1024, 0, NULL,
-			   &info->agpMemHandle)) < 0) {
+    if ((ret = drmAgpAlloc(info->dri->drmFD, info->dri->gartSize*1024*1024, 0, NULL,
+			   &info->dri->agpMemHandle)) < 0) {
 	xf86DrvMsg(pScreen->myNum, X_ERROR, "[agp] Out of memory (%d)\n", ret);
-	drmAgpRelease(info->drmFD);
+	drmAgpRelease(info->dri->drmFD);
 	return FALSE;
     }
     xf86DrvMsg(pScreen->myNum, X_INFO,
 	       "[agp] %d kB allocated with handle 0x%08x\n",
-	       info->gartSize*1024, info->agpMemHandle);
+	       info->dri->gartSize*1024, info->dri->agpMemHandle);
 
-    if (drmAgpBind(info->drmFD,
-		   info->agpMemHandle, info->gartOffset) < 0) {
+    if (drmAgpBind(info->dri->drmFD,
+		   info->dri->agpMemHandle, info->dri->gartOffset) < 0) {
 	xf86DrvMsg(pScreen->myNum, X_ERROR, "[agp] Could not bind\n");
-	drmAgpFree(info->drmFD, info->agpMemHandle);
-	drmAgpRelease(info->drmFD);
+	drmAgpFree(info->dri->drmFD, info->dri->agpMemHandle);
+	drmAgpRelease(info->dri->drmFD);
 	return FALSE;
     }
 
-    if (drmAddMap(info->drmFD, info->ringStart, info->ringMapSize,
-		  DRM_AGP, DRM_READ_ONLY, &info->ringHandle) < 0) {
+    if (drmAddMap(info->dri->drmFD, info->dri->ringStart, info->dri->ringMapSize,
+		  DRM_AGP, DRM_READ_ONLY, &info->dri->ringHandle) < 0) {
 	xf86DrvMsg(pScreen->myNum, X_ERROR,
 		   "[agp] Could not add ring mapping\n");
 	return FALSE;
     }
     xf86DrvMsg(pScreen->myNum, X_INFO,
-	       "[agp] ring handle = 0x%08x\n", info->ringHandle);
+	       "[agp] ring handle = 0x%08x\n", info->dri->ringHandle);
 
-    if (drmMap(info->drmFD, info->ringHandle, info->ringMapSize,
-	       &info->ring) < 0) {
+    if (drmMap(info->dri->drmFD, info->dri->ringHandle, info->dri->ringMapSize,
+	       &info->dri->ring) < 0) {
 	xf86DrvMsg(pScreen->myNum, X_ERROR, "[agp] Could not map ring\n");
 	return FALSE;
     }
     xf86DrvMsg(pScreen->myNum, X_INFO,
 	       "[agp] Ring mapped at 0x%08lx\n",
-	       (unsigned long)info->ring);
+	       (unsigned long)info->dri->ring);
 
-    if (drmAddMap(info->drmFD, info->ringReadOffset, info->ringReadMapSize,
-		  DRM_AGP, DRM_READ_ONLY, &info->ringReadPtrHandle) < 0) {
+    if (drmAddMap(info->dri->drmFD, info->dri->ringReadOffset, info->dri->ringReadMapSize,
+		  DRM_AGP, DRM_READ_ONLY, &info->dri->ringReadPtrHandle) < 0) {
 	xf86DrvMsg(pScreen->myNum, X_ERROR,
 		   "[agp] Could not add ring read ptr mapping\n");
 	return FALSE;
     }
     xf86DrvMsg(pScreen->myNum, X_INFO,
  	       "[agp] ring read ptr handle = 0x%08x\n",
-	       info->ringReadPtrHandle);
+	       info->dri->ringReadPtrHandle);
 
-    if (drmMap(info->drmFD, info->ringReadPtrHandle, info->ringReadMapSize,
-	       &info->ringReadPtr) < 0) {
+    if (drmMap(info->dri->drmFD, info->dri->ringReadPtrHandle, info->dri->ringReadMapSize,
+	       &info->dri->ringReadPtr) < 0) {
 	xf86DrvMsg(pScreen->myNum, X_ERROR,
 		   "[agp] Could not map ring read ptr\n");
 	return FALSE;
     }
     xf86DrvMsg(pScreen->myNum, X_INFO,
 	       "[agp] Ring read ptr mapped at 0x%08lx\n",
-	       (unsigned long)info->ringReadPtr);
+	       (unsigned long)info->dri->ringReadPtr);
 
-    if (drmAddMap(info->drmFD, info->bufStart, info->bufMapSize,
-		  DRM_AGP, 0, &info->bufHandle) < 0) {
+    if (drmAddMap(info->dri->drmFD, info->dri->bufStart, info->dri->bufMapSize,
+		  DRM_AGP, 0, &info->dri->bufHandle) < 0) {
 	xf86DrvMsg(pScreen->myNum, X_ERROR,
 		   "[agp] Could not add vertex/indirect buffers mapping\n");
 	return FALSE;
     }
     xf86DrvMsg(pScreen->myNum, X_INFO,
  	       "[agp] vertex/indirect buffers handle = 0x%08x\n",
-	       info->bufHandle);
+	       info->dri->bufHandle);
 
-    if (drmMap(info->drmFD, info->bufHandle, info->bufMapSize,
-	       &info->buf) < 0) {
+    if (drmMap(info->dri->drmFD, info->dri->bufHandle, info->dri->bufMapSize,
+	       &info->dri->buf) < 0) {
 	xf86DrvMsg(pScreen->myNum, X_ERROR,
 		   "[agp] Could not map vertex/indirect buffers\n");
 	return FALSE;
     }
     xf86DrvMsg(pScreen->myNum, X_INFO,
 	       "[agp] Vertex/indirect buffers mapped at 0x%08lx\n",
-	       (unsigned long)info->buf);
+	       (unsigned long)info->dri->buf);
 
-    if (drmAddMap(info->drmFD, info->gartTexStart, info->gartTexMapSize,
-		  DRM_AGP, 0, &info->gartTexHandle) < 0) {
+    if (drmAddMap(info->dri->drmFD, info->dri->gartTexStart, info->dri->gartTexMapSize,
+		  DRM_AGP, 0, &info->dri->gartTexHandle) < 0) {
 	xf86DrvMsg(pScreen->myNum, X_ERROR,
 		   "[agp] Could not add GART texture map mapping\n");
 	return FALSE;
     }
     xf86DrvMsg(pScreen->myNum, X_INFO,
  	       "[agp] GART texture map handle = 0x%08x\n",
-	       info->gartTexHandle);
+	       info->dri->gartTexHandle);
 
-    if (drmMap(info->drmFD, info->gartTexHandle, info->gartTexMapSize,
-	       &info->gartTex) < 0) {
+    if (drmMap(info->dri->drmFD, info->dri->gartTexHandle, info->dri->gartTexMapSize,
+	       &info->dri->gartTex) < 0) {
 	xf86DrvMsg(pScreen->myNum, X_ERROR,
 		   "[agp] Could not map GART texture map\n");
 	return FALSE;
     }
     xf86DrvMsg(pScreen->myNum, X_INFO,
 	       "[agp] GART Texture map mapped at 0x%08lx\n",
-	       (unsigned long)info->gartTex);
+	       (unsigned long)info->dri->gartTex);
 
     RADEONSetAgpBase(info, pScreen);
 
@@ -966,104 +970,104 @@ static Bool RADEONDRIPciInit(RADEONInfoPtr info, ScreenPtr pScreen)
     int  ret;
     int  flags = DRM_READ_ONLY | DRM_LOCKED | DRM_KERNEL;
 
-    ret = drmScatterGatherAlloc(info->drmFD, info->gartSize*1024*1024,
-				&info->pciMemHandle);
+    ret = drmScatterGatherAlloc(info->dri->drmFD, info->dri->gartSize*1024*1024,
+				&info->dri->pciMemHandle);
     if (ret < 0) {
 	xf86DrvMsg(pScreen->myNum, X_ERROR, "[pci] Out of memory (%d)\n", ret);
 	return FALSE;
     }
     xf86DrvMsg(pScreen->myNum, X_INFO,
 	       "[pci] %d kB allocated with handle 0x%08x\n",
-	       info->gartSize*1024, info->pciMemHandle);
+	       info->dri->gartSize*1024, info->dri->pciMemHandle);
 
     RADEONDRIInitGARTValues(info);
 
-    if (drmAddMap(info->drmFD, info->ringStart, info->ringMapSize,
-		  DRM_SCATTER_GATHER, flags, &info->ringHandle) < 0) {
+    if (drmAddMap(info->dri->drmFD, info->dri->ringStart, info->dri->ringMapSize,
+		  DRM_SCATTER_GATHER, flags, &info->dri->ringHandle) < 0) {
 	xf86DrvMsg(pScreen->myNum, X_ERROR,
 		   "[pci] Could not add ring mapping\n");
 	return FALSE;
     }
     xf86DrvMsg(pScreen->myNum, X_INFO,
-	       "[pci] ring handle = 0x%08x\n", info->ringHandle);
+	       "[pci] ring handle = 0x%08x\n", info->dri->ringHandle);
 
-    if (drmMap(info->drmFD, info->ringHandle, info->ringMapSize,
-	       &info->ring) < 0) {
+    if (drmMap(info->dri->drmFD, info->dri->ringHandle, info->dri->ringMapSize,
+	       &info->dri->ring) < 0) {
 	xf86DrvMsg(pScreen->myNum, X_ERROR, "[pci] Could not map ring\n");
 	return FALSE;
     }
     xf86DrvMsg(pScreen->myNum, X_INFO,
 	       "[pci] Ring mapped at 0x%08lx\n",
-	       (unsigned long)info->ring);
+	       (unsigned long)info->dri->ring);
     xf86DrvMsg(pScreen->myNum, X_INFO,
 	       "[pci] Ring contents 0x%08lx\n",
-	       *(unsigned long *)(pointer)info->ring);
+	       *(unsigned long *)(pointer)info->dri->ring);
 
-    if (drmAddMap(info->drmFD, info->ringReadOffset, info->ringReadMapSize,
-		  DRM_SCATTER_GATHER, flags, &info->ringReadPtrHandle) < 0) {
+    if (drmAddMap(info->dri->drmFD, info->dri->ringReadOffset, info->dri->ringReadMapSize,
+		  DRM_SCATTER_GATHER, flags, &info->dri->ringReadPtrHandle) < 0) {
 	xf86DrvMsg(pScreen->myNum, X_ERROR,
 		   "[pci] Could not add ring read ptr mapping\n");
 	return FALSE;
     }
     xf86DrvMsg(pScreen->myNum, X_INFO,
  	       "[pci] ring read ptr handle = 0x%08x\n",
-	       info->ringReadPtrHandle);
+	       info->dri->ringReadPtrHandle);
 
-    if (drmMap(info->drmFD, info->ringReadPtrHandle, info->ringReadMapSize,
-	       &info->ringReadPtr) < 0) {
+    if (drmMap(info->dri->drmFD, info->dri->ringReadPtrHandle, info->dri->ringReadMapSize,
+	       &info->dri->ringReadPtr) < 0) {
 	xf86DrvMsg(pScreen->myNum, X_ERROR,
 		   "[pci] Could not map ring read ptr\n");
 	return FALSE;
     }
     xf86DrvMsg(pScreen->myNum, X_INFO,
 	       "[pci] Ring read ptr mapped at 0x%08lx\n",
-	       (unsigned long)info->ringReadPtr);
+	       (unsigned long)info->dri->ringReadPtr);
     xf86DrvMsg(pScreen->myNum, X_INFO,
 	       "[pci] Ring read ptr contents 0x%08lx\n",
-	       *(unsigned long *)(pointer)info->ringReadPtr);
+	       *(unsigned long *)(pointer)info->dri->ringReadPtr);
 
-    if (drmAddMap(info->drmFD, info->bufStart, info->bufMapSize,
-		  DRM_SCATTER_GATHER, 0, &info->bufHandle) < 0) {
+    if (drmAddMap(info->dri->drmFD, info->dri->bufStart, info->dri->bufMapSize,
+		  DRM_SCATTER_GATHER, 0, &info->dri->bufHandle) < 0) {
 	xf86DrvMsg(pScreen->myNum, X_ERROR,
 		   "[pci] Could not add vertex/indirect buffers mapping\n");
 	return FALSE;
     }
     xf86DrvMsg(pScreen->myNum, X_INFO,
  	       "[pci] vertex/indirect buffers handle = 0x%08x\n",
-	       info->bufHandle);
+	       info->dri->bufHandle);
 
-    if (drmMap(info->drmFD, info->bufHandle, info->bufMapSize,
-	       &info->buf) < 0) {
+    if (drmMap(info->dri->drmFD, info->dri->bufHandle, info->dri->bufMapSize,
+	       &info->dri->buf) < 0) {
 	xf86DrvMsg(pScreen->myNum, X_ERROR,
 		   "[pci] Could not map vertex/indirect buffers\n");
 	return FALSE;
     }
     xf86DrvMsg(pScreen->myNum, X_INFO,
 	       "[pci] Vertex/indirect buffers mapped at 0x%08lx\n",
-	       (unsigned long)info->buf);
+	       (unsigned long)info->dri->buf);
     xf86DrvMsg(pScreen->myNum, X_INFO,
 	       "[pci] Vertex/indirect buffers contents 0x%08lx\n",
-	       *(unsigned long *)(pointer)info->buf);
+	       *(unsigned long *)(pointer)info->dri->buf);
 
-    if (drmAddMap(info->drmFD, info->gartTexStart, info->gartTexMapSize,
-		  DRM_SCATTER_GATHER, 0, &info->gartTexHandle) < 0) {
+    if (drmAddMap(info->dri->drmFD, info->dri->gartTexStart, info->dri->gartTexMapSize,
+		  DRM_SCATTER_GATHER, 0, &info->dri->gartTexHandle) < 0) {
 	xf86DrvMsg(pScreen->myNum, X_ERROR,
 		   "[pci] Could not add GART texture map mapping\n");
 	return FALSE;
     }
     xf86DrvMsg(pScreen->myNum, X_INFO,
  	       "[pci] GART texture map handle = 0x%08x\n",
-	       info->gartTexHandle);
+	       info->dri->gartTexHandle);
 
-    if (drmMap(info->drmFD, info->gartTexHandle, info->gartTexMapSize,
-	       &info->gartTex) < 0) {
+    if (drmMap(info->dri->drmFD, info->dri->gartTexHandle, info->dri->gartTexMapSize,
+	       &info->dri->gartTex) < 0) {
 	xf86DrvMsg(pScreen->myNum, X_ERROR,
 		   "[pci] Could not map GART texture map\n");
 	return FALSE;
     }
     xf86DrvMsg(pScreen->myNum, X_INFO,
 	       "[pci] GART Texture map mapped at 0x%08lx\n",
-	       (unsigned long)info->gartTex);
+	       (unsigned long)info->dri->gartTex);
 
     return TRUE;
 }
@@ -1074,13 +1078,13 @@ static Bool RADEONDRIPciInit(RADEONInfoPtr info, ScreenPtr pScreen)
 static Bool RADEONDRIMapInit(RADEONInfoPtr info, ScreenPtr pScreen)
 {
 				/* Map registers */
-    info->registerSize = info->MMIOSize;
-    if (drmAddMap(info->drmFD, info->MMIOAddr, info->registerSize,
-		  DRM_REGISTERS, DRM_READ_ONLY, &info->registerHandle) < 0) {
+    info->dri->registerSize = info->MMIOSize;
+    if (drmAddMap(info->dri->drmFD, info->MMIOAddr, info->dri->registerSize,
+		  DRM_REGISTERS, DRM_READ_ONLY, &info->dri->registerHandle) < 0) {
 	return FALSE;
     }
     xf86DrvMsg(pScreen->myNum, X_INFO,
-	       "[drm] register handle = 0x%08x\n", info->registerHandle);
+	       "[drm] register handle = 0x%08x\n", info->dri->registerHandle);
 
     return TRUE;
 }
@@ -1090,43 +1094,43 @@ static int RADEONDRIKernelInit(RADEONInfoPtr info, ScreenPtr pScreen)
 {
     ScrnInfoPtr    pScrn = xf86Screens[pScreen->myNum];
     int            cpp   = info->CurrentLayout.pixel_bytes;
-    drmRadeonInit  drmInfo;
+    drm_radeon_init_t  drmInfo;
 
-    memset(&drmInfo, 0, sizeof(drmRadeonInit));
+    memset(&drmInfo, 0, sizeof(drm_radeon_init_t));
     if ( info->ChipFamily >= CHIP_FAMILY_R300 )
-       drmInfo.func             = DRM_RADEON_INIT_R300_CP;
+       drmInfo.func             = RADEON_INIT_R300_CP;
     else
     if ( info->ChipFamily >= CHIP_FAMILY_R200 )
-       drmInfo.func		= DRM_RADEON_INIT_R200_CP;
+       drmInfo.func		= RADEON_INIT_R200_CP;
     else
-       drmInfo.func		= DRM_RADEON_INIT_CP;
+       drmInfo.func		= RADEON_INIT_CP;
 
     drmInfo.sarea_priv_offset   = sizeof(XF86DRISAREARec);
     drmInfo.is_pci              = (info->cardType!=CARD_AGP);
-    drmInfo.cp_mode             = info->CPMode;
-    drmInfo.gart_size           = info->gartSize*1024*1024;
-    drmInfo.ring_size           = info->ringSize*1024*1024;
-    drmInfo.usec_timeout        = info->CPusecTimeout;
+    drmInfo.cp_mode             = RADEON_CSQ_PRIBM_INDBM;
+    drmInfo.gart_size           = info->dri->gartSize*1024*1024;
+    drmInfo.ring_size           = info->dri->ringSize*1024*1024;
+    drmInfo.usec_timeout        = info->cp->CPusecTimeout;
 
     drmInfo.fb_bpp              = info->CurrentLayout.pixel_code;
-    drmInfo.depth_bpp           = (info->depthBits - 8) * 2;
-
-    drmInfo.front_offset        = info->frontOffset;
-    drmInfo.front_pitch         = info->frontPitch * cpp;
-    drmInfo.back_offset         = info->backOffset;
-    drmInfo.back_pitch          = info->backPitch * cpp;
-    drmInfo.depth_offset        = info->depthOffset;
-    drmInfo.depth_pitch         = info->depthPitch * drmInfo.depth_bpp / 8;
-
-    drmInfo.fb_offset           = info->fbHandle;
-    drmInfo.mmio_offset         = info->registerHandle;
-    drmInfo.ring_offset         = info->ringHandle;
-    drmInfo.ring_rptr_offset    = info->ringReadPtrHandle;
-    drmInfo.buffers_offset      = info->bufHandle;
-    drmInfo.gart_textures_offset= info->gartTexHandle;
-
-    if (drmCommandWrite(info->drmFD, DRM_RADEON_CP_INIT,
-			&drmInfo, sizeof(drmRadeonInit)) < 0)
+    drmInfo.depth_bpp           = (info->dri->depthBits - 8) * 2;
+
+    drmInfo.front_offset        = info->dri->frontOffset;
+    drmInfo.front_pitch         = info->dri->frontPitch * cpp;
+    drmInfo.back_offset         = info->dri->backOffset;
+    drmInfo.back_pitch          = info->dri->backPitch * cpp;
+    drmInfo.depth_offset        = info->dri->depthOffset;
+    drmInfo.depth_pitch         = info->dri->depthPitch * drmInfo.depth_bpp / 8;
+
+    drmInfo.fb_offset           = info->dri->fbHandle;
+    drmInfo.mmio_offset         = info->dri->registerHandle;
+    drmInfo.ring_offset         = info->dri->ringHandle;
+    drmInfo.ring_rptr_offset    = info->dri->ringReadPtrHandle;
+    drmInfo.buffers_offset      = info->dri->bufHandle;
+    drmInfo.gart_textures_offset= info->dri->gartTexHandle;
+
+    if (drmCommandWrite(info->dri->drmFD, DRM_RADEON_CP_INIT,
+			&drmInfo, sizeof(drm_radeon_init_t)) < 0)
 	return FALSE;
 
     /* DRM_RADEON_CP_INIT does an engine reset, which resets some engine
@@ -1140,21 +1144,21 @@ static int RADEONDRIKernelInit(RADEONInfoPtr info, ScreenPtr pScreen)
 
 static void RADEONDRIGartHeapInit(RADEONInfoPtr info, ScreenPtr pScreen)
 {
-    drmRadeonMemInitHeap drmHeap;
+    drm_radeon_mem_init_heap_t drmHeap;
 
     /* Start up the simple memory manager for GART space */
     drmHeap.region = RADEON_MEM_REGION_GART;
     drmHeap.start  = 0;
-    drmHeap.size   = info->gartTexMapSize;
+    drmHeap.size   = info->dri->gartTexMapSize;
 
-    if (drmCommandWrite(info->drmFD, DRM_RADEON_INIT_HEAP,
+    if (drmCommandWrite(info->dri->drmFD, DRM_RADEON_INIT_HEAP,
 			&drmHeap, sizeof(drmHeap))) {
 	xf86DrvMsg(pScreen->myNum, X_ERROR,
 		   "[drm] Failed to initialize GART heap manager\n");
     } else {
 	xf86DrvMsg(pScreen->myNum, X_INFO,
 		   "[drm] Initialized kernel GART heap manager, %d\n",
-		   info->gartTexMapSize);
+		   info->dri->gartTexMapSize);
     }
 }
 
@@ -1164,29 +1168,29 @@ static void RADEONDRIGartHeapInit(RADEONInfoPtr info, ScreenPtr pScreen)
 static Bool RADEONDRIBufInit(RADEONInfoPtr info, ScreenPtr pScreen)
 {
 				/* Initialize vertex buffers */
-    info->bufNumBufs = drmAddBufs(info->drmFD,
-				  info->bufMapSize / RADEON_BUFFER_SIZE,
-				  RADEON_BUFFER_SIZE,
-				  (info->cardType!=CARD_AGP) ? DRM_SG_BUFFER : DRM_AGP_BUFFER,
-				  info->bufStart);
+    info->dri->bufNumBufs = drmAddBufs(info->dri->drmFD,
+				       info->dri->bufMapSize / RADEON_BUFFER_SIZE,
+				       RADEON_BUFFER_SIZE,
+				       (info->cardType!=CARD_AGP) ? DRM_SG_BUFFER : DRM_AGP_BUFFER,
+				       info->dri->bufStart);
 
-    if (info->bufNumBufs <= 0) {
+    if (info->dri->bufNumBufs <= 0) {
 	xf86DrvMsg(pScreen->myNum, X_ERROR,
 		   "[drm] Could not create vertex/indirect buffers list\n");
 	return FALSE;
     }
     xf86DrvMsg(pScreen->myNum, X_INFO,
 	       "[drm] Added %d %d byte vertex/indirect buffers\n",
-	       info->bufNumBufs, RADEON_BUFFER_SIZE);
+	       info->dri->bufNumBufs, RADEON_BUFFER_SIZE);
 
-    if (!(info->buffers = drmMapBufs(info->drmFD))) {
+    if (!(info->dri->buffers = drmMapBufs(info->dri->drmFD))) {
 	xf86DrvMsg(pScreen->myNum, X_ERROR,
 		   "[drm] Failed to map vertex/indirect buffers list\n");
 	return FALSE;
     }
     xf86DrvMsg(pScreen->myNum, X_INFO,
 	       "[drm] Mapped %d vertex/indirect buffers\n",
-	       info->buffers->count);
+	       info->dri->buffers->count);
 
     return TRUE;
 }
@@ -1195,29 +1199,35 @@ static void RADEONDRIIrqInit(RADEONInfoPtr info, ScreenPtr pScreen)
 {
     ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
 
-    if (!info->irq) {
-	info->irq = drmGetInterruptFromBusID(
-	    info->drmFD,
+    if (!info->dri->irq) {
+	info->dri->irq = drmGetInterruptFromBusID(
+	    info->dri->drmFD,
 	    PCI_CFG_BUS(info->PciInfo),
 	    PCI_CFG_DEV(info->PciInfo),
 	    PCI_CFG_FUNC(info->PciInfo));
 
-	if ((drmCtlInstHandler(info->drmFD, info->irq)) != 0) {
+	if ((drmCtlInstHandler(info->dri->drmFD, info->dri->irq)) != 0) {
 	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 		       "[drm] failure adding irq handler, "
 		       "there is a device already using that irq\n"
 		       "[drm] falling back to irq-free operation\n");
-	    info->irq = 0;
+	    info->dri->irq = 0;
 	} else {
 	    unsigned char *RADEONMMIO = info->MMIO;
 	    info->ModeReg->gen_int_cntl = INREG( RADEON_GEN_INT_CNTL );
+
+	    /* Let the DRM know it can safely disable the vblank interrupts */
+	    radeon_crtc_modeset_ioctl(XF86_CRTC_CONFIG_PTR(pScrn)->crtc[0],
+				      FALSE);
+	    radeon_crtc_modeset_ioctl(XF86_CRTC_CONFIG_PTR(pScrn)->crtc[0],
+				      TRUE);
 	}
     }
 
-    if (info->irq)
+    if (info->dri->irq)
 	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 		   "[drm] dma control initialized, using IRQ %d\n",
-		   info->irq);
+		   info->dri->irq);
 }
 
 
@@ -1233,7 +1243,7 @@ static void RADEONDRICPInit(ScrnInfoPtr pScrn)
     RADEONCP_START(pScrn, info);
 #ifdef USE_XAA
     if (!info->useEXA)
-	info->dst_pitch_offset = info->frontPitchOffset;
+	info->accel_state->dst_pitch_offset = info->dri->frontPitchOffset;
 #endif
 }
 
@@ -1274,16 +1284,16 @@ Bool RADEONDRIGetVersion(ScrnInfoPtr pScrn)
 
     /* Check the lib version */
     if (xf86LoaderCheckSymbol("drmGetLibVersion"))
-	info->pLibDRMVersion = drmGetLibVersion(info->drmFD);
-    if (info->pLibDRMVersion == NULL) {
+	info->dri->pLibDRMVersion = drmGetLibVersion(info->dri->drmFD);
+    if (info->dri->pLibDRMVersion == NULL) {
 	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		   "[dri] RADEONDRIGetVersion failed because libDRM is really "
 		   "way to old to even get a version number out of it.\n"
 		   "[dri] Disabling DRI.\n");
 	return FALSE;
     }
-    if (info->pLibDRMVersion->version_major != 1 ||
-	info->pLibDRMVersion->version_minor < 2) {
+    if (info->dri->pLibDRMVersion->version_major != 1 ||
+	info->dri->pLibDRMVersion->version_minor < 2) {
 	    /* incompatible drm library version */
 	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		   "[dri] RADEONDRIGetVersion failed because of a "
@@ -1291,11 +1301,11 @@ Bool RADEONDRIGetVersion(ScrnInfoPtr pScrn)
 		   "[dri] libdrm.a module version is %d.%d.%d but "
 		   "version 1.2.x is needed.\n"
 		   "[dri] Disabling DRI.\n",
-		   info->pLibDRMVersion->version_major,
-		   info->pLibDRMVersion->version_minor,
-		   info->pLibDRMVersion->version_patchlevel);
-	drmFreeVersion(info->pLibDRMVersion);
-	info->pLibDRMVersion = NULL;
+		   info->dri->pLibDRMVersion->version_major,
+		   info->dri->pLibDRMVersion->version_minor,
+		   info->dri->pLibDRMVersion->version_patchlevel);
+	drmFreeVersion(info->dri->pLibDRMVersion);
+	info->dri->pLibDRMVersion = NULL;
 	return FALSE;
     }
 
@@ -1322,9 +1332,9 @@ Bool RADEONDRIGetVersion(ScrnInfoPtr pScrn)
     }
 
     /* Get DRM version & close DRM */
-    info->pKernelDRMVersion = drmGetVersion(fd);
+    info->dri->pKernelDRMVersion = drmGetVersion(fd);
     drmClose(fd);
-    if (info->pKernelDRMVersion == NULL) {
+    if (info->dri->pKernelDRMVersion == NULL) {
 	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		   "[dri] RADEONDRIGetVersion failed to get the DRM version\n"
 		   "[dri] Disabling DRI.\n");
@@ -1344,10 +1354,10 @@ Bool RADEONDRIGetVersion(ScrnInfoPtr pScrn)
     }
 
     /* We don't, bummer ! */
-    if (info->pKernelDRMVersion->version_major != 1 ||
-	info->pKernelDRMVersion->version_minor < req_minor ||
-	(info->pKernelDRMVersion->version_minor == req_minor &&
-	 info->pKernelDRMVersion->version_patchlevel < req_patch)) {
+    if (info->dri->pKernelDRMVersion->version_major != 1 ||
+	info->dri->pKernelDRMVersion->version_minor < req_minor ||
+	(info->dri->pKernelDRMVersion->version_minor == req_minor &&
+	 info->dri->pKernelDRMVersion->version_patchlevel < req_patch)) {
         /* Incompatible drm version */
 	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		   "[dri] RADEONDRIGetVersion failed because of a version "
@@ -1355,13 +1365,13 @@ Bool RADEONDRIGetVersion(ScrnInfoPtr pScrn)
 		   "[dri] radeon.o kernel module version is %d.%d.%d "
 		   "but version 1.%d.%d or newer is needed.\n"
 		   "[dri] Disabling DRI.\n",
-		   info->pKernelDRMVersion->version_major,
-		   info->pKernelDRMVersion->version_minor,
-		   info->pKernelDRMVersion->version_patchlevel,
+		   info->dri->pKernelDRMVersion->version_major,
+		   info->dri->pKernelDRMVersion->version_minor,
+		   info->dri->pKernelDRMVersion->version_patchlevel,
 		   req_minor,
 		   req_patch);
-	drmFreeVersion(info->pKernelDRMVersion);
-	info->pKernelDRMVersion = NULL;
+	drmFreeVersion(info->dri->pKernelDRMVersion);
+	info->dri->pKernelDRMVersion = NULL;
 	return FALSE;
     }
 
@@ -1377,7 +1387,7 @@ Bool RADEONDRISetVBlankInterrupt(ScrnInfoPtr pScrn, Bool on)
     if (!info->want_vblank_interrupts)
         on = FALSE;
 
-    if (info->directRenderingEnabled && info->pKernelDRMVersion->version_minor >= 28) {
+    if (info->directRenderingEnabled && info->dri->pKernelDRMVersion->version_minor >= 28) {
         if (on) {
   	    if (xf86_config->num_crtc > 1 && xf86_config->crtc[1]->enabled)
 	        value = DRM_RADEON_VBLANK_CRTC1 | DRM_RADEON_VBLANK_CRTC2;
@@ -1406,7 +1416,7 @@ Bool RADEONDRIScreenInit(ScreenPtr pScreen)
     DRIInfoPtr     pDRIInfo;
     RADEONDRIPtr   pRADEONDRI;
 
-    info->DRICloseScreen = NULL;
+    info->dri->DRICloseScreen = NULL;
 
     switch (info->CurrentLayout.pixel_code) {
     case 8:
@@ -1432,7 +1442,7 @@ Bool RADEONDRIScreenInit(ScreenPtr pScreen)
      */
     if (!(pDRIInfo = DRICreateInfoRec())) return FALSE;
 
-    info->pDRIInfo                       = pDRIInfo;
+    info->dri->pDRIInfo                       = pDRIInfo;
     pDRIInfo->drmDriverName              = RADEON_DRIVER_NAME;
 
     if ( (info->ChipFamily >= CHIP_FAMILY_R300) ) {
@@ -1453,11 +1463,10 @@ Bool RADEONDRIScreenInit(ScreenPtr pScreen)
 		PCI_DEV_DEV(info->PciInfo),
 		PCI_DEV_FUNC(info->PciInfo));
     }
-    pDRIInfo->ddxDriverMajorVersion      = info->allowColorTiling ?
-    				RADEON_VERSION_MAJOR_TILED : RADEON_VERSION_MAJOR;
-    pDRIInfo->ddxDriverMinorVersion      = RADEON_VERSION_MINOR;
-    pDRIInfo->ddxDriverPatchVersion      = RADEON_VERSION_PATCH;
-    pDRIInfo->frameBufferPhysicalAddress = (void *)info->LinearAddr + info->frontOffset;
+    pDRIInfo->ddxDriverMajorVersion      = info->allowColorTiling ? 5 : 4;
+    pDRIInfo->ddxDriverMinorVersion      = 3;
+    pDRIInfo->ddxDriverPatchVersion      = 0;
+    pDRIInfo->frameBufferPhysicalAddress = (void *)info->LinearAddr + info->dri->frontOffset;
     pDRIInfo->frameBufferSize            = info->FbMapSize - info->FbSecureSize;
     pDRIInfo->frameBufferStride          = (pScrn->displayWidth *
 					    info->CurrentLayout.pixel_bytes);
@@ -1487,7 +1496,7 @@ Bool RADEONDRIScreenInit(ScreenPtr pScreen)
     /* For now the mapping works by using a fixed size defined
      * in the SAREA header
      */
-    if (sizeof(XF86DRISAREARec)+sizeof(RADEONSAREAPriv) > SAREA_MAX) {
+    if (sizeof(XF86DRISAREARec)+sizeof(drm_radeon_sarea_t) > SAREA_MAX) {
 	ErrorF("Data does not fit in SAREA\n");
 	return FALSE;
     }
@@ -1495,8 +1504,8 @@ Bool RADEONDRIScreenInit(ScreenPtr pScreen)
 #endif
 
     if (!(pRADEONDRI = (RADEONDRIPtr)xcalloc(sizeof(RADEONDRIRec),1))) {
-	DRIDestroyInfoRec(info->pDRIInfo);
-	info->pDRIInfo = NULL;
+	DRIDestroyInfoRec(info->dri->pDRIInfo);
+	info->dri->pDRIInfo = NULL;
 	return FALSE;
     }
     pDRIInfo->devPrivate     = pRADEONDRI;
@@ -1538,7 +1547,7 @@ Bool RADEONDRIScreenInit(ScreenPtr pScreen)
     }
 #endif
 
-    if (!DRIScreenInit(pScreen, pDRIInfo, &info->drmFD)) {
+    if (!DRIScreenInit(pScreen, pDRIInfo, &info->dri->drmFD)) {
 	xf86DrvMsg(pScreen->myNum, X_ERROR,
 		   "[dri] DRIScreenInit failed.  Disabling DRI.\n");
 	xfree(pDRIInfo->devPrivate);
@@ -1581,7 +1590,7 @@ Bool RADEONDRIScreenInit(ScreenPtr pScreen)
 	void *scratch_ptr;
         int scratch_int;
 
-	DRIGetDeviceInfo(pScreen, &info->fbHandle,
+	DRIGetDeviceInfo(pScreen, &info->dri->fbHandle,
                          &scratch_int, &scratch_int,
                          &scratch_int, &scratch_int,
                          &scratch_ptr);
@@ -1605,7 +1614,7 @@ static Bool RADEONDRIDoCloseScreen(int scrnIndex, ScreenPtr pScreen)
 
     RADEONDRICloseScreen(pScreen);
 
-    pScreen->CloseScreen = info->DRICloseScreen;
+    pScreen->CloseScreen = info->dri->DRICloseScreen;
     return (*pScreen->CloseScreen)(scrnIndex, pScreen);
 }
 
@@ -1617,11 +1626,11 @@ Bool RADEONDRIFinishScreenInit(ScreenPtr pScreen)
 {
     ScrnInfoPtr         pScrn = xf86Screens[pScreen->myNum];
     RADEONInfoPtr       info  = RADEONPTR(pScrn);
-    RADEONSAREAPrivPtr  pSAREAPriv;
+    drm_radeon_sarea_t  *pSAREAPriv;
     RADEONDRIPtr        pRADEONDRI;
 
-    info->pDRIInfo->driverSwapMethod = DRI_HIDE_X_CONTEXT;
-    /* info->pDRIInfo->driverSwapMethod = DRI_SERVER_SWAP; */
+    info->dri->pDRIInfo->driverSwapMethod = DRI_HIDE_X_CONTEXT;
+    /* info->dri->pDRIInfo->driverSwapMethod = DRI_SERVER_SWAP; */
 
     /* NOTE: DRIFinishScreenInit must be called before *DRIKernelInit
      * because *DRIKernelInit requires that the hardware lock is held by
@@ -1655,10 +1664,10 @@ Bool RADEONDRIFinishScreenInit(ScreenPtr pScreen)
     RADEONDRICPInit(pScrn);
 
     /* Initialize the SAREA private data structure */
-    pSAREAPriv = (RADEONSAREAPrivPtr)DRIGetSAREAPrivate(pScreen);
+    pSAREAPriv = (drm_radeon_sarea_t*)DRIGetSAREAPrivate(pScreen);
     memset(pSAREAPriv, 0, sizeof(*pSAREAPriv));
 
-    pRADEONDRI                    = (RADEONDRIPtr)info->pDRIInfo->devPrivate;
+    pRADEONDRI                    = (RADEONDRIPtr)info->dri->pDRIInfo->devPrivate;
 
     pRADEONDRI->deviceID          = info->Chipset;
     pRADEONDRI->width             = pScrn->virtualX;
@@ -1667,40 +1676,40 @@ Bool RADEONDRIFinishScreenInit(ScreenPtr pScreen)
     pRADEONDRI->bpp               = pScrn->bitsPerPixel;
 
     pRADEONDRI->IsPCI             = (info->cardType!=CARD_AGP);
-    pRADEONDRI->AGPMode           = info->agpMode;
+    pRADEONDRI->AGPMode           = info->dri->agpMode;
 
-    pRADEONDRI->frontOffset       = info->frontOffset;
-    pRADEONDRI->frontPitch        = info->frontPitch;
-    pRADEONDRI->backOffset        = info->backOffset;
-    pRADEONDRI->backPitch         = info->backPitch;
-    pRADEONDRI->depthOffset       = info->depthOffset;
-    pRADEONDRI->depthPitch        = info->depthPitch;
-    pRADEONDRI->textureOffset     = info->textureOffset;
-    pRADEONDRI->textureSize       = info->textureSize;
-    pRADEONDRI->log2TexGran       = info->log2TexGran;
+    pRADEONDRI->frontOffset       = info->dri->frontOffset;
+    pRADEONDRI->frontPitch        = info->dri->frontPitch;
+    pRADEONDRI->backOffset        = info->dri->backOffset;
+    pRADEONDRI->backPitch         = info->dri->backPitch;
+    pRADEONDRI->depthOffset       = info->dri->depthOffset;
+    pRADEONDRI->depthPitch        = info->dri->depthPitch;
+    pRADEONDRI->textureOffset     = info->dri->textureOffset;
+    pRADEONDRI->textureSize       = info->dri->textureSize;
+    pRADEONDRI->log2TexGran       = info->dri->log2TexGran;
 
-    pRADEONDRI->registerHandle    = info->registerHandle;
-    pRADEONDRI->registerSize      = info->registerSize;
+    pRADEONDRI->registerHandle    = info->dri->registerHandle;
+    pRADEONDRI->registerSize      = info->dri->registerSize;
 
-    pRADEONDRI->statusHandle      = info->ringReadPtrHandle;
-    pRADEONDRI->statusSize        = info->ringReadMapSize;
+    pRADEONDRI->statusHandle      = info->dri->ringReadPtrHandle;
+    pRADEONDRI->statusSize        = info->dri->ringReadMapSize;
 
-    pRADEONDRI->gartTexHandle     = info->gartTexHandle;
-    pRADEONDRI->gartTexMapSize    = info->gartTexMapSize;
-    pRADEONDRI->log2GARTTexGran   = info->log2GARTTexGran;
-    pRADEONDRI->gartTexOffset     = info->gartTexStart;
+    pRADEONDRI->gartTexHandle     = info->dri->gartTexHandle;
+    pRADEONDRI->gartTexMapSize    = info->dri->gartTexMapSize;
+    pRADEONDRI->log2GARTTexGran   = info->dri->log2GARTTexGran;
+    pRADEONDRI->gartTexOffset     = info->dri->gartTexStart;
 
     pRADEONDRI->sarea_priv_offset = sizeof(XF86DRISAREARec);
 
 #ifdef PER_CONTEXT_SAREA
     /* Set per-context SAREA size */
-    pRADEONDRI->perctx_sarea_size = info->perctx_sarea_size;
+    pRADEONDRI->perctx_sarea_size = info->dri->perctx_sarea_size;
 #endif
 
     info->directRenderingInited = TRUE;
 
     /* Wrap CloseScreen */
-    info->DRICloseScreen = pScreen->CloseScreen;
+    info->dri->DRICloseScreen = pScreen->CloseScreen;
     pScreen->CloseScreen = RADEONDRIDoCloseScreen;
 
     /* disable vblank at startup */
@@ -1721,7 +1730,7 @@ void RADEONDRIResume(ScreenPtr pScreen)
     ScrnInfoPtr   pScrn   = xf86Screens[pScreen->myNum];
     RADEONInfoPtr info    = RADEONPTR(pScrn);
 
-    if (info->pKernelDRMVersion->version_minor >= 9) {
+    if (info->dri->pKernelDRMVersion->version_minor >= 9) {
 	xf86DrvMsg(pScreen->myNum, X_INFO,
 		   "[RESUME] Attempting to re-init Radeon hardware.\n");
     } else {
@@ -1738,7 +1747,7 @@ void RADEONDRIResume(ScreenPtr pScreen)
 	RADEONSetAgpBase(info, pScreen);
     }
 
-    _ret = drmCommandNone(info->drmFD, DRM_RADEON_CP_RESUME);
+    _ret = drmCommandNone(info->dri->drmFD, DRM_RADEON_CP_RESUME);
     if (_ret) {
 	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		   "%s: CP resume %d\n", __FUNCTION__, _ret);
@@ -1777,86 +1786,86 @@ void RADEONDRICloseScreen(ScreenPtr pScreen)
 {
     ScrnInfoPtr    pScrn = xf86Screens[pScreen->myNum];
     RADEONInfoPtr  info  = RADEONPTR(pScrn);
-    drmRadeonInit  drmInfo;
+    drm_radeon_init_t  drmInfo;
 
      xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
 		    "RADEONDRICloseScreen\n");
 
 #ifdef DAMAGE
-     REGION_UNINIT(pScreen, &info->driRegion);
+     REGION_UNINIT(pScreen, &info->dri->driRegion);
 #endif
 
-     if (info->irq) {
+     if (info->dri->irq) {
 	RADEONDRISetVBlankInterrupt (pScrn, FALSE);
-	drmCtlUninstHandler(info->drmFD);
-	info->irq = 0;
+	drmCtlUninstHandler(info->dri->drmFD);
+	info->dri->irq = 0;
 	info->ModeReg->gen_int_cntl = 0;
     }
 
     /* De-allocate vertex buffers */
-    if (info->buffers) {
-	drmUnmapBufs(info->buffers);
-	info->buffers = NULL;
+    if (info->dri->buffers) {
+	drmUnmapBufs(info->dri->buffers);
+	info->dri->buffers = NULL;
     }
 
     /* De-allocate all kernel resources */
-    memset(&drmInfo, 0, sizeof(drmRadeonInit));
-    drmInfo.func = DRM_RADEON_CLEANUP_CP;
-    drmCommandWrite(info->drmFD, DRM_RADEON_CP_INIT,
-		    &drmInfo, sizeof(drmRadeonInit));
+    memset(&drmInfo, 0, sizeof(drm_radeon_init_t));
+    drmInfo.func = RADEON_CLEANUP_CP;
+    drmCommandWrite(info->dri->drmFD, DRM_RADEON_CP_INIT,
+		    &drmInfo, sizeof(drm_radeon_init_t));
 
     /* De-allocate all GART resources */
-    if (info->gartTex) {
-	drmUnmap(info->gartTex, info->gartTexMapSize);
-	info->gartTex = NULL;
+    if (info->dri->gartTex) {
+	drmUnmap(info->dri->gartTex, info->dri->gartTexMapSize);
+	info->dri->gartTex = NULL;
     }
-    if (info->buf) {
-	drmUnmap(info->buf, info->bufMapSize);
-	info->buf = NULL;
+    if (info->dri->buf) {
+	drmUnmap(info->dri->buf, info->dri->bufMapSize);
+	info->dri->buf = NULL;
     }
-    if (info->ringReadPtr) {
-	drmUnmap(info->ringReadPtr, info->ringReadMapSize);
-	info->ringReadPtr = NULL;
+    if (info->dri->ringReadPtr) {
+	drmUnmap(info->dri->ringReadPtr, info->dri->ringReadMapSize);
+	info->dri->ringReadPtr = NULL;
     }
-    if (info->ring) {
-	drmUnmap(info->ring, info->ringMapSize);
-	info->ring = NULL;
+    if (info->dri->ring) {
+	drmUnmap(info->dri->ring, info->dri->ringMapSize);
+	info->dri->ring = NULL;
     }
-    if (info->agpMemHandle != DRM_AGP_NO_HANDLE) {
-	drmAgpUnbind(info->drmFD, info->agpMemHandle);
-	drmAgpFree(info->drmFD, info->agpMemHandle);
-	info->agpMemHandle = DRM_AGP_NO_HANDLE;
-	drmAgpRelease(info->drmFD);
+    if (info->dri->agpMemHandle != DRM_AGP_NO_HANDLE) {
+	drmAgpUnbind(info->dri->drmFD, info->dri->agpMemHandle);
+	drmAgpFree(info->dri->drmFD, info->dri->agpMemHandle);
+	info->dri->agpMemHandle = DRM_AGP_NO_HANDLE;
+	drmAgpRelease(info->dri->drmFD);
     }
-    if (info->pciMemHandle) {
-	drmScatterGatherFree(info->drmFD, info->pciMemHandle);
-	info->pciMemHandle = 0;
+    if (info->dri->pciMemHandle) {
+	drmScatterGatherFree(info->dri->drmFD, info->dri->pciMemHandle);
+	info->dri->pciMemHandle = 0;
     }
 
-    if (info->pciGartBackup) {
-	xfree(info->pciGartBackup);
-	info->pciGartBackup = NULL;
+    if (info->dri->pciGartBackup) {
+	xfree(info->dri->pciGartBackup);
+	info->dri->pciGartBackup = NULL;
     }
 
     /* De-allocate all DRI resources */
     DRICloseScreen(pScreen);
 
     /* De-allocate all DRI data structures */
-    if (info->pDRIInfo) {
-	if (info->pDRIInfo->devPrivate) {
-	    xfree(info->pDRIInfo->devPrivate);
-	    info->pDRIInfo->devPrivate = NULL;
+    if (info->dri->pDRIInfo) {
+	if (info->dri->pDRIInfo->devPrivate) {
+	    xfree(info->dri->pDRIInfo->devPrivate);
+	    info->dri->pDRIInfo->devPrivate = NULL;
 	}
-	DRIDestroyInfoRec(info->pDRIInfo);
-	info->pDRIInfo = NULL;
+	DRIDestroyInfoRec(info->dri->pDRIInfo);
+	info->dri->pDRIInfo = NULL;
     }
-    if (info->pVisualConfigs) {
-	xfree(info->pVisualConfigs);
-	info->pVisualConfigs = NULL;
+    if (info->dri->pVisualConfigs) {
+	xfree(info->dri->pVisualConfigs);
+	info->dri->pVisualConfigs = NULL;
     }
-    if (info->pVisualConfigsPriv) {
-	xfree(info->pVisualConfigsPriv);
-	info->pVisualConfigsPriv = NULL;
+    if (info->dri->pVisualConfigsPriv) {
+	xfree(info->dri->pVisualConfigsPriv);
+	info->dri->pVisualConfigsPriv = NULL;
     }
 }
 
@@ -1885,24 +1894,24 @@ static void RADEONDRIRefreshArea(ScrnInfoPtr pScrn, RegionPtr pReg)
     RADEONInfoPtr       info       = RADEONPTR(pScrn);
     int                 i, num;
     ScreenPtr           pScreen    = pScrn->pScreen;
-    RADEONSAREAPrivPtr  pSAREAPriv = DRIGetSAREAPrivate(pScreen);
+    drm_radeon_sarea_t  *pSAREAPriv = DRIGetSAREAPrivate(pScreen);
 #ifdef USE_EXA
     PixmapPtr           pPix = pScreen->GetScreenPixmap(pScreen);
 #endif
     RegionRec region;
     BoxPtr pbox;
 
-    if (!info->directRenderingInited || !info->CPStarted)
+    if (!info->directRenderingInited || !info->cp->CPStarted)
 	return;
 
     /* Don't want to do this when no 3d is active and pages are
      * right-way-round
      */
-    if (!pSAREAPriv->pfAllowPageFlip && pSAREAPriv->pfCurrentPage == 0)
+    if (!pSAREAPriv->pfState && pSAREAPriv->pfCurrentPage == 0)
 	return;
 
     REGION_NULL(pScreen, &region);
-    REGION_SUBTRACT(pScreen, &region, pReg, &info->driRegion);
+    REGION_SUBTRACT(pScreen, &region, pReg, &info->dri->driRegion);
 
     num = REGION_NUM_RECTS(&region);
 
@@ -1919,9 +1928,9 @@ static void RADEONDRIRefreshArea(ScrnInfoPtr pScrn, RegionPtr pReg)
 	uint32_t src_pitch_offset, dst_pitch_offset, datatype;
 
 	RADEONGetPixmapOffsetPitch(pPix, &src_pitch_offset);
-	dst_pitch_offset = src_pitch_offset + (info->backOffset >> 10);
+	dst_pitch_offset = src_pitch_offset + (info->dri->backOffset >> 10);
 	RADEONGetDatatypeBpp(pScrn->bitsPerPixel, &datatype);
-	info->xdir = info->ydir = 1;
+	info->accel_state->xdir = info->accel_state->ydir = 1;
 
 	RADEONDoPrepareCopyCP(pScrn, src_pitch_offset, dst_pitch_offset, datatype,
 			      GXcopy, ~0);
@@ -1931,13 +1940,14 @@ static void RADEONDRIRefreshArea(ScrnInfoPtr pScrn, RegionPtr pReg)
 #ifdef USE_XAA
     if (!info->useEXA) {
 	/* Make sure accel has been properly inited */
-	if (info->accel == NULL || info->accel->SetupForScreenToScreenCopy == NULL)
+	if (info->accel_state->accel == NULL ||
+	    info->accel_state->accel->SetupForScreenToScreenCopy == NULL)
 	    goto out;
 	if (info->tilingEnabled)
-	    info->dst_pitch_offset |= RADEON_DST_TILE_MACRO;
-	(*info->accel->SetupForScreenToScreenCopy)(pScrn,
-						   1, 1, GXcopy,
-						   (uint32_t)(-1), -1);
+	    info->accel_state->dst_pitch_offset |= RADEON_DST_TILE_MACRO;
+	(*info->accel_state->accel->SetupForScreenToScreenCopy)(pScrn,
+								1, 1, GXcopy,
+								(uint32_t)(-1), -1);
     }
 #endif
 
@@ -1954,23 +1964,23 @@ static void RADEONDRIRefreshArea(ScrnInfoPtr pScrn, RegionPtr pReg)
 
 #ifdef USE_XAA
 	    if (!info->useEXA) {
-		(*info->accel->SubsequentScreenToScreenCopy)(pScrn, xa, ya,
-							     xa + info->backX,
-							     ya + info->backY,
-							     xb - xa + 1,
-							     yb - ya + 1);
+		(*info->accel_state->accel->SubsequentScreenToScreenCopy)(pScrn, xa, ya,
+									  xa + info->dri->backX,
+									  ya + info->dri->backY,
+									  xb - xa + 1,
+									  yb - ya + 1);
 	    }
 #endif
 	}
     }
 
 #ifdef USE_XAA
-    info->dst_pitch_offset &= ~RADEON_DST_TILE_MACRO;
+    info->accel_state->dst_pitch_offset &= ~RADEON_DST_TILE_MACRO;
 #endif
 
 out:
     REGION_NULL(pScreen, &region);
-    DamageEmpty(info->pDamage);
+    DamageEmpty(info->dri->pDamage);
 }
 
 #endif /* DAMAGE */
@@ -1981,13 +1991,13 @@ static void RADEONEnablePageFlip(ScreenPtr pScreen)
     ScrnInfoPtr         pScrn      = xf86Screens[pScreen->myNum];
     RADEONInfoPtr       info       = RADEONPTR(pScrn);
 
-    if (info->allowPageFlip) {
-	RADEONSAREAPrivPtr pSAREAPriv = DRIGetSAREAPrivate(pScreen);
+    if (info->dri->allowPageFlip) {
+	drm_radeon_sarea_t *pSAREAPriv = DRIGetSAREAPrivate(pScreen);
 	BoxRec box = { .x1 = 0, .y1 = 0, .x2 = pScrn->virtualX - 1,
 		       .y2 = pScrn->virtualY - 1 };
 	RegionPtr pReg = REGION_CREATE(pScreen, &box, 1);
 
-	pSAREAPriv->pfAllowPageFlip = 1;
+	pSAREAPriv->pfState = 1;
 	RADEONDRIRefreshArea(pScrn, pReg);
 	REGION_DESTROY(pScreen, pReg);
     }
@@ -2000,9 +2010,9 @@ static void RADEONDisablePageFlip(ScreenPtr pScreen)
      *   -- Field in sarea, plus bumping the window counters.
      *   -- DRM needs to cope with Front-to-Back swapbuffers.
      */
-    RADEONSAREAPrivPtr  pSAREAPriv = DRIGetSAREAPrivate(pScreen);
+    drm_radeon_sarea_t  *pSAREAPriv = DRIGetSAREAPrivate(pScreen);
 
-    pSAREAPriv->pfAllowPageFlip = 0;
+    pSAREAPriv->pfState = 0;
 }
 
 static void RADEONDRITransitionSingleToMulti3d(ScreenPtr pScreen)
@@ -2034,9 +2044,9 @@ static void RADEONDRITransitionTo3d(ScreenPtr pScreen)
 	 * first so we always start with all free offscreen memory, except
 	 * maybe for Xv
 	 */
-	if (info->backArea) {
-	    xf86FreeOffscreenArea(info->backArea);
-	    info->backArea = NULL;
+	if (info->dri->backArea) {
+	    xf86FreeOffscreenArea(info->dri->backArea);
+	    info->dri->backArea = NULL;
         }
 
 	xf86PurgeUnlockedOffscreenAreas(pScreen);
@@ -2047,7 +2057,7 @@ static void RADEONDRITransitionTo3d(ScreenPtr pScreen)
 	 * FIXME: This is hideous.  What about telling xv "oh btw you have no memory
 	 * any more?" -- anholt
 	 */
-	if (height < (info->depthTexLines + info->backLines)) {
+	if (height < (info->dri->depthTexLines + info->dri->backLines)) {
 	    RADEONPortPrivPtr portPriv = info->adaptor->pPortPrivates[0].ptr;
 	    xf86FreeOffscreenLinear((FBLinearPtr)portPriv->video_memory);
 	    portPriv->video_memory = NULL;
@@ -2061,29 +2071,29 @@ static void RADEONDRITransitionTo3d(ScreenPtr pScreen)
 	 */
 	fbarea = xf86AllocateOffscreenArea(pScreen, pScrn->displayWidth,
 					   height
-					   - info->depthTexLines
-					   - info->backLines,
+					   - info->dri->depthTexLines
+					   - info->dri->backLines,
 					   pScrn->displayWidth,
 					   NULL, NULL, NULL);
 	if (!fbarea)
 	    xf86DrvMsg(pScreen->myNum, X_ERROR, "Unable to reserve placeholder "
 		       "offscreen area, you might experience screen corruption\n");
 
-	info->backArea = xf86AllocateOffscreenArea(pScreen, pScrn->displayWidth,
-						   info->backLines,
-						   pScrn->displayWidth,
-						   NULL, NULL, NULL);
-	if (!info->backArea)
+	info->dri->backArea = xf86AllocateOffscreenArea(pScreen, pScrn->displayWidth,
+							info->dri->backLines,
+							pScrn->displayWidth,
+							NULL, NULL, NULL);
+	if (!info->dri->backArea)
 	    xf86DrvMsg(pScreen->myNum, X_ERROR, "Unable to reserve offscreen "
 		       "area for back buffer, you might experience screen "
 		       "corruption\n");
 
-	info->depthTexArea = xf86AllocateOffscreenArea(pScreen,
-						       pScrn->displayWidth,
-						       info->depthTexLines,
-						       pScrn->displayWidth,
-						       NULL, NULL, NULL);
-	if (!info->depthTexArea)
+	info->dri->depthTexArea = xf86AllocateOffscreenArea(pScreen,
+							    pScrn->displayWidth,
+							    info->dri->depthTexLines,
+							    pScrn->displayWidth,
+							    NULL, NULL, NULL);
+	if (!info->dri->depthTexArea)
 	    xf86DrvMsg(pScreen->myNum, X_ERROR, "Unable to reserve offscreen "
 		       "area for depth buffer and textures, you might "
 		       "experience screen corruption\n");
@@ -2092,7 +2102,7 @@ static void RADEONDRITransitionTo3d(ScreenPtr pScreen)
     }
 #endif /* USE_XAA */
 
-    info->have3DWindows = 1;
+    info->dri->have3DWindows = 1;
 
     RADEONChangeSurfaces(pScrn);
     RADEONEnablePageFlip(pScreen);
@@ -2108,19 +2118,19 @@ static void RADEONDRITransitionTo2d(ScreenPtr pScreen)
 {
     ScrnInfoPtr         pScrn      = xf86Screens[pScreen->myNum];
     RADEONInfoPtr       info       = RADEONPTR(pScrn);
-    RADEONSAREAPrivPtr  pSAREAPriv = DRIGetSAREAPrivate(pScreen);
+    drm_radeon_sarea_t  *pSAREAPriv = DRIGetSAREAPrivate(pScreen);
 
     /* Try flipping back to the front page if necessary */
     if (pSAREAPriv->pfCurrentPage == 1)
-	drmCommandNone(info->drmFD, DRM_RADEON_FLIP);
+	drmCommandNone(info->dri->drmFD, DRM_RADEON_FLIP);
 
     /* Shut down shadowing if we've made it back to the front page */
     if (pSAREAPriv->pfCurrentPage == 0) {
 	RADEONDisablePageFlip(pScreen);
 #ifdef USE_XAA
 	if (!info->useEXA) {
-	    xf86FreeOffscreenArea(info->backArea);
-	    info->backArea = NULL;
+	    xf86FreeOffscreenArea(info->dri->backArea);
+	    info->dri->backArea = NULL;
 	}
 #endif
     } else {
@@ -2131,10 +2141,10 @@ static void RADEONDRITransitionTo2d(ScreenPtr pScreen)
 
 #ifdef USE_XAA
     if (!info->useEXA)
-	xf86FreeOffscreenArea(info->depthTexArea);
+	xf86FreeOffscreenArea(info->dri->depthTexArea);
 #endif
 
-    info->have3DWindows = 0;
+    info->dri->have3DWindows = 0;
 
     RADEONChangeSurfaces(pScrn);
 
@@ -2154,8 +2164,8 @@ RADEONDRIClipNotify(ScreenPtr pScreen, WindowPtr *ppWin, int num)
     ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
     RADEONInfoPtr info = RADEONPTR(pScrn);
 
-    REGION_UNINIT(pScreen, &info->driRegion);
-    REGION_NULL(pScreen, &info->driRegion);
+    REGION_UNINIT(pScreen, &info->dri->driRegion);
+    REGION_NULL(pScreen, &info->dri->driRegion);
 
     if (num > 0) {
 	int i;
@@ -2164,8 +2174,8 @@ RADEONDRIClipNotify(ScreenPtr pScreen, WindowPtr *ppWin, int num)
 	    WindowPtr pWin = ppWin[i];
 
 	    if (pWin) {
-		REGION_UNION(pScreen, &info->driRegion, &pWin->clipList,
-			     &info->driRegion);
+		REGION_UNION(pScreen, &info->dri->driRegion, &pWin->clipList,
+			     &info->dri->driRegion);
 	    }
 	}
     }
@@ -2178,24 +2188,24 @@ void RADEONDRIAllocatePCIGARTTable(ScreenPtr pScreen)
     RADEONInfoPtr      info    = RADEONPTR(pScrn);
 
     if (info->cardType != CARD_PCIE ||
-	info->pKernelDRMVersion->version_minor < 19)
+	info->dri->pKernelDRMVersion->version_minor < 19)
       return;
 
     if (info->FbSecureSize==0)
       return;
 
     /* set the old default size of pci gart table */
-    if (info->pKernelDRMVersion->version_minor < 26)
-      info->pciGartSize = 32768;
+    if (info->dri->pKernelDRMVersion->version_minor < 26)
+      info->dri->pciGartSize = 32768;
 
-    info->pciGartSize = RADEONDRIGetPciAperTableSize(pScrn);
+    info->dri->pciGartSize = RADEONDRIGetPciAperTableSize(pScrn);
 
     /* allocate space to back up PCIEGART table */
-    info->pciGartBackup = xnfcalloc(1, info->pciGartSize);
-    if (info->pciGartBackup == NULL)
+    info->dri->pciGartBackup = xnfcalloc(1, info->dri->pciGartSize);
+    if (info->dri->pciGartBackup == NULL)
       return;
 
-    info->pciGartOffset = (info->FbMapSize - info->FbSecureSize);
+    info->dri->pciGartOffset = (info->FbMapSize - info->FbSecureSize);
 
 
 }
@@ -2207,7 +2217,7 @@ int RADEONDRIGetPciAperTableSize(ScrnInfoPtr pScrn)
     int ret_size;
     int num_pages;
 
-    num_pages = (info->pciAperSize * 1024 * 1024) / page_size;
+    num_pages = (info->dri->pciAperSize * 1024 * 1024) / page_size;
     
     ret_size = num_pages * sizeof(unsigned int);
 
@@ -2216,14 +2226,14 @@ int RADEONDRIGetPciAperTableSize(ScrnInfoPtr pScrn)
 
 int RADEONDRISetParam(ScrnInfoPtr pScrn, unsigned int param, int64_t value)
 {
-    drmRadeonSetParam  radeonsetparam;
+    drm_radeon_setparam_t  radeonsetparam;
     RADEONInfoPtr  info   = RADEONPTR(pScrn);
     int ret;
 
-    memset(&radeonsetparam, 0, sizeof(drmRadeonSetParam));
+    memset(&radeonsetparam, 0, sizeof(drm_radeon_setparam_t));
     radeonsetparam.param = param;
     radeonsetparam.value = value;
-    ret = drmCommandWrite(info->drmFD, DRM_RADEON_SETPARAM,
-			  &radeonsetparam, sizeof(drmRadeonSetParam));
+    ret = drmCommandWrite(info->dri->drmFD, DRM_RADEON_SETPARAM,
+			  &radeonsetparam, sizeof(drm_radeon_setparam_t));
     return ret;
 }
diff --git a/src/radeon_dri.h b/src/radeon_dri.h
index 67892a6..6e3ad62 100644
--- a/src/radeon_dri.h
+++ b/src/radeon_dri.h
@@ -39,9 +39,8 @@
 #include "xf86drm.h"
 
 /* DRI Driver defaults */
-#define RADEON_DEFAULT_CP_PIO_MODE    RADEON_CSQ_PRIPIO_INDPIO
-#define RADEON_DEFAULT_CP_BM_MODE     RADEON_CSQ_PRIBM_INDBM
 #define RADEON_DEFAULT_GART_SIZE      8 /* MB (must be 2^n and > 4MB) */
+#define R300_DEFAULT_GART_SIZE        32 /* MB (for R300 and above) */
 #define RADEON_DEFAULT_RING_SIZE      1 /* MB (must be page aligned) */
 #define RADEON_DEFAULT_BUFFER_SIZE    2 /* MB (must be page aligned) */
 #define RADEON_DEFAULT_GART_TEX_SIZE  1 /* MB (must be page aligned) */
@@ -52,10 +51,6 @@
 
 #define RADEON_CARD_TYPE_RADEON       1
 
-#define RADEONCP_USE_RING_BUFFER(m)					\
-    (((m) == RADEON_CSQ_PRIBM_INDDIS) ||				\
-     ((m) == RADEON_CSQ_PRIBM_INDBM))
-
 typedef struct {
     /* DRI screen private data */
     int           deviceID;	/* PCI device ID */
diff --git a/src/radeon_dripriv.h b/src/radeon_dripriv.h
deleted file mode 100644
index fcde08e..0000000
--- a/src/radeon_dripriv.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright 2000 ATI Technologies Inc., Markham, Ontario,
- *                VA Linux Systems Inc., Fremont, California.
- *
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation on the rights to use, copy, modify, merge,
- * publish, distribute, sublicense, and/or sell copies of the Software,
- * and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial
- * portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NON-INFRINGEMENT.  IN NO EVENT SHALL ATI, VA LINUX SYSTEMS AND/OR
- * THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-/*
- * Authors:
- *   Kevin E. Martin <martin@xfree86.org>
- *   Rickard E. Faith <faith@valinux.com>
- *
- */
-
-#ifndef _RADEON_DRIPRIV_H_
-#define _RADEON_DRIPRIV_H_
-
-#include "GL/glxint.h"
-#include "xf86drm.h"
-#include "radeon_common.h"
-
-#define RADEON_MAX_DRAWABLES 256
-
-extern void GlxSetVisualConfigs(int nconfigs, __GLXvisualConfig *configs,
-				void **configprivs);
-
-typedef struct {
-    /* Nothing here yet */
-    int dummy;
-} RADEONConfigPrivRec, *RADEONConfigPrivPtr;
-
-typedef struct {
-#ifdef PER_CONTEXT_SAREA
-    drm_context_t ctx_id;
-    drm_handle_t sarea_handle;
-#else
-    /* Nothing here yet */
-    int dummy;
-#endif
-} RADEONDRIContextRec, *RADEONDRIContextPtr;
-
-#endif
diff --git a/src/radeon_driver.c b/src/radeon_driver.c
index f18ad99..42b6d0c 100644
--- a/src/radeon_driver.c
+++ b/src/radeon_driver.c
@@ -79,7 +79,7 @@
 #ifdef XF86DRI
 #define _XF86DRI_SERVER_
 #include "radeon_dri.h"
-#include "radeon_sarea.h"
+#include "radeon_drm.h"
 #include "sarea.h"
 #endif
 
@@ -669,7 +669,14 @@ static void radeon_write_mc_fb_agp_location(ScrnInfoPtr pScrn, int mask, uint32_
     RADEONInfoPtr  info       = RADEONPTR(pScrn);
     unsigned char *RADEONMMIO = info->MMIO;
 
-    if (info->ChipFamily >= CHIP_FAMILY_R600) {
+    if (info->ChipFamily >= CHIP_FAMILY_RV770) {
+	if (mask & LOC_FB)
+	    OUTREG(R700_MC_VM_FB_LOCATION, fb_loc);
+	if (mask & LOC_AGP) {
+	    OUTREG(R600_MC_VM_AGP_BOT, agp_loc);
+	    OUTREG(R600_MC_VM_AGP_TOP, agp_loc_hi);
+	}
+    } else if (info->ChipFamily >= CHIP_FAMILY_R600) {
 	if (mask & LOC_FB)
 	    OUTREG(R600_MC_VM_FB_LOCATION, fb_loc);
 	if (mask & LOC_AGP) {
@@ -712,7 +719,14 @@ static void radeon_read_mc_fb_agp_location(ScrnInfoPtr pScrn, int mask, uint32_t
     RADEONInfoPtr  info       = RADEONPTR(pScrn);
     unsigned char *RADEONMMIO = info->MMIO;
 
-    if (info->ChipFamily >= CHIP_FAMILY_R600) {
+    if (info->ChipFamily >= CHIP_FAMILY_RV770) {
+	if (mask & LOC_FB)
+	    *fb_loc = INREG(R700_MC_VM_FB_LOCATION);
+	if (mask & LOC_AGP) {
+	    *agp_loc = INREG(R600_MC_VM_AGP_BOT);
+	    *agp_loc_hi = INREG(R600_MC_VM_AGP_TOP);
+	}
+    } else if (info->ChipFamily >= CHIP_FAMILY_R600) {
 	if (mask & LOC_FB)
 	    *fb_loc = INREG(R600_MC_VM_FB_LOCATION);
 	if (mask & LOC_AGP) {
@@ -1160,7 +1174,6 @@ static Bool RADEONPreInitVisual(ScrnInfoPtr pScrn)
 
     xf86PrintDepthBpp(pScrn);
 
-    info->fifo_slots                 = 0;
     info->pix24bpp                   = xf86GetBppFromDepth(pScrn,
 							   pScrn->depth);
     info->CurrentLayout.bitsPerPixel = pScrn->bitsPerPixel;
@@ -1271,7 +1284,7 @@ static void RADEONInitMemoryMap(ScrnInfoPtr pScrn)
 
 #ifdef XF86DRI
     /* Apply memory map limitation if using an old DRI */
-    if (info->directRenderingEnabled && !info->newMemoryMap) {
+    if (info->directRenderingEnabled && !info->dri->newMemoryMap) {
 	    if (aper_size < mem_size)
 		mem_size = aper_size;
     }
@@ -1286,7 +1299,7 @@ static void RADEONInitMemoryMap(ScrnInfoPtr pScrn)
 #ifdef XF86DRI
 	/* Old DRI has restrictions on the memory map */
 	if ( info->directRenderingEnabled &&
-	     info->pKernelDRMVersion->version_minor < 10 )
+	     info->dri->pKernelDRMVersion->version_minor < 10 )
 	    info->mc_fb_location = (mem_size - 1) & 0xffff0000U;
 	else
 #endif
@@ -1474,18 +1487,18 @@ static uint32_t RADEONGetAccessibleVRAM(ScrnInfoPtr pScrn)
      * we need to limit the amount of accessible video memory
      */
     if (info->directRenderingEnabled &&
-	info->pKernelDRMVersion->version_minor < 23) {
+	info->dri->pKernelDRMVersion->version_minor < 23) {
 	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
 		   "[dri] limiting video memory to one aperture of %uK\n",
 		   (unsigned)aper_size);
 	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
 		   "[dri] detected radeon kernel module version 1.%d but"
 		   " 1.23 or newer is required for full memory mapping.\n",
-		   info->pKernelDRMVersion->version_minor);
-	info->newMemoryMap = FALSE;
+		   info->dri->pKernelDRMVersion->version_minor);
+	info->dri->newMemoryMap = FALSE;
 	return aper_size;
     }
-    info->newMemoryMap = TRUE;
+    info->dri->newMemoryMap = TRUE;
 #endif /* XF86DRI */
 
     /* Set HDP_APER_CNTL only on cards that are known not to be broken,
@@ -1893,20 +1906,6 @@ static Bool RADEONPreInitChipType(ScrnInfoPtr pScrn)
             return FALSE;
     }
 
-
-    if ((info->ChipFamily == CHIP_FAMILY_RS100) ||
-	(info->ChipFamily == CHIP_FAMILY_RS200) ||
-	(info->ChipFamily == CHIP_FAMILY_RS300) ||
-	(info->ChipFamily == CHIP_FAMILY_RS400) ||
-	(info->ChipFamily == CHIP_FAMILY_RS480) ||
-	(info->ChipFamily == CHIP_FAMILY_RS600) ||
-	(info->ChipFamily == CHIP_FAMILY_RS690) ||
-	(info->ChipFamily == CHIP_FAMILY_RS740))
-	info->has_tcl = FALSE;
-    else {
-	info->has_tcl = TRUE;
-    }
-
     return TRUE;
 }
 
@@ -1960,6 +1959,25 @@ static Bool RADEONPreInitAccel(ScrnInfoPtr pScrn)
     char *optstr;
 #endif
 
+    if (!(info->accel_state = xcalloc(1, sizeof(struct radeon_accel_state)))) {
+	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Unable to allocate accel_state rec!\n");
+	return FALSE;
+    }
+    info->accel_state->fifo_slots                 = 0;
+
+    if ((info->ChipFamily == CHIP_FAMILY_RS100) ||
+	(info->ChipFamily == CHIP_FAMILY_RS200) ||
+	(info->ChipFamily == CHIP_FAMILY_RS300) ||
+	(info->ChipFamily == CHIP_FAMILY_RS400) ||
+	(info->ChipFamily == CHIP_FAMILY_RS480) ||
+	(info->ChipFamily == CHIP_FAMILY_RS600) ||
+	(info->ChipFamily == CHIP_FAMILY_RS690) ||
+	(info->ChipFamily == CHIP_FAMILY_RS740))
+	info->accel_state->has_tcl = FALSE;
+    else {
+	info->accel_state->has_tcl = TRUE;
+    }
+
     info->useEXA = FALSE;
 
     if (info->ChipFamily >= CHIP_FAMILY_R600) {
@@ -2032,16 +2050,22 @@ static Bool RADEONPreInitAccel(ScrnInfoPtr pScrn)
 
 static Bool RADEONPreInitInt10(ScrnInfoPtr pScrn, xf86Int10InfoPtr *ppInt10)
 {
-#if !defined(__powerpc__) && !defined(__sparc__)
+#if (!defined(__powerpc__) && !defined(__sparc__)) || \
+    (defined(XSERVER_LIBPCIACCESS) && HAVE_PCI_DEVICE_ENABLE)
     RADEONInfoPtr  info = RADEONPTR(pScrn);
+#endif
+#if !defined(__powerpc__) && !defined(__sparc__)
     unsigned char *RADEONMMIO = info->MMIO;
     uint32_t       fp2_gen_ctl_save   = 0;
+#endif
 
 #ifdef XSERVER_LIBPCIACCESS
 #if HAVE_PCI_DEVICE_ENABLE
     pci_device_enable(info->PciInfo);
 #endif
 #endif
+
+#if !defined(__powerpc__) && !defined(__sparc__)
     /* don't need int10 on atom cards.
      * in theory all radeons, but the older stuff
      * isn't 100% yet
@@ -2087,10 +2111,19 @@ static Bool RADEONPreInitDRI(ScrnInfoPtr pScrn)
 
     info->directRenderingEnabled = FALSE;
     info->directRenderingInited = FALSE;
-    info->CPInUse = FALSE;
-    info->CPStarted = FALSE;
-    info->pLibDRMVersion = NULL;
-    info->pKernelDRMVersion = NULL;
+
+    if (!(info->dri = xcalloc(1, sizeof(struct radeon_dri)))) {
+	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,"Unable to allocate dri rec!\n");
+	return FALSE;
+    }
+
+    if (!(info->cp = xcalloc(1, sizeof(struct radeon_cp)))) {
+	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,"Unable to allocate cp rec!\n");
+	return FALSE;
+    }
+    info->cp->CPInUse = FALSE;
+    info->cp->CPStarted = FALSE;
+    info->cp->CPusecTimeout = RADEON_DEFAULT_CP_TIMEOUT;
 
    if (xf86IsEntityShared(info->pEnt->index)) {
         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
@@ -2106,19 +2139,16 @@ static Bool RADEONPreInitDRI(ScrnInfoPtr pScrn)
 
     if (info->Chipset == PCI_CHIP_RN50_515E ||
 	info->Chipset == PCI_CHIP_RN50_5969 ||
-	info->Chipset == PCI_CHIP_RC410_5A61 ||
-	info->Chipset == PCI_CHIP_RC410_5A62 ||
-	info->Chipset == PCI_CHIP_RS485_5975 ||
 	info->ChipFamily == CHIP_FAMILY_RS600 ||
 	info->ChipFamily >= CHIP_FAMILY_R600) {
 	if (xf86ReturnOptValBool(info->Options, OPTION_DRI, FALSE)) {
 	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-		"Direct rendering for RN50/RC410/RS485/RS600/R600 forced on -- "
+		"Direct rendering for RN50/RS600/R600 forced on -- "
 		"This is NOT officially supported at the hardware level "
 		"and may cause instability or lockups\n");
 	} else {
 	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-		"Direct rendering not officially supported on RN50/RC410/R600\n");
+		"Direct rendering not officially supported on RN50/RS600/R600\n");
 	    return FALSE;
 	}
     }
@@ -2136,18 +2166,26 @@ static Bool RADEONPreInitDRI(ScrnInfoPtr pScrn)
 	return FALSE;
     }
 
+    if (!(info->dri = xcalloc(1, sizeof(struct radeon_dri)))) {
+	ErrorF("Unable to allocate dri rec!\n");
+	return FALSE;
+    }
+
+    info->dri->pLibDRMVersion = NULL;
+    info->dri->pKernelDRMVersion = NULL;
+
     if (!RADEONDRIGetVersion(pScrn))
 	return FALSE;
 
     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 	       "[dri] Found DRI library version %d.%d.%d and kernel"
 	       " module version %d.%d.%d\n",
-	       info->pLibDRMVersion->version_major,
-	       info->pLibDRMVersion->version_minor,
-	       info->pLibDRMVersion->version_patchlevel,
-	       info->pKernelDRMVersion->version_major,
-	       info->pKernelDRMVersion->version_minor,
-	       info->pKernelDRMVersion->version_patchlevel);
+	       info->dri->pLibDRMVersion->version_major,
+	       info->dri->pLibDRMVersion->version_minor,
+	       info->dri->pLibDRMVersion->version_patchlevel,
+	       info->dri->pKernelDRMVersion->version_major,
+	       info->dri->pKernelDRMVersion->version_minor,
+	       info->dri->pKernelDRMVersion->version_patchlevel);
 
     if (info->Chipset == PCI_CHIP_RS400_5A41 ||
 	info->Chipset == PCI_CHIP_RS400_5A42 ||
@@ -2158,7 +2196,7 @@ static Bool RADEONPreInitDRI(ScrnInfoPtr pScrn)
 	info->Chipset == PCI_CHIP_RS482_5974 ||
 	info->Chipset == PCI_CHIP_RS485_5975) {
 
-	if (info->pKernelDRMVersion->version_minor < 27) {
+	if (info->dri->pKernelDRMVersion->version_minor < 27) {
  	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 			"Direct rendering broken on XPRESS 200 and 200M with DRI less than 1.27\n");
 	     return FALSE;
@@ -2167,25 +2205,22 @@ static Bool RADEONPreInitDRI(ScrnInfoPtr pScrn)
 	"Direct rendering experimental on RS400/Xpress 200 enabled\n");
     }
 
-    if (xf86ReturnOptValBool(info->Options, OPTION_CP_PIO, FALSE)) {
-	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Forcing CP into PIO mode\n");
-	info->CPMode = RADEON_DEFAULT_CP_PIO_MODE;
-    } else {
-	info->CPMode = RADEON_DEFAULT_CP_BM_MODE;
-    }
+    if (info->ChipFamily >= CHIP_FAMILY_R300)
+	info->dri->gartSize      = R300_DEFAULT_GART_SIZE;
+    else
+	info->dri->gartSize      = RADEON_DEFAULT_GART_SIZE;
 
-    info->gartSize      = RADEON_DEFAULT_GART_SIZE;
-    info->ringSize      = RADEON_DEFAULT_RING_SIZE;
-    info->bufSize       = RADEON_DEFAULT_BUFFER_SIZE;
-    info->gartTexSize   = RADEON_DEFAULT_GART_TEX_SIZE;
-    info->pciAperSize   = RADEON_DEFAULT_PCI_APER_SIZE;
-    info->CPusecTimeout = RADEON_DEFAULT_CP_TIMEOUT;
+    info->dri->ringSize      = RADEON_DEFAULT_RING_SIZE;
+    info->dri->bufSize       = RADEON_DEFAULT_BUFFER_SIZE;
+    info->dri->gartTexSize   = RADEON_DEFAULT_GART_TEX_SIZE;
+    info->dri->pciAperSize   = RADEON_DEFAULT_PCI_APER_SIZE;
+    info->cp->CPusecTimeout = RADEON_DEFAULT_CP_TIMEOUT;
 
     if ((xf86GetOptValInteger(info->Options,
-			     OPTION_GART_SIZE, (int *)&(info->gartSize))) ||
+			     OPTION_GART_SIZE, (int *)&(info->dri->gartSize))) ||
 			     (xf86GetOptValInteger(info->Options,
-			     OPTION_GART_SIZE_OLD, (int *)&(info->gartSize)))) {
-	switch (info->gartSize) {
+			     OPTION_GART_SIZE_OLD, (int *)&(info->dri->gartSize)))) {
+	switch (info->dri->gartSize) {
 	case 4:
 	case 8:
 	case 16:
@@ -2197,24 +2232,24 @@ static Bool RADEONPreInitDRI(ScrnInfoPtr pScrn)
 
 	default:
 	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-		       "Illegal GART size: %d MB\n", info->gartSize);
+		       "Illegal GART size: %d MB\n", info->dri->gartSize);
 	    return FALSE;
 	}
     }
 
     if (xf86GetOptValInteger(info->Options,
-			     OPTION_RING_SIZE, &(info->ringSize))) {
-	if (info->ringSize < 1 || info->ringSize >= (int)info->gartSize) {
+			     OPTION_RING_SIZE, &(info->dri->ringSize))) {
+	if (info->dri->ringSize < 1 || info->dri->ringSize >= (int)info->dri->gartSize) {
 	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		       "Illegal ring buffer size: %d MB\n",
-		       info->ringSize);
+		       info->dri->ringSize);
 	    return FALSE;
 	}
     }
 
     if (xf86GetOptValInteger(info->Options,
-			     OPTION_PCIAPER_SIZE, &(info->pciAperSize))) {
-      switch(info->pciAperSize) {
+			     OPTION_PCIAPER_SIZE, &(info->dri->pciAperSize))) {
+      switch(info->dri->pciAperSize) {
       case 32:
       case 64:
       case 128:
@@ -2223,63 +2258,63 @@ static Bool RADEONPreInitDRI(ScrnInfoPtr pScrn)
       default:
 	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		       "Illegal pci aper size: %d MB\n",
-		       info->pciAperSize);
+		       info->dri->pciAperSize);
 	return FALSE;
       }
     }
 
 
     if (xf86GetOptValInteger(info->Options,
-			     OPTION_BUFFER_SIZE, &(info->bufSize))) {
-	if (info->bufSize < 1 || info->bufSize >= (int)info->gartSize) {
+			     OPTION_BUFFER_SIZE, &(info->dri->bufSize))) {
+	if (info->dri->bufSize < 1 || info->dri->bufSize >= (int)info->dri->gartSize) {
 	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		       "Illegal vertex/indirect buffers size: %d MB\n",
-		       info->bufSize);
+		       info->dri->bufSize);
 	    return FALSE;
 	}
-	if (info->bufSize > 2) {
+	if (info->dri->bufSize > 2) {
 	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		       "Illegal vertex/indirect buffers size: %d MB\n",
-		       info->bufSize);
+		       info->dri->bufSize);
 	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		       "Clamping vertex/indirect buffers size to 2 MB\n");
-	    info->bufSize = 2;
+	    info->dri->bufSize = 2;
 	}
     }
 
-    if (info->ringSize + info->bufSize + info->gartTexSize >
-	(int)info->gartSize) {
+    if (info->dri->ringSize + info->dri->bufSize + info->dri->gartTexSize >
+	(int)info->dri->gartSize) {
 	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		   "Buffers are too big for requested GART space\n");
 	return FALSE;
     }
 
-    info->gartTexSize = info->gartSize - (info->ringSize + info->bufSize);
+    info->dri->gartTexSize = info->dri->gartSize - (info->dri->ringSize + info->dri->bufSize);
 
     if (xf86GetOptValInteger(info->Options, OPTION_USEC_TIMEOUT,
-			     &(info->CPusecTimeout))) {
+			     &(info->cp->CPusecTimeout))) {
 	/* This option checked by the RADEON DRM kernel module */
     }
 
     /* Two options to try and squeeze as much texture memory as possible
      * for dedicated 3d rendering boxes
      */
-    info->noBackBuffer = xf86ReturnOptValBool(info->Options,
-					      OPTION_NO_BACKBUFFER,
-					      FALSE);
+    info->dri->noBackBuffer = xf86ReturnOptValBool(info->Options,
+						   OPTION_NO_BACKBUFFER,
+						   FALSE);
 
-    info->allowPageFlip = 0;
+    info->dri->allowPageFlip = 0;
 
 #ifdef DAMAGE
-    if (info->noBackBuffer) {
+    if (info->dri->noBackBuffer) {
 	from = X_DEFAULT;
 	reason = " because back buffer disabled";
     } else {
 	from = xf86GetOptValBool(info->Options, OPTION_PAGE_FLIP,
-				 &info->allowPageFlip) ? X_CONFIG : X_DEFAULT;
+				 &info->dri->allowPageFlip) ? X_CONFIG : X_DEFAULT;
 
 	if (IS_AVIVO_VARIANT) {
-	    info->allowPageFlip = 0;
+	    info->dri->allowPageFlip = 0;
 	    reason = " on r5xx and newer chips.\n";
 	} else {
 	    reason = "";
@@ -2292,7 +2327,7 @@ static Bool RADEONPreInitDRI(ScrnInfoPtr pScrn)
 #endif
 
     xf86DrvMsg(pScrn->scrnIndex, from, "Page Flipping %sabled%s\n",
-	       info->allowPageFlip ? "en" : "dis", reason);
+	       info->dri->allowPageFlip ? "en" : "dis", reason);
 
     info->DMAForXv = TRUE;
     from = xf86GetOptValBool(info->Options, OPTION_XV_DMA, &info->DMAForXv)
@@ -2332,15 +2367,15 @@ static void RADEONPreInitColorTiling(ScrnInfoPtr pScrn)
 
 #ifdef XF86DRI
     if (info->directRenderingEnabled &&
-	info->pKernelDRMVersion->version_minor < 14) {
+	info->dri->pKernelDRMVersion->version_minor < 14) {
 	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
 		   "[dri] color tiling disabled because of version "
 		   "mismatch.\n"
 		   "[dri] radeon.o kernel module version is %d.%d.%d but "
 		   "1.14.0 or later is required for color tiling.\n",
-		   info->pKernelDRMVersion->version_major,
-		   info->pKernelDRMVersion->version_minor,
-		   info->pKernelDRMVersion->version_patchlevel);
+		   info->dri->pKernelDRMVersion->version_major,
+		   info->dri->pKernelDRMVersion->version_minor,
+		   info->dri->pKernelDRMVersion->version_patchlevel);
 	   info->allowColorTiling = FALSE;
 	   return;
     }
@@ -2994,7 +3029,7 @@ static void RADEONLoadPalette(ScrnInfoPtr pScrn, int numColors,
     int c;
 
 #ifdef XF86DRI
-    if (info->CPStarted && pScrn->pScreen) DRILock(pScrn->pScreen, 0);
+    if (info->cp->CPStarted && pScrn->pScreen) DRILock(pScrn->pScreen, 0);
 #endif
 
     if (info->accelOn && pScrn->pScreen)
@@ -3058,7 +3093,7 @@ static void RADEONLoadPalette(ScrnInfoPtr pScrn, int numColors,
     }
 
 #ifdef XF86DRI
-    if (info->CPStarted && pScrn->pScreen) DRIUnlock(pScrn->pScreen);
+    if (info->cp->CPStarted && pScrn->pScreen) DRIUnlock(pScrn->pScreen);
 #endif
 }
 
@@ -3077,12 +3112,12 @@ static void RADEONBlockHandler(int i, pointer blockData,
 	(*info->VideoTimerCallback)(pScrn, currentTime.milliseconds);
 
 #if defined(RENDER) && defined(USE_XAA)
-    if(info->RenderCallback)
-	(*info->RenderCallback)(pScrn);
+    if(info->accel_state->RenderCallback)
+	(*info->accel_state->RenderCallback)(pScrn);
 #endif
 
 #ifdef USE_EXA
-    info->engineMode = EXA_ENGINEMODE_UNKNOWN;
+    info->accel_state->engineMode = EXA_ENGINEMODE_UNKNOWN;
 #endif
 }
 
@@ -3175,17 +3210,17 @@ Bool RADEONScreenInit(int scrnIndex, ScreenPtr pScreen,
 
     info->accelOn      = FALSE;
 #ifdef USE_XAA
-    info->accel        = NULL;
+    info->accel_state->accel        = NULL;
 #endif
 #ifdef XF86DRI
-    pScrn->fbOffset    = info->frontOffset;
+    pScrn->fbOffset    = info->dri->frontOffset;
 #endif
 
     if (info->IsSecondary) pScrn->fbOffset = pScrn->videoRam * 1024;
 #ifdef XF86DRI
     xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
 		   "RADEONScreenInit %lx %ld %d\n",
-		   pScrn->memPhysBase, pScrn->fbOffset, info->frontOffset);
+		   pScrn->memPhysBase, pScrn->fbOffset, info->dri->frontOffset);
 #else
     xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
 		   "RADEONScreenInit %lx %ld\n",
@@ -3194,8 +3229,8 @@ Bool RADEONScreenInit(int scrnIndex, ScreenPtr pScreen,
     if (!RADEONMapMem(pScrn)) return FALSE;
 
 #ifdef XF86DRI
-    info->fbX = 0;
-    info->fbY = 0;
+    info->dri->fbX = 0;
+    info->dri->fbY = 0;
 #endif
 
     info->PaletteSavedOnVT = FALSE;
@@ -3249,21 +3284,21 @@ Bool RADEONScreenInit(int scrnIndex, ScreenPtr pScreen,
     if (info->directRenderingEnabled) {
 	MessageType from;
 
-	info->depthBits = pScrn->depth;
+	info->dri->depthBits = pScrn->depth;
 
 	from = xf86GetOptValInteger(info->Options, OPTION_DEPTH_BITS,
-				    &info->depthBits)
+				    &info->dri->depthBits)
 	     ? X_CONFIG : X_DEFAULT;
 
-	if (info->depthBits != 16 && info->depthBits != 24) {
+	if (info->dri->depthBits != 16 && info->dri->depthBits != 24) {
 	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		       "Value for Option \"DepthBits\" must be 16 or 24\n");
-	    info->depthBits = pScrn->depth;
+	    info->dri->depthBits = pScrn->depth;
 	    from = X_DEFAULT;
 	}
 
 	xf86DrvMsg(pScrn->scrnIndex, from,
-		   "Using %d bit depth buffer\n", info->depthBits);
+		   "Using %d bit depth buffer\n", info->dri->depthBits);
     }
 
 
@@ -3288,14 +3323,14 @@ Bool RADEONScreenInit(int scrnIndex, ScreenPtr pScreen,
 
 #ifdef XF86DRI
     /* Depth moves are disabled by default since they are extremely slow */
-    info->depthMoves = xf86ReturnOptValBool(info->Options,
+    info->dri->depthMoves = xf86ReturnOptValBool(info->Options,
 						 OPTION_DEPTH_MOVE, FALSE);
-    if (info->depthMoves && info->allowColorTiling) {
+    if (info->dri->depthMoves && info->allowColorTiling) {
 	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Enabling depth moves\n");
-    } else if (info->depthMoves) {
+    } else if (info->dri->depthMoves) {
 	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 		   "Depth moves don't work without color tiling, disabled\n");
-	info->depthMoves = FALSE;
+	info->dri->depthMoves = FALSE;
     } else {
 	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 		   "Depth moves disabled by default\n");
@@ -3331,15 +3366,15 @@ Bool RADEONScreenInit(int scrnIndex, ScreenPtr pScreen,
 	     * default, can be overridden with Option "FBTexPercent".
 	     * Round down to a whole number of texture regions.
 	     */
-	    info->textureSize = 50;
+	    info->dri->textureSize = 50;
 
 	    if (xf86GetOptValInteger(info->Options, OPTION_FBTEX_PERCENT,
-				     &(info->textureSize))) {
-		if (info->textureSize < 0 || info->textureSize > 100) {
+				     &(info->dri->textureSize))) {
+		if (info->dri->textureSize < 0 || info->dri->textureSize > 100) {
 		    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 			       "Illegal texture memory percentage: %dx, setting to default 50%%\n",
-			       info->textureSize);
-		    info->textureSize = 50;
+			       info->dri->textureSize);
+		    info->dri->textureSize = 50;
 		}
 	    }
 	}
@@ -3356,19 +3391,19 @@ Bool RADEONScreenInit(int scrnIndex, ScreenPtr pScreen,
 
 #if defined(XF86DRI) && defined(USE_XAA)
     if (!info->useEXA && hasDRI) {
-	info->textureSize = -1;
+	info->dri->textureSize = -1;
 	if (xf86GetOptValInteger(info->Options, OPTION_FBTEX_PERCENT,
-				 &(info->textureSize))) {
-	    if (info->textureSize < 0 || info->textureSize > 100) {
+				 &(info->dri->textureSize))) {
+	    if (info->dri->textureSize < 0 || info->dri->textureSize > 100) {
 		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 			   "Illegal texture memory percentage: %dx, using default behaviour\n",
-			   info->textureSize);
-		info->textureSize = -1;
+			   info->dri->textureSize);
+		info->dri->textureSize = -1;
 	    }
 	}
 	if (!RADEONSetupMemXAA_DRI(scrnIndex, pScreen))
 	    return FALSE;
-    	pScrn->fbOffset    = info->frontOffset;
+    	pScrn->fbOffset    = info->dri->frontOffset;
     }
 #endif
 
@@ -3377,8 +3412,9 @@ Bool RADEONScreenInit(int scrnIndex, ScreenPtr pScreen,
 	return FALSE;
 #endif
 
-    info->dst_pitch_offset = (((pScrn->displayWidth * info->CurrentLayout.pixel_bytes / 64)
-			       << 22) | ((info->fbLocation + pScrn->fbOffset) >> 10));
+    info->accel_state->dst_pitch_offset =
+	(((pScrn->displayWidth * info->CurrentLayout.pixel_bytes / 64)
+	  << 22) | ((info->fbLocation + pScrn->fbOffset) >> 10));
 
     /* Setup DRI after visuals have been established, but before fbScreenInit is
      * called.  fbScreenInit will eventually call the driver's InitGLXVisuals
@@ -3408,7 +3444,7 @@ Bool RADEONScreenInit(int scrnIndex, ScreenPtr pScreen,
     }
 
     /* Tell DRI about new memory map */
-    if (info->directRenderingEnabled && info->newMemoryMap) {
+    if (info->directRenderingEnabled && info->dri->newMemoryMap) {
         if (RADEONDRISetParam(pScrn, RADEON_SETPARAM_NEW_MEMMAP, 1) < 0) {
 		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
 			   "[drm] failed to enable new memory map\n");
@@ -3495,14 +3531,14 @@ Bool RADEONScreenInit(int scrnIndex, ScreenPtr pScreen,
     /* DRI finalisation */
 #ifdef XF86DRI
     if (info->directRenderingEnabled && info->cardType==CARD_PCIE &&
-        info->pKernelDRMVersion->version_minor >= 19)
+        info->dri->pKernelDRMVersion->version_minor >= 19)
     {
-      if (RADEONDRISetParam(pScrn, RADEON_SETPARAM_PCIGART_LOCATION, info->pciGartOffset) < 0)
+      if (RADEONDRISetParam(pScrn, RADEON_SETPARAM_PCIGART_LOCATION, info->dri->pciGartOffset) < 0)
 	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		   "[drm] failed set pci gart location\n");
 
-      if (info->pKernelDRMVersion->version_minor >= 26) {
-	if (RADEONDRISetParam(pScrn, RADEON_SETPARAM_PCIGART_TABLE_SIZE, info->pciGartSize) < 0)
+      if (info->dri->pKernelDRMVersion->version_minor >= 26) {
+	if (RADEONDRISetParam(pScrn, RADEON_SETPARAM_PCIGART_TABLE_SIZE, info->dri->pciGartSize) < 0)
 	  xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		     "[drm] failed set pci gart table size\n");
       }
@@ -3519,10 +3555,6 @@ Bool RADEONScreenInit(int scrnIndex, ScreenPtr pScreen,
 	 */
 	RADEONAdjustMemMapRegisters(pScrn, info->ModeReg);
 
-	if ((info->DispPriority == 1) && (info->cardType==CARD_AGP)) {
-	    /* we need to re-calculate bandwidth because of AGPMode difference. */ 
-	    RADEONInitDispBandwidth(pScrn);
-	}
 	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Direct rendering enabled\n");
 
 	/* we might already be in tiled mode, tell drm about it */
@@ -3910,7 +3942,7 @@ static void RADEONAdjustMemMapRegisters(ScrnInfoPtr pScrn, RADEONSavePtr save)
 	else
 	    info->fbLocation = (info->mc_fb_location & 0xffff) << 16;
 
-	info->dst_pitch_offset =
+	info->accel_state->dst_pitch_offset =
 	    (((pScrn->displayWidth * info->CurrentLayout.pixel_bytes / 64)
 	      << 22) | ((info->fbLocation + pScrn->fbOffset) >> 10));
 	RADEONInitMemMapRegisters(pScrn, save, info);
@@ -3920,14 +3952,14 @@ static void RADEONAdjustMemMapRegisters(ScrnInfoPtr pScrn, RADEONSavePtr save)
 #ifdef USE_EXA
     if (info->accelDFS)
     {
-	drmRadeonGetParam gp;
+	drm_radeon_getparam_t gp;
 	int gart_base;
 
 	memset(&gp, 0, sizeof(gp));
 	gp.param = RADEON_PARAM_GART_BASE;
 	gp.value = &gart_base;
 
-	if (drmCommandWriteRead(info->drmFD, DRM_RADEON_GETPARAM, &gp,
+	if (drmCommandWriteRead(info->dri->drmFD, DRM_RADEON_GETPARAM, &gp,
 				sizeof(gp)) < 0) {
 	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		       "Failed to determine GART area MC location, not using "
@@ -4011,35 +4043,35 @@ void RADEONChangeSurfaces(ScrnInfoPtr pScrn)
     }   
 #ifdef XF86DRI
     if (info->directRenderingInited) {
-	drmRadeonSurfaceFree drmsurffree;
-	drmRadeonSurfaceAlloc drmsurfalloc;
+	drm_radeon_surface_free_t drmsurffree;
+	drm_radeon_surface_alloc_t drmsurfalloc;
 	int retvalue;
-	int depthCpp = (info->depthBits - 8) / 4;
+	int depthCpp = (info->dri->depthBits - 8) / 4;
 	int depth_width_bytes = pScrn->displayWidth * depthCpp;
 	int depthBufferSize = ((((pScrn->virtualY + 15) & ~15) * depth_width_bytes
 				+ RADEON_BUFFER_ALIGN) & ~RADEON_BUFFER_ALIGN);
 	unsigned int depth_pattern;
 
-	drmsurffree.address = info->frontOffset;
-	retvalue = drmCommandWrite(info->drmFD, DRM_RADEON_SURF_FREE,
+	drmsurffree.address = info->dri->frontOffset;
+	retvalue = drmCommandWrite(info->dri->drmFD, DRM_RADEON_SURF_FREE,
 	    &drmsurffree, sizeof(drmsurffree));
 
 	if (!((info->ChipFamily == CHIP_FAMILY_RV100) ||
 	    (info->ChipFamily == CHIP_FAMILY_RS100) ||
 	    (info->ChipFamily == CHIP_FAMILY_RS200))) {
-	    drmsurffree.address = info->depthOffset;
-	    retvalue = drmCommandWrite(info->drmFD, DRM_RADEON_SURF_FREE,
+	    drmsurffree.address = info->dri->depthOffset;
+	    retvalue = drmCommandWrite(info->dri->drmFD, DRM_RADEON_SURF_FREE,
 		&drmsurffree, sizeof(drmsurffree));
 	}
 
-	if (!info->noBackBuffer) {
-	    drmsurffree.address = info->backOffset;
-	    retvalue = drmCommandWrite(info->drmFD, DRM_RADEON_SURF_FREE,
+	if (!info->dri->noBackBuffer) {
+	    drmsurffree.address = info->dri->backOffset;
+	    retvalue = drmCommandWrite(info->dri->drmFD, DRM_RADEON_SURF_FREE,
 		&drmsurffree, sizeof(drmsurffree));
 	}
 
 	drmsurfalloc.size = bufferSize;
-	drmsurfalloc.address = info->frontOffset;
+	drmsurfalloc.address = info->dri->frontOffset;
 	drmsurfalloc.flags = swap_pattern;
 
 	if (info->tilingEnabled) {
@@ -4048,15 +4080,15 @@ void RADEONChangeSurfaces(ScrnInfoPtr pScrn)
 	    else
 		drmsurfalloc.flags |= (width_bytes / 16) | color_pattern;
 	}
-	retvalue = drmCommandWrite(info->drmFD, DRM_RADEON_SURF_ALLOC,
+	retvalue = drmCommandWrite(info->dri->drmFD, DRM_RADEON_SURF_ALLOC,
 				   &drmsurfalloc, sizeof(drmsurfalloc));
 	if (retvalue < 0)
 	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		       "drm: could not allocate surface for front buffer!\n");
 	
-	if ((info->have3DWindows) && (!info->noBackBuffer)) {
-	    drmsurfalloc.address = info->backOffset;
-	    retvalue = drmCommandWrite(info->drmFD, DRM_RADEON_SURF_ALLOC,
+	if ((info->dri->have3DWindows) && (!info->dri->noBackBuffer)) {
+	    drmsurfalloc.address = info->dri->backOffset;
+	    retvalue = drmCommandWrite(info->dri->drmFD, DRM_RADEON_SURF_ALLOC,
 				       &drmsurfalloc, sizeof(drmsurfalloc));
 	    if (retvalue < 0)
 		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
@@ -4081,18 +4113,18 @@ void RADEONChangeSurfaces(ScrnInfoPtr pScrn)
 	}
 
 	/* rv100 and probably the derivative igps don't have depth tiling on all the time? */
-	if (info->have3DWindows &&
+	if (info->dri->have3DWindows &&
 	    (!((info->ChipFamily == CHIP_FAMILY_RV100) ||
 	    (info->ChipFamily == CHIP_FAMILY_RS100) ||
 	    (info->ChipFamily == CHIP_FAMILY_RS200)))) {
-	    drmRadeonSurfaceAlloc drmsurfalloc;
+	    drm_radeon_surface_alloc_t drmsurfalloc;
 	    drmsurfalloc.size = depthBufferSize;
-	    drmsurfalloc.address = info->depthOffset;
+	    drmsurfalloc.address = info->dri->depthOffset;
             if (IS_R300_VARIANT || IS_AVIVO_VARIANT)
                 drmsurfalloc.flags = swap_pattern | (depth_width_bytes / 8) | depth_pattern;
             else
                 drmsurfalloc.flags = swap_pattern | (depth_width_bytes / 16) | depth_pattern;
-	    retvalue = drmCommandWrite(info->drmFD, DRM_RADEON_SURF_ALLOC,
+	    retvalue = drmCommandWrite(info->dri->drmFD, DRM_RADEON_SURF_ALLOC,
 		&drmsurfalloc, sizeof(drmsurfalloc));
 	    if (retvalue < 0)
 		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
@@ -4178,6 +4210,7 @@ avivo_save(ScrnInfoPtr pScrn, RADEONSavePtr save)
 
     state->crtc_master_en = INREG(AVIVO_DC_CRTC_MASTER_EN);
     state->crtc_tv_control = INREG(AVIVO_DC_CRTC_TV_CONTROL);
+    state->dc_lb_memory_split = INREG(AVIVO_DC_LB_MEMORY_SPLIT);
 
     state->pll1.ref_div_src = INREG(AVIVO_EXT1_PPLL_REF_DIV_SRC);
     state->pll1.ref_div = INREG(AVIVO_EXT1_PPLL_REF_DIV);
@@ -4233,8 +4266,10 @@ avivo_save(ScrnInfoPtr pScrn, RADEONSavePtr save)
     state->grph1.x_end = INREG(AVIVO_D1GRPH_X_END);
     state->grph1.y_end = INREG(AVIVO_D1GRPH_Y_END);
 
+    state->grph1.desktop_height = INREG(AVIVO_D1MODE_DESKTOP_HEIGHT);
     state->grph1.viewport_start = INREG(AVIVO_D1MODE_VIEWPORT_START);
     state->grph1.viewport_size = INREG(AVIVO_D1MODE_VIEWPORT_SIZE);
+    state->grph1.mode_data_format = INREG(AVIVO_D1MODE_DATA_FORMAT);
 
     state->crtc2.pll_source = INREG(AVIVO_PCLK_CRTC2_CNTL);
 
@@ -4272,8 +4307,10 @@ avivo_save(ScrnInfoPtr pScrn, RADEONSavePtr save)
     state->grph2.x_end = INREG(AVIVO_D2GRPH_X_END);
     state->grph2.y_end = INREG(AVIVO_D2GRPH_Y_END);
 
+    state->grph2.desktop_height = INREG(AVIVO_D2MODE_DESKTOP_HEIGHT);
     state->grph2.viewport_start = INREG(AVIVO_D2MODE_VIEWPORT_START);
     state->grph2.viewport_size = INREG(AVIVO_D2MODE_VIEWPORT_SIZE);
+    state->grph2.mode_data_format = INREG(AVIVO_D2MODE_DATA_FORMAT);
 
     if (IS_DCE3_VARIANT) {
 	/* save DVOA regs */
@@ -4477,14 +4514,71 @@ avivo_restore(ScrnInfoPtr pScrn, RADEONSavePtr restore)
     struct avivo_state *state = &restore->avivo;
     int i, j;
 
-    //    OUTMC(pScrn, AVIVO_MC_MEMORY_MAP, state->mc_memory_map);
-    //    OUTREG(AVIVO_VGA_MEMORY_BASE, state->vga_memory_base);
-    //    OUTREG(AVIVO_VGA_FB_START, state->vga_fb_start);
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "avivo_restore !\n");
+
+    /* Disable VGA control for now.. maybe needs to be changed */
+    OUTREG(AVIVO_D1VGA_CONTROL, 0);
+    OUTREG(AVIVO_D2VGA_CONTROL, 0);
+
+    /* Disable CRTCs */
+    OUTREG(AVIVO_D1CRTC_CONTROL,
+	   (INREG(AVIVO_D1CRTC_CONTROL) & ~0x300) | 0x01000000);
+    OUTREG(AVIVO_D2CRTC_CONTROL,
+	   (INREG(AVIVO_D2CRTC_CONTROL) & ~0x300) | 0x01000000);
+    OUTREG(AVIVO_D1CRTC_CONTROL,
+	   INREG(AVIVO_D1CRTC_CONTROL) & ~0x1);
+    OUTREG(AVIVO_D2CRTC_CONTROL,
+	   INREG(AVIVO_D2CRTC_CONTROL) & ~0x1);
+    OUTREG(AVIVO_D1CRTC_CONTROL,
+	   INREG(AVIVO_D1CRTC_CONTROL) | 0x100);
+    OUTREG(AVIVO_D2CRTC_CONTROL,
+	   INREG(AVIVO_D2CRTC_CONTROL) | 0x100);
+
+    /* Lock graph registers */
+    OUTREG(AVIVO_D1GRPH_UPDATE, AVIVO_D1GRPH_UPDATE_LOCK);
+    OUTREG(AVIVO_D1GRPH_PRIMARY_SURFACE_ADDRESS, state->grph1.prim_surf_addr);
+    OUTREG(AVIVO_D1GRPH_SECONDARY_SURFACE_ADDRESS, state->grph1.sec_surf_addr);
+    OUTREG(AVIVO_D1GRPH_CONTROL, state->grph1.control);
+    OUTREG(AVIVO_D1GRPH_SURFACE_OFFSET_X, state->grph1.x_offset);
+    OUTREG(AVIVO_D1GRPH_SURFACE_OFFSET_Y, state->grph1.y_offset);
+    OUTREG(AVIVO_D1GRPH_X_START, state->grph1.x_start);
+    OUTREG(AVIVO_D1GRPH_Y_START, state->grph1.y_start);
+    OUTREG(AVIVO_D1GRPH_X_END, state->grph1.x_end);
+    OUTREG(AVIVO_D1GRPH_Y_END, state->grph1.y_end);
+    OUTREG(AVIVO_D1GRPH_PITCH, state->grph1.pitch);
+    OUTREG(AVIVO_D1GRPH_ENABLE, state->grph1.enable);
+    OUTREG(AVIVO_D1GRPH_UPDATE, 0);
 
+    OUTREG(AVIVO_D2GRPH_UPDATE, AVIVO_D1GRPH_UPDATE_LOCK);
+    OUTREG(AVIVO_D2GRPH_PRIMARY_SURFACE_ADDRESS, state->grph2.prim_surf_addr);
+    OUTREG(AVIVO_D2GRPH_SECONDARY_SURFACE_ADDRESS, state->grph2.sec_surf_addr);
+    OUTREG(AVIVO_D2GRPH_CONTROL, state->grph2.control);
+    OUTREG(AVIVO_D2GRPH_SURFACE_OFFSET_X, state->grph2.x_offset);
+    OUTREG(AVIVO_D2GRPH_SURFACE_OFFSET_Y, state->grph2.y_offset);
+    OUTREG(AVIVO_D2GRPH_X_START, state->grph2.x_start);
+    OUTREG(AVIVO_D2GRPH_Y_START, state->grph2.y_start);
+    OUTREG(AVIVO_D2GRPH_X_END, state->grph2.x_end);
+    OUTREG(AVIVO_D2GRPH_Y_END, state->grph2.y_end);
+    OUTREG(AVIVO_D2GRPH_PITCH, state->grph2.pitch);
+    OUTREG(AVIVO_D2GRPH_ENABLE, state->grph2.enable);
+    OUTREG(AVIVO_D2GRPH_UPDATE, 0);
 
-    OUTREG(AVIVO_DC_CRTC_MASTER_EN, state->crtc_master_en);
-    OUTREG(AVIVO_DC_CRTC_TV_CONTROL, state->crtc_tv_control);
+    /* Whack some mode regs too */
+    OUTREG(AVIVO_D1SCL_UPDATE, AVIVO_D1SCL_UPDATE_LOCK);
+    OUTREG(AVIVO_D1MODE_DESKTOP_HEIGHT, state->grph1.desktop_height);
+    OUTREG(AVIVO_D1MODE_VIEWPORT_START, state->grph1.viewport_start);
+    OUTREG(AVIVO_D1MODE_VIEWPORT_SIZE, state->grph1.viewport_size);
+    OUTREG(AVIVO_D1MODE_DATA_FORMAT, state->grph1.mode_data_format);
+    OUTREG(AVIVO_D1SCL_UPDATE, 0);
 
+    OUTREG(AVIVO_D2SCL_UPDATE, AVIVO_D1SCL_UPDATE_LOCK);
+    OUTREG(AVIVO_D2MODE_DESKTOP_HEIGHT, state->grph2.desktop_height);
+    OUTREG(AVIVO_D2MODE_VIEWPORT_START, state->grph2.viewport_start);
+    OUTREG(AVIVO_D2MODE_VIEWPORT_SIZE, state->grph2.viewport_size);
+    OUTREG(AVIVO_D2MODE_DATA_FORMAT, state->grph2.mode_data_format);
+    OUTREG(AVIVO_D2SCL_UPDATE, 0);
+
+    /* Set the PLL */
     OUTREG(AVIVO_EXT1_PPLL_REF_DIV_SRC, state->pll1.ref_div_src);
     OUTREG(AVIVO_EXT1_PPLL_REF_DIV, state->pll1.ref_div);
     OUTREG(AVIVO_EXT1_PPLL_FB_DIV, state->pll1.fb_div);
@@ -4504,7 +4598,9 @@ avivo_restore(ScrnInfoPtr pScrn, RADEONSavePtr restore)
     OUTREG(AVIVO_P2PLL_INT_SS_CNTL, state->pll2.int_ss_cntl);
 
     OUTREG(AVIVO_PCLK_CRTC1_CNTL, state->crtc1.pll_source);
+    OUTREG(AVIVO_PCLK_CRTC2_CNTL, state->crtc2.pll_source);
 
+    /* Set the CRTC */
     OUTREG(AVIVO_D1CRTC_H_TOTAL, state->crtc1.h_total);
     OUTREG(AVIVO_D1CRTC_H_BLANK_START_END, state->crtc1.h_blank_start_end);
     OUTREG(AVIVO_D1CRTC_H_SYNC_A, state->crtc1.h_sync_a);
@@ -4519,29 +4615,12 @@ avivo_restore(ScrnInfoPtr pScrn, RADEONSavePtr restore)
     OUTREG(AVIVO_D1CRTC_V_SYNC_B, state->crtc1.v_sync_b);
     OUTREG(AVIVO_D1CRTC_V_SYNC_B_CNTL, state->crtc1.v_sync_b_cntl);
 
-    OUTREG(AVIVO_D1CRTC_CONTROL, state->crtc1.control);
-    OUTREG(AVIVO_D1CRTC_BLANK_CONTROL, state->crtc1.blank_control);
     OUTREG(AVIVO_D1CRTC_INTERLACE_CONTROL, state->crtc1.interlace_control);
     OUTREG(AVIVO_D1CRTC_STEREO_CONTROL, state->crtc1.stereo_control);
 
     OUTREG(AVIVO_D1CUR_CONTROL, state->crtc1.cursor_control);
 
-    OUTREG(AVIVO_D1GRPH_ENABLE, state->grph1.enable);
-    OUTREG(AVIVO_D1GRPH_CONTROL, state->grph1.control);
-    OUTREG(AVIVO_D1GRPH_PRIMARY_SURFACE_ADDRESS, state->grph1.prim_surf_addr);
-    OUTREG(AVIVO_D1GRPH_SECONDARY_SURFACE_ADDRESS, state->grph1.sec_surf_addr);
-    OUTREG(AVIVO_D1GRPH_PITCH, state->grph1.pitch);
-    OUTREG(AVIVO_D1GRPH_SURFACE_OFFSET_X, state->grph1.x_offset);
-    OUTREG(AVIVO_D1GRPH_SURFACE_OFFSET_Y, state->grph1.y_offset);
-    OUTREG(AVIVO_D1GRPH_X_START, state->grph1.x_start);
-    OUTREG(AVIVO_D1GRPH_Y_START, state->grph1.y_start);
-    OUTREG(AVIVO_D1GRPH_X_END, state->grph1.x_end);
-    OUTREG(AVIVO_D1GRPH_Y_END, state->grph1.y_end);
-
-    OUTREG(AVIVO_D1MODE_VIEWPORT_START, state->grph1.viewport_start);
-    OUTREG(AVIVO_D1MODE_VIEWPORT_SIZE, state->grph1.viewport_size);
-
-    OUTREG(AVIVO_PCLK_CRTC2_CNTL, state->crtc2.pll_source);
+    /* XXX Fix scaler */
 
     OUTREG(AVIVO_D2CRTC_H_TOTAL, state->crtc2.h_total);
     OUTREG(AVIVO_D2CRTC_H_BLANK_START_END, state->crtc2.h_blank_start_end);
@@ -4557,29 +4636,11 @@ avivo_restore(ScrnInfoPtr pScrn, RADEONSavePtr restore)
     OUTREG(AVIVO_D2CRTC_V_SYNC_B, state->crtc2.v_sync_b);
     OUTREG(AVIVO_D2CRTC_V_SYNC_B_CNTL, state->crtc2.v_sync_b_cntl);
 
-    OUTREG(AVIVO_D2CRTC_CONTROL, state->crtc2.control);
-    OUTREG(AVIVO_D2CRTC_BLANK_CONTROL, state->crtc2.blank_control);
     OUTREG(AVIVO_D2CRTC_INTERLACE_CONTROL, state->crtc2.interlace_control);
     OUTREG(AVIVO_D2CRTC_STEREO_CONTROL, state->crtc2.stereo_control);
 
     OUTREG(AVIVO_D2CUR_CONTROL, state->crtc2.cursor_control);
 
-    OUTREG(AVIVO_D2GRPH_ENABLE, state->grph2.enable);
-    OUTREG(AVIVO_D2GRPH_CONTROL, state->grph2.control);
-    OUTREG(AVIVO_D2GRPH_PRIMARY_SURFACE_ADDRESS, state->grph2.prim_surf_addr);
-    OUTREG(AVIVO_D2GRPH_SECONDARY_SURFACE_ADDRESS, state->grph2.sec_surf_addr);
-    OUTREG(AVIVO_D2GRPH_PITCH, state->grph2.pitch);
-    OUTREG(AVIVO_D2GRPH_SURFACE_OFFSET_X, state->grph2.x_offset);
-    OUTREG(AVIVO_D2GRPH_SURFACE_OFFSET_Y, state->grph2.y_offset);
-    OUTREG(AVIVO_D2GRPH_X_START, state->grph2.x_start);
-    OUTREG(AVIVO_D2GRPH_Y_START, state->grph2.y_start);
-    OUTREG(AVIVO_D2GRPH_X_END, state->grph2.x_end);
-    OUTREG(AVIVO_D2GRPH_Y_END, state->grph2.y_end);
-
-    OUTREG(AVIVO_D2MODE_VIEWPORT_START, state->grph2.viewport_start);
-    OUTREG(AVIVO_D2MODE_VIEWPORT_SIZE, state->grph2.viewport_size);
-
-
     if (IS_DCE3_VARIANT) {
 	/* DVOA regs */
 	OUTREG(0x7080, state->dvoa[0]);
@@ -4699,7 +4760,7 @@ avivo_restore(ScrnInfoPtr pScrn, RADEONSavePtr restore)
 	}
 
 	j = 0;
-	/* DAC regs */
+	/* DAC regs */ /* -- MIGHT NEED ORDERING FIX & DELAYS -- */
 	for (i = 0x7800; i <= 0x782c; i += 4) {
 	    OUTREG(i, state->daca[j]);
 	    OUTREG((i + 0x200), state->dacb[j]);
@@ -4766,8 +4827,31 @@ avivo_restore(ScrnInfoPtr pScrn, RADEONSavePtr restore)
     OUTREG(0x6e30, state->dxscl[6]);
     OUTREG(0x6e34, state->dxscl[7]);
 
+    /* Enable CRTCs */
+    if (state->crtc1.control & 1) {
+	    OUTREG(AVIVO_D1CRTC_CONTROL, 0x01000101);
+	    INREG(AVIVO_D1CRTC_CONTROL);
+	    OUTREG(AVIVO_D1CRTC_CONTROL, 0x00010101);
+    }
+    if (state->crtc2.control & 1) {
+	    OUTREG(AVIVO_D2CRTC_CONTROL, 0x01000101);
+	    INREG(AVIVO_D2CRTC_CONTROL);
+	    OUTREG(AVIVO_D2CRTC_CONTROL, 0x00010101);
+    }
+
+    /* Where should that go ? */
+    OUTREG(AVIVO_DC_CRTC_TV_CONTROL, state->crtc_tv_control);
+    OUTREG(AVIVO_DC_LB_MEMORY_SPLIT, state->dc_lb_memory_split);
+
+    /* Need fixing too ? */
+    OUTREG(AVIVO_D1CRTC_BLANK_CONTROL, state->crtc1.blank_control);
+    OUTREG(AVIVO_D2CRTC_BLANK_CONTROL, state->crtc2.blank_control);
+
+    /* Dbl check */
     OUTREG(AVIVO_D1VGA_CONTROL, state->vga1_cntl);
     OUTREG(AVIVO_D2VGA_CONTROL, state->vga2_cntl);
+
+    /* Should only enable outputs here */
 }
 
 static void avivo_restore_vga_regs(ScrnInfoPtr pScrn, RADEONSavePtr restore)
@@ -5045,7 +5129,7 @@ Bool RADEONSwitchMode(int scrnIndex, DisplayModePtr mode, int flags)
     Bool           tilingOld   = info->tilingEnabled;
     Bool           ret;
 #ifdef XF86DRI
-    Bool           CPStarted   = info->CPStarted;
+    Bool           CPStarted   = info->cp->CPStarted;
 
     if (CPStarted) {
 	DRILock(pScrn->pScreen, 0);
@@ -5060,7 +5144,7 @@ Bool RADEONSwitchMode(int scrnIndex, DisplayModePtr mode, int flags)
         info->tilingEnabled = (mode->Flags & (V_DBLSCAN | V_INTERLACE)) ? FALSE : TRUE;
 #ifdef XF86DRI	
 	if (info->directRenderingEnabled && (info->tilingEnabled != tilingOld)) {
-	    RADEONSAREAPrivPtr pSAREAPriv;
+	    drm_radeon_sarea_t *pSAREAPriv;
 	  if (RADEONDRISetParam(pScrn, RADEON_SETPARAM_SWITCH_TILING, (info->tilingEnabled ? 1 : 0)) < 0)
   	      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 			 "[drm] failed changing tiling status\n");
@@ -5170,7 +5254,7 @@ void RADEONDoAdjustFrame(ScrnInfoPtr pScrn, int x, int y, Bool crtc2)
     unsigned char *RADEONMMIO = info->MMIO;
     int            Base, reg, regcntl, crtcoffsetcntl, xytilereg, crtcxytile = 0;
 #ifdef XF86DRI
-    RADEONSAREAPrivPtr pSAREAPriv;
+    drm_radeon_sarea_t *pSAREAPriv;
     XF86DRISAREAPtr pSAREA;
 #endif
 
@@ -5209,7 +5293,7 @@ void RADEONDoAdjustFrame(ScrnInfoPtr pScrn, int x, int y, Bool crtc2)
 #if 0
     /* try to get rid of flickering when scrolling at least for 2d */
 #ifdef XF86DRI
-    if (!info->have3DWindows)
+    if (!info->dri->have3DWindows)
 #endif
     crtcoffsetcntl &= ~RADEON_CRTC_OFFSET_FLIP_CNTL;
 #endif
@@ -5266,7 +5350,7 @@ void RADEONDoAdjustFrame(ScrnInfoPtr pScrn, int x, int y, Bool crtc2)
 	}
 
 	if (pSAREAPriv->pfCurrentPage == 1) {
-	    Base += info->backOffset - info->frontOffset;
+	    Base += info->dri->backOffset - info->dri->frontOffset;
 	}
     }
 #endif
@@ -5290,7 +5374,7 @@ void RADEONAdjustFrame(int scrnIndex, int x, int y, int flags)
     xf86CrtcPtr	crtc = output->crtc;
 
 #ifdef XF86DRI
-    if (info->CPStarted && pScrn->pScreen) DRILock(pScrn->pScreen, 0);
+    if (info->cp->CPStarted && pScrn->pScreen) DRILock(pScrn->pScreen, 0);
 #endif
 
     if (info->accelOn)
@@ -5307,7 +5391,7 @@ void RADEONAdjustFrame(int scrnIndex, int x, int y, int flags)
 
 
 #ifdef XF86DRI
-	if (info->CPStarted && pScrn->pScreen) DRIUnlock(pScrn->pScreen);
+	if (info->cp->CPStarted && pScrn->pScreen) DRIUnlock(pScrn->pScreen);
 #endif
 }
 
@@ -5318,26 +5402,18 @@ Bool RADEONEnterVT(int scrnIndex, int flags)
 {
     ScrnInfoPtr    pScrn = xf86Screens[scrnIndex];
     RADEONInfoPtr  info  = RADEONPTR(pScrn);
-    unsigned char *RADEONMMIO = info->MMIO;
-    uint32_t mem_size;
     xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(pScrn);
     int i;
 
     xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
 		   "RADEONEnterVT\n");
 
-    if (info->ChipFamily >= CHIP_FAMILY_R600)
-	mem_size = INREG(R600_CONFIG_MEMSIZE);
-    else
-	mem_size = INREG(RADEON_CONFIG_MEMSIZE);
-
-    if (mem_size == 0) { /* Softboot V_BIOS */
+    if (!radeon_card_posted(pScrn)) { /* Softboot V_BIOS */
 	if (info->IsAtomBios) {
 	    rhdAtomASICInit(info->atomBIOS);
 	} else {
 	    xf86Int10InfoPtr pInt;
-	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-		       "zero MEMSIZE, probably at D3cold. Re-POSTing via int10.\n");
+
 	    pInt = xf86InitInt10 (info->pEnt->index);
 	    if (pInt) {
 		pInt->num = 0xe6;
@@ -5382,10 +5458,10 @@ Bool RADEONEnterVT(int scrnIndex, int flags)
 #ifdef XF86DRI
     if (info->directRenderingEnabled) {
     	if (info->cardType == CARD_PCIE &&
-	    info->pKernelDRMVersion->version_minor >= 19 &&
+	    info->dri->pKernelDRMVersion->version_minor >= 19 &&
 	    info->FbSecureSize) {
 	    /* we need to backup the PCIE GART TABLE from fb memory */
-	    memcpy(info->FB + info->pciGartOffset, info->pciGartBackup, info->pciGartSize);
+	    memcpy(info->FB + info->dri->pciGartOffset, info->dri->pciGartBackup, info->dri->pciGartSize);
     	}
 
 	/* get the DRI back into shape after resume */
@@ -5433,18 +5509,18 @@ void RADEONLeaveVT(int scrnIndex, int flags)
 	RADEONCP_STOP(pScrn, info);
 
         if (info->cardType == CARD_PCIE &&
-	    info->pKernelDRMVersion->version_minor >= 19 &&
+	    info->dri->pKernelDRMVersion->version_minor >= 19 &&
 	    info->FbSecureSize) {
             /* we need to backup the PCIE GART TABLE from fb memory */
-            memcpy(info->pciGartBackup, (info->FB + info->pciGartOffset), info->pciGartSize);
+            memcpy(info->dri->pciGartBackup, (info->FB + info->dri->pciGartOffset), info->dri->pciGartSize);
         }
 
 	/* Make sure 3D clients will re-upload textures to video RAM */
-	if (info->textureSize) {
-	    RADEONSAREAPrivPtr pSAREAPriv =
-		(RADEONSAREAPrivPtr)DRIGetSAREAPrivate(pScrn->pScreen);
-	    drmTextureRegionPtr list = pSAREAPriv->texList[0];
-	    int age = ++pSAREAPriv->texAge[0];
+	if (info->dri->textureSize) {
+	    drm_radeon_sarea_t *pSAREAPriv =
+		(drm_radeon_sarea_t*)DRIGetSAREAPrivate(pScrn->pScreen);
+	    drmTextureRegionPtr list = pSAREAPriv->tex_list[0];
+	    int age = ++pSAREAPriv->tex_age[0];
 
 	    i = 0;
 
@@ -5501,12 +5577,12 @@ static Bool RADEONCloseScreen(int scrnIndex, ScreenPtr pScreen)
 
 #ifdef XF86DRI
 #ifdef DAMAGE
-    if (info->pDamage) {
+    if (info->dri && info->dri->pDamage) {
 	PixmapPtr pPix = pScreen->GetScreenPixmap(pScreen);
 
-	DamageUnregister(&pPix->drawable, info->pDamage);
-	DamageDestroy(info->pDamage);
-	info->pDamage = NULL;
+	DamageUnregister(&pPix->drawable, info->dri->pDamage);
+	DamageDestroy(info->dri->pDamage);
+	info->dri->pDamage = NULL;
     }
 #endif
 
@@ -5514,9 +5590,9 @@ static Bool RADEONCloseScreen(int scrnIndex, ScreenPtr pScreen)
 #endif
 
 #ifdef USE_XAA
-    if(!info->useEXA && info->RenderTex) {
-        xf86FreeOffscreenLinear(info->RenderTex);
-        info->RenderTex = NULL;
+    if(!info->useEXA && info->accel_state->RenderTex) {
+        xf86FreeOffscreenLinear(info->accel_state->RenderTex);
+        info->accel_state->RenderTex = NULL;
     }
 #endif /* USE_XAA */
 
@@ -5527,21 +5603,21 @@ static Bool RADEONCloseScreen(int scrnIndex, ScreenPtr pScreen)
     xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
 		   "Disposing accel...\n");
 #ifdef USE_EXA
-    if (info->exa) {
+    if (info->accel_state->exa) {
 	exaDriverFini(pScreen);
-	xfree(info->exa);
-	info->exa = NULL;
+	xfree(info->accel_state->exa);
+	info->accel_state->exa = NULL;
     }
 #endif /* USE_EXA */
 #ifdef USE_XAA
     if (!info->useEXA) {
-	if (info->accel)
-		XAADestroyInfoRec(info->accel);
-	info->accel = NULL;
+	if (info->accel_state->accel)
+		XAADestroyInfoRec(info->accel_state->accel);
+	info->accel_state->accel = NULL;
 
-	if (info->scratch_save)
-	    xfree(info->scratch_save);
-	info->scratch_save = NULL;
+	if (info->accel_state->scratch_save)
+	    xfree(info->accel_state->scratch_save);
+	info->accel_state->scratch_save = NULL;
     }
 #endif /* USE_XAA */
 
diff --git a/src/radeon_drm.h b/src/radeon_drm.h
new file mode 100644
index 0000000..c0d566c
--- /dev/null
+++ b/src/radeon_drm.h
@@ -0,0 +1,755 @@
+/* radeon_drm.h -- Public header for the radeon driver -*- linux-c -*-
+ *
+ * Copyright 2000 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Fremont, California.
+ * Copyright 2002 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Kevin E. Martin <martin@valinux.com>
+ *    Gareth Hughes <gareth@valinux.com>
+ *    Keith Whitwell <keith@tungstengraphics.com>
+ */
+
+#ifndef __RADEON_DRM_H__
+#define __RADEON_DRM_H__
+
+/* WARNING: If you change any of these defines, make sure to change the
+ * defines in the X server file (radeon_sarea.h)
+ */
+#ifndef __RADEON_SAREA_DEFINES__
+#define __RADEON_SAREA_DEFINES__
+
+/* Old style state flags, required for sarea interface (1.1 and 1.2
+ * clears) and 1.2 drm_vertex2 ioctl.
+ */
+#define RADEON_UPLOAD_CONTEXT		0x00000001
+#define RADEON_UPLOAD_VERTFMT		0x00000002
+#define RADEON_UPLOAD_LINE		0x00000004
+#define RADEON_UPLOAD_BUMPMAP		0x00000008
+#define RADEON_UPLOAD_MASKS		0x00000010
+#define RADEON_UPLOAD_VIEWPORT		0x00000020
+#define RADEON_UPLOAD_SETUP		0x00000040
+#define RADEON_UPLOAD_TCL		0x00000080
+#define RADEON_UPLOAD_MISC		0x00000100
+#define RADEON_UPLOAD_TEX0		0x00000200
+#define RADEON_UPLOAD_TEX1		0x00000400
+#define RADEON_UPLOAD_TEX2		0x00000800
+#define RADEON_UPLOAD_TEX0IMAGES	0x00001000
+#define RADEON_UPLOAD_TEX1IMAGES	0x00002000
+#define RADEON_UPLOAD_TEX2IMAGES	0x00004000
+#define RADEON_UPLOAD_CLIPRECTS		0x00008000	/* handled client-side */
+#define RADEON_REQUIRE_QUIESCENCE	0x00010000
+#define RADEON_UPLOAD_ZBIAS		0x00020000	/* version 1.2 and newer */
+#define RADEON_UPLOAD_ALL		0x003effff
+#define RADEON_UPLOAD_CONTEXT_ALL       0x003e01ff
+
+/* New style per-packet identifiers for use in cmd_buffer ioctl with
+ * the RADEON_EMIT_PACKET command.  Comments relate new packets to old
+ * state bits and the packet size:
+ */
+#define RADEON_EMIT_PP_MISC                         0	/* context/7 */
+#define RADEON_EMIT_PP_CNTL                         1	/* context/3 */
+#define RADEON_EMIT_RB3D_COLORPITCH                 2	/* context/1 */
+#define RADEON_EMIT_RE_LINE_PATTERN                 3	/* line/2 */
+#define RADEON_EMIT_SE_LINE_WIDTH                   4	/* line/1 */
+#define RADEON_EMIT_PP_LUM_MATRIX                   5	/* bumpmap/1 */
+#define RADEON_EMIT_PP_ROT_MATRIX_0                 6	/* bumpmap/2 */
+#define RADEON_EMIT_RB3D_STENCILREFMASK             7	/* masks/3 */
+#define RADEON_EMIT_SE_VPORT_XSCALE                 8	/* viewport/6 */
+#define RADEON_EMIT_SE_CNTL                         9	/* setup/2 */
+#define RADEON_EMIT_SE_CNTL_STATUS                  10	/* setup/1 */
+#define RADEON_EMIT_RE_MISC                         11	/* misc/1 */
+#define RADEON_EMIT_PP_TXFILTER_0                   12	/* tex0/6 */
+#define RADEON_EMIT_PP_BORDER_COLOR_0               13	/* tex0/1 */
+#define RADEON_EMIT_PP_TXFILTER_1                   14	/* tex1/6 */
+#define RADEON_EMIT_PP_BORDER_COLOR_1               15	/* tex1/1 */
+#define RADEON_EMIT_PP_TXFILTER_2                   16	/* tex2/6 */
+#define RADEON_EMIT_PP_BORDER_COLOR_2               17	/* tex2/1 */
+#define RADEON_EMIT_SE_ZBIAS_FACTOR                 18	/* zbias/2 */
+#define RADEON_EMIT_SE_TCL_OUTPUT_VTX_FMT           19	/* tcl/11 */
+#define RADEON_EMIT_SE_TCL_MATERIAL_EMMISSIVE_RED   20	/* material/17 */
+#define R200_EMIT_PP_TXCBLEND_0                     21	/* tex0/4 */
+#define R200_EMIT_PP_TXCBLEND_1                     22	/* tex1/4 */
+#define R200_EMIT_PP_TXCBLEND_2                     23	/* tex2/4 */
+#define R200_EMIT_PP_TXCBLEND_3                     24	/* tex3/4 */
+#define R200_EMIT_PP_TXCBLEND_4                     25	/* tex4/4 */
+#define R200_EMIT_PP_TXCBLEND_5                     26	/* tex5/4 */
+#define R200_EMIT_PP_TXCBLEND_6                     27	/* /4 */
+#define R200_EMIT_PP_TXCBLEND_7                     28	/* /4 */
+#define R200_EMIT_TCL_LIGHT_MODEL_CTL_0             29	/* tcl/7 */
+#define R200_EMIT_TFACTOR_0                         30	/* tf/7 */
+#define R200_EMIT_VTX_FMT_0                         31	/* vtx/5 */
+#define R200_EMIT_VAP_CTL                           32	/* vap/1 */
+#define R200_EMIT_MATRIX_SELECT_0                   33	/* msl/5 */
+#define R200_EMIT_TEX_PROC_CTL_2                    34	/* tcg/5 */
+#define R200_EMIT_TCL_UCP_VERT_BLEND_CTL            35	/* tcl/1 */
+#define R200_EMIT_PP_TXFILTER_0                     36	/* tex0/6 */
+#define R200_EMIT_PP_TXFILTER_1                     37	/* tex1/6 */
+#define R200_EMIT_PP_TXFILTER_2                     38	/* tex2/6 */
+#define R200_EMIT_PP_TXFILTER_3                     39	/* tex3/6 */
+#define R200_EMIT_PP_TXFILTER_4                     40	/* tex4/6 */
+#define R200_EMIT_PP_TXFILTER_5                     41	/* tex5/6 */
+#define R200_EMIT_PP_TXOFFSET_0                     42	/* tex0/1 */
+#define R200_EMIT_PP_TXOFFSET_1                     43	/* tex1/1 */
+#define R200_EMIT_PP_TXOFFSET_2                     44	/* tex2/1 */
+#define R200_EMIT_PP_TXOFFSET_3                     45	/* tex3/1 */
+#define R200_EMIT_PP_TXOFFSET_4                     46	/* tex4/1 */
+#define R200_EMIT_PP_TXOFFSET_5                     47	/* tex5/1 */
+#define R200_EMIT_VTE_CNTL                          48	/* vte/1 */
+#define R200_EMIT_OUTPUT_VTX_COMP_SEL               49	/* vtx/1 */
+#define R200_EMIT_PP_TAM_DEBUG3                     50	/* tam/1 */
+#define R200_EMIT_PP_CNTL_X                         51	/* cst/1 */
+#define R200_EMIT_RB3D_DEPTHXY_OFFSET               52	/* cst/1 */
+#define R200_EMIT_RE_AUX_SCISSOR_CNTL               53	/* cst/1 */
+#define R200_EMIT_RE_SCISSOR_TL_0                   54	/* cst/2 */
+#define R200_EMIT_RE_SCISSOR_TL_1                   55	/* cst/2 */
+#define R200_EMIT_RE_SCISSOR_TL_2                   56	/* cst/2 */
+#define R200_EMIT_SE_VAP_CNTL_STATUS                57	/* cst/1 */
+#define R200_EMIT_SE_VTX_STATE_CNTL                 58	/* cst/1 */
+#define R200_EMIT_RE_POINTSIZE                      59	/* cst/1 */
+#define R200_EMIT_TCL_INPUT_VTX_VECTOR_ADDR_0       60	/* cst/4 */
+#define R200_EMIT_PP_CUBIC_FACES_0                  61
+#define R200_EMIT_PP_CUBIC_OFFSETS_0                62
+#define R200_EMIT_PP_CUBIC_FACES_1                  63
+#define R200_EMIT_PP_CUBIC_OFFSETS_1                64
+#define R200_EMIT_PP_CUBIC_FACES_2                  65
+#define R200_EMIT_PP_CUBIC_OFFSETS_2                66
+#define R200_EMIT_PP_CUBIC_FACES_3                  67
+#define R200_EMIT_PP_CUBIC_OFFSETS_3                68
+#define R200_EMIT_PP_CUBIC_FACES_4                  69
+#define R200_EMIT_PP_CUBIC_OFFSETS_4                70
+#define R200_EMIT_PP_CUBIC_FACES_5                  71
+#define R200_EMIT_PP_CUBIC_OFFSETS_5                72
+#define RADEON_EMIT_PP_TEX_SIZE_0                   73
+#define RADEON_EMIT_PP_TEX_SIZE_1                   74
+#define RADEON_EMIT_PP_TEX_SIZE_2                   75
+#define R200_EMIT_RB3D_BLENDCOLOR                   76
+#define R200_EMIT_TCL_POINT_SPRITE_CNTL             77
+#define RADEON_EMIT_PP_CUBIC_FACES_0                78
+#define RADEON_EMIT_PP_CUBIC_OFFSETS_T0             79
+#define RADEON_EMIT_PP_CUBIC_FACES_1                80
+#define RADEON_EMIT_PP_CUBIC_OFFSETS_T1             81
+#define RADEON_EMIT_PP_CUBIC_FACES_2                82
+#define RADEON_EMIT_PP_CUBIC_OFFSETS_T2             83
+#define R200_EMIT_PP_TRI_PERF_CNTL                  84
+#define R200_EMIT_PP_AFS_0                          85
+#define R200_EMIT_PP_AFS_1                          86
+#define R200_EMIT_ATF_TFACTOR                       87
+#define R200_EMIT_PP_TXCTLALL_0                     88
+#define R200_EMIT_PP_TXCTLALL_1                     89
+#define R200_EMIT_PP_TXCTLALL_2                     90
+#define R200_EMIT_PP_TXCTLALL_3                     91
+#define R200_EMIT_PP_TXCTLALL_4                     92
+#define R200_EMIT_PP_TXCTLALL_5                     93
+#define R200_EMIT_VAP_PVS_CNTL                      94
+#define RADEON_MAX_STATE_PACKETS                    95
+
+/* Commands understood by cmd_buffer ioctl.  More can be added but
+ * obviously these can't be removed or changed:
+ */
+#define RADEON_CMD_PACKET      1	/* emit one of the register packets above */
+#define RADEON_CMD_SCALARS     2	/* emit scalar data */
+#define RADEON_CMD_VECTORS     3	/* emit vector data */
+#define RADEON_CMD_DMA_DISCARD 4	/* discard current dma buf */
+#define RADEON_CMD_PACKET3     5	/* emit hw packet */
+#define RADEON_CMD_PACKET3_CLIP 6	/* emit hw packet wrapped in cliprects */
+#define RADEON_CMD_SCALARS2     7	/* r200 stopgap */
+#define RADEON_CMD_WAIT         8	/* emit hw wait commands -- note:
+					 *  doesn't make the cpu wait, just
+					 *  the graphics hardware */
+#define RADEON_CMD_VECLINEAR	9       /* another r200 stopgap */
+
+typedef union {
+	int i;
+	struct {
+		unsigned char cmd_type, pad0, pad1, pad2;
+	} header;
+	struct {
+		unsigned char cmd_type, packet_id, pad0, pad1;
+	} packet;
+	struct {
+		unsigned char cmd_type, offset, stride, count;
+	} scalars;
+	struct {
+		unsigned char cmd_type, offset, stride, count;
+	} vectors;
+	struct {
+		unsigned char cmd_type, addr_lo, addr_hi, count;
+	} veclinear;
+	struct {
+		unsigned char cmd_type, buf_idx, pad0, pad1;
+	} dma;
+	struct {
+		unsigned char cmd_type, flags, pad0, pad1;
+	} wait;
+} drm_radeon_cmd_header_t;
+
+#define RADEON_WAIT_2D  0x1
+#define RADEON_WAIT_3D  0x2
+
+/* Allowed parameters for R300_CMD_PACKET3
+ */
+#define R300_CMD_PACKET3_CLEAR		0
+#define R300_CMD_PACKET3_RAW		1
+
+/* Commands understood by cmd_buffer ioctl for R300.
+ * The interface has not been stabilized, so some of these may be removed
+ * and eventually reordered before stabilization.
+ */
+#define R300_CMD_PACKET0		1
+#define R300_CMD_VPU			2	/* emit vertex program upload */
+#define R300_CMD_PACKET3		3	/* emit a packet3 */
+#define R300_CMD_END3D			4	/* emit sequence ending 3d rendering */
+#define R300_CMD_CP_DELAY		5
+#define R300_CMD_DMA_DISCARD		6
+#define R300_CMD_WAIT			7
+#	define R300_WAIT_2D		0x1
+#	define R300_WAIT_3D		0x2
+/* these two defines are DOING IT WRONG - however
+ * we have userspace which relies on using these.
+ * The wait interface is backwards compat new 
+ * code should use the NEW_WAIT defines below
+ * THESE ARE NOT BIT FIELDS
+ */
+#	define R300_WAIT_2D_CLEAN	0x3
+#	define R300_WAIT_3D_CLEAN	0x4
+
+#	define R300_NEW_WAIT_2D_3D	0x3
+#	define R300_NEW_WAIT_2D_2D_CLEAN	0x4
+#	define R300_NEW_WAIT_3D_3D_CLEAN	0x6
+#	define R300_NEW_WAIT_2D_2D_CLEAN_3D_3D_CLEAN	0x8
+
+#define R300_CMD_SCRATCH		8
+#define R300_CMD_R500FP                 9
+
+typedef union {
+	unsigned int u;
+	struct {
+		unsigned char cmd_type, pad0, pad1, pad2;
+	} header;
+	struct {
+		unsigned char cmd_type, count, reglo, reghi;
+	} packet0;
+	struct {
+		unsigned char cmd_type, count, adrlo, adrhi;
+	} vpu;
+	struct {
+		unsigned char cmd_type, packet, pad0, pad1;
+	} packet3;
+	struct {
+		unsigned char cmd_type, packet;
+		unsigned short count;	/* amount of packet2 to emit */
+	} delay;
+	struct {
+		unsigned char cmd_type, buf_idx, pad0, pad1;
+	} dma;
+	struct {
+		unsigned char cmd_type, flags, pad0, pad1;
+	} wait;
+	struct {
+		unsigned char cmd_type, reg, n_bufs, flags;
+	} scratch;
+	struct {
+		unsigned char cmd_type, count, adrlo, adrhi_flags;
+	} r500fp;
+} drm_r300_cmd_header_t;
+
+#define RADEON_FRONT			0x1
+#define RADEON_BACK			0x2
+#define RADEON_DEPTH			0x4
+#define RADEON_STENCIL			0x8
+#define RADEON_CLEAR_FASTZ		0x80000000
+#define RADEON_USE_HIERZ		0x40000000
+#define RADEON_USE_COMP_ZBUF		0x20000000
+
+#define R500FP_CONSTANT_TYPE  (1 << 1)
+#define R500FP_CONSTANT_CLAMP (1 << 2)
+
+/* Primitive types
+ */
+#define RADEON_POINTS			0x1
+#define RADEON_LINES			0x2
+#define RADEON_LINE_STRIP		0x3
+#define RADEON_TRIANGLES		0x4
+#define RADEON_TRIANGLE_FAN		0x5
+#define RADEON_TRIANGLE_STRIP		0x6
+
+/* Vertex/indirect buffer size
+ */
+#define RADEON_BUFFER_SIZE		65536
+
+/* Byte offsets for indirect buffer data
+ */
+#define RADEON_INDEX_PRIM_OFFSET	20
+
+#define RADEON_SCRATCH_REG_OFFSET	32
+#define R600_SCRATCH_REG_OFFSET	        256
+
+#define RADEON_NR_SAREA_CLIPRECTS	12
+
+/* There are 2 heaps (local/GART).  Each region within a heap is a
+ * minimum of 64k, and there are at most 64 of them per heap.
+ */
+#define RADEON_LOCAL_TEX_HEAP		0
+#define RADEON_GART_TEX_HEAP		1
+#define RADEON_NR_TEX_HEAPS		2
+#define RADEON_NR_TEX_REGIONS		64
+#define RADEON_LOG_TEX_GRANULARITY	16
+
+#define RADEON_MAX_TEXTURE_LEVELS	12
+#define RADEON_MAX_TEXTURE_UNITS	3
+
+#define RADEON_MAX_SURFACES		8
+
+/* Blits have strict offset rules.  All blit offset must be aligned on
+ * a 1K-byte boundary.
+ */
+#define RADEON_OFFSET_SHIFT             10
+#define RADEON_OFFSET_ALIGN             (1 << RADEON_OFFSET_SHIFT)
+#define RADEON_OFFSET_MASK              (RADEON_OFFSET_ALIGN - 1)
+
+#endif				/* __RADEON_SAREA_DEFINES__ */
+
+typedef struct {
+	unsigned int red;
+	unsigned int green;
+	unsigned int blue;
+	unsigned int alpha;
+} radeon_color_regs_t;
+
+typedef struct {
+	/* Context state */
+	unsigned int pp_misc;	/* 0x1c14 */
+	unsigned int pp_fog_color;
+	unsigned int re_solid_color;
+	unsigned int rb3d_blendcntl;
+	unsigned int rb3d_depthoffset;
+	unsigned int rb3d_depthpitch;
+	unsigned int rb3d_zstencilcntl;
+
+	unsigned int pp_cntl;	/* 0x1c38 */
+	unsigned int rb3d_cntl;
+	unsigned int rb3d_coloroffset;
+	unsigned int re_width_height;
+	unsigned int rb3d_colorpitch;
+	unsigned int se_cntl;
+
+	/* Vertex format state */
+	unsigned int se_coord_fmt;	/* 0x1c50 */
+
+	/* Line state */
+	unsigned int re_line_pattern;	/* 0x1cd0 */
+	unsigned int re_line_state;
+
+	unsigned int se_line_width;	/* 0x1db8 */
+
+	/* Bumpmap state */
+	unsigned int pp_lum_matrix;	/* 0x1d00 */
+
+	unsigned int pp_rot_matrix_0;	/* 0x1d58 */
+	unsigned int pp_rot_matrix_1;
+
+	/* Mask state */
+	unsigned int rb3d_stencilrefmask;	/* 0x1d7c */
+	unsigned int rb3d_ropcntl;
+	unsigned int rb3d_planemask;
+
+	/* Viewport state */
+	unsigned int se_vport_xscale;	/* 0x1d98 */
+	unsigned int se_vport_xoffset;
+	unsigned int se_vport_yscale;
+	unsigned int se_vport_yoffset;
+	unsigned int se_vport_zscale;
+	unsigned int se_vport_zoffset;
+
+	/* Setup state */
+	unsigned int se_cntl_status;	/* 0x2140 */
+
+	/* Misc state */
+	unsigned int re_top_left;	/* 0x26c0 */
+	unsigned int re_misc;
+} drm_radeon_context_regs_t;
+
+typedef struct {
+	/* Zbias state */
+	unsigned int se_zbias_factor;	/* 0x1dac */
+	unsigned int se_zbias_constant;
+} drm_radeon_context2_regs_t;
+
+/* Setup registers for each texture unit
+ */
+typedef struct {
+	unsigned int pp_txfilter;
+	unsigned int pp_txformat;
+	unsigned int pp_txoffset;
+	unsigned int pp_txcblend;
+	unsigned int pp_txablend;
+	unsigned int pp_tfactor;
+	unsigned int pp_border_color;
+} drm_radeon_texture_regs_t;
+
+typedef struct {
+	unsigned int start;
+	unsigned int finish;
+	unsigned int prim:8;
+	unsigned int stateidx:8;
+	unsigned int numverts:16;	/* overloaded as offset/64 for elt prims */
+	unsigned int vc_format;	/* vertex format */
+} drm_radeon_prim_t;
+
+typedef struct {
+	drm_radeon_context_regs_t context;
+	drm_radeon_texture_regs_t tex[RADEON_MAX_TEXTURE_UNITS];
+	drm_radeon_context2_regs_t context2;
+	unsigned int dirty;
+} drm_radeon_state_t;
+
+typedef struct {
+	/* The channel for communication of state information to the
+	 * kernel on firing a vertex buffer with either of the
+	 * obsoleted vertex/index ioctls.
+	 */
+	drm_radeon_context_regs_t context_state;
+	drm_radeon_texture_regs_t tex_state[RADEON_MAX_TEXTURE_UNITS];
+	unsigned int dirty;
+	unsigned int vertsize;
+	unsigned int vc_format;
+
+	/* The current cliprects, or a subset thereof.
+	 */
+	struct drm_clip_rect boxes[RADEON_NR_SAREA_CLIPRECTS];
+	unsigned int nbox;
+
+	/* Counters for client-side throttling of rendering clients.
+	 */
+	unsigned int last_frame;
+	unsigned int last_dispatch;
+	unsigned int last_clear;
+
+	struct drm_tex_region tex_list[RADEON_NR_TEX_HEAPS][RADEON_NR_TEX_REGIONS +
+						       1];
+	unsigned int tex_age[RADEON_NR_TEX_HEAPS];
+	int ctx_owner;
+	int pfState;		/* number of 3d windows (0,1,2ormore) */
+	int pfCurrentPage;	/* which buffer is being displayed? */
+	int crtc2_base;		/* CRTC2 frame offset */
+	int tiling_enabled;	/* set by drm, read by 2d + 3d clients */
+} drm_radeon_sarea_t;
+
+/* WARNING: If you change any of these defines, make sure to change the
+ * defines in the Xserver file (xf86drmRadeon.h)
+ *
+ * KW: actually it's illegal to change any of this (backwards compatibility).
+ */
+
+/* Radeon specific ioctls
+ * The device specific ioctl range is 0x40 to 0x79.
+ */
+#define DRM_RADEON_CP_INIT    0x00
+#define DRM_RADEON_CP_START   0x01
+#define DRM_RADEON_CP_STOP    0x02
+#define DRM_RADEON_CP_RESET   0x03
+#define DRM_RADEON_CP_IDLE    0x04
+#define DRM_RADEON_RESET      0x05
+#define DRM_RADEON_FULLSCREEN 0x06
+#define DRM_RADEON_SWAP       0x07
+#define DRM_RADEON_CLEAR      0x08
+#define DRM_RADEON_VERTEX     0x09
+#define DRM_RADEON_INDICES    0x0A
+#define DRM_RADEON_NOT_USED
+#define DRM_RADEON_STIPPLE    0x0C
+#define DRM_RADEON_INDIRECT   0x0D
+#define DRM_RADEON_TEXTURE    0x0E
+#define DRM_RADEON_VERTEX2    0x0F
+#define DRM_RADEON_CMDBUF     0x10
+#define DRM_RADEON_GETPARAM   0x11
+#define DRM_RADEON_FLIP       0x12
+#define DRM_RADEON_ALLOC      0x13
+#define DRM_RADEON_FREE       0x14
+#define DRM_RADEON_INIT_HEAP  0x15
+#define DRM_RADEON_IRQ_EMIT   0x16
+#define DRM_RADEON_IRQ_WAIT   0x17
+#define DRM_RADEON_CP_RESUME  0x18
+#define DRM_RADEON_SETPARAM   0x19
+#define DRM_RADEON_SURF_ALLOC 0x1a
+#define DRM_RADEON_SURF_FREE  0x1b
+
+#define DRM_IOCTL_RADEON_CP_INIT    DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_CP_INIT, drm_radeon_init_t)
+#define DRM_IOCTL_RADEON_CP_START   DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_CP_START)
+#define DRM_IOCTL_RADEON_CP_STOP    DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_CP_STOP, drm_radeon_cp_stop_t)
+#define DRM_IOCTL_RADEON_CP_RESET   DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_CP_RESET)
+#define DRM_IOCTL_RADEON_CP_IDLE    DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_CP_IDLE)
+#define DRM_IOCTL_RADEON_RESET      DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_RESET)
+#define DRM_IOCTL_RADEON_FULLSCREEN DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_FULLSCREEN, drm_radeon_fullscreen_t)
+#define DRM_IOCTL_RADEON_SWAP       DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_SWAP)
+#define DRM_IOCTL_RADEON_CLEAR      DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_CLEAR, drm_radeon_clear_t)
+#define DRM_IOCTL_RADEON_VERTEX     DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_VERTEX, drm_radeon_vertex_t)
+#define DRM_IOCTL_RADEON_INDICES    DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_INDICES, drm_radeon_indices_t)
+#define DRM_IOCTL_RADEON_STIPPLE    DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_STIPPLE, drm_radeon_stipple_t)
+#define DRM_IOCTL_RADEON_INDIRECT   DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_INDIRECT, drm_radeon_indirect_t)
+#define DRM_IOCTL_RADEON_TEXTURE    DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_TEXTURE, drm_radeon_texture_t)
+#define DRM_IOCTL_RADEON_VERTEX2    DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_VERTEX2, drm_radeon_vertex2_t)
+#define DRM_IOCTL_RADEON_CMDBUF     DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_CMDBUF, drm_radeon_cmd_buffer_t)
+#define DRM_IOCTL_RADEON_GETPARAM   DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GETPARAM, drm_radeon_getparam_t)
+#define DRM_IOCTL_RADEON_FLIP       DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_FLIP)
+#define DRM_IOCTL_RADEON_ALLOC      DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_ALLOC, drm_radeon_mem_alloc_t)
+#define DRM_IOCTL_RADEON_FREE       DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_FREE, drm_radeon_mem_free_t)
+#define DRM_IOCTL_RADEON_INIT_HEAP  DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_INIT_HEAP, drm_radeon_mem_init_heap_t)
+#define DRM_IOCTL_RADEON_IRQ_EMIT   DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_IRQ_EMIT, drm_radeon_irq_emit_t)
+#define DRM_IOCTL_RADEON_IRQ_WAIT   DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_IRQ_WAIT, drm_radeon_irq_wait_t)
+#define DRM_IOCTL_RADEON_CP_RESUME  DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_CP_RESUME)
+#define DRM_IOCTL_RADEON_SETPARAM   DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_SETPARAM, drm_radeon_setparam_t)
+#define DRM_IOCTL_RADEON_SURF_ALLOC DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_SURF_ALLOC, drm_radeon_surface_alloc_t)
+#define DRM_IOCTL_RADEON_SURF_FREE  DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_SURF_FREE, drm_radeon_surface_free_t)
+
+typedef struct drm_radeon_init {
+	enum {
+		RADEON_INIT_CP = 0x01,
+		RADEON_CLEANUP_CP = 0x02,
+		RADEON_INIT_R200_CP = 0x03,
+		RADEON_INIT_R300_CP = 0x04,
+		RADEON_INIT_R600_CP = 0x05,
+	} func;
+	unsigned long sarea_priv_offset;
+	int is_pci; /* for overriding only */
+	int cp_mode;
+	int gart_size;
+	int ring_size;
+	int usec_timeout;
+
+	unsigned int fb_bpp;
+	unsigned int front_offset, front_pitch;
+	unsigned int back_offset, back_pitch;
+	unsigned int depth_bpp;
+	unsigned int depth_offset, depth_pitch;
+
+	unsigned long fb_offset DEPRECATED;	/* deprecated, driver asks hardware */
+	unsigned long mmio_offset DEPRECATED;	/* deprecated, driver asks hardware */
+	unsigned long ring_offset;
+	unsigned long ring_rptr_offset;
+	unsigned long buffers_offset;
+	unsigned long gart_textures_offset;
+} drm_radeon_init_t;
+
+typedef struct drm_radeon_cp_stop {
+	int flush;
+	int idle;
+} drm_radeon_cp_stop_t;
+
+typedef struct drm_radeon_fullscreen {
+	enum {
+		RADEON_INIT_FULLSCREEN = 0x01,
+		RADEON_CLEANUP_FULLSCREEN = 0x02
+	} func;
+} drm_radeon_fullscreen_t;
+
+#define CLEAR_X1	0
+#define CLEAR_Y1	1
+#define CLEAR_X2	2
+#define CLEAR_Y2	3
+#define CLEAR_DEPTH	4
+
+typedef union drm_radeon_clear_rect {
+	float f[5];
+	unsigned int ui[5];
+} drm_radeon_clear_rect_t;
+
+typedef struct drm_radeon_clear {
+	unsigned int flags;
+	unsigned int clear_color;
+	unsigned int clear_depth;
+	unsigned int color_mask;
+	unsigned int depth_mask;	/* misnamed field:  should be stencil */
+	drm_radeon_clear_rect_t __user *depth_boxes;
+} drm_radeon_clear_t;
+
+typedef struct drm_radeon_vertex {
+	int prim;
+	int idx;		/* Index of vertex buffer */
+	int count;		/* Number of vertices in buffer */
+	int discard;		/* Client finished with buffer? */
+} drm_radeon_vertex_t;
+
+typedef struct drm_radeon_indices {
+	int prim;
+	int idx;
+	int start;
+	int end;
+	int discard;		/* Client finished with buffer? */
+} drm_radeon_indices_t;
+
+/* v1.2 - obsoletes drm_radeon_vertex and drm_radeon_indices
+ *      - allows multiple primitives and state changes in a single ioctl
+ *      - supports driver change to emit native primitives
+ */
+typedef struct drm_radeon_vertex2 {
+	int idx;		/* Index of vertex buffer */
+	int discard;		/* Client finished with buffer? */
+	int nr_states;
+	drm_radeon_state_t __user *state;
+	int nr_prims;
+	drm_radeon_prim_t __user *prim;
+} drm_radeon_vertex2_t;
+
+/* v1.3 - obsoletes drm_radeon_vertex2
+ *      - allows arbitarily large cliprect list
+ *      - allows updating of tcl packet, vector and scalar state
+ *      - allows memory-efficient description of state updates
+ *      - allows state to be emitted without a primitive
+ *           (for clears, ctx switches)
+ *      - allows more than one dma buffer to be referenced per ioctl
+ *      - supports tcl driver
+ *      - may be extended in future versions with new cmd types, packets
+ */
+typedef struct drm_radeon_cmd_buffer {
+	int bufsz;
+	char __user *buf;
+	int nbox;
+	struct drm_clip_rect __user *boxes;
+} drm_radeon_cmd_buffer_t;
+
+typedef struct drm_radeon_tex_image {
+	unsigned int x, y;	/* Blit coordinates */
+	unsigned int width, height;
+	const void __user *data;
+} drm_radeon_tex_image_t;
+
+typedef struct drm_radeon_texture {
+	unsigned int offset;
+	int pitch;
+	int format;
+	int width;		/* Texture image coordinates */
+	int height;
+	drm_radeon_tex_image_t __user *image;
+} drm_radeon_texture_t;
+
+typedef struct drm_radeon_stipple {
+	unsigned int __user *mask;
+} drm_radeon_stipple_t;
+
+typedef struct drm_radeon_indirect {
+	int idx;
+	int start;
+	int end;
+	int discard;
+} drm_radeon_indirect_t;
+
+#define RADEON_INDIRECT_DISCARD (1 << 0)
+#define RADEON_INDIRECT_NOFLUSH (1 << 1)
+
+/* enum for card type parameters */
+#define RADEON_CARD_PCI 0
+#define RADEON_CARD_AGP 1
+#define RADEON_CARD_PCIE 2
+
+/* 1.3: An ioctl to get parameters that aren't available to the 3d
+ * client any other way.
+ */
+#define RADEON_PARAM_GART_BUFFER_OFFSET    1	/* card offset of 1st GART buffer */
+#define RADEON_PARAM_LAST_FRAME            2
+#define RADEON_PARAM_LAST_DISPATCH         3
+#define RADEON_PARAM_LAST_CLEAR            4
+/* Added with DRM version 1.6. */
+#define RADEON_PARAM_IRQ_NR                5
+#define RADEON_PARAM_GART_BASE             6	/* card offset of GART base */
+/* Added with DRM version 1.8. */
+#define RADEON_PARAM_REGISTER_HANDLE       7	/* for drmMap() */
+#define RADEON_PARAM_STATUS_HANDLE         8
+#define RADEON_PARAM_SAREA_HANDLE          9
+#define RADEON_PARAM_GART_TEX_HANDLE       10
+#define RADEON_PARAM_SCRATCH_OFFSET        11
+#define RADEON_PARAM_CARD_TYPE             12
+#define RADEON_PARAM_VBLANK_CRTC           13   /* VBLANK CRTC */
+#define RADEON_PARAM_FB_LOCATION           14   /* FB location */
+#define RADEON_PARAM_NUM_GB_PIPES          15   /* num GB pipes */
+
+typedef struct drm_radeon_getparam {
+	int param;
+	void __user *value;
+} drm_radeon_getparam_t;
+
+/* 1.6: Set up a memory manager for regions of shared memory:
+ */
+#define RADEON_MEM_REGION_GART 1
+#define RADEON_MEM_REGION_FB   2
+
+typedef struct drm_radeon_mem_alloc {
+	int region;
+	int alignment;
+	int size;
+	int __user *region_offset;	/* offset from start of fb or GART */
+} drm_radeon_mem_alloc_t;
+
+typedef struct drm_radeon_mem_free {
+	int region;
+	int region_offset;
+} drm_radeon_mem_free_t;
+
+typedef struct drm_radeon_mem_init_heap {
+	int region;
+	int size;
+	int start;
+} drm_radeon_mem_init_heap_t;
+
+/* 1.6: Userspace can request & wait on irq's:
+ */
+typedef struct drm_radeon_irq_emit {
+	int __user *irq_seq;
+} drm_radeon_irq_emit_t;
+
+typedef struct drm_radeon_irq_wait {
+	int irq_seq;
+} drm_radeon_irq_wait_t;
+
+/* 1.10: Clients tell the DRM where they think the framebuffer is located in
+ * the card's address space, via a new generic ioctl to set parameters
+ */
+
+typedef struct drm_radeon_setparam {
+	unsigned int param;
+	int64_t value;
+} drm_radeon_setparam_t;
+
+#define RADEON_SETPARAM_FB_LOCATION    1	/* determined framebuffer location */
+#define RADEON_SETPARAM_SWITCH_TILING  2	/* enable/disable color tiling */
+#define RADEON_SETPARAM_PCIGART_LOCATION 3	/* PCI Gart Location */
+
+#define RADEON_SETPARAM_NEW_MEMMAP 4		/* Use new memory map */
+#define RADEON_SETPARAM_PCIGART_TABLE_SIZE 5    /* PCI GART Table Size */
+#define RADEON_SETPARAM_VBLANK_CRTC 6           /* VBLANK CRTC */
+/* 1.14: Clients can allocate/free a surface
+ */
+typedef struct drm_radeon_surface_alloc {
+	unsigned int address;
+	unsigned int size;
+	unsigned int flags;
+} drm_radeon_surface_alloc_t;
+
+typedef struct drm_radeon_surface_free {
+	unsigned int address;
+} drm_radeon_surface_free_t;
+
+#define	DRM_RADEON_VBLANK_CRTC1		1
+#define	DRM_RADEON_VBLANK_CRTC2		2
+
+#endif
diff --git a/src/radeon_exa.c b/src/radeon_exa.c
index f461f3c..0f86fdd 100644
--- a/src/radeon_exa.c
+++ b/src/radeon_exa.c
@@ -36,14 +36,11 @@
 #include "radeon.h"
 #include "radeon_reg.h"
 #ifdef XF86DRI
-#include "radeon_dri.h"
+#include "radeon_drm.h"
 #endif
 #include "radeon_macros.h"
 #include "radeon_probe.h"
 #include "radeon_version.h"
-#ifdef XF86DRI
-#include "radeon_sarea.h"
-#endif
 
 #include "xf86.h"
 
@@ -164,10 +161,10 @@ static Bool RADEONGetOffsetPitch(PixmapPtr pPix, int bpp, uint32_t *pitch_offset
 {
 	RINFO_FROM_SCREEN(pPix->drawable.pScreen);
 
-	if (pitch > 16320 || pitch % info->exa->pixmapPitchAlign != 0)
+	if (pitch > 16320 || pitch % info->accel_state->exa->pixmapPitchAlign != 0)
 		RADEON_FALLBACK(("Bad pitch 0x%08x\n", pitch));
 
-	if (offset % info->exa->pixmapOffsetAlign != 0)
+	if (offset % info->accel_state->exa->pixmapOffsetAlign != 0)
 		RADEON_FALLBACK(("Bad offset 0x%08x\n", offset));
 
 	pitch = pitch >> 6;
@@ -237,14 +234,14 @@ static Bool RADEONPrepareAccess(PixmapPtr pPix, int index)
     }
 #if defined(XF86DRI)
     if (info->directRenderingEnabled && info->allowColorTiling) {
-	drmRadeonSurfaceAlloc drmsurfalloc;
+	struct drm_radeon_surface_alloc drmsurfalloc;
 	int rc;
 
         drmsurfalloc.address = offset;
         drmsurfalloc.size = size;
 	drmsurfalloc.flags = flags | 1; /* bogus pitch to please DRM */
 
-        rc = drmCommandWrite(info->drmFD, DRM_RADEON_SURF_ALLOC,
+        rc = drmCommandWrite(info->dri->drmFD, DRM_RADEON_SURF_ALLOC,
 			     &drmsurfalloc, sizeof(drmsurfalloc));
 	if (rc < 0) {
 	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
@@ -280,10 +277,10 @@ static void RADEONFinishAccess(PixmapPtr pPix, int index)
         return;
 #if defined(XF86DRI)
     if (info->directRenderingEnabled && info->allowColorTiling) {
-	drmRadeonSurfaceFree drmsurffree;
+	struct drm_radeon_surface_free drmsurffree;
 
 	drmsurffree.address = offset;
-	drmCommandWrite(info->drmFD, DRM_RADEON_SURF_FREE,
+	drmCommandWrite(info->dri->drmFD, DRM_RADEON_SURF_FREE,
 			&drmsurffree, sizeof(drmsurffree));
 	swapper_surfaces[index] = 0;
 	return;
@@ -302,7 +299,7 @@ static void RADEONFinishAccess(PixmapPtr pPix, int index)
 do {									\
 	uint32_t wait_until = 0;			\
 	BEGIN_ACCEL(1);							\
-	switch (info->engineMode) {					\
+	switch (info->accel_state->engineMode) {			\
 	case EXA_ENGINEMODE_UNKNOWN:					\
 	    wait_until |= RADEON_WAIT_HOST_IDLECLEAN | RADEON_WAIT_2D_IDLECLEAN;	\
 	case EXA_ENGINEMODE_3D:						\
@@ -312,14 +309,14 @@ do {									\
 	}								\
 	OUT_ACCEL_REG(RADEON_WAIT_UNTIL, wait_until);			\
 	FINISH_ACCEL();							\
-        info->engineMode = EXA_ENGINEMODE_2D;                           \
+        info->accel_state->engineMode = EXA_ENGINEMODE_2D;              \
 } while (0);
 
 #define RADEON_SWITCH_TO_3D()						\
 do {									\
 	uint32_t wait_until = 0;			\
 	BEGIN_ACCEL(1);							\
-	switch (info->engineMode) {					\
+	switch (info->accel_state->engineMode) {			\
 	case EXA_ENGINEMODE_UNKNOWN:					\
 	    wait_until |= RADEON_WAIT_HOST_IDLECLEAN | RADEON_WAIT_3D_IDLECLEAN;	\
 	case EXA_ENGINEMODE_2D:						\
@@ -329,7 +326,7 @@ do {									\
 	}								\
 	OUT_ACCEL_REG(RADEON_WAIT_UNTIL, wait_until);			\
 	FINISH_ACCEL();							\
-        info->engineMode = EXA_ENGINEMODE_3D;                           \
+        info->accel_state->engineMode = EXA_ENGINEMODE_3D;              \
 } while (0);
 
 #define ENTER_DRAW(x) TRACE
@@ -352,6 +349,7 @@ do {									\
 #undef ACCEL_PREAMBLE
 #undef BEGIN_ACCEL
 #undef OUT_ACCEL_REG
+#undef OUT_ACCEL_REG_F
 #undef FINISH_ACCEL
 
 #ifdef XF86DRI
@@ -371,6 +369,13 @@ do {									\
 #endif
 #include "radeon_exa_funcs.c"
 
+#undef ACCEL_CP
+#undef ACCEL_PREAMBLE
+#undef BEGIN_ACCEL
+#undef OUT_ACCEL_REG
+#undef FINISH_ACCEL
+#undef OUT_RING_F
+
 #endif /* XF86DRI */
 
 /*
@@ -386,12 +391,12 @@ Bool RADEONSetupMemEXA (ScreenPtr pScreen)
     int screen_size;
     int byteStride = pScrn->displayWidth * cpp;
 
-    if (info->exa != NULL) {
+    if (info->accel_state->exa != NULL) {
 	xf86DrvMsg(pScreen->myNum, X_ERROR, "Memory map already initialized\n");
 	return FALSE;
     }
-    info->exa = exaDriverAlloc();
-    if (info->exa == NULL)
+    info->accel_state->exa = exaDriverAlloc();
+    if (info->accel_state->exa == NULL)
 	return FALSE;
 
     /* Need to adjust screen size for 16 line tiles, and then make it align to.
@@ -402,53 +407,52 @@ Bool RADEONSetupMemEXA (ScreenPtr pScreen)
     else
 	screen_size = pScrn->virtualY * byteStride;
 
-    info->exa->memoryBase = info->FB;
-    info->exa->memorySize = info->FbMapSize - info->FbSecureSize;
-    info->exa->offScreenBase = screen_size;
+    info->accel_state->exa->memoryBase = info->FB;
+    info->accel_state->exa->memorySize = info->FbMapSize - info->FbSecureSize;
+    info->accel_state->exa->offScreenBase = screen_size;
 
     xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Allocating from a screen of %ld kb\n",
-	       info->exa->memorySize / 1024);
-
+	       info->accel_state->exa->memorySize / 1024);
 
     /* Reserve static area for hardware cursor */
     if (!xf86ReturnOptValBool(info->Options, OPTION_SW_CURSOR, FALSE)) {
-	int cursor_size = 64 * 4 * 64;
-	int c;
-
-	for (c = 0; c < xf86_config->num_crtc; c++) {
-	    xf86CrtcPtr crtc = xf86_config->crtc[c];
-	    RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
-
-	    radeon_crtc->cursor_offset = info->exa->offScreenBase;
-	    info->exa->offScreenBase += cursor_size;
-
-	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-		       "Will use %d kb for hardware cursor %d at offset 0x%08x\n",
-		       (cursor_size * xf86_config->num_crtc) / 1024,
-		       c,
-		       (unsigned int)radeon_crtc->cursor_offset);
-	}
-
-
+        int cursor_size = 64 * 4 * 64;
+        int align = IS_AVIVO_VARIANT ? 4096 : 256;
+        int c;
+
+        for (c = 0; c < xf86_config->num_crtc; c++) {
+            xf86CrtcPtr crtc = xf86_config->crtc[c];
+            RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
+
+            radeon_crtc->cursor_offset =
+                RADEON_ALIGN(info->accel_state->exa->offScreenBase, align);
+            info->accel_state->exa->offScreenBase = radeon_crtc->cursor_offset + cursor_size;
+
+            xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+                       "Will use %d kb for hardware cursor %d at offset 0x%08x\n",
+                       (cursor_size * xf86_config->num_crtc) / 1024,
+                       c,
+                       (unsigned int)radeon_crtc->cursor_offset);
+        }
     }
 
 #if defined(XF86DRI)
     if (info->directRenderingEnabled) {
-	int depthCpp = (info->depthBits - 8) / 4, l, next, depth_size;
+	int depthCpp = (info->dri->depthBits - 8) / 4, l, next, depth_size;
 
-	info->frontOffset = 0;
-	info->frontPitch = pScrn->displayWidth;
+	info->dri->frontOffset = 0;
+	info->dri->frontPitch = pScrn->displayWidth;
 
         xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 	       "Will use %d kb for front buffer at offset 0x%08x\n",
-	       screen_size / 1024, info->frontOffset);
+	       screen_size / 1024, info->dri->frontOffset);
 	RADEONDRIAllocatePCIGARTTable(pScreen);
 	
 	if (info->cardType==CARD_PCIE)
 	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 		     "Will use %d kb for PCI GART at offset 0x%08x\n",
-		     info->pciGartSize / 1024,
-		     (int)info->pciGartOffset);
+		     info->dri->pciGartSize / 1024,
+		     (int)info->dri->pciGartOffset);
 
 	/* Reserve a static area for the back buffer the same size as the
 	 * visible screen.  XXX: This would be better initialized in ati_dri.c
@@ -456,49 +460,49 @@ Bool RADEONSetupMemEXA (ScreenPtr pScreen)
 	 * don't last through VT switches, while the kernel's understanding of
 	 * offscreen locations does.
 	 */
-	info->backPitch = pScrn->displayWidth;
-	next = RADEON_ALIGN(info->exa->offScreenBase, RADEON_BUFFER_ALIGN);
-	if (!info->noBackBuffer &&
-	    next + screen_size <= info->exa->memorySize)
+	info->dri->backPitch = pScrn->displayWidth;
+	next = RADEON_ALIGN(info->accel_state->exa->offScreenBase, RADEON_BUFFER_ALIGN);
+	if (!info->dri->noBackBuffer &&
+	    next + screen_size <= info->accel_state->exa->memorySize)
 	{
-	    info->backOffset = next;
-	    info->exa->offScreenBase = next + screen_size;
+	    info->dri->backOffset = next;
+	    info->accel_state->exa->offScreenBase = next + screen_size;
 	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 		       "Will use %d kb for back buffer at offset 0x%08x\n",
-		       screen_size / 1024, info->backOffset);
+		       screen_size / 1024, info->dri->backOffset);
 	}
 
 	/* Reserve the static depth buffer, and adjust pitch and height to
 	 * handle tiling.
 	 */
-	info->depthPitch = RADEON_ALIGN(pScrn->displayWidth, 32);
-	depth_size = RADEON_ALIGN(pScrn->virtualY, 16) * info->depthPitch * depthCpp;
-	next = RADEON_ALIGN(info->exa->offScreenBase, RADEON_BUFFER_ALIGN);
-	if (next + depth_size <= info->exa->memorySize)
+	info->dri->depthPitch = RADEON_ALIGN(pScrn->displayWidth, 32);
+	depth_size = RADEON_ALIGN(pScrn->virtualY, 16) * info->dri->depthPitch * depthCpp;
+	next = RADEON_ALIGN(info->accel_state->exa->offScreenBase, RADEON_BUFFER_ALIGN);
+	if (next + depth_size <= info->accel_state->exa->memorySize)
 	{
-	    info->depthOffset = next;
-	    info->exa->offScreenBase = next + depth_size;
+	    info->dri->depthOffset = next;
+	    info->accel_state->exa->offScreenBase = next + depth_size;
 	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 		       "Will use %d kb for depth buffer at offset 0x%08x\n",
-		       depth_size / 1024, info->depthOffset);
+		       depth_size / 1024, info->dri->depthOffset);
 	}
 	
-	info->textureSize *= (info->exa->memorySize -
-			      info->exa->offScreenBase) / 100;
+	info->dri->textureSize *= (info->accel_state->exa->memorySize -
+				   info->accel_state->exa->offScreenBase) / 100;
 
-	l = RADEONLog2(info->textureSize / RADEON_NR_TEX_REGIONS);
+	l = RADEONLog2(info->dri->textureSize / RADEON_NR_TEX_REGIONS);
 	if (l < RADEON_LOG_TEX_GRANULARITY)
 	    l = RADEON_LOG_TEX_GRANULARITY;
-	info->textureSize = (info->textureSize >> l) << l;
-	if (info->textureSize >= 512 * 1024) {
-	    info->textureOffset = info->exa->offScreenBase;
-	    info->exa->offScreenBase += info->textureSize;
+	info->dri->textureSize = (info->dri->textureSize >> l) << l;
+	if (info->dri->textureSize >= 512 * 1024) {
+	    info->dri->textureOffset = info->accel_state->exa->offScreenBase;
+	    info->accel_state->exa->offScreenBase += info->dri->textureSize;
 	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 		       "Will use %d kb for textures at offset 0x%08x\n",
-		       info->textureSize / 1024, info->textureOffset);
+		       info->dri->textureSize / 1024, info->dri->textureOffset);
 	} else {
 	    /* Minimum texture size is for 2 256x256x32bpp textures */
-	    info->textureSize = 0;
+	    info->dri->textureSize = 0;
 	}
     } else
 #endif /* XF86DRI */
@@ -508,8 +512,8 @@ Bool RADEONSetupMemEXA (ScreenPtr pScreen)
 
     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 	       "Will use %ld kb for X Server offscreen at offset 0x%08lx\n",
-	       (info->exa->memorySize - info->exa->offScreenBase) /
-	       1024, info->exa->offScreenBase);
+	       (info->accel_state->exa->memorySize - info->accel_state->exa->offScreenBase) /
+	       1024, info->accel_state->exa->offScreenBase);
 
     return TRUE;
 }
diff --git a/src/radeon_exa_funcs.c b/src/radeon_exa_funcs.c
index 56de23e..62224d0 100644
--- a/src/radeon_exa_funcs.c
+++ b/src/radeon_exa_funcs.c
@@ -65,7 +65,7 @@ FUNC_NAME(RADEONMarkSync)(ScreenPtr pScreen)
 
     TRACE;
 
-    return ++info->exaSyncMarker;
+    return ++info->accel_state->exaSyncMarker;
 }
 
 static void
@@ -76,12 +76,12 @@ FUNC_NAME(RADEONSync)(ScreenPtr pScreen, int marker)
 
     TRACE;
 
-    if (info->exaMarkerSynced != marker) {
+    if (info->accel_state->exaMarkerSynced != marker) {
 	FUNC_NAME(RADEONWaitForIdle)(pScrn);
-	info->exaMarkerSynced = marker;
+	info->accel_state->exaMarkerSynced = marker;
     }
 
-    RADEONPTR(pScrn)->engineMode = EXA_ENGINEMODE_UNKNOWN;
+    RADEONPTR(pScrn)->accel_state->engineMode = EXA_ENGINEMODE_UNKNOWN;
 }
 
 static Bool
@@ -172,8 +172,8 @@ FUNC_NAME(RADEONDoPrepareCopy)(ScrnInfoPtr pScrn, uint32_t src_pitch_offset,
 	RADEON_GMC_CLR_CMP_CNTL_DIS);
     OUT_ACCEL_REG(RADEON_DP_WRITE_MASK, planemask);
     OUT_ACCEL_REG(RADEON_DP_CNTL,
-	((info->xdir >= 0 ? RADEON_DST_X_LEFT_TO_RIGHT : 0) |
-	 (info->ydir >= 0 ? RADEON_DST_Y_TOP_TO_BOTTOM : 0)));
+	((info->accel_state->xdir >= 0 ? RADEON_DST_X_LEFT_TO_RIGHT : 0) |
+	 (info->accel_state->ydir >= 0 ? RADEON_DST_Y_TOP_TO_BOTTOM : 0)));
     OUT_ACCEL_REG(RADEON_DST_PITCH_OFFSET, dst_pitch_offset);
     OUT_ACCEL_REG(RADEON_SRC_PITCH_OFFSET, src_pitch_offset);
     FINISH_ACCEL();
@@ -190,8 +190,8 @@ FUNC_NAME(RADEONPrepareCopy)(PixmapPtr pSrc,   PixmapPtr pDst,
 
     TRACE;
 
-    info->xdir = xdir;
-    info->ydir = ydir;
+    info->accel_state->xdir = xdir;
+    info->accel_state->ydir = ydir;
 
     if (pDst->drawable.bitsPerPixel == 24)
 	RADEON_FALLBACK(("24bpp unsupported"));
@@ -219,11 +219,11 @@ FUNC_NAME(RADEONCopy)(PixmapPtr pDst,
 
     TRACE;
 
-    if (info->xdir < 0) {
+    if (info->accel_state->xdir < 0) {
 	srcX += w - 1;
 	dstX += w - 1;
     }
-    if (info->ydir < 0) {
+    if (info->accel_state->ydir < 0) {
 	srcY += h - 1;
 	dstY += h - 1;
     }
@@ -401,9 +401,9 @@ FUNC_NAME(RADEONDownloadFromScreen)(PixmapPtr pSrc, int x, int y, int w, int h,
 	int swap = RADEON_HOST_DATA_SWAP_NONE, wpass = w * bpp / 8;
 	int hpass = min(h, scratch->total/2 / scratch_pitch);
 	uint32_t scratch_pitch_offset = scratch_pitch << 16
-				    | (info->gartLocation + info->bufStart
+				    | (info->gartLocation + info->dri->bufStart
 				       + scratch->idx * scratch->total) >> 10;
-	drmRadeonIndirect indirect;
+	drm_radeon_indirect_t indirect;
 	ACCEL_PREAMBLE();
 
 	RADEON_SWITCH_TO_2D();
@@ -450,7 +450,7 @@ FUNC_NAME(RADEONDownloadFromScreen)(PixmapPtr pSrc, int x, int y, int w, int h,
 	     * we'd really need is a way to reliably wait for the host interface
 	     * to be done with pushing the data to the host.
 	     */
-	    while ((drmCommandNone(info->drmFD, DRM_RADEON_CP_IDLE) == -EBUSY)
+	    while ((drmCommandNone(info->dri->drmFD, DRM_RADEON_CP_IDLE) == -EBUSY)
 		   && (i++ < RADEON_TIMEOUT))
 		;
 
@@ -473,10 +473,10 @@ FUNC_NAME(RADEONDownloadFromScreen)(PixmapPtr pSrc, int x, int y, int w, int h,
 	indirect.start = indirect.end = 0;
 	indirect.discard = 1;
 
-	drmCommandWriteRead(info->drmFD, DRM_RADEON_INDIRECT,
-			    &indirect, sizeof(drmRadeonIndirect));
+	drmCommandWriteRead(info->dri->drmFD, DRM_RADEON_INDIRECT,
+			    &indirect, sizeof(drm_radeon_indirect_t));
 
-	info->exaMarkerSynced = info->exaSyncMarker;
+	info->accel_state->exaMarkerSynced = info->accel_state->exaSyncMarker;
 
 	return TRUE;
     }
@@ -522,35 +522,35 @@ Bool FUNC_NAME(RADEONDrawInit)(ScreenPtr pScreen)
 {
     RINFO_FROM_SCREEN(pScreen);
 
-    if (info->exa == NULL) {
+    if (info->accel_state->exa == NULL) {
 	xf86DrvMsg(pScreen->myNum, X_ERROR, "Memory map not set up\n");
 	return FALSE;
     }
 
-    info->exa->exa_major = EXA_VERSION_MAJOR;
-    info->exa->exa_minor = EXA_VERSION_MINOR;
+    info->accel_state->exa->exa_major = EXA_VERSION_MAJOR;
+    info->accel_state->exa->exa_minor = EXA_VERSION_MINOR;
 
-    info->exa->PrepareSolid = FUNC_NAME(RADEONPrepareSolid);
-    info->exa->Solid = FUNC_NAME(RADEONSolid);
-    info->exa->DoneSolid = FUNC_NAME(RADEONDoneSolid);
+    info->accel_state->exa->PrepareSolid = FUNC_NAME(RADEONPrepareSolid);
+    info->accel_state->exa->Solid = FUNC_NAME(RADEONSolid);
+    info->accel_state->exa->DoneSolid = FUNC_NAME(RADEONDoneSolid);
 
-    info->exa->PrepareCopy = FUNC_NAME(RADEONPrepareCopy);
-    info->exa->Copy = FUNC_NAME(RADEONCopy);
-    info->exa->DoneCopy = FUNC_NAME(RADEONDoneCopy);
+    info->accel_state->exa->PrepareCopy = FUNC_NAME(RADEONPrepareCopy);
+    info->accel_state->exa->Copy = FUNC_NAME(RADEONCopy);
+    info->accel_state->exa->DoneCopy = FUNC_NAME(RADEONDoneCopy);
 
-    info->exa->MarkSync = FUNC_NAME(RADEONMarkSync);
-    info->exa->WaitMarker = FUNC_NAME(RADEONSync);
-    info->exa->UploadToScreen = FUNC_NAME(RADEONUploadToScreen);
-    info->exa->DownloadFromScreen = FUNC_NAME(RADEONDownloadFromScreen);
+    info->accel_state->exa->MarkSync = FUNC_NAME(RADEONMarkSync);
+    info->accel_state->exa->WaitMarker = FUNC_NAME(RADEONSync);
+    info->accel_state->exa->UploadToScreen = FUNC_NAME(RADEONUploadToScreen);
+    info->accel_state->exa->DownloadFromScreen = FUNC_NAME(RADEONDownloadFromScreen);
 
 #if X_BYTE_ORDER == X_BIG_ENDIAN
-    info->exa->PrepareAccess = RADEONPrepareAccess;
-    info->exa->FinishAccess = RADEONFinishAccess;
+    info->accel_state->exa->PrepareAccess = RADEONPrepareAccess;
+    info->accel_state->exa->FinishAccess = RADEONFinishAccess;
 #endif /* X_BYTE_ORDER == X_BIG_ENDIAN */
 
-    info->exa->flags = EXA_OFFSCREEN_PIXMAPS;
-    info->exa->pixmapOffsetAlign = RADEON_BUFFER_ALIGN + 1;
-    info->exa->pixmapPitchAlign = 64;
+    info->accel_state->exa->flags = EXA_OFFSCREEN_PIXMAPS;
+    info->accel_state->exa->pixmapOffsetAlign = RADEON_BUFFER_ALIGN + 1;
+    info->accel_state->exa->pixmapPitchAlign = 64;
 
 #ifdef RENDER
     if (info->RenderAccel) {
@@ -565,11 +565,11 @@ Bool FUNC_NAME(RADEONDrawInit)(ScreenPtr pScreen)
 		) {
 		xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Render acceleration "
 			       "enabled for R300/R400/R500 type cards.\n");
-		info->exa->CheckComposite = R300CheckComposite;
-		info->exa->PrepareComposite =
+		info->accel_state->exa->CheckComposite = R300CheckComposite;
+		info->accel_state->exa->PrepareComposite =
 		    FUNC_NAME(R300PrepareComposite);
-		info->exa->Composite = FUNC_NAME(RadeonComposite);
-		info->exa->DoneComposite = FUNC_NAME(RadeonDoneComposite);
+		info->accel_state->exa->Composite = FUNC_NAME(RadeonComposite);
+		info->accel_state->exa->DoneComposite = FUNC_NAME(RadeonDoneComposite);
 	    } else
 		xf86DrvMsg(pScrn->scrnIndex, X_INFO, "EXA Composite requires CP on R5xx/IGP\n");
 	} else if ((info->ChipFamily == CHIP_FAMILY_RV250) ||
@@ -578,19 +578,19 @@ Bool FUNC_NAME(RADEONDrawInit)(ScreenPtr pScreen)
 		   (info->ChipFamily == CHIP_FAMILY_R200)) {
 		xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Render acceleration "
 			       "enabled for R200 type cards.\n");
-		info->exa->CheckComposite = R200CheckComposite;
-		info->exa->PrepareComposite =
+		info->accel_state->exa->CheckComposite = R200CheckComposite;
+		info->accel_state->exa->PrepareComposite =
 		    FUNC_NAME(R200PrepareComposite);
-		info->exa->Composite = FUNC_NAME(RadeonComposite);
-		info->exa->DoneComposite = FUNC_NAME(RadeonDoneComposite);
+		info->accel_state->exa->Composite = FUNC_NAME(RadeonComposite);
+		info->accel_state->exa->DoneComposite = FUNC_NAME(RadeonDoneComposite);
 	} else {
 		xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Render acceleration "
 			       "enabled for R100 type cards.\n");
-		info->exa->CheckComposite = R100CheckComposite;
-		info->exa->PrepareComposite =
+		info->accel_state->exa->CheckComposite = R100CheckComposite;
+		info->accel_state->exa->PrepareComposite =
 		    FUNC_NAME(R100PrepareComposite);
-		info->exa->Composite = FUNC_NAME(RadeonComposite);
-		info->exa->DoneComposite = FUNC_NAME(RadeonDoneComposite);
+		info->accel_state->exa->Composite = FUNC_NAME(RadeonComposite);
+		info->accel_state->exa->DoneComposite = FUNC_NAME(RadeonDoneComposite);
 	}
     }
 #endif
@@ -598,17 +598,17 @@ Bool FUNC_NAME(RADEONDrawInit)(ScreenPtr pScreen)
 #if EXA_VERSION_MAJOR > 2 || (EXA_VERSION_MAJOR == 2 && EXA_VERSION_MINOR >= 3)
     xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Setting EXA maxPitchBytes\n");
 
-    info->exa->maxPitchBytes = 16320;
-    info->exa->maxX = 8192;
+    info->accel_state->exa->maxPitchBytes = 16320;
+    info->accel_state->exa->maxX = 8192;
 #else
-    info->exa->maxX = 16320 / 4;
+    info->accel_state->exa->maxX = 16320 / 4;
 #endif
-    info->exa->maxY = 8192;
+    info->accel_state->exa->maxY = 8192;
 
     RADEONEngineInit(pScrn);
 
-    if (!exaDriverInit(pScreen, info->exa)) {
-	xfree(info->exa);
+    if (!exaDriverInit(pScreen, info->accel_state->exa)) {
+	xfree(info->accel_state->exa);
 	return FALSE;
     }
     exaMarkSync(pScreen);
diff --git a/src/radeon_exa_render.c b/src/radeon_exa_render.c
index 4736e4f..97199ae 100644
--- a/src/radeon_exa_render.c
+++ b/src/radeon_exa_render.c
@@ -56,15 +56,6 @@
 
 /* Only include the following (generic) bits once. */
 #ifdef ONLY_ONCE
-static Bool is_transform[2];
-static PictTransform *transform[2];
-static Bool has_mask;
-/* Whether we are tiling horizontally and vertically */
-static Bool need_src_tile_x;
-static Bool need_src_tile_y;
-/* Size of tiles ... set to 65536x65536 if not tiling in that direction */
-static Bool src_tile_width;
-static Bool src_tile_height;
 
 struct blendinfo {
     Bool dst_alpha;
@@ -287,8 +278,10 @@ static Bool RADEONSetupSourceTile(PicturePtr pPict,
 				  Bool canTile1d,
 				  Bool needMatchingPitch)
 {
-    need_src_tile_x = need_src_tile_y = FALSE;
-    src_tile_width = src_tile_height = 65536; /* "infinite" */
+    RINFO_FROM_SCREEN(pPix->drawable.pScreen);
+
+    info->accel_state->need_src_tile_x = info->accel_state->need_src_tile_y = FALSE;
+    info->accel_state->src_tile_width = info->accel_state->src_tile_height = 65536; /* "infinite" */
 	    
     if (pPict->repeat) {
 	Bool badPitch = needMatchingPitch && !RADEONPitchMatches(pPix);
@@ -301,17 +294,19 @@ static Bool RADEONSetupSourceTile(PicturePtr pPict,
 		RADEON_FALLBACK(("Width %d and pitch %u not compatible for repeat\n",
 				 w, (unsigned)exaGetPixmapPitch(pPix)));
 	} else {
-	    need_src_tile_x = (w & (w - 1)) != 0 || badPitch;
-	    need_src_tile_y = (h & (h - 1)) != 0;
+	    info->accel_state->need_src_tile_x = (w & (w - 1)) != 0 || badPitch;
+	    info->accel_state->need_src_tile_y = (h & (h - 1)) != 0;
 	    
 	    if (!canTile1d)
-		need_src_tile_x = need_src_tile_y = need_src_tile_x || need_src_tile_y;
+		info->accel_state->need_src_tile_x =
+		    info->accel_state->need_src_tile_y =
+		    info->accel_state->need_src_tile_x || info->accel_state->need_src_tile_y;
 	}
 
-	if (need_src_tile_x)
-	  src_tile_width = w;
-	if (need_src_tile_y)
-	  src_tile_height = h;
+	if (info->accel_state->need_src_tile_x)
+	    info->accel_state->src_tile_width = w;
+	if (info->accel_state->need_src_tile_y)
+	    info->accel_state->src_tile_height = h;
     }
 
     return TRUE;
@@ -357,7 +352,8 @@ static Bool FUNC_NAME(R100TextureSetup)(PicturePtr pPict, PixmapPtr pPix,
     uint32_t txfilter, txformat, txoffset, txpitch;
     int w = pPict->pDrawable->width;
     int h = pPict->pDrawable->height;
-    Bool repeat = pPict->repeat && !(unit == 0 && (need_src_tile_x || need_src_tile_y));
+    Bool repeat = pPict->repeat &&
+	!(unit == 0 && (info->accel_state->need_src_tile_x || info->accel_state->need_src_tile_y));
     int i;
     ACCEL_PREAMBLE();
 
@@ -389,8 +385,8 @@ static Bool FUNC_NAME(R100TextureSetup)(PicturePtr pPict, PixmapPtr pPix,
 	txformat |= RADEON_TXFORMAT_NON_POWER2;
     txformat |= unit << 24; /* RADEON_TXFORMAT_ST_ROUTE_STQX */
 
-    info->texW[unit] = 1;
-    info->texH[unit] = 1;
+    info->accel_state->texW[unit] = 1;
+    info->accel_state->texH[unit] = 1;
 
     switch (pPict->filter) {
     case PictFilterNearest:
@@ -427,10 +423,10 @@ static Bool FUNC_NAME(R100TextureSetup)(PicturePtr pPict, PixmapPtr pPix,
     FINISH_ACCEL();
 
     if (pPict->transform != 0) {
-	is_transform[unit] = TRUE;
-	transform[unit] = pPict->transform;
+	info->accel_state->is_transform[unit] = TRUE;
+	info->accel_state->transform[unit] = pPict->transform;
     } else {
-	is_transform[unit] = FALSE;
+	info->accel_state->is_transform[unit] = FALSE;
     }
 
     return TRUE;
@@ -531,16 +527,16 @@ static Bool FUNC_NAME(R100PrepareComposite)(int op,
 
     TRACE;
 
-    if (!info->XInited3D)
+    if (!info->accel_state->XInited3D)
 	RADEONInit3DEngine(pScrn);
 
     if (!RADEONGetDestFormat(pDstPicture, &dst_format))
 	return FALSE;
 
     if (pMask)
-	has_mask = TRUE;
+	info->accel_state->has_mask = TRUE;
     else
-	has_mask = FALSE;
+	info->accel_state->has_mask = FALSE;
 
     pixel_shift = pDst->drawable.bitsPerPixel >> 4;
 
@@ -569,7 +565,7 @@ static Bool FUNC_NAME(R100PrepareComposite)(int op,
 	    return FALSE;
 	pp_cntl |= RADEON_TEX_1_ENABLE;
     } else {
-	is_transform[1] = FALSE;
+	info->accel_state->is_transform[1] = FALSE;
     }
 
     RADEON_SWITCH_TO_3D();
@@ -670,7 +666,8 @@ static Bool FUNC_NAME(R200TextureSetup)(PicturePtr pPict, PixmapPtr pPix,
     uint32_t txfilter, txformat, txoffset, txpitch;
     int w = pPict->pDrawable->width;
     int h = pPict->pDrawable->height;
-    Bool repeat = pPict->repeat && !(unit == 0 && (need_src_tile_x || need_src_tile_y));
+    Bool repeat = pPict->repeat &&
+	!(unit == 0 && (info->accel_state->need_src_tile_x || info->accel_state->need_src_tile_y));
     int i;
     ACCEL_PREAMBLE();
 
@@ -702,8 +699,8 @@ static Bool FUNC_NAME(R200TextureSetup)(PicturePtr pPict, PixmapPtr pPix,
 	txformat |= R200_TXFORMAT_NON_POWER2;
     txformat |= unit << R200_TXFORMAT_ST_ROUTE_SHIFT;
 
-    info->texW[unit] = w;
-    info->texH[unit] = h;
+    info->accel_state->texW[unit] = w;
+    info->accel_state->texH[unit] = h;
 
     switch (pPict->filter) {
     case PictFilterNearest:
@@ -742,10 +739,10 @@ static Bool FUNC_NAME(R200TextureSetup)(PicturePtr pPict, PixmapPtr pPix,
     FINISH_ACCEL();
 
     if (pPict->transform != 0) {
-	is_transform[unit] = TRUE;
-	transform[unit] = pPict->transform;
+	info->accel_state->is_transform[unit] = TRUE;
+	info->accel_state->transform[unit] = pPict->transform;
     } else {
-	is_transform[unit] = FALSE;
+	info->accel_state->is_transform[unit] = FALSE;
     }
 
     return TRUE;
@@ -830,16 +827,16 @@ static Bool FUNC_NAME(R200PrepareComposite)(int op, PicturePtr pSrcPicture,
 
     TRACE;
 
-    if (!info->XInited3D)
+    if (!info->accel_state->XInited3D)
 	RADEONInit3DEngine(pScrn);
 
     if (!RADEONGetDestFormat(pDstPicture, &dst_format))
 	return FALSE;
 
     if (pMask)
-	has_mask = TRUE;
+	info->accel_state->has_mask = TRUE;
     else
-	has_mask = FALSE;
+	info->accel_state->has_mask = FALSE;
 
     pixel_shift = pDst->drawable.bitsPerPixel >> 4;
 
@@ -866,7 +863,7 @@ static Bool FUNC_NAME(R200PrepareComposite)(int op, PicturePtr pSrcPicture,
 	    return FALSE;
 	pp_cntl |= RADEON_TEX_1_ENABLE;
     } else {
-	is_transform[1] = FALSE;
+	info->accel_state->is_transform[1] = FALSE;
     }
 
     RADEON_SWITCH_TO_3D();
@@ -1045,15 +1042,15 @@ static Bool FUNC_NAME(R300TextureSetup)(PicturePtr pPict, PixmapPtr pPix,
      */
     txformat0 |= R300_TXPITCH_EN;
 
-    info->texW[unit] = w;
-    info->texH[unit] = h;
+    info->accel_state->texW[unit] = w;
+    info->accel_state->texH[unit] = h;
 
-    if (pPict->repeat && !(unit == 0 && need_src_tile_x))
+    if (pPict->repeat && !(unit == 0 && info->accel_state->need_src_tile_x))
       txfilter = R300_TX_CLAMP_S(R300_TX_CLAMP_WRAP);
     else
       txfilter = R300_TX_CLAMP_S(R300_TX_CLAMP_CLAMP_GL);
 
-    if (pPict->repeat && !(unit == 0 && need_src_tile_y))
+    if (pPict->repeat && !(unit == 0 && info->accel_state->need_src_tile_y))
       txfilter |= R300_TX_CLAMP_T(R300_TX_CLAMP_WRAP);
     else
       txfilter |= R300_TX_CLAMP_T(R300_TX_CLAMP_CLAMP_GL);
@@ -1083,10 +1080,10 @@ static Bool FUNC_NAME(R300TextureSetup)(PicturePtr pPict, PixmapPtr pPix,
     FINISH_ACCEL();
 
     if (pPict->transform != 0) {
-	is_transform[unit] = TRUE;
-	transform[unit] = pPict->transform;
+	info->accel_state->is_transform[unit] = TRUE;
+	info->accel_state->transform[unit] = pPict->transform;
     } else {
-	is_transform[unit] = FALSE;
+	info->accel_state->is_transform[unit] = FALSE;
     }
 
     return TRUE;
@@ -1191,16 +1188,16 @@ static Bool FUNC_NAME(R300PrepareComposite)(int op, PicturePtr pSrcPicture,
 
     TRACE;
 
-    if (!info->XInited3D)
+    if (!info->accel_state->XInited3D)
 	RADEONInit3DEngine(pScrn);
 
     if (!R300GetDestFormat(pDstPicture, &dst_format))
 	return FALSE;
 
     if (pMask)
-	has_mask = TRUE;
+	info->accel_state->has_mask = TRUE;
     else
-	has_mask = FALSE;
+	info->accel_state->has_mask = FALSE;
 
     pixel_shift = pDst->drawable.bitsPerPixel >> 4;
 
@@ -1230,13 +1227,13 @@ static Bool FUNC_NAME(R300PrepareComposite)(int op, PicturePtr pSrcPicture,
 	    return FALSE;
 	txenable |= R300_TEX_1_ENABLE;
     } else {
-	is_transform[1] = FALSE;
+	info->accel_state->is_transform[1] = FALSE;
     }
 
     RADEON_SWITCH_TO_3D();
 
     /* setup the VAP */
-    if (info->has_tcl) {
+    if (info->accel_state->has_tcl) {
 	if (pMask)
 	    BEGIN_ACCEL(8);
 	else
@@ -1296,7 +1293,7 @@ static Bool FUNC_NAME(R300PrepareComposite)(int op, PicturePtr pSrcPicture,
      * - Xv
      * Here we select the offset of the vertex program we want to use
      */
-    if (info->has_tcl) {
+    if (info->accel_state->has_tcl) {
 	if (pMask) {
 	    OUT_ACCEL_REG(R300_VAP_PVS_CODE_CNTL_0,
 			  ((0 << R300_PVS_FIRST_INST_SHIFT) |
@@ -1419,7 +1416,7 @@ static Bool FUNC_NAME(R300PrepareComposite)(int op, PicturePtr pSrcPicture,
 
 
 	/* setup the rasterizer, load FS */
-	BEGIN_ACCEL(9);
+	BEGIN_ACCEL(10);
 	if (pMask) {
 	    /* 4 components: 2 for tex0, 2 for tex1 */
 	    OUT_ACCEL_REG(R300_RS_COUNT,
@@ -1461,6 +1458,7 @@ static Bool FUNC_NAME(R300PrepareComposite)(int op, PicturePtr pSrcPicture,
 			   R300_RGBA_OUT));
 	}
 
+	OUT_ACCEL_REG(R300_US_PIXSIZE, 1); /* highest temp used */
 	/* shader output swizzling */
 	OUT_ACCEL_REG(R300_US_OUT_FMT_0, output_fmt);
 
@@ -1474,7 +1472,7 @@ static Bool FUNC_NAME(R300PrepareComposite)(int op, PicturePtr pSrcPicture,
 	 * R300_ALU_RGB_OMASK - output components to write
 	 * R300_ALU_RGB_TARGET_A - render target
 	 */
-	OUT_ACCEL_REG(R300_US_ALU_RGB_ADDR_0,
+	OUT_ACCEL_REG(R300_US_ALU_RGB_ADDR(0),
 		      (R300_ALU_RGB_ADDR0(0) |
 		       R300_ALU_RGB_ADDR1(1) |
 		       R300_ALU_RGB_ADDR2(0) |
@@ -1486,7 +1484,7 @@ static Bool FUNC_NAME(R300PrepareComposite)(int op, PicturePtr pSrcPicture,
 	/* RGB inst
 	 * ALU operation
 	 */
-	OUT_ACCEL_REG(R300_US_ALU_RGB_INST_0,
+	OUT_ACCEL_REG(R300_US_ALU_RGB_INST(0),
 		      (R300_ALU_RGB_SEL_A(src_color) |
 		       R300_ALU_RGB_MOD_A(R300_ALU_RGB_MOD_NOP) |
 		       R300_ALU_RGB_SEL_B(mask_color) |
@@ -1503,7 +1501,7 @@ static Bool FUNC_NAME(R300PrepareComposite)(int op, PicturePtr pSrcPicture,
 	 * R300_ALU_ALPHA_OMASK - output components to write
 	 * R300_ALU_ALPHA_TARGET_A - render target
 	 */
-	OUT_ACCEL_REG(R300_US_ALU_ALPHA_ADDR_0,
+	OUT_ACCEL_REG(R300_US_ALU_ALPHA_ADDR(0),
 		      (R300_ALU_ALPHA_ADDR0(0) |
 		       R300_ALU_ALPHA_ADDR1(1) |
 		       R300_ALU_ALPHA_ADDR2(0) |
@@ -1514,7 +1512,7 @@ static Bool FUNC_NAME(R300PrepareComposite)(int op, PicturePtr pSrcPicture,
 	/* Alpha inst
 	 * ALU operation
 	 */
-	OUT_ACCEL_REG(R300_US_ALU_ALPHA_INST_0,
+	OUT_ACCEL_REG(R300_US_ALU_ALPHA_INST(0),
 		      (R300_ALU_ALPHA_SEL_A(src_alpha) |
 		       R300_ALU_ALPHA_MOD_A(R300_ALU_ALPHA_MOD_NOP) |
 		       R300_ALU_ALPHA_SEL_B(mask_alpha) |
@@ -1633,7 +1631,7 @@ static Bool FUNC_NAME(R300PrepareComposite)(int op, PicturePtr pSrcPicture,
 	    break;
 	}
 
-	BEGIN_ACCEL(6);
+	BEGIN_ACCEL(7);
 	if (pMask) {
 	    /* 4 components: 2 for tex0, 2 for tex1 */
 	    OUT_ACCEL_REG(R300_RS_COUNT,
@@ -1662,12 +1660,13 @@ static Bool FUNC_NAME(R300PrepareComposite)(int op, PicturePtr pSrcPicture,
 	    OUT_ACCEL_REG(R500_US_CODE_OFFSET, 0);
 	}
 
+	OUT_ACCEL_REG(R300_US_PIXSIZE, 1); /* highest temp used */
 	OUT_ACCEL_REG(R300_US_OUT_FMT_0, output_fmt);
 	FINISH_ACCEL();
 
 	if (pMask) {
 	    BEGIN_ACCEL(19);
-	    OUT_ACCEL_REG(R500_GA_US_VECTOR_INDEX, 0);
+	    OUT_ACCEL_REG(R500_GA_US_VECTOR_INDEX, R500_US_VECTOR_INST_INDEX(0));
 	    /* tex inst for src texture */
 	    OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_INST_TYPE_TEX |
 						   R500_INST_RGB_WMASK_R |
@@ -1739,7 +1738,7 @@ static Bool FUNC_NAME(R300PrepareComposite)(int op, PicturePtr pSrcPicture,
 	    OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
 	} else {
 	    BEGIN_ACCEL(13);
-	    OUT_ACCEL_REG(R500_GA_US_VECTOR_INDEX, 0);
+	    OUT_ACCEL_REG(R500_GA_US_VECTOR_INDEX, R500_US_VECTOR_INST_INDEX(0));
 	    /* tex inst for src texture */
 	    OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_INST_TYPE_TEX |
 						   R500_INST_TEX_SEM_WAIT |
@@ -1936,20 +1935,20 @@ static void FUNC_NAME(RadeonCompositeTile)(PixmapPtr pDst,
     maskBottomRight.x = IntToxFixed(maskX + w);
     maskBottomRight.y = IntToxFixed(maskY + h);
 
-    if (is_transform[0]) {
-	transformPoint(transform[0], &srcTopLeft);
-	transformPoint(transform[0], &srcTopRight);
-	transformPoint(transform[0], &srcBottomLeft);
-	transformPoint(transform[0], &srcBottomRight);
+    if (info->accel_state->is_transform[0]) {
+	transformPoint(info->accel_state->transform[0], &srcTopLeft);
+	transformPoint(info->accel_state->transform[0], &srcTopRight);
+	transformPoint(info->accel_state->transform[0], &srcBottomLeft);
+	transformPoint(info->accel_state->transform[0], &srcBottomRight);
     }
-    if (is_transform[1]) {
-	transformPoint(transform[1], &maskTopLeft);
-	transformPoint(transform[1], &maskTopRight);
-	transformPoint(transform[1], &maskBottomLeft);
-	transformPoint(transform[1], &maskBottomRight);
+    if (info->accel_state->is_transform[1]) {
+	transformPoint(info->accel_state->transform[1], &maskTopLeft);
+	transformPoint(info->accel_state->transform[1], &maskTopRight);
+	transformPoint(info->accel_state->transform[1], &maskBottomLeft);
+	transformPoint(info->accel_state->transform[1], &maskBottomRight);
     }
 
-    if (has_mask)
+    if (info->accel_state->has_mask)
 	vtx_count = VTX_COUNT_MASK;
     else
 	vtx_count = VTX_COUNT;
@@ -1962,21 +1961,21 @@ static void FUNC_NAME(RadeonCompositeTile)(PixmapPtr pDst,
 
 #ifdef ACCEL_CP
     if (info->ChipFamily < CHIP_FAMILY_R200) {
-	BEGIN_RING(4 * vtx_count + 3);
+	BEGIN_RING(3 * vtx_count + 3);
 	OUT_RING(CP_PACKET3(RADEON_CP_PACKET3_3D_DRAW_IMMD,
-			    4 * vtx_count + 1));
-	if (has_mask)
+			    3 * vtx_count + 1));
+	if (info->accel_state->has_mask)
 	    OUT_RING(RADEON_CP_VC_FRMT_XY |
 		     RADEON_CP_VC_FRMT_ST0 |
 		     RADEON_CP_VC_FRMT_ST1);
 	else
 	    OUT_RING(RADEON_CP_VC_FRMT_XY |
 		     RADEON_CP_VC_FRMT_ST0);
-	OUT_RING(RADEON_CP_VC_CNTL_PRIM_TYPE_TRI_FAN |
+	OUT_RING(RADEON_CP_VC_CNTL_PRIM_TYPE_RECT_LIST |
 		 RADEON_CP_VC_CNTL_PRIM_WALK_RING |
 		 RADEON_CP_VC_CNTL_MAOS_ENABLE |
 		 RADEON_CP_VC_CNTL_VTX_FMT_RADEON_MODE |
-		 (4 << RADEON_CP_VC_CNTL_NUM_SHIFT));
+		 (3 << RADEON_CP_VC_CNTL_NUM_SHIFT));
     } else {
 	if (IS_R300_3D || IS_R500_3D)
 	    BEGIN_RING(4 * vtx_count + 4);
@@ -1985,7 +1984,7 @@ static void FUNC_NAME(RadeonCompositeTile)(PixmapPtr pDst,
 
 	OUT_RING(CP_PACKET3(R200_CP_PACKET3_3D_DRAW_IMMD_2,
 			    4 * vtx_count));
-	OUT_RING(RADEON_CP_VC_CNTL_PRIM_TYPE_TRI_FAN |
+	OUT_RING(RADEON_CP_VC_CNTL_PRIM_TYPE_QUAD_LIST |
 		 RADEON_CP_VC_CNTL_PRIM_WALK_RING |
 		 (4 << RADEON_CP_VC_CNTL_NUM_SHIFT));
     }
@@ -1993,43 +1992,49 @@ static void FUNC_NAME(RadeonCompositeTile)(PixmapPtr pDst,
 #else /* ACCEL_CP */
     if (IS_R300_3D || IS_R500_3D)
 	BEGIN_ACCEL(2 + vtx_count * 4);
+    else if (info->ChipFamily < CHIP_FAMILY_R200)
+	BEGIN_ACCEL(1 + vtx_count * 3);
     else
 	BEGIN_ACCEL(1 + vtx_count * 4);
 
-    if (info->ChipFamily < CHIP_FAMILY_R200) {
-	OUT_ACCEL_REG(RADEON_SE_VF_CNTL, (RADEON_VF_PRIM_TYPE_TRIANGLE_FAN |
+    if (info->ChipFamily < CHIP_FAMILY_R200)
+	OUT_ACCEL_REG(RADEON_SE_VF_CNTL, (RADEON_VF_PRIM_TYPE_RECTANGLE_LIST |
 					  RADEON_VF_PRIM_WALK_DATA |
 					  RADEON_VF_RADEON_MODE |
-					  4 << RADEON_VF_NUM_VERTICES_SHIFT));
-    } else {
+					  (3 << RADEON_VF_NUM_VERTICES_SHIFT)));
+    else
 	OUT_ACCEL_REG(RADEON_SE_VF_CNTL, (RADEON_VF_PRIM_TYPE_QUAD_LIST |
 					  RADEON_VF_PRIM_WALK_DATA |
-					  4 << RADEON_VF_NUM_VERTICES_SHIFT));
-    }
+					  (4 << RADEON_VF_NUM_VERTICES_SHIFT)));
+
 #endif
 
-    if (has_mask) {
-	VTX_OUT_MASK((float)dstX,                                      (float)dstY,
-		xFixedToFloat(srcTopLeft.x) / info->texW[0],      xFixedToFloat(srcTopLeft.y) / info->texH[0],
-		xFixedToFloat(maskTopLeft.x) / info->texW[1],     xFixedToFloat(maskTopLeft.y) / info->texH[1]);
+    if (info->accel_state->has_mask) {
+	if (info->ChipFamily >= CHIP_FAMILY_R200) {
+	    VTX_OUT_MASK((float)dstX,                                      (float)dstY,
+			 xFixedToFloat(srcTopLeft.x) / info->accel_state->texW[0],      xFixedToFloat(srcTopLeft.y) / info->accel_state->texH[0],
+			 xFixedToFloat(maskTopLeft.x) / info->accel_state->texW[1],     xFixedToFloat(maskTopLeft.y) / info->accel_state->texH[1]);
+	}
 	VTX_OUT_MASK((float)dstX,                                      (float)(dstY + h),
-		xFixedToFloat(srcBottomLeft.x) / info->texW[0],   xFixedToFloat(srcBottomLeft.y) / info->texH[0],
-		xFixedToFloat(maskBottomLeft.x) / info->texW[1],  xFixedToFloat(maskBottomLeft.y) / info->texH[1]);
+		xFixedToFloat(srcBottomLeft.x) / info->accel_state->texW[0],   xFixedToFloat(srcBottomLeft.y) / info->accel_state->texH[0],
+		xFixedToFloat(maskBottomLeft.x) / info->accel_state->texW[1],  xFixedToFloat(maskBottomLeft.y) / info->accel_state->texH[1]);
 	VTX_OUT_MASK((float)(dstX + w),                                (float)(dstY + h),
-		xFixedToFloat(srcBottomRight.x) / info->texW[0],  xFixedToFloat(srcBottomRight.y) / info->texH[0],
-		xFixedToFloat(maskBottomRight.x) / info->texW[1], xFixedToFloat(maskBottomRight.y) / info->texH[1]);
+		xFixedToFloat(srcBottomRight.x) / info->accel_state->texW[0],  xFixedToFloat(srcBottomRight.y) / info->accel_state->texH[0],
+		xFixedToFloat(maskBottomRight.x) / info->accel_state->texW[1], xFixedToFloat(maskBottomRight.y) / info->accel_state->texH[1]);
 	VTX_OUT_MASK((float)(dstX + w),                                (float)dstY,
-		xFixedToFloat(srcTopRight.x) / info->texW[0],     xFixedToFloat(srcTopRight.y) / info->texH[0],
-		xFixedToFloat(maskTopRight.x) / info->texW[1],    xFixedToFloat(maskTopRight.y) / info->texH[1]);
+		xFixedToFloat(srcTopRight.x) / info->accel_state->texW[0],     xFixedToFloat(srcTopRight.y) / info->accel_state->texH[0],
+		xFixedToFloat(maskTopRight.x) / info->accel_state->texW[1],    xFixedToFloat(maskTopRight.y) / info->accel_state->texH[1]);
     } else {
-	VTX_OUT((float)dstX,                                      (float)dstY,
-		xFixedToFloat(srcTopLeft.x) / info->texW[0],      xFixedToFloat(srcTopLeft.y) / info->texH[0]);
+	if (info->ChipFamily >= CHIP_FAMILY_R200) {
+	    VTX_OUT((float)dstX,                                      (float)dstY,
+		    xFixedToFloat(srcTopLeft.x) / info->accel_state->texW[0],      xFixedToFloat(srcTopLeft.y) / info->accel_state->texH[0]);
+	}
 	VTX_OUT((float)dstX,                                      (float)(dstY + h),
-		xFixedToFloat(srcBottomLeft.x) / info->texW[0],   xFixedToFloat(srcBottomLeft.y) / info->texH[0]);
+		xFixedToFloat(srcBottomLeft.x) / info->accel_state->texW[0],   xFixedToFloat(srcBottomLeft.y) / info->accel_state->texH[0]);
 	VTX_OUT((float)(dstX + w),                                (float)(dstY + h),
-		xFixedToFloat(srcBottomRight.x) / info->texW[0],  xFixedToFloat(srcBottomRight.y) / info->texH[0]);
+		xFixedToFloat(srcBottomRight.x) / info->accel_state->texW[0],  xFixedToFloat(srcBottomRight.y) / info->accel_state->texH[0]);
 	VTX_OUT((float)(dstX + w),                                (float)dstY,
-		xFixedToFloat(srcTopRight.x) / info->texW[0],     xFixedToFloat(srcTopRight.y) / info->texH[0]);
+		xFixedToFloat(srcTopRight.x) / info->accel_state->texW[0],     xFixedToFloat(srcTopRight.y) / info->accel_state->texH[0]);
     }
 
     if (IS_R300_3D || IS_R500_3D)
@@ -2055,8 +2060,9 @@ static void FUNC_NAME(RadeonComposite)(PixmapPtr pDst,
 {
     int tileSrcY, tileMaskY, tileDstY;
     int remainingHeight;
-    
-    if (!need_src_tile_x && !need_src_tile_y) {
+    RINFO_FROM_SCREEN(pDst->drawable.pScreen);
+
+    if (!info->accel_state->need_src_tile_x && !info->accel_state->need_src_tile_y) {
 	FUNC_NAME(RadeonCompositeTile)(pDst,
 				       srcX, srcY,
 				       maskX, maskY,
@@ -2067,7 +2073,7 @@ static void FUNC_NAME(RadeonComposite)(PixmapPtr pDst,
 
     /* Tiling logic borrowed from exaFillRegionTiled */
 
-    modulus(srcY, src_tile_height, tileSrcY);
+    modulus(srcY, info->accel_state->src_tile_height, tileSrcY);
     tileMaskY = maskY;
     tileDstY = dstY;
 
@@ -2075,18 +2081,18 @@ static void FUNC_NAME(RadeonComposite)(PixmapPtr pDst,
     while (remainingHeight > 0) {
 	int remainingWidth = width;
 	int tileSrcX, tileMaskX, tileDstX;
-	int h = src_tile_height - tileSrcY;
+	int h = info->accel_state->src_tile_height - tileSrcY;
 	
 	if (h > remainingHeight)
 	    h = remainingHeight;
 	remainingHeight -= h;
 
-	modulus(srcX, src_tile_width, tileSrcX);
+	modulus(srcX, info->accel_state->src_tile_width, tileSrcX);
 	tileMaskX = maskX;
 	tileDstX = dstX;
 	
 	while (remainingWidth > 0) {
-	    int w = src_tile_width - tileSrcX;
+	    int w = info->accel_state->src_tile_width - tileSrcX;
 	    if (w > remainingWidth)
 		w = remainingWidth;
 	    remainingWidth -= w;
diff --git a/src/radeon_macros.h b/src/radeon_macros.h
index afe442e..f19bc3e 100644
--- a/src/radeon_macros.h
+++ b/src/radeon_macros.h
@@ -51,32 +51,6 @@
 
 #include "compiler.h"
 
-#if HAVE_BYTESWAP_H
-#include <byteswap.h>
-#elif defined(USE_SYS_ENDIAN_H)
-#include <sys/endian.h>
-#else
-#define	bswap_16(value)  \
- 	((((value) & 0xff) << 8) | ((value) >> 8))
-
-#define	bswap_32(value)	\
- 	(((uint32_t)bswap_16((uint16_t)((value) & 0xffff)) << 16) | \
- 	(uint32_t)bswap_16((uint16_t)((value) >> 16)))
- 
-#define	bswap_64(value)	\
- 	(((uint64_t)bswap_32((uint32_t)((value) & 0xffffffff)) \
- 	    << 32) | \
- 	(uint64_t)bswap_32((uint32_t)((value) >> 32)))
-#endif
-
-#if X_BYTE_ORDER == X_BIG_ENDIAN
-#define le32_to_cpu(x) bswap_32(x)
-#define le16_to_cpu(x) bswap_16(x)
-#else
-#define le32_to_cpu(x) (x)
-#define le16_to_cpu(x) (x)
-#endif
-
 #define RADEON_BIOS8(v)  (info->VBIOS[v])
 #define RADEON_BIOS16(v) (info->VBIOS[v] | \
                           (info->VBIOS[(v) + 1] << 8))
diff --git a/src/radeon_memory.c b/src/radeon_memory.c
new file mode 100644
index 0000000..178eed0
--- /dev/null
+++ b/src/radeon_memory.c
@@ -0,0 +1,118 @@
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+/* Driver data structures */
+#include "radeon.h"
+
+/* Allocates memory, either by resizing the allocation pointed to by mem_struct,
+ * or by freeing mem_struct (if non-NULL) and allocating a new space.  The size
+ * is measured in bytes, and the offset from the beginning of card space is
+ * returned.
+ */
+uint32_t
+radeon_allocate_memory(ScrnInfoPtr pScrn,
+		       void **mem_struct,
+		       int size,
+		       int align)
+{
+    ScreenPtr pScreen;
+    RADEONInfoPtr info = RADEONPTR(pScrn);
+    uint32_t offset = 0;
+
+    pScreen = screenInfo.screens[pScrn->scrnIndex];
+
+#ifdef USE_EXA
+    if (info->useEXA) {
+	ExaOffscreenArea *area = *mem_struct;
+
+	if (area != NULL) {
+	    if (area->size >= size)
+		return area->offset;
+
+	    exaOffscreenFree(pScrn->pScreen, area);
+	}
+
+	area = exaOffscreenAlloc(pScrn->pScreen, size, align, TRUE,
+				 NULL, NULL);
+
+	*mem_struct = area;
+	if (area == NULL)
+	    return 0;
+	offset = area->offset;
+    }
+#endif /* USE_EXA */
+#ifdef USE_XAA
+    if (!info->useEXA) {
+	FBLinearPtr linear = *mem_struct;
+	int cpp = info->CurrentLayout.bitsPerPixel / 8;
+
+	/* XAA allocates in units of pixels at the screen bpp, so adjust size
+	 * appropriately.
+	 */
+	size = (size + cpp - 1) / cpp;
+	align = (align + cpp - 1) / cpp;
+
+	if (linear) {
+	    if(linear->size >= size)
+		return linear->offset * cpp;
+
+	    if(xf86ResizeOffscreenLinear(linear, size))
+		return linear->offset * cpp;
+
+	    xf86FreeOffscreenLinear(linear);
+	}
+
+	linear = xf86AllocateOffscreenLinear(pScreen, size, align,
+					     NULL, NULL, NULL);
+	*mem_struct = linear;
+
+	if (!linear) {
+	    int max_size;
+
+	    xf86QueryLargestOffscreenLinear(pScreen, &max_size, align,
+					    PRIORITY_EXTREME);
+
+	    if (max_size < size)
+		return 0;
+
+	    xf86PurgeUnlockedOffscreenAreas(pScreen);
+	    linear = xf86AllocateOffscreenLinear(pScreen, size, align,
+						 NULL, NULL, NULL);
+	    *mem_struct = linear;
+	    if (!linear)
+		return 0;
+	}
+	offset = linear->offset * cpp;
+    }
+#endif /* USE_XAA */
+
+    return offset;
+}
+
+void
+radeon_free_memory(ScrnInfoPtr pScrn,
+		   void *mem_struct)
+{
+    RADEONInfoPtr info = RADEONPTR(pScrn);
+
+#ifdef USE_EXA
+    if (info->useEXA) {
+	ExaOffscreenArea *area = mem_struct;
+
+	if (area != NULL)
+	    exaOffscreenFree(pScrn->pScreen, area);
+	area = NULL;
+    }
+#endif /* USE_EXA */
+#ifdef USE_XAA
+    if (!info->useEXA) {
+	FBLinearPtr linear = mem_struct;
+
+	if (linear != NULL)
+	    xf86FreeOffscreenLinear(linear);
+	linear = NULL;
+    }
+#endif /* USE_XAA */
+}
diff --git a/src/radeon_output.c b/src/radeon_output.c
index 7b89d66..2cc38a5 100644
--- a/src/radeon_output.c
+++ b/src/radeon_output.c
@@ -173,9 +173,6 @@ static const uint32_t default_tvdac_adj [CHIP_FAMILY_LAST] =
 
 static void RADEONUpdatePanelSize(xf86OutputPtr output);
 static void RADEONGetTMDSInfoFromTable(xf86OutputPtr output);
-#define AVIVO_I2C_DISABLE 0
-#define AVIVO_I2C_ENABLE 1
-static Bool AVIVOI2CDoLock(xf86OutputPtr output, int lock_state);
 
 extern void atombios_output_mode_set(xf86OutputPtr output,
 				     DisplayModePtr mode,
@@ -183,6 +180,8 @@ extern void atombios_output_mode_set(xf86OutputPtr output,
 extern void atombios_output_dpms(xf86OutputPtr output, int mode);
 extern RADEONMonitorType atombios_dac_detect(ScrnInfoPtr pScrn, xf86OutputPtr output);
 extern int atombios_external_tmds_setup(xf86OutputPtr output, DisplayModePtr mode);
+extern AtomBiosResult
+atombios_lock_crtc(atomBiosHandlePtr atomBIOS, int crtc, int lock);
 static void
 radeon_bios_output_dpms(xf86OutputPtr output, int mode);
 static void
@@ -213,88 +212,6 @@ void RADEONPrintPortMap(ScrnInfoPtr pScrn)
 
 }
 
-static xf86MonPtr
-radeon_do_ddc(xf86OutputPtr output)
-{
-    RADEONInfoPtr info = RADEONPTR(output->scrn);
-    unsigned char *RADEONMMIO = info->MMIO;
-    uint32_t DDCReg;
-    xf86MonPtr MonInfo = NULL;
-    RADEONOutputPrivatePtr radeon_output = output->driver_private;
-    int i, j;
-
-    if (radeon_output->pI2CBus) {
-	DDCReg = radeon_output->ddc_i2c.mask_clk_reg;
-
-	if (IS_AVIVO_VARIANT) {
-	    AVIVOI2CDoLock(output, AVIVO_I2C_ENABLE);
-	    MonInfo = xf86OutputGetEDID(output, radeon_output->pI2CBus);
-	    AVIVOI2CDoLock(output, AVIVO_I2C_DISABLE);
-	} else if ((DDCReg == RADEON_LCD_GPIO_MASK) || (DDCReg == RADEON_MDGPIO_EN_REG)) {
-	    MonInfo = xf86OutputGetEDID(output, radeon_output->pI2CBus);
-	} else {
-	    OUTREG(DDCReg, INREG(DDCReg) &
-		   (uint32_t)~(RADEON_GPIO_A_0 | RADEON_GPIO_A_1));
-
-	    /* For some old monitors (like Compaq Presario FP500), we need
-	     * following process to initialize/stop DDC
-	     */
-	    OUTREG(DDCReg, INREG(DDCReg) & ~(RADEON_GPIO_EN_1));
-	    for (j = 0; j < 3; j++) {
-		OUTREG(DDCReg,
-		       INREG(DDCReg) & ~(RADEON_GPIO_EN_0));
-		usleep(13000);
-
-		OUTREG(DDCReg,
-		       INREG(DDCReg) & ~(RADEON_GPIO_EN_1));
-		for (i = 0; i < 10; i++) {
-		    usleep(15000);
-		    if (INREG(DDCReg) & RADEON_GPIO_Y_1)
-			break;
-		}
-		if (i == 10) continue;
-
-		usleep(15000);
-
-		OUTREG(DDCReg, INREG(DDCReg) | RADEON_GPIO_EN_0);
-		usleep(15000);
-
-		OUTREG(DDCReg, INREG(DDCReg) | RADEON_GPIO_EN_1);
-		usleep(15000);
-		OUTREG(DDCReg,
-		       INREG(DDCReg) & ~(RADEON_GPIO_EN_0));
-		usleep(15000);
-
-		MonInfo = xf86OutputGetEDID(output, radeon_output->pI2CBus);
-
-		OUTREG(DDCReg, INREG(DDCReg) | RADEON_GPIO_EN_1);
-		OUTREG(DDCReg, INREG(DDCReg) | RADEON_GPIO_EN_0);
-		usleep(15000);
-		OUTREG(DDCReg,
-		       INREG(DDCReg) & ~(RADEON_GPIO_EN_1));
-		for (i = 0; i < 5; i++) {
-		    usleep(15000);
-		    if (INREG(DDCReg) & RADEON_GPIO_Y_1)
-			break;
-		}
-		usleep(15000);
-		OUTREG(DDCReg,
-		       INREG(DDCReg) & ~(RADEON_GPIO_EN_0));
-		usleep(15000);
-
-		OUTREG(DDCReg, INREG(DDCReg) | RADEON_GPIO_EN_1);
-		OUTREG(DDCReg, INREG(DDCReg) | RADEON_GPIO_EN_0);
-		usleep(15000);
-		if (MonInfo)  break;
-	    }
-	    OUTREG(DDCReg, INREG(DDCReg) &
-		   ~(RADEON_GPIO_EN_0 | RADEON_GPIO_EN_1));
-	}
-    }
-
-    return MonInfo;
-}
-
 static RADEONMonitorType
 radeon_ddc_connected(xf86OutputPtr output)
 {
@@ -304,8 +221,11 @@ radeon_ddc_connected(xf86OutputPtr output)
     xf86MonPtr MonInfo = NULL;
     RADEONOutputPrivatePtr radeon_output = output->driver_private;
 
-    if (radeon_output->pI2CBus)
-	MonInfo = radeon_do_ddc(output);
+    if (radeon_output->pI2CBus) {
+	RADEONI2CDoLock(output, TRUE);
+	MonInfo = xf86OutputGetEDID(output, radeon_output->pI2CBus);
+	RADEONI2CDoLock(output, FALSE);
+    }
     if (MonInfo) {
 	if (!xf86ReturnOptValBool(info->Options, OPTION_IGNORE_EDID, FALSE))
 	    xf86OutputSetEDID(output, MonInfo);
@@ -317,13 +237,14 @@ radeon_ddc_connected(xf86OutputPtr output)
 	    MonType = MT_DFP;
 	else if (radeon_output->type == OUTPUT_DP)
 	    MonType = MT_DFP;
-	else if (radeon_output->type == OUTPUT_DVI_I && (MonInfo->rawData[0x14] & 0x80)) /* if it's digital and DVI */
+	else if (radeon_output->type == OUTPUT_DVI_I &&
+		 (MonInfo->rawData[0x14] & 0x80)) /* if it's digital and DVI */
 	    MonType = MT_DFP;
 	else
 	    MonType = MT_CRT;
     } else
 	MonType = MT_NONE;
-    
+
     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 	       "Output: %s, Detected Monitor Type: %d\n", output->name, MonType);
 
@@ -537,7 +458,7 @@ radeon_mode_fixup(xf86OutputPtr output, DisplayModePtr mode,
 		if (IS_AVIVO_VARIANT) {
 		    /* set to the panel's native mode */
 		    adjusted_mode->HDisplay = radeon_output->PanelXRes;
-		    adjusted_mode->HDisplay = radeon_output->PanelYRes;
+		    adjusted_mode->VDisplay = radeon_output->PanelYRes;
 		    adjusted_mode->HTotal = radeon_output->PanelXRes + radeon_output->HBlank;
 		    adjusted_mode->HSyncStart = radeon_output->PanelXRes + radeon_output->HOverPlus;
 		    adjusted_mode->HSyncEnd = adjusted_mode->HSyncStart + radeon_output->HSyncWidth;
@@ -580,12 +501,20 @@ radeon_mode_fixup(xf86OutputPtr output, DisplayModePtr mode,
 	}
     }
 
+    if (IS_AVIVO_VARIANT) {
+	/* hw bug */
+	if ((mode->Flags & V_INTERLACE)
+	    && (mode->CrtcVSyncStart < (mode->CrtcVDisplay + 2)))
+	    adjusted_mode->CrtcVSyncStart = adjusted_mode->CrtcVDisplay + 2;
+    }
+
     return TRUE;
 }
 
 static void
 radeon_mode_prepare(xf86OutputPtr output)
 {
+    RADEONInfoPtr info = RADEONPTR(output->scrn);
     xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR (output->scrn);
     int o;
 
@@ -595,9 +524,12 @@ radeon_mode_prepare(xf86OutputPtr output)
 	    continue;
 	else if (loop_output->crtc) {
 	    xf86CrtcPtr other_crtc = loop_output->crtc;
+	    RADEONCrtcPrivatePtr other_radeon_crtc = other_crtc->driver_private;
 	    if (other_crtc->enabled) {
-		radeon_dpms(loop_output, DPMSModeOff);
 		radeon_crtc_dpms(other_crtc, DPMSModeOff);
+		if (IS_AVIVO_VARIANT)
+		    atombios_lock_crtc(info->atomBIOS, other_radeon_crtc->crtc_id, 1);
+		radeon_dpms(loop_output, DPMSModeOff);
 	    }
 	}
     }
@@ -625,6 +557,7 @@ radeon_mode_set(xf86OutputPtr output, DisplayModePtr mode,
 static void
 radeon_mode_commit(xf86OutputPtr output)
 {
+    RADEONInfoPtr info = RADEONPTR(output->scrn);
     xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR (output->scrn);
     int o;
 
@@ -634,9 +567,12 @@ radeon_mode_commit(xf86OutputPtr output)
 	    continue;
 	else if (loop_output->crtc) {
 	    xf86CrtcPtr other_crtc = loop_output->crtc;
+	    RADEONCrtcPrivatePtr other_radeon_crtc = other_crtc->driver_private;
 	    if (other_crtc->enabled) {
-		radeon_dpms(loop_output, DPMSModeOn);		
 		radeon_crtc_dpms(other_crtc, DPMSModeOn);
+		if (IS_AVIVO_VARIANT)
+		    atombios_lock_crtc(info->atomBIOS, other_radeon_crtc->crtc_id, 0);
+		radeon_dpms(loop_output, DPMSModeOn);
 	    }
 	}
     }
@@ -1682,8 +1618,8 @@ Bool AVIVOI2CReset(ScrnInfoPtr pScrn)
 }
 #endif
 
-static
-Bool AVIVOI2CDoLock(xf86OutputPtr output, int lock_state)
+Bool
+RADEONI2CDoLock(xf86OutputPtr output, int lock_state)
 {
     ScrnInfoPtr pScrn = output->scrn;
     RADEONInfoPtr  info       = RADEONPTR(pScrn);
@@ -1692,19 +1628,29 @@ Bool AVIVOI2CDoLock(xf86OutputPtr output, int lock_state)
     unsigned char *RADEONMMIO = info->MMIO;
     uint32_t temp;
 
+    if (lock_state) {
+	temp = INREG(pRADEONI2CBus->a_clk_reg);
+	temp &= ~(pRADEONI2CBus->a_clk_mask);
+	OUTREG(pRADEONI2CBus->a_clk_reg, temp);
+
+	temp = INREG(pRADEONI2CBus->a_data_reg);
+	temp &= ~(pRADEONI2CBus->a_data_mask);
+	OUTREG(pRADEONI2CBus->a_data_reg, temp);
+    }
+
     temp = INREG(pRADEONI2CBus->mask_clk_reg);
-    if (lock_state == AVIVO_I2C_ENABLE)
-	temp |= (pRADEONI2CBus->put_clk_mask);
+    if (lock_state)
+	temp |= (pRADEONI2CBus->mask_clk_mask);
     else
-	temp &= ~(pRADEONI2CBus->put_clk_mask);
+	temp &= ~(pRADEONI2CBus->mask_clk_mask);
     OUTREG(pRADEONI2CBus->mask_clk_reg, temp);
     temp = INREG(pRADEONI2CBus->mask_clk_reg);
 
     temp = INREG(pRADEONI2CBus->mask_data_reg);
-    if (lock_state == AVIVO_I2C_ENABLE)
-	temp |= (pRADEONI2CBus->put_data_mask);
+    if (lock_state)
+	temp |= (pRADEONI2CBus->mask_data_mask);
     else
-	temp &= ~(pRADEONI2CBus->put_data_mask);
+	temp &= ~(pRADEONI2CBus->mask_data_mask);
     OUTREG(pRADEONI2CBus->mask_data_reg, temp);
     temp = INREG(pRADEONI2CBus->mask_data_reg);
 
@@ -1786,8 +1732,10 @@ legacy_setup_i2c_bus(int ddc_line)
 {
     RADEONI2CBusRec i2c;
 
-    i2c.mask_clk_mask = RADEON_GPIO_EN_1 | RADEON_GPIO_Y_1;
-    i2c.mask_data_mask =  RADEON_GPIO_EN_0 | RADEON_GPIO_Y_0;
+    i2c.mask_clk_mask = RADEON_GPIO_EN_1;
+    i2c.mask_data_mask = RADEON_GPIO_EN_0;
+    i2c.a_clk_mask = RADEON_GPIO_A_1;
+    i2c.a_data_mask = RADEON_GPIO_A_0;
     i2c.put_clk_mask = RADEON_GPIO_EN_1;
     i2c.put_data_mask = RADEON_GPIO_EN_0;
     i2c.get_clk_mask = RADEON_GPIO_Y_1;
@@ -1796,6 +1744,8 @@ legacy_setup_i2c_bus(int ddc_line)
 	(ddc_line == RADEON_MDGPIO_EN_REG)) {
 	i2c.mask_clk_reg = ddc_line;
 	i2c.mask_data_reg = ddc_line;
+	i2c.a_clk_reg = ddc_line;
+	i2c.a_data_reg = ddc_line;
 	i2c.put_clk_reg = ddc_line;
 	i2c.put_data_reg = ddc_line;
 	i2c.get_clk_reg = ddc_line + 4;
@@ -1803,6 +1753,8 @@ legacy_setup_i2c_bus(int ddc_line)
     } else {
 	i2c.mask_clk_reg = ddc_line;
 	i2c.mask_data_reg = ddc_line;
+	i2c.a_clk_reg = ddc_line;
+	i2c.a_data_reg = ddc_line;
 	i2c.put_clk_reg = ddc_line;
 	i2c.put_data_reg = ddc_line;
 	i2c.get_clk_reg = ddc_line;
@@ -1829,6 +1781,8 @@ atom_setup_i2c_bus(int ddc_line)
 	i2c.get_data_mask = (1 << 18);
 	i2c.mask_clk_mask = (1 << 19);
 	i2c.mask_data_mask = (1 << 18);
+	i2c.a_clk_mask = (1 << 19);
+	i2c.a_data_mask = (1 << 18);
     } else {
 	i2c.put_clk_mask = (1 << 0);
 	i2c.put_data_mask = (1 << 8);
@@ -1836,9 +1790,13 @@ atom_setup_i2c_bus(int ddc_line)
 	i2c.get_data_mask = (1 << 8);
 	i2c.mask_clk_mask = (1 << 0);
 	i2c.mask_data_mask = (1 << 8);
+	i2c.a_clk_mask = (1 << 0);
+	i2c.a_data_mask = (1 << 8);
     }
     i2c.mask_clk_reg = ddc_line;
     i2c.mask_data_reg = ddc_line;
+    i2c.a_clk_reg = ddc_line + 0x4;
+    i2c.a_data_reg = ddc_line + 0x4;
     i2c.put_clk_reg = ddc_line + 0x8;
     i2c.put_data_reg = ddc_line + 0x8;
     i2c.get_clk_reg = ddc_line + 0xc;
@@ -2301,13 +2259,13 @@ static Bool RADEONSetupAppleConnectors(ScrnInfoPtr pScrn)
 	info->BiosConnector[0].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_DVI_DDC);
 	info->BiosConnector[0].DACType = DAC_NONE;
 	info->BiosConnector[0].TMDSType = TMDS_NONE;
-	info->BiosConnector[0].ConnectorType = CONNECTOR_VGA;
+	info->BiosConnector[0].ConnectorType = CONNECTOR_LVDS;
 	info->BiosConnector[0].valid = TRUE;
 
 	info->BiosConnector[1].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_VGA_DDC);
 	info->BiosConnector[1].DACType = DAC_PRIMARY;
-	info->BiosConnector[1].TMDSType = TMDS_INT;
-	info->BiosConnector[1].ConnectorType = CONNECTOR_DVI_I;
+	info->BiosConnector[1].TMDSType = TMDS_NONE;
+	info->BiosConnector[1].ConnectorType = CONNECTOR_VGA;
 	info->BiosConnector[1].valid = TRUE;
 
 	info->BiosConnector[2].ConnectorType = CONNECTOR_STV;
@@ -2677,7 +2635,6 @@ Bool RADEONSetupConnectors(ScrnInfoPtr pScrn)
 {
     xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
     RADEONInfoPtr info       = RADEONPTR(pScrn);
-    RADEONEntPtr pRADEONEnt  = RADEONEntPriv(pScrn);
     xf86OutputPtr output;
     char *optstr;
     int i = 0;
@@ -2742,13 +2699,6 @@ Bool RADEONSetupConnectors(ScrnInfoPtr pScrn)
 	    RADEONSetupGenericConnectors(pScrn);
     }
 
-    if (!pRADEONEnt->HasCRTC2) {
-	for (i = 0; i < RADEON_MAX_BIOS_CONNECTOR; i++) {
-	    if (info->BiosConnector[i].ConnectorType == CONNECTOR_VGA)
-		info->BiosConnector[i].DACType = DAC_PRIMARY;
-	}
-    }
-
     /* parse connector table option */
     optstr = (char *)xf86GetOptValString(info->Options, OPTION_CONNECTORTABLE);
 
diff --git a/src/radeon_pci_chipset_gen.h b/src/radeon_pci_chipset_gen.h
index 39adb5e..ff1801f 100644
--- a/src/radeon_pci_chipset_gen.h
+++ b/src/radeon_pci_chipset_gen.h
@@ -1,6 +1,7 @@
 /* This file is autogenerated please do not edit */
 PciChipsets RADEONPciChipsets[] = {
  { PCI_CHIP_RV380_3150, PCI_CHIP_RV380_3150, RES_SHARED_VGA },
+ { PCI_CHIP_RV380_3151, PCI_CHIP_RV380_3151, RES_SHARED_VGA },
  { PCI_CHIP_RV380_3152, PCI_CHIP_RV380_3152, RES_SHARED_VGA },
  { PCI_CHIP_RV380_3154, PCI_CHIP_RV380_3154, RES_SHARED_VGA },
  { PCI_CHIP_RV380_3E50, PCI_CHIP_RV380_3E50, RES_SHARED_VGA },
@@ -250,6 +251,9 @@ PciChipsets RADEONPciChipsets[] = {
  { PCI_CHIP_R600_940A, PCI_CHIP_R600_940A, RES_SHARED_VGA },
  { PCI_CHIP_R600_940B, PCI_CHIP_R600_940B, RES_SHARED_VGA },
  { PCI_CHIP_R600_940F, PCI_CHIP_R600_940F, RES_SHARED_VGA },
+ { PCI_CHIP_RV770_9440, PCI_CHIP_RV770_9440, RES_SHARED_VGA },
+ { PCI_CHIP_RV770_9441, PCI_CHIP_RV770_9441, RES_SHARED_VGA },
+ { PCI_CHIP_RV770_9442, PCI_CHIP_RV770_9442, RES_SHARED_VGA },
  { PCI_CHIP_RV610_94C0, PCI_CHIP_RV610_94C0, RES_SHARED_VGA },
  { PCI_CHIP_RV610_94C1, PCI_CHIP_RV610_94C1, RES_SHARED_VGA },
  { PCI_CHIP_RV610_94C3, PCI_CHIP_RV610_94C3, RES_SHARED_VGA },
@@ -267,6 +271,7 @@ PciChipsets RADEONPciChipsets[] = {
  { PCI_CHIP_RV670_9507, PCI_CHIP_RV670_9507, RES_SHARED_VGA },
  { PCI_CHIP_RV670_950F, PCI_CHIP_RV670_950F, RES_SHARED_VGA },
  { PCI_CHIP_RV670_9511, PCI_CHIP_RV670_9511, RES_SHARED_VGA },
+ { PCI_CHIP_RV670_9515, PCI_CHIP_RV670_9515, RES_SHARED_VGA },
  { PCI_CHIP_RV630_9580, PCI_CHIP_RV630_9580, RES_SHARED_VGA },
  { PCI_CHIP_RV630_9581, PCI_CHIP_RV630_9581, RES_SHARED_VGA },
  { PCI_CHIP_RV630_9583, PCI_CHIP_RV630_9583, RES_SHARED_VGA },
diff --git a/src/radeon_pci_device_match_gen.h b/src/radeon_pci_device_match_gen.h
index d81cbe3..d650f9f 100644
--- a/src/radeon_pci_device_match_gen.h
+++ b/src/radeon_pci_device_match_gen.h
@@ -1,6 +1,7 @@
 /* This file is autogenerated please do not edit */
 static const struct pci_id_match radeon_device_match[] = {
  ATI_DEVICE_MATCH( PCI_CHIP_RV380_3150, 0 ),
+ ATI_DEVICE_MATCH( PCI_CHIP_RV380_3151, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV380_3152, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV380_3154, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV380_3E50, 0 ),
@@ -250,6 +251,9 @@ static const struct pci_id_match radeon_device_match[] = {
  ATI_DEVICE_MATCH( PCI_CHIP_R600_940A, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_R600_940B, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_R600_940F, 0 ),
+ ATI_DEVICE_MATCH( PCI_CHIP_RV770_9440, 0 ),
+ ATI_DEVICE_MATCH( PCI_CHIP_RV770_9441, 0 ),
+ ATI_DEVICE_MATCH( PCI_CHIP_RV770_9442, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV610_94C0, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV610_94C1, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV610_94C3, 0 ),
@@ -267,6 +271,7 @@ static const struct pci_id_match radeon_device_match[] = {
  ATI_DEVICE_MATCH( PCI_CHIP_RV670_9507, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV670_950F, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV670_9511, 0 ),
+ ATI_DEVICE_MATCH( PCI_CHIP_RV670_9515, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV630_9580, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV630_9581, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_RV630_9583, 0 ),
diff --git a/src/radeon_probe.h b/src/radeon_probe.h
index 24af52b..ce4ba93 100644
--- a/src/radeon_probe.h
+++ b/src/radeon_probe.h
@@ -166,6 +166,8 @@ typedef struct
     Bool   valid;
     uint32_t mask_clk_reg;
     uint32_t mask_data_reg;
+    uint32_t a_clk_reg;
+    uint32_t a_data_reg;
     uint32_t put_clk_reg;
     uint32_t put_data_reg;
     uint32_t get_clk_reg;
@@ -176,15 +178,13 @@ typedef struct
     uint32_t put_data_mask;
     uint32_t get_clk_mask;
     uint32_t get_data_mask;
+    uint32_t a_clk_mask;
+    uint32_t a_data_mask;
 } RADEONI2CBusRec, *RADEONI2CBusPtr;
 
 typedef struct _RADEONCrtcPrivateRec {
-#ifdef USE_XAA
-    FBLinearPtr rotate_mem_xaa;
-#endif
-#ifdef USE_EXA
-    ExaOffscreenArea *rotate_mem_exa;
-#endif
+    void *crtc_rotate_mem;
+    void *cursor_mem;
     int crtc_id;
     int binding;
     uint32_t cursor_offset;
@@ -310,8 +310,10 @@ struct avivo_grph_state {
     uint32_t x_end;
     uint32_t y_end;
 
+    uint32_t desktop_height;
     uint32_t viewport_start;
     uint32_t viewport_size;
+    uint32_t mode_data_format;
 };
 
 struct avivo_state
@@ -326,6 +328,7 @@ struct avivo_state
 
     uint32_t crtc_master_en;
     uint32_t crtc_tv_control;
+    uint32_t dc_lb_memory_split;
 
     struct avivo_pll_state pll1;
     struct avivo_pll_state pll2;
diff --git a/src/radeon_reg.h b/src/radeon_reg.h
index 59e2f12..19f9869 100644
--- a/src/radeon_reg.h
+++ b/src/radeon_reg.h
@@ -1032,6 +1032,10 @@
 #define RADEON_OV0_BASE_ADDR                0x43c
 #define RADEON_NB_TOM                       0x15c
 #define R300_MC_INIT_MISC_LAT_TIMER         0x180
+#       define R300_MC_DISP0R_INIT_LAT_SHIFT 8
+#       define R300_MC_DISP0R_INIT_LAT_MASK  0xf
+#       define R300_MC_DISP1R_INIT_LAT_SHIFT 12
+#       define R300_MC_DISP1R_INIT_LAT_MASK  0xf
 #define RADEON_MCLK_CNTL                    0x0012 /* PLL */
 #       define RADEON_FORCEON_MCLKA         (1 << 16)
 #       define RADEON_FORCEON_MCLKB         (1 << 17)
@@ -3185,6 +3189,7 @@
 #define RADEON_CP_VC_CNTL_PRIM_TYPE_RECT_LIST       0x00000008
 #define RADEON_CP_VC_CNTL_PRIM_TYPE_3VRT_POINT_LIST 0x00000009
 #define RADEON_CP_VC_CNTL_PRIM_TYPE_3VRT_LINE_LIST  0x0000000a
+#define RADEON_CP_VC_CNTL_PRIM_TYPE_QUAD_LIST       0x0000000d
 #define RADEON_CP_VC_CNTL_PRIM_WALK_IND             0x00000010
 #define RADEON_CP_VC_CNTL_PRIM_WALK_LIST            0x00000020
 #define RADEON_CP_VC_CNTL_PRIM_WALK_RING            0x00000030
@@ -3418,6 +3423,7 @@
 #define RS690_MC_AGP_LOCATION			0x101
 #define RS690_MC_AGP_BASE			0x102
 #define RS690_MC_AGP_BASE_2                     0x103
+#define RS690_MC_INIT_MISC_LAT_TIMER            0x104
 #define RS690_MC_STATUS                         0x90
 #define RS690_MC_STATUS_IDLE                    (1 << 0)
 
@@ -3431,12 +3437,13 @@
 #define RS600_MC_STATUS                         0x0
 #define RS600_MC_STATUS_IDLE                    (1 << 0)
 
-#define AVIVO_MC_INDEX						0x0070
-#define R520_MC_STATUS 0x00
-#define R520_MC_STATUS_IDLE (1<<1)
-#define RV515_MC_STATUS 0x08
-#define RV515_MC_STATUS_IDLE (1<<4)
-#define AVIVO_MC_DATA						0x0074
+#define AVIVO_MC_INDEX				0x0070
+#define R520_MC_STATUS                          0x00
+#       define R520_MC_STATUS_IDLE              (1 << 1)
+#define RV515_MC_STATUS                         0x08
+#       define RV515_MC_STATUS_IDLE             (1 << 4)
+#define RV515_MC_INIT_MISC_LAT_TIMER            0x09
+#define AVIVO_MC_DATA				0x0074
 
 #define RV515_MC_FB_LOCATION   0x1
 #define RV515_MC_AGP_LOCATION  0x2
@@ -3598,8 +3605,20 @@
 #define AVIVO_DC_LUTA_WHITE_OFFSET_GREEN        0x64d4
 #define AVIVO_DC_LUTA_WHITE_OFFSET_RED          0x64d8
 
-
-#define AVIVO_D1MODE_DESKTOP_HEIGHT             0x652C
+#define AVIVO_DC_LB_MEMORY_SPLIT                0x6520
+#       define AVIVO_DC_LB_MEMORY_SPLIT_MASK    0x3
+#       define AVIVO_DC_LB_MEMORY_SPLIT_SHIFT   0
+#       define AVIVO_DC_LB_MEMORY_SPLIT_D1HALF_D2HALF  0
+#       define AVIVO_DC_LB_MEMORY_SPLIT_D1_3Q_D2_1Q    1
+#       define AVIVO_DC_LB_MEMORY_SPLIT_D1_ONLY        2
+#       define AVIVO_DC_LB_MEMORY_SPLIT_D1_1Q_D2_3Q    3
+#       define AVIVO_DC_LB_MEMORY_SPLIT_SHIFT_MODE (1 << 2)
+#       define AVIVO_DC_LB_DISP1_END_ADR_SHIFT  4
+#       define AVIVO_DC_LB_DISP1_END_ADR_MASK   0x7ff
+
+#define AVIVO_D1MODE_DATA_FORMAT                0x6528
+#       define AVIVO_D1MODE_INTERLEAVE_EN       (1 << 0)
+#define AVIVO_D1MODE_DESKTOP_HEIGHT             0x652c
 #define AVIVO_D1MODE_VIEWPORT_START             0x6580
 #define AVIVO_D1MODE_VIEWPORT_SIZE              0x6584
 #define AVIVO_D1MODE_EXT_OVERSCAN_LEFT_RIGHT    0x6588
@@ -3651,6 +3670,8 @@
 #define AVIVO_D2CUR_SIZE                        0x6c10
 #define AVIVO_D2CUR_POSITION                    0x6c14
 
+#define AVIVO_D2MODE_DATA_FORMAT                0x6d28
+#define AVIVO_D2MODE_DESKTOP_HEIGHT             0x6d2c
 #define AVIVO_D2MODE_VIEWPORT_START             0x6d80
 #define AVIVO_D2MODE_VIEWPORT_SIZE              0x6d84
 #define AVIVO_D2MODE_EXT_OVERSCAN_LEFT_RIGHT    0x6d88
@@ -3658,6 +3679,7 @@
 
 #define AVIVO_D2SCL_SCALER_ENABLE               0x6d90
 #define AVIVO_D2SCL_SCALER_TAP_CONTROL	 	0x6d94
+#define AVIVO_D2SCL_UPDATE                      0x6dcc
 
 #define AVIVO_DDIA_BIT_DEPTH_CONTROL				0x7214
 
@@ -3918,6 +3940,8 @@
 #define R600_MC_VM_SYSTEM_APERTURE_HIGH_ADDR                       0x2194
 #define R600_MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR                    0x2198
 
+#define R700_MC_VM_FB_LOCATION                                     0x2024
+
 #define R600_HDP_NONSURFACE_BASE                                0x2c04
 
 #define R600_BUS_CNTL                                           0x5420
@@ -4234,7 +4258,7 @@
 #define R300_PVS_SRC_ADDR_SEL(x)                        (x << 29)
 #define R300_PVS_SRC_ADDR_MODE_1                        (1 << 31)
 
-#define R300_VAP_PVS_FLOW_CNTL_OPC		        0x22DC
+#define R300_VAP_PVS_FLOW_CNTL_OPC		        0x22dc
 #define R300_VAP_OUT_VTX_FMT_0			        0x2090
 #       define R300_VTX_POS_PRESENT                     (1 << 0)
 #       define R300_VTX_COLOR_0_PRESENT                 (1 << 1)
@@ -4322,6 +4346,7 @@
 
 #define R300_TX_INVALTAGS				0x4100
 #define R300_TX_FILTER0_0				0x4400
+#define R300_TX_FILTER0_1				0x4404
 #       define R300_TX_CLAMP_S(x)                       (x << 0)
 #       define R300_TX_CLAMP_T(x)                       (x << 3)
 #       define R300_TX_CLAMP_R(x)                       (x << 6)
@@ -4339,7 +4364,9 @@
 #       define R300_TX_MIN_FILTER_LINEAR                (2 << 11)
 #       define R300_TX_ID_SHIFT                         28
 #define R300_TX_FILTER1_0				0x4440
+#define R300_TX_FILTER1_1				0x4444
 #define R300_TX_FORMAT0_0				0x4480
+#define R300_TX_FORMAT0_1				0x4484
 #       define R300_TXWIDTH_SHIFT                       0
 #       define R300_TXHEIGHT_SHIFT                      11
 #       define R300_NUM_LEVELS_SHIFT                    26
@@ -4347,6 +4374,7 @@
 #       define R300_TXPROJECTED                         (1 << 30)
 #       define R300_TXPITCH_EN                          (1 << 31)
 #define R300_TX_FORMAT1_0				0x44c0
+#define R300_TX_FORMAT1_1				0x44c4
 #	define R300_TX_FORMAT_X8		    0x0
 #	define R300_TX_FORMAT_X16		    0x1
 #	define R300_TX_FORMAT_Y4X4		    0x2
@@ -4420,10 +4448,12 @@
 #       define R300_TX_FORMAT_SWAP_YUV                 (1 << 24)
 
 #define R300_TX_FORMAT2_0				0x4500
+#define R300_TX_FORMAT2_1				0x4504
 #       define R500_TXWIDTH_11                          (1 << 15)
 #       define R500_TXHEIGHT_11                         (1 << 16)
 
 #define R300_TX_OFFSET_0				0x4540
+#define R300_TX_OFFSET_1				0x4544
 #       define R300_ENDIAN_SWAP_16_BIT                  (1 << 0)
 #       define R300_ENDIAN_SWAP_32_BIT                  (2 << 0)
 #       define R300_ENDIAN_SWAP_HALF_DWORD              (3 << 0)
@@ -4500,6 +4530,7 @@
 #define R300_US_TEX_INST_0				0x4620
 #define R300_US_TEX_INST_1				0x4624
 #define R300_US_TEX_INST_2				0x4628
+#define R300_US_TEX_INST(x)			        (R300_US_TEX_INST_0 + (x)*4)
 #       define R300_TEX_SRC_ADDR(x)                     (x << 0)
 #       define R300_TEX_DST_ADDR(x)                     (x << 6)
 #       define R300_TEX_ID(x)                           (x << 11)
@@ -4512,11 +4543,13 @@
 #define R300_US_ALU_RGB_ADDR_0			        0x46c0
 #define R300_US_ALU_RGB_ADDR_1			        0x46c4
 #define R300_US_ALU_RGB_ADDR_2			        0x46c8
+#define R300_US_ALU_RGB_ADDR(x)			        (R300_US_ALU_RGB_ADDR_0 + (x)*4)
 /* for ADDR0-2, values 0-31 specify a location in the pixel stack,
    values 32-63 specify a constant */
 #       define R300_ALU_RGB_ADDR0(x)                    (x << 0)
 #       define R300_ALU_RGB_ADDR1(x)                    (x << 6)
 #       define R300_ALU_RGB_ADDR2(x)                    (x << 12)
+#       define R300_ALU_RGB_CONST(x)                    ((x) | (1 << 5))
 /* ADDRD - where on the pixel stack the result of this instruction
    will be written */
 #       define R300_ALU_RGB_ADDRD(x)                    (x << 18)
@@ -4526,6 +4559,7 @@
 #       define R300_ALU_RGB_MASK_R                      1
 #       define R300_ALU_RGB_MASK_G                      2
 #       define R300_ALU_RGB_MASK_B                      4
+#       define R300_ALU_RGB_MASK_RGB                    7
 #       define R300_ALU_RGB_TARGET_A                    (0 << 29)
 #       define R300_ALU_RGB_TARGET_B                    (1 << 29)
 #       define R300_ALU_RGB_TARGET_C                    (2 << 29)
@@ -4533,6 +4567,7 @@
 #define R300_US_ALU_RGB_INST_0			        0x48c0
 #define R300_US_ALU_RGB_INST_1			        0x48c4
 #define R300_US_ALU_RGB_INST_2			        0x48c8
+#define R300_US_ALU_RGB_INST(x)			        (R300_US_ALU_RGB_INST_0 + (x)*4)
 #       define R300_ALU_RGB_SEL_A(x)                    (x << 0)
 #       define R300_ALU_RGB_SRC0_RGB                    0
 #       define R300_ALU_RGB_SRC0_RRR                    1
@@ -4604,11 +4639,13 @@
 #define R300_US_ALU_ALPHA_ADDR_0		        0x47c0
 #define R300_US_ALU_ALPHA_ADDR_1		        0x47c4
 #define R300_US_ALU_ALPHA_ADDR_2		        0x47c8
+#define R300_US_ALU_ALPHA_ADDR(x)		        (R300_US_ALU_ALPHA_ADDR_0 + (x)*4)
 /* for ADDR0-2, values 0-31 specify a location in the pixel stack,
    values 32-63 specify a constant */
 #       define R300_ALU_ALPHA_ADDR0(x)                  (x << 0)
 #       define R300_ALU_ALPHA_ADDR1(x)                  (x << 6)
 #       define R300_ALU_ALPHA_ADDR2(x)                  (x << 12)
+#       define R300_ALU_ALPHA_CONST(x)                  ((x) | (1 << 5))
 /* ADDRD - where on the pixel stack the result of this instruction
    will be written */
 #       define R300_ALU_ALPHA_ADDRD(x)                  (x << 18)
@@ -4624,6 +4661,7 @@
 #define R300_US_ALU_ALPHA_INST_0		        0x49c0
 #define R300_US_ALU_ALPHA_INST_1		        0x49c4
 #define R300_US_ALU_ALPHA_INST_2		        0x49c8
+#define R300_US_ALU_ALPHA_INST(x)		        (R300_US_ALU_ALPHA_INST_0 + (x)*4)
 #       define R300_ALU_ALPHA_SEL_A(x)                  (x << 0)
 #       define R300_ALU_ALPHA_SRC0_R                    0
 #       define R300_ALU_ALPHA_SRC0_G                    1
@@ -4680,6 +4718,15 @@
 #       define R300_ALU_ALPHA_OMOD_DIV_8                6
 #       define R300_ALU_ALPHA_CLAMP                     (1 << 30)
 
+#define R300_US_ALU_CONST_R_0                           0x4c00
+#define R300_US_ALU_CONST_R(x)                          (R300_US_ALU_CONST_R_0 + (x)*16)
+#define R300_US_ALU_CONST_G_0                           0x4c04
+#define R300_US_ALU_CONST_G(x)                          (R300_US_ALU_CONST_G_0 + (x)*16)
+#define R300_US_ALU_CONST_B_0                           0x4c08
+#define R300_US_ALU_CONST_B(x)                          (R300_US_ALU_CONST_B_0 + (x)*16)
+#define R300_US_ALU_CONST_A_0                           0x4c0c
+#define R300_US_ALU_CONST_A(x)                          (R300_US_ALU_CONST_A_0 + (x)*16)
+
 #define R300_FG_DEPTH_SRC				0x4bd8
 #define R300_FG_FOG_BLEND				0x4bc0
 #define R300_FG_ALPHA_FUNC				0x4bd4
@@ -4759,10 +4806,11 @@
 
 /* R500 US has to be loaded through an index/data pair */
 #define R500_GA_US_VECTOR_INDEX				0x4250
-#   define R500_US_VECTOR_INDEX(x)			(x << 0)
 #   define R500_US_VECTOR_TYPE_INST			(0 << 16)
 #   define R500_US_VECTOR_TYPE_CONST			(1 << 16)
 #   define R500_US_VECTOR_CLAMP				(1 << 17)
+#   define R500_US_VECTOR_INST_INDEX(x)			((x) | R500_US_VECTOR_TYPE_INST)
+#   define R500_US_VECTOR_CONST_INDEX(x)		((x) | R500_US_VECTOR_TYPE_CONST)
 #define R500_GA_US_VECTOR_DATA				0x4254
 
 /*
diff --git a/src/radeon_render.c b/src/radeon_render.c
index dbd5b79..6668fe0 100644
--- a/src/radeon_render.c
+++ b/src/radeon_render.c
@@ -268,7 +268,7 @@ RemoveLinear (FBLinearPtr linear)
 {
    RADEONInfoPtr info = (RADEONInfoPtr)(linear->devPrivate.ptr);
 
-   info->RenderTex = NULL; 
+   info->accel_state->RenderTex = NULL; 
 }
 
 static void
@@ -276,13 +276,14 @@ RenderCallback (ScrnInfoPtr pScrn)
 {
     RADEONInfoPtr  info       = RADEONPTR(pScrn);
 
-    if ((currentTime.milliseconds > info->RenderTimeout) && info->RenderTex) {
-	xf86FreeOffscreenLinear(info->RenderTex);
-	info->RenderTex = NULL;
+    if ((currentTime.milliseconds > info->accel_state->RenderTimeout) &&
+	info->accel_state->RenderTex) {
+	xf86FreeOffscreenLinear(info->accel_state->RenderTex);
+	info->accel_state->RenderTex = NULL;
     }
 
-    if (!info->RenderTex)
-	info->RenderCallback = NULL;
+    if (!info->accel_state->RenderTex)
+	info->accel_state->RenderCallback = NULL;
 }
 
 static Bool
@@ -293,30 +294,30 @@ AllocateLinear (
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    int cpp = info->CurrentLayout.bitsPerPixel / 8;
 
-   info->RenderTimeout = currentTime.milliseconds + 30000;
-   info->RenderCallback = RenderCallback;
+   info->accel_state->RenderTimeout = currentTime.milliseconds + 30000;
+   info->accel_state->RenderCallback = RenderCallback;
 
    /* XAA allocates in units of pixels at the screen bpp, so adjust size
     * appropriately.
     */
    sizeNeeded = (sizeNeeded + cpp - 1) / cpp;
 
-   if (info->RenderTex) {
-	if (info->RenderTex->size >= sizeNeeded)
+   if (info->accel_state->RenderTex) {
+	if (info->accel_state->RenderTex->size >= sizeNeeded)
 	   return TRUE;
 	else {
-	   if (xf86ResizeOffscreenLinear(info->RenderTex, sizeNeeded))
+	   if (xf86ResizeOffscreenLinear(info->accel_state->RenderTex, sizeNeeded))
 		return TRUE;
 
-	   xf86FreeOffscreenLinear(info->RenderTex);
-	   info->RenderTex = NULL;
+	   xf86FreeOffscreenLinear(info->accel_state->RenderTex);
+	   info->accel_state->RenderTex = NULL;
 	}
    }
 
-   info->RenderTex = xf86AllocateOffscreenLinear(pScrn->pScreen, sizeNeeded, 32,
-						 NULL, RemoveLinear, info);
+   info->accel_state->RenderTex = xf86AllocateOffscreenLinear(pScrn->pScreen, sizeNeeded, 32,
+							      NULL, RemoveLinear, info);
 
-   return (info->RenderTex != NULL);
+   return (info->accel_state->RenderTex != NULL);
 }
 
 #if X_BYTE_ORDER == X_BIG_ENDIAN
@@ -435,7 +436,7 @@ static Bool FUNC_NAME(R100SetupTexture)(
 	txformat |= RADEON_TXFORMAT_NON_POWER2;
     }
 
-    offset = info->RenderTex->offset * pScrn->bitsPerPixel / 8;
+    offset = info->accel_state->RenderTex->offset * pScrn->bitsPerPixel / 8;
     dst = (uint8_t*)(info->FB + offset);
 
     /* Upload texture to card. */
@@ -459,8 +460,8 @@ static Bool FUNC_NAME(R100SetupTexture)(
 
 #else
 
-    if (info->accel->NeedToSync)
-	info->accel->Sync(pScrn);
+    if (info->accel_state->accel->NeedToSync)
+	info->accel_state->accel->Sync(pScrn);
 
     while (height--) {
 	memcpy(dst, src, width * tex_bytepp);
@@ -514,7 +515,7 @@ FUNC_NAME(R100SetupForCPUToScreenAlphaTexture) (
     if (blend_cntl == 0)
 	return FALSE;
 
-    if (!info->XInited3D)
+    if (!info->accel_state->XInited3D)
 	RADEONInit3DEngine(pScrn);
 
     if (!FUNC_NAME(R100SetupTexture)(pScrn, maskFormat, alphaPtr, alphaPitch,
@@ -565,7 +566,7 @@ FUNC_NAME(R100SetupForCPUToScreenTexture) (
     if (blend_cntl == 0)
 	return FALSE;
     
-    if (!info->XInited3D)
+    if (!info->accel_state->XInited3D)
 	RADEONInit3DEngine(pScrn);
 
     if (!FUNC_NAME(R100SetupTexture)(pScrn, srcFormat, texPtr, texPitch, width,
@@ -772,10 +773,10 @@ static Bool FUNC_NAME(R200SetupTexture)(
 	txformat |= RADEON_TXFORMAT_NON_POWER2;
     }
 
-    info->texW[0] = width;
-    info->texH[0] = height;
+    info->accel_state->texW[0] = width;
+    info->accel_state->texH[0] = height;
 
-    offset = info->RenderTex->offset * pScrn->bitsPerPixel / 8;
+    offset = info->accel_state->RenderTex->offset * pScrn->bitsPerPixel / 8;
     dst = (uint8_t*)(info->FB + offset);
 
     /* Upload texture to card. */
@@ -799,8 +800,8 @@ static Bool FUNC_NAME(R200SetupTexture)(
 
 #else
 
-    if (info->accel->NeedToSync)
-	info->accel->Sync(pScrn);
+    if (info->accel_state->accel->NeedToSync)
+	info->accel_state->accel->Sync(pScrn);
 
     while (height--) {
 	memcpy(dst, src, width * tex_bytepp);
@@ -855,7 +856,7 @@ FUNC_NAME(R200SetupForCPUToScreenAlphaTexture) (
     if (blend_cntl == 0)
 	return FALSE;
 
-    if (!info->XInited3D)
+    if (!info->accel_state->XInited3D)
 	RADEONInit3DEngine(pScrn);
 
     if (!FUNC_NAME(R200SetupTexture)(pScrn, maskFormat, alphaPtr, alphaPitch,
@@ -907,7 +908,7 @@ FUNC_NAME(R200SetupForCPUToScreenTexture) (
     if (blend_cntl == 0)
 	return FALSE;
 
-    if (!info->XInited3D)
+    if (!info->accel_state->XInited3D)
 	RADEONInit3DEngine(pScrn);
 
     if (!FUNC_NAME(R200SetupTexture)(pScrn, srcFormat, texPtr, texPitch, width,
@@ -974,10 +975,10 @@ FUNC_NAME(R200SubsequentCPUToScreenTexture) (
     
     r = width + l;
     b = height + t;
-    fl = (float)srcx / info->texW[0];
-    fr = (float)(srcx + width) / info->texW[0];
-    ft = (float)srcy / info->texH[0];
-    fb = (float)(srcy + height) / info->texH[0];
+    fl = (float)srcx / info->accel_state->texW[0];
+    fr = (float)(srcx + width) / info->accel_state->texW[0];
+    ft = (float)srcy / info->accel_state->texH[0];
+    fb = (float)(srcy + height) / info->accel_state->texH[0];
 
 #ifdef ACCEL_CP
     BEGIN_RING(24);
diff --git a/src/radeon_sarea.h b/src/radeon_sarea.h
deleted file mode 100644
index 80333a4..0000000
--- a/src/radeon_sarea.h
+++ /dev/null
@@ -1,231 +0,0 @@
-/*
- * Copyright 2000 ATI Technologies Inc., Markham, Ontario,
- *                VA Linux Systems Inc., Fremont, California.
- *
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation on the rights to use, copy, modify, merge,
- * publish, distribute, sublicense, and/or sell copies of the Software,
- * and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial
- * portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NON-INFRINGEMENT.  IN NO EVENT SHALL ATI, VA LINUX SYSTEMS AND/OR
- * THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-/*
- * Authors:
- *   Kevin E. Martin <martin@xfree86.org>
- *   Gareth Hughes <gareth@valinux.com>
- *
- */
-
-#ifndef _RADEON_SAREA_H_
-#define _RADEON_SAREA_H_
-
-/* WARNING: If you change any of these defines, make sure to change the
- * defines in the kernel file (radeon_drm.h)
- */
-#ifndef __RADEON_SAREA_DEFINES__
-#define __RADEON_SAREA_DEFINES__
-
-/* What needs to be changed for the current vertex buffer? */
-#define RADEON_UPLOAD_CONTEXT		0x00000001
-#define RADEON_UPLOAD_VERTFMT		0x00000002
-#define RADEON_UPLOAD_LINE		0x00000004
-#define RADEON_UPLOAD_BUMPMAP		0x00000008
-#define RADEON_UPLOAD_MASKS		0x00000010
-#define RADEON_UPLOAD_VIEWPORT		0x00000020
-#define RADEON_UPLOAD_SETUP		0x00000040
-#define RADEON_UPLOAD_TCL		0x00000080
-#define RADEON_UPLOAD_MISC		0x00000100
-#define RADEON_UPLOAD_TEX0		0x00000200
-#define RADEON_UPLOAD_TEX1		0x00000400
-#define RADEON_UPLOAD_TEX2		0x00000800
-#define RADEON_UPLOAD_TEX0IMAGES	0x00001000
-#define RADEON_UPLOAD_TEX1IMAGES	0x00002000
-#define RADEON_UPLOAD_TEX2IMAGES	0x00004000
-#define RADEON_UPLOAD_CLIPRECTS		0x00008000 /* handled client-side */
-#define RADEON_REQUIRE_QUIESCENCE	0x00010000
-#define RADEON_UPLOAD_ZBIAS		0x00020000
-#define RADEON_UPLOAD_ALL		0x0002ffff
-#define RADEON_UPLOAD_CONTEXT_ALL       0x000201ff
-
-#define RADEON_FRONT			0x1
-#define RADEON_BACK			0x2
-#define RADEON_DEPTH			0x4
-#define RADEON_STENCIL                  0x8
-
-/* Primitive types */
-#define RADEON_POINTS			0x1
-#define RADEON_LINES			0x2
-#define RADEON_LINE_STRIP		0x3
-#define RADEON_TRIANGLES		0x4
-#define RADEON_TRIANGLE_FAN		0x5
-#define RADEON_TRIANGLE_STRIP		0x6
-#define RADEON_3VTX_POINTS		0x9
-#define RADEON_3VTX_LINES		0xa
-
-/* Vertex/indirect buffer size */
-#define RADEON_BUFFER_SIZE		65536
-
-/* Byte offsets for indirect buffer data */
-#define RADEON_INDEX_PRIM_OFFSET	20
-#define RADEON_HOSTDATA_BLIT_OFFSET	32
-
-#define RADEON_SCRATCH_REG_OFFSET	32
-
-/* Keep these small for testing */
-#define RADEON_NR_SAREA_CLIPRECTS	12
-
-/* There are 2 heaps (local/GART).  Each region within a heap is a
- * minimum of 64k, and there are at most 64 of them per heap.
- */
-#define RADEON_CARD_HEAP		0
-#define RADEON_GART_HEAP		1
-#define RADEON_NR_TEX_HEAPS		2
-#define RADEON_NR_TEX_REGIONS		64
-#define RADEON_LOG_TEX_GRANULARITY	16
-
-#define RADEON_MAX_TEXTURE_LEVELS	12
-#define RADEON_MAX_TEXTURE_UNITS	3
-
-/* Blits have strict offset rules.  All blit offset must be aligned on
- * a 1K-byte boundary.
- */
-#define RADEON_OFFSET_SHIFT		10
-#define RADEON_OFFSET_ALIGN		(1 << RADEON_OFFSET_SHIFT)
-#define RADEON_OFFSET_MASK		(RADEON_OFFSET_ALIGN - 1)
-
-#endif /* __RADEON_SAREA_DEFINES__ */
-
-typedef struct {
-    unsigned int red;
-    unsigned int green;
-    unsigned int blue;
-    unsigned int alpha;
-} radeon_color_regs_t;
-
-typedef struct {
-    /* Context state */
-    unsigned int pp_misc;
-    unsigned int pp_fog_color;
-    unsigned int re_solid_color;
-    unsigned int rb3d_blendcntl;
-    unsigned int rb3d_depthoffset;
-    unsigned int rb3d_depthpitch;
-    unsigned int rb3d_zstencilcntl;
-
-    unsigned int pp_cntl;
-    unsigned int rb3d_cntl;
-    unsigned int rb3d_coloroffset;
-    unsigned int re_width_height;
-    unsigned int rb3d_colorpitch;
-    unsigned int se_cntl;
-
-    /* Vertex format state */
-    unsigned int se_coord_fmt;
-
-    /* Line state */
-    unsigned int re_line_pattern;
-    unsigned int re_line_state;
-
-    unsigned int se_line_width;
-
-    /* Bumpmap state */
-    unsigned int pp_lum_matrix;
-
-    unsigned int pp_rot_matrix_0;
-    unsigned int pp_rot_matrix_1;
-
-    /* Mask state */
-    unsigned int rb3d_stencilrefmask;
-    unsigned int rb3d_ropcntl;
-    unsigned int rb3d_planemask;
-
-    /* Viewport state */
-    unsigned int se_vport_xscale;
-    unsigned int se_vport_xoffset;
-    unsigned int se_vport_yscale;
-    unsigned int se_vport_yoffset;
-    unsigned int se_vport_zscale;
-    unsigned int se_vport_zoffset;
-
-    /* Setup state */
-    unsigned int se_cntl_status;
-
-    /* Misc state */
-    unsigned int re_top_left;
-    unsigned int re_misc;
-} radeon_context_regs_t;
-
-/* Setup registers for each texture unit */
-typedef struct {
-    unsigned int pp_txfilter;
-    unsigned int pp_txformat;
-    unsigned int pp_txoffset;
-    unsigned int pp_txcblend;
-    unsigned int pp_txablend;
-    unsigned int pp_tfactor;
-    unsigned int pp_border_color;
-} radeon_texture_regs_t;
-
-typedef struct {
-    /* The channel for communication of state information to the kernel
-     * on firing a vertex buffer.
-     */
-    radeon_context_regs_t ContextState;
-    radeon_texture_regs_t TexState[RADEON_MAX_TEXTURE_UNITS];
-    unsigned int dirty;
-    unsigned int vertsize;
-    unsigned int vc_format;
-
-    /* The current cliprects, or a subset thereof */
-    drm_clip_rect_t boxes[RADEON_NR_SAREA_CLIPRECTS];
-    unsigned int nbox;
-
-    /* Counters for throttling of rendering clients */
-    unsigned int last_frame;
-    unsigned int last_dispatch;
-    unsigned int last_clear;
-
-    /* Maintain an LRU of contiguous regions of texture space.  If you
-     * think you own a region of texture memory, and it has an age
-     * different to the one you set, then you are mistaken and it has
-     * been stolen by another client.  If global texAge hasn't changed,
-     * there is no need to walk the list.
-     *
-     * These regions can be used as a proxy for the fine-grained texture
-     * information of other clients - by maintaining them in the same
-     * lru which is used to age their own textures, clients have an
-     * approximate lru for the whole of global texture space, and can
-     * make informed decisions as to which areas to kick out.  There is
-     * no need to choose whether to kick out your own texture or someone
-     * else's - simply eject them all in LRU order.
-     */
-				/* Last elt is sentinal */
-    drmTextureRegion texList[RADEON_NR_TEX_HEAPS][RADEON_NR_TEX_REGIONS+1];
-				/* last time texture was uploaded */
-    unsigned int texAge[RADEON_NR_TEX_HEAPS];
-
-    int ctxOwner;		/* last context to upload state */
-    int pfAllowPageFlip;	/* set by the 2d driver, read by the client */
-    int pfCurrentPage;		/* set by kernel, read by others */
-    int crtc2_base;		/* for pageflipping with CloneMode */
-    int tiling_enabled;         /* set by drm, read by 2d + 3d clients */
- } RADEONSAREAPriv, *RADEONSAREAPrivPtr;
-
-#endif
diff --git a/src/radeon_textured_video.c b/src/radeon_textured_video.c
index cfa349d..4005df9 100644
--- a/src/radeon_textured_video.c
+++ b/src/radeon_textured_video.c
@@ -81,33 +81,43 @@ static __inline__ uint32_t F_TO_DW(float val)
 }
 
 #define ACCEL_MMIO
-#define VIDEO_PREAMBLE()	unsigned char *RADEONMMIO = info->MMIO
-#define BEGIN_VIDEO(n)		RADEONWaitForFifo(pScrn, (n))
-#define OUT_VIDEO_REG(reg, val)	OUTREG(reg, val)
-#define OUT_VIDEO_REG_F(reg, val) OUTREG(reg, F_TO_DW(val))
-#define FINISH_VIDEO()
+#define ACCEL_PREAMBLE()	unsigned char *RADEONMMIO = info->MMIO
+#define BEGIN_ACCEL(n)		RADEONWaitForFifo(pScrn, (n))
+#define OUT_ACCEL_REG(reg, val)	OUTREG(reg, val)
+#define OUT_ACCEL_REG_F(reg, val) OUTREG(reg, F_TO_DW(val))
+#define FINISH_ACCEL()
 
 #include "radeon_textured_videofuncs.c"
 
 #undef ACCEL_MMIO
-#undef VIDEO_PREAMBLE
-#undef BEGIN_VIDEO
-#undef OUT_VIDEO_REG
-#undef FINISH_VIDEO
+#undef ACCEL_PREAMBLE
+#undef BEGIN_ACCEL
+#undef OUT_ACCEL_REG
+#undef OUT_ACCEL_REG_F
+#undef FINISH_ACCEL
 
 #ifdef XF86DRI
 
 #define ACCEL_CP
-#define VIDEO_PREAMBLE()						\
+#define ACCEL_PREAMBLE()						\
     RING_LOCALS;							\
     RADEONCP_REFRESH(pScrn, info)
-#define BEGIN_VIDEO(n)		BEGIN_RING(2*(n))
-#define OUT_VIDEO_REG(reg, val)	OUT_RING_REG(reg, val)
-#define FINISH_VIDEO()		ADVANCE_RING()
-#define OUT_VIDEO_RING_F(x) OUT_RING(F_TO_DW(x))
+#define BEGIN_ACCEL(n)		BEGIN_RING(2*(n))
+#define OUT_ACCEL_REG(reg, val)	OUT_RING_REG(reg, val)
+#define OUT_ACCEL_REG_F(reg, val)	OUT_ACCEL_REG(reg, F_TO_DW(val))
+#define FINISH_ACCEL()		ADVANCE_RING()
+#define OUT_RING_F(x) OUT_RING(F_TO_DW(x))
 
 #include "radeon_textured_videofuncs.c"
 
+#undef ACCEL_CP
+#undef ACCEL_PREAMBLE
+#undef BEGIN_ACCEL
+#undef OUT_ACCEL_REG
+#undef OUT_ACCEL_REG_F
+#undef FINISH_ACCEL
+#undef OUT_RING_F
+
 #endif /* XF86DRI */
 
 static int
@@ -187,18 +197,30 @@ RADEONPutImageTextured(ScrnInfoPtr pScrn,
        dstPitch = (dstPitch + 15) & ~15;
 
     if (pPriv->video_memory != NULL && size != pPriv->size) {
-	RADEONFreeMemory(pScrn, pPriv->video_memory);
+	radeon_free_memory(pScrn, pPriv->video_memory);
 	pPriv->video_memory = NULL;
     }
 
     if (pPriv->video_memory == NULL) {
-	pPriv->video_offset = RADEONAllocateMemory(pScrn,
-						       &pPriv->video_memory,
-						       size * 2);
+	pPriv->video_offset = radeon_allocate_memory(pScrn,
+						     &pPriv->video_memory,
+						     size * 2, 64);
 	if (pPriv->video_offset == 0)
 	    return BadAlloc;
     }
 
+    /* Bicubic filter loading */
+    if (!IS_R500_3D)
+	pPriv->bicubic_enabled = FALSE;
+    if (pPriv->bicubic_memory == NULL && pPriv->bicubic_enabled) {
+	pPriv->bicubic_offset = radeon_allocate_memory(pScrn,
+						       &pPriv->bicubic_memory,
+						       sizeof(bicubic_tex_512), 64);
+	pPriv->bicubic_src_offset = pPriv->bicubic_offset + info->fbLocation + pScrn->fbOffset;
+	if (pPriv->bicubic_offset == 0)
+		pPriv->bicubic_enabled = FALSE;
+    }
+
     if (pDraw->type == DRAWABLE_WINDOW)
 	pPriv->pPixmap = (*pScreen->GetWindowPixmap)((WindowPtr)pDraw);
     else
@@ -267,6 +289,10 @@ RADEONPutImageTextured(ScrnInfoPtr pScrn,
 	break;
     }
 
+    /* Upload bicubic filter tex */
+    if (pPriv->bicubic_enabled)
+	RADEONCopyData(pScrn, (uint8_t *)bicubic_tex_512, (uint8_t *)(info->FB + pPriv->bicubic_offset), 1024, 1024, 1, 512, 2);
+
     /* update cliplist */
     if (!REGION_EQUAL(pScrn->pScreen, &pPriv->clip, clipBoxes)) {
 	REGION_COPY(pScrn->pScreen, &pPriv->clip, clipBoxes);
@@ -320,12 +346,16 @@ static XF86VideoFormatRec Formats[NUM_FORMATS] =
     {15, TrueColor}, {16, TrueColor}, {24, TrueColor}
 };
 
-#define NUM_ATTRIBUTES 0
+#define NUM_ATTRIBUTES 1
 
-static XF86AttributeRec Attributes[NUM_ATTRIBUTES] =
+static XF86AttributeRec Attributes[NUM_ATTRIBUTES+1] =
 {
+    {XvSettable | XvGettable, 0, 1, "XV_BICUBIC"},
+    {0, 0, 0, NULL}
 };
 
+static Atom xvBicubic;
+
 #define NUM_IMAGES 4
 
 static XF86ImageRec Images[NUM_IMAGES] =
@@ -336,6 +366,44 @@ static XF86ImageRec Images[NUM_IMAGES] =
     XVIMAGE_UYVY
 };
 
+int
+RADEONGetTexPortAttribute(ScrnInfoPtr  pScrn,
+		       Atom	    attribute,
+		       INT32	    *value,
+		       pointer	    data)
+{
+    RADEONInfoPtr	info = RADEONPTR(pScrn);
+    RADEONPortPrivPtr	pPriv = (RADEONPortPrivPtr)data;
+
+    if (info->accelOn) RADEON_SYNC(info, pScrn);
+
+    if (attribute == xvBicubic)
+	*value = pPriv->bicubic_enabled ? 1 : 0;
+    else
+	return BadMatch;
+
+    return Success;
+}
+
+int
+RADEONSetTexPortAttribute(ScrnInfoPtr  pScrn,
+		       Atom	    attribute,
+		       INT32	    value,
+		       pointer	    data)
+{
+    RADEONInfoPtr	info = RADEONPTR(pScrn);
+    RADEONPortPrivPtr	pPriv = (RADEONPortPrivPtr)data;
+
+    RADEON_SYNC(info, pScrn);
+
+    if (attribute == xvBicubic)
+	pPriv->bicubic_enabled = ClipValue (value, 0, 1);
+    else
+	return BadMatch;
+
+    return Success;
+}
+
 XF86VideoAdaptorPtr
 RADEONSetupImageTexturedVideo(ScreenPtr pScreen)
 {
@@ -351,6 +419,8 @@ RADEONSetupImageTexturedVideo(ScreenPtr pScreen)
     if (adapt == NULL)
 	return NULL;
 
+    xvBicubic         = MAKE_ATOM("XV_BICUBIC");
+
     adapt->type = XvWindowMask | XvInputMask | XvImageMask;
     adapt->flags = 0;
     adapt->name = "Radeon Textured Video";
@@ -367,8 +437,13 @@ RADEONSetupImageTexturedVideo(ScreenPtr pScreen)
     pPortPriv =
 	(RADEONPortPrivPtr)(&adapt->pPortPrivates[num_texture_ports]);
 
-    adapt->nAttributes = NUM_ATTRIBUTES;
-    adapt->pAttributes = Attributes;
+    if (IS_R500_3D) {
+	adapt->nAttributes = NUM_ATTRIBUTES;
+	adapt->pAttributes = Attributes;
+    } else {
+	adapt->nAttributes = 0;
+	adapt->pAttributes = NULL;
+    }
     adapt->pImages = Images;
     adapt->nImages = NUM_IMAGES;
     adapt->PutVideo = NULL;
@@ -376,8 +451,8 @@ RADEONSetupImageTexturedVideo(ScreenPtr pScreen)
     adapt->GetVideo = NULL;
     adapt->GetStill = NULL;
     adapt->StopVideo = RADEONStopVideo;
-    adapt->SetPortAttribute = RADEONSetPortAttribute;
-    adapt->GetPortAttribute = RADEONGetPortAttribute;
+    adapt->SetPortAttribute = RADEONSetTexPortAttribute;
+    adapt->GetPortAttribute = RADEONGetTexPortAttribute;
     adapt->QueryBestSize = RADEONQueryBestSize;
     adapt->PutImage = RADEONPutImageTextured;
     adapt->ReputImage = NULL;
@@ -390,6 +465,7 @@ RADEONSetupImageTexturedVideo(ScreenPtr pScreen)
 	pPriv->videoStatus = 0;
 	pPriv->currentBuffer = 0;
 	pPriv->doubleBuffer = 0;
+	pPriv->bicubic_enabled = (info->ChipFamily >= CHIP_FAMILY_RV515);
 
 	/* gotta uninit this someplace, XXX: shouldn't be necessary for textured */
 	REGION_NULL(pScreen, &pPriv->clip);
diff --git a/src/radeon_textured_videofuncs.c b/src/radeon_textured_videofuncs.c
index 277d9b2..c5ad0e1 100644
--- a/src/radeon_textured_videofuncs.c
+++ b/src/radeon_textured_videofuncs.c
@@ -45,26 +45,47 @@
 #endif
 #endif
 
+#define VTX_DWORD_COUNT_FILTER 6
 #define VTX_DWORD_COUNT 4
 
 #ifdef ACCEL_CP
 
+#define VTX_OUT_FILTER(_dstX, _dstY, _srcX, _srcY, _maskX, _maskY)	\
+do {									\
+    OUT_RING_F(_dstX);						\
+    OUT_RING_F(_dstY);						\
+    OUT_RING_F(_srcX);						\
+    OUT_RING_F(_srcY);						\
+    OUT_RING_F(_maskX);						\
+    OUT_RING_F(_maskY);						\
+} while (0)
+
 #define VTX_OUT(_dstX, _dstY, _srcX, _srcY)	\
 do {								\
-    OUT_VIDEO_RING_F(_dstX);						\
-    OUT_VIDEO_RING_F(_dstY);						\
-    OUT_VIDEO_RING_F(_srcX);						\
-    OUT_VIDEO_RING_F(_srcY);						\
+    OUT_RING_F(_dstX);						\
+    OUT_RING_F(_dstY);						\
+    OUT_RING_F(_srcX);						\
+    OUT_RING_F(_srcY);						\
 } while (0)
 
 #else /* ACCEL_CP */
 
+#define VTX_OUT_FILTER(_dstX, _dstY, _srcX, _srcY, _maskX, _maskY)	\
+do {									\
+    OUT_ACCEL_REG_F(RADEON_SE_PORT_DATA0, _dstX);			\
+    OUT_ACCEL_REG_F(RADEON_SE_PORT_DATA0, _dstY);			\
+    OUT_ACCEL_REG_F(RADEON_SE_PORT_DATA0, _srcX);			\
+    OUT_ACCEL_REG_F(RADEON_SE_PORT_DATA0, _srcY);			\
+    OUT_ACCEL_REG_F(RADEON_SE_PORT_DATA0, _maskX);			\
+    OUT_ACCEL_REG_F(RADEON_SE_PORT_DATA0, _maskY);			\
+} while (0)
+
 #define VTX_OUT(_dstX, _dstY, _srcX, _srcY)	\
 do {								\
-    OUT_VIDEO_REG_F(RADEON_SE_PORT_DATA0, _dstX);		\
-    OUT_VIDEO_REG_F(RADEON_SE_PORT_DATA0, _dstY);		\
-    OUT_VIDEO_REG_F(RADEON_SE_PORT_DATA0, _srcX);		\
-    OUT_VIDEO_REG_F(RADEON_SE_PORT_DATA0, _srcY);		\
+    OUT_ACCEL_REG_F(RADEON_SE_PORT_DATA0, _dstX);		\
+    OUT_ACCEL_REG_F(RADEON_SE_PORT_DATA0, _dstY);		\
+    OUT_ACCEL_REG_F(RADEON_SE_PORT_DATA0, _srcX);		\
+    OUT_ACCEL_REG_F(RADEON_SE_PORT_DATA0, _srcY);		\
 } while (0)
 
 #endif /* !ACCEL_CP */
@@ -79,10 +100,10 @@ FUNC_NAME(RADEONDisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv
     uint32_t dst_offset, dst_pitch, dst_format;
     uint32_t txenable, colorpitch;
     uint32_t blendcntl;
-    int dstxoff, dstyoff, pixel_shift;
+    int dstxoff, dstyoff, pixel_shift, vtx_count;
     BoxPtr pBox = REGION_RECTS(&pPriv->clip);
     int nBox = REGION_NUM_RECTS(&pPriv->clip);
-    VIDEO_PREAMBLE();
+    ACCEL_PREAMBLE();
 
     pixel_shift = pPixmap->drawable.bitsPerPixel >> 4;
 
@@ -106,22 +127,27 @@ FUNC_NAME(RADEONDisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv
     dstyoff = 0;
 #endif
 
-    if (!info->XInited3D)
+    if (!info->accel_state->XInited3D)
 	RADEONInit3DEngine(pScrn);
 
     /* we can probably improve this */
-    BEGIN_VIDEO(2);
+    BEGIN_ACCEL(2);
     if (IS_R300_3D || IS_R500_3D)
-	OUT_VIDEO_REG(R300_RB3D_DSTCACHE_CTLSTAT, R300_DC_FLUSH_3D);
+	OUT_ACCEL_REG(R300_RB3D_DSTCACHE_CTLSTAT, R300_DC_FLUSH_3D);
     else
-	OUT_VIDEO_REG(RADEON_RB3D_DSTCACHE_CTLSTAT, RADEON_RB3D_DC_FLUSH);
+	OUT_ACCEL_REG(RADEON_RB3D_DSTCACHE_CTLSTAT, RADEON_RB3D_DC_FLUSH);
     /* We must wait for 3d to idle, in case source was just written as a dest. */
-    OUT_VIDEO_REG(RADEON_WAIT_UNTIL,
+    OUT_ACCEL_REG(RADEON_WAIT_UNTIL,
 		  RADEON_WAIT_HOST_IDLECLEAN |
 		  RADEON_WAIT_2D_IDLECLEAN |
 		  RADEON_WAIT_3D_IDLECLEAN |
 		  RADEON_WAIT_DMA_GUI_IDLE);
-    FINISH_VIDEO();
+    FINISH_ACCEL();
+
+    if (pPriv->bicubic_enabled)
+	vtx_count = VTX_DWORD_COUNT_FILTER;
+    else
+	vtx_count = VTX_DWORD_COUNT;
 
     if (IS_R300_3D || IS_R500_3D) {
 	uint32_t output_fmt;
@@ -160,16 +186,17 @@ FUNC_NAME(RADEONDisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv
 	txformat1 |= R300_TX_FORMAT_YUV_TO_RGB_CLAMP;
 
 	txformat0 = ((((pPriv->w - 1) & 0x7ff) << R300_TXWIDTH_SHIFT) |
-		     (((pPriv->h - 1) & 0x7ff) << R300_TXHEIGHT_SHIFT));
-
-	txformat0 |= R300_TXPITCH_EN;
+		     (((pPriv->h - 1) & 0x7ff) << R300_TXHEIGHT_SHIFT) |
+		     R300_TXPITCH_EN);
 
-	info->texW[0] = pPriv->w;
-	info->texH[0] = pPriv->h;
+	info->accel_state->texW[0] = pPriv->w;
+	info->accel_state->texH[0] = pPriv->h;
 
 	txfilter = (R300_TX_CLAMP_S(R300_TX_CLAMP_CLAMP_LAST) |
 		    R300_TX_CLAMP_T(R300_TX_CLAMP_CLAMP_LAST) |
-		    R300_TX_MAG_FILTER_LINEAR | R300_TX_MIN_FILTER_LINEAR);
+		    R300_TX_MAG_FILTER_LINEAR |
+		    R300_TX_MIN_FILTER_LINEAR |
+		    (0 << R300_TX_ID_SHIFT));
 
 	/* pitch is in pixels */
 	txpitch = pPriv->src_pitch / 2;
@@ -183,22 +210,58 @@ FUNC_NAME(RADEONDisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv
 
 	txoffset = pPriv->src_offset;
 
-	BEGIN_VIDEO(6);
-	OUT_VIDEO_REG(R300_TX_FILTER0_0, txfilter);
-	OUT_VIDEO_REG(R300_TX_FILTER1_0, 0);
-	OUT_VIDEO_REG(R300_TX_FORMAT0_0, txformat0);
-	OUT_VIDEO_REG(R300_TX_FORMAT1_0, txformat1);
-	OUT_VIDEO_REG(R300_TX_FORMAT2_0, txpitch);
-	OUT_VIDEO_REG(R300_TX_OFFSET_0, txoffset);
-	FINISH_VIDEO();
+	BEGIN_ACCEL(6);
+	OUT_ACCEL_REG(R300_TX_FILTER0_0, txfilter);
+	OUT_ACCEL_REG(R300_TX_FILTER1_0, 0);
+	OUT_ACCEL_REG(R300_TX_FORMAT0_0, txformat0);
+	OUT_ACCEL_REG(R300_TX_FORMAT1_0, txformat1);
+	OUT_ACCEL_REG(R300_TX_FORMAT2_0, txpitch);
+	OUT_ACCEL_REG(R300_TX_OFFSET_0, txoffset);
+	FINISH_ACCEL();
 
 	txenable = R300_TEX_0_ENABLE;
 
+	if (pPriv->bicubic_enabled) {
+		/* Size is 128x1 */
+		txformat0 = ((0x7f << R300_TXWIDTH_SHIFT) |
+			     (0x0 << R300_TXHEIGHT_SHIFT) |
+			     R300_TXPITCH_EN);
+		/* Format is 32-bit floats, 4bpp */
+		txformat1 = R300_EASY_TX_FORMAT(Z, Y, X, W, FL_R16G16B16A16);
+		/* Pitch is 127 (128-1) */
+		txpitch = 0x7f;
+		/* Tex filter */
+		txfilter = (R300_TX_CLAMP_S(R300_TX_CLAMP_WRAP) |
+			    R300_TX_CLAMP_T(R300_TX_CLAMP_WRAP) |
+			    R300_TX_MIN_FILTER_NEAREST |
+			    R300_TX_MAG_FILTER_NEAREST |
+			    (1 << R300_TX_ID_SHIFT));
+
+		BEGIN_ACCEL(6);
+		OUT_ACCEL_REG(R300_TX_FILTER0_1, txfilter);
+		OUT_ACCEL_REG(R300_TX_FILTER1_1, 0);
+		OUT_ACCEL_REG(R300_TX_FORMAT0_1, txformat0);
+		OUT_ACCEL_REG(R300_TX_FORMAT1_1, txformat1);
+		OUT_ACCEL_REG(R300_TX_FORMAT2_1, txpitch);
+		OUT_ACCEL_REG(R300_TX_OFFSET_1, pPriv->bicubic_src_offset);
+		FINISH_ACCEL();
+
+		/* Enable tex 1 */
+		txenable |= R300_TEX_1_ENABLE;
+	}
+
 	/* setup the VAP */
-	if (info->has_tcl)
-	    BEGIN_VIDEO(6);
-	else
-	    BEGIN_VIDEO(4);
+	if (info->accel_state->has_tcl) {
+	    if (pPriv->bicubic_enabled)
+		BEGIN_ACCEL(7);
+	    else
+		BEGIN_ACCEL(6);
+	} else {
+	    if (pPriv->bicubic_enabled)
+		BEGIN_ACCEL(5);
+	    else
+		BEGIN_ACCEL(4);
+	}
 
 	/* These registers define the number, type, and location of data submitted
 	 * to the PVS unit of GA input (when PVS is disabled)
@@ -213,56 +276,90 @@ FUNC_NAME(RADEONDisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv
 	 * Textures 0-7
 	 * Fog
 	 */
-	OUT_VIDEO_REG(R300_VAP_PROG_STREAM_CNTL_0,
-		      ((R300_DATA_TYPE_FLOAT_2 << R300_DATA_TYPE_0_SHIFT) |
-		       (0 << R300_SKIP_DWORDS_0_SHIFT) |
-		       (0 << R300_DST_VEC_LOC_0_SHIFT) |
-		       R300_SIGNED_0 |
-		       (R300_DATA_TYPE_FLOAT_2 << R300_DATA_TYPE_1_SHIFT) |
-		       (0 << R300_SKIP_DWORDS_1_SHIFT) |
-		       (6 << R300_DST_VEC_LOC_1_SHIFT) |
-		       R300_LAST_VEC_1 |
-		       R300_SIGNED_1));
+	if (pPriv->bicubic_enabled) {
+	    OUT_ACCEL_REG(R300_VAP_PROG_STREAM_CNTL_0,
+			  ((R300_DATA_TYPE_FLOAT_2 << R300_DATA_TYPE_0_SHIFT) |
+			   (0 << R300_SKIP_DWORDS_0_SHIFT) |
+			   (0 << R300_DST_VEC_LOC_0_SHIFT) |
+			   R300_SIGNED_0 |
+			   (R300_DATA_TYPE_FLOAT_2 << R300_DATA_TYPE_1_SHIFT) |
+			   (0 << R300_SKIP_DWORDS_1_SHIFT) |
+			   (6 << R300_DST_VEC_LOC_1_SHIFT) |
+			   R300_SIGNED_1));
+	    OUT_ACCEL_REG(R300_VAP_PROG_STREAM_CNTL_1,
+			  ((R300_DATA_TYPE_FLOAT_2 << R300_DATA_TYPE_2_SHIFT) |
+			   (0 << R300_SKIP_DWORDS_2_SHIFT) |
+			   (7 << R300_DST_VEC_LOC_2_SHIFT) |
+			   R300_LAST_VEC_2 |
+			   R300_SIGNED_2));
+	} else {
+	    OUT_ACCEL_REG(R300_VAP_PROG_STREAM_CNTL_0,
+			  ((R300_DATA_TYPE_FLOAT_2 << R300_DATA_TYPE_0_SHIFT) |
+			   (0 << R300_SKIP_DWORDS_0_SHIFT) |
+			   (0 << R300_DST_VEC_LOC_0_SHIFT) |
+			   R300_SIGNED_0 |
+			   (R300_DATA_TYPE_FLOAT_2 << R300_DATA_TYPE_1_SHIFT) |
+			   (0 << R300_SKIP_DWORDS_1_SHIFT) |
+			   (6 << R300_DST_VEC_LOC_1_SHIFT) |
+			   R300_LAST_VEC_1 |
+			   R300_SIGNED_1));
+	}
 
 	/* load the vertex shader
 	 * We pre-load vertex programs in RADEONInit3DEngine():
+	 * - exa mask/Xv bicubic
 	 * - exa no mask
-	 * - exa mask
 	 * - Xv
 	 * Here we select the offset of the vertex program we want to use
 	 */
-	if (info->has_tcl) {
-	    OUT_VIDEO_REG(R300_VAP_PVS_CODE_CNTL_0,
-			  ((5 << R300_PVS_FIRST_INST_SHIFT) |
-			   (6 << R300_PVS_XYZW_VALID_INST_SHIFT) |
-			   (6 << R300_PVS_LAST_INST_SHIFT)));
-	    OUT_VIDEO_REG(R300_VAP_PVS_CODE_CNTL_1,
-			  (6 << R300_PVS_LAST_VTX_SRC_INST_SHIFT));
+	if (info->accel_state->has_tcl) {
+	    if (pPriv->bicubic_enabled) {
+		OUT_ACCEL_REG(R300_VAP_PVS_CODE_CNTL_0,
+			      ((0 << R300_PVS_FIRST_INST_SHIFT) |
+			       (2 << R300_PVS_XYZW_VALID_INST_SHIFT) |
+			       (2 << R300_PVS_LAST_INST_SHIFT)));
+		OUT_ACCEL_REG(R300_VAP_PVS_CODE_CNTL_1,
+			      (2 << R300_PVS_LAST_VTX_SRC_INST_SHIFT));
+	    } else {
+		OUT_ACCEL_REG(R300_VAP_PVS_CODE_CNTL_0,
+			      ((5 << R300_PVS_FIRST_INST_SHIFT) |
+			       (6 << R300_PVS_XYZW_VALID_INST_SHIFT) |
+			       (6 << R300_PVS_LAST_INST_SHIFT)));
+		OUT_ACCEL_REG(R300_VAP_PVS_CODE_CNTL_1,
+			      (6 << R300_PVS_LAST_VTX_SRC_INST_SHIFT));
+	    }
 	}
 
 	/* Position and one set of 2 texture coordinates */
-	OUT_VIDEO_REG(R300_VAP_OUT_VTX_FMT_0, R300_VTX_POS_PRESENT);
-	OUT_VIDEO_REG(R300_VAP_OUT_VTX_FMT_1, (2 << R300_TEX_0_COMP_CNT_SHIFT));
-	OUT_VIDEO_REG(R300_US_OUT_FMT_0, output_fmt);
-	FINISH_VIDEO();
+	OUT_ACCEL_REG(R300_VAP_OUT_VTX_FMT_0, R300_VTX_POS_PRESENT);
+	if (pPriv->bicubic_enabled)
+	    OUT_ACCEL_REG(R300_VAP_OUT_VTX_FMT_1, ((2 << R300_TEX_0_COMP_CNT_SHIFT) |
+						   (2 << R300_TEX_1_COMP_CNT_SHIFT)));
+	else
+	    OUT_ACCEL_REG(R300_VAP_OUT_VTX_FMT_1, (2 << R300_TEX_0_COMP_CNT_SHIFT));
+
+	OUT_ACCEL_REG(R300_US_OUT_FMT_0, output_fmt);
+	FINISH_ACCEL();
 
 	/* setup pixel shader */
 	if (IS_R300_3D) {
-	    BEGIN_VIDEO(8);
+	    BEGIN_ACCEL(9);
 	    /* 2 components: 2 for tex0 */
-	    OUT_VIDEO_REG(R300_RS_COUNT,
+	    OUT_ACCEL_REG(R300_RS_COUNT,
 			  ((2 << R300_RS_COUNT_IT_COUNT_SHIFT) |
 			   R300_RS_COUNT_HIRES_EN));
 	    /* R300_INST_COUNT_RS - highest RS instruction used */
-	    OUT_VIDEO_REG(R300_RS_INST_COUNT, R300_INST_COUNT_RS(0) | R300_TX_OFFSET_RS(6));
+	    OUT_ACCEL_REG(R300_RS_INST_COUNT, R300_INST_COUNT_RS(0) | R300_TX_OFFSET_RS(6));
 
-	    OUT_VIDEO_REG(R300_US_CODE_OFFSET,
+	    OUT_ACCEL_REG(R300_US_PIXSIZE, 0); /* highest temp used */
+
+	    OUT_ACCEL_REG(R300_US_CODE_OFFSET,
 			  (R300_ALU_CODE_OFFSET(0) |
 			   R300_ALU_CODE_SIZE(1) |
 			   R300_TEX_CODE_OFFSET(0) |
 			   R300_TEX_CODE_SIZE(1)));
 
-	    OUT_VIDEO_REG(R300_US_CODE_ADDR_3,
+	    OUT_ACCEL_REG(R300_US_CODE_ADDR_3,
 			  (R300_ALU_START(0) |
 			   R300_ALU_SIZE(0) |
 			   R300_TEX_START(0) |
@@ -273,7 +370,7 @@ FUNC_NAME(RADEONDisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv
 
 	    /* ALU inst */
 	    /* RGB */
-	    OUT_VIDEO_REG(R300_US_ALU_RGB_ADDR_0,
+	    OUT_ACCEL_REG(R300_US_ALU_RGB_ADDR_0,
 			  (R300_ALU_RGB_ADDR0(0) |
 			   R300_ALU_RGB_ADDR1(0) |
 			   R300_ALU_RGB_ADDR2(0) |
@@ -282,7 +379,7 @@ FUNC_NAME(RADEONDisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv
 					       R300_ALU_RGB_MASK_G |
 					       R300_ALU_RGB_MASK_B)) |
 			   R300_ALU_RGB_TARGET_A));
-	    OUT_VIDEO_REG(R300_US_ALU_RGB_INST_0,
+	    OUT_ACCEL_REG(R300_US_ALU_RGB_INST_0,
 			  (R300_ALU_RGB_SEL_A(R300_ALU_RGB_SRC0_RGB) |
 			   R300_ALU_RGB_MOD_A(R300_ALU_RGB_MOD_NOP) |
 			   R300_ALU_RGB_SEL_B(R300_ALU_RGB_1_0) |
@@ -293,7 +390,7 @@ FUNC_NAME(RADEONDisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv
 			   R300_ALU_RGB_OMOD(R300_ALU_RGB_OMOD_NONE) |
 			   R300_ALU_RGB_CLAMP));
 	    /* Alpha */
-	    OUT_VIDEO_REG(R300_US_ALU_ALPHA_ADDR_0,
+	    OUT_ACCEL_REG(R300_US_ALU_ALPHA_ADDR_0,
 			  (R300_ALU_ALPHA_ADDR0(0) |
 			   R300_ALU_ALPHA_ADDR1(0) |
 			   R300_ALU_ALPHA_ADDR2(0) |
@@ -301,7 +398,7 @@ FUNC_NAME(RADEONDisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv
 			   R300_ALU_ALPHA_OMASK(R300_ALU_ALPHA_MASK_A) |
 			   R300_ALU_ALPHA_TARGET_A |
 			   R300_ALU_ALPHA_OMASK_W(R300_ALU_ALPHA_MASK_NONE)));
-	    OUT_VIDEO_REG(R300_US_ALU_ALPHA_INST_0,
+	    OUT_ACCEL_REG(R300_US_ALU_ALPHA_INST_0,
 			  (R300_ALU_ALPHA_SEL_A(R300_ALU_ALPHA_SRC0_A) |
 			   R300_ALU_ALPHA_MOD_A(R300_ALU_ALPHA_MOD_NOP) |
 			   R300_ALU_ALPHA_SEL_B(R300_ALU_ALPHA_1_0) |
@@ -311,118 +408,591 @@ FUNC_NAME(RADEONDisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv
 			   R300_ALU_ALPHA_OP(R300_ALU_ALPHA_OP_MAD) |
 			   R300_ALU_ALPHA_OMOD(R300_ALU_ALPHA_OMOD_NONE) |
 			   R300_ALU_ALPHA_CLAMP));
-	    FINISH_VIDEO();
+	    FINISH_ACCEL();
 	} else {
-	    BEGIN_VIDEO(18);
-	    /* 2 components: 2 for tex0 */
-	    OUT_VIDEO_REG(R300_RS_COUNT,
-			  ((2 << R300_RS_COUNT_IT_COUNT_SHIFT) |
-			   R300_RS_COUNT_HIRES_EN));
-
-	    /* R300_INST_COUNT_RS - highest RS instruction used */
-	    OUT_VIDEO_REG(R300_RS_INST_COUNT, R300_INST_COUNT_RS(0) | R300_TX_OFFSET_RS(6));
-
-	    OUT_VIDEO_REG(R500_US_CODE_ADDR, (R500_US_CODE_START_ADDR(0) |
-					      R500_US_CODE_END_ADDR(1)));
-	    OUT_VIDEO_REG(R500_US_CODE_RANGE, (R500_US_CODE_RANGE_ADDR(0) |
-					       R500_US_CODE_RANGE_SIZE(1)));
-	    OUT_VIDEO_REG(R500_US_CODE_OFFSET, 0);
-	    OUT_VIDEO_REG(R500_GA_US_VECTOR_INDEX, 0);
-
-	    /* tex inst */
-	    OUT_VIDEO_REG(R500_GA_US_VECTOR_DATA, (R500_INST_TYPE_TEX |
-						   R500_INST_TEX_SEM_WAIT |
-						   R500_INST_RGB_WMASK_R |
-						   R500_INST_RGB_WMASK_G |
-						   R500_INST_RGB_WMASK_B |
-						   R500_INST_ALPHA_WMASK |
-						   R500_INST_RGB_CLAMP |
-						   R500_INST_ALPHA_CLAMP));
-
-	    OUT_VIDEO_REG(R500_GA_US_VECTOR_DATA, (R500_TEX_ID(0) |
-						   R500_TEX_INST_LD |
-						   R500_TEX_SEM_ACQUIRE |
-						   R500_TEX_IGNORE_UNCOVERED));
-
-	    OUT_VIDEO_REG(R500_GA_US_VECTOR_DATA, (R500_TEX_SRC_ADDR(0) |
-						   R500_TEX_SRC_S_SWIZ_R |
-						   R500_TEX_SRC_T_SWIZ_G |
-						   R500_TEX_DST_ADDR(0) |
-						   R500_TEX_DST_R_SWIZ_R |
-						   R500_TEX_DST_G_SWIZ_G |
-						   R500_TEX_DST_B_SWIZ_B |
-						   R500_TEX_DST_A_SWIZ_A));
-	    OUT_VIDEO_REG(R500_GA_US_VECTOR_DATA, (R500_DX_ADDR(0) |
-						   R500_DX_S_SWIZ_R |
-						   R500_DX_T_SWIZ_R |
-						   R500_DX_R_SWIZ_R |
-						   R500_DX_Q_SWIZ_R |
-						   R500_DY_ADDR(0) |
-						   R500_DY_S_SWIZ_R |
-						   R500_DY_T_SWIZ_R |
-						   R500_DY_R_SWIZ_R |
-						   R500_DY_Q_SWIZ_R));
-	    OUT_VIDEO_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
-	    OUT_VIDEO_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
-
-	    /* ALU inst */
-	    OUT_VIDEO_REG(R500_GA_US_VECTOR_DATA, (R500_INST_TYPE_OUT |
-						   R500_INST_TEX_SEM_WAIT |
-						   R500_INST_LAST |
-						   R500_INST_RGB_OMASK_R |
-						   R500_INST_RGB_OMASK_G |
-						   R500_INST_RGB_OMASK_B |
-						   R500_INST_ALPHA_OMASK |
-						   R500_INST_RGB_CLAMP |
-						   R500_INST_ALPHA_CLAMP));
-
-	    OUT_VIDEO_REG(R500_GA_US_VECTOR_DATA, (R500_RGB_ADDR0(0) |
-						   R500_RGB_ADDR1(0) |
-						   R500_RGB_ADDR1_CONST |
-						   R500_RGB_ADDR2(0) |
-						   R500_RGB_ADDR2_CONST));
-	    OUT_VIDEO_REG(R500_GA_US_VECTOR_DATA, (R500_ALPHA_ADDR0(0) |
-						   R500_ALPHA_ADDR1(0) |
-						   R500_ALPHA_ADDR1_CONST |
-						   R500_ALPHA_ADDR2(0) |
-						   R500_ALPHA_ADDR2_CONST));
-
-	    OUT_VIDEO_REG(R500_GA_US_VECTOR_DATA, (R500_ALU_RGB_SEL_A_SRC0 |
-						   R500_ALU_RGB_R_SWIZ_A_R |
-						   R500_ALU_RGB_G_SWIZ_A_G |
-						   R500_ALU_RGB_B_SWIZ_A_B |
-						   R500_ALU_RGB_SEL_B_SRC0 |
-						   R500_ALU_RGB_R_SWIZ_B_1 |
-						   R500_ALU_RGB_B_SWIZ_B_1 |
-						   R500_ALU_RGB_G_SWIZ_B_1));
-
-	    OUT_VIDEO_REG(R500_GA_US_VECTOR_DATA, (R500_ALPHA_OP_MAD |
-						   R500_ALPHA_SWIZ_A_A |
-						   R500_ALPHA_SWIZ_B_1));
-
-	    OUT_VIDEO_REG(R500_GA_US_VECTOR_DATA, (R500_ALU_RGBA_OP_MAD |
-						   R500_ALU_RGBA_R_SWIZ_0 |
-						   R500_ALU_RGBA_G_SWIZ_0 |
-						   R500_ALU_RGBA_B_SWIZ_0 |
-						   R500_ALU_RGBA_A_SWIZ_0));
-	    FINISH_VIDEO();
+	    if (pPriv->bicubic_enabled) {
+		BEGIN_ACCEL(7);
+
+		/* 4 components: 2 for tex0 and 2 for tex1 */
+		OUT_ACCEL_REG(R300_RS_COUNT,
+			      ((4 << R300_RS_COUNT_IT_COUNT_SHIFT) |
+			       R300_RS_COUNT_HIRES_EN));
+
+		/* R300_INST_COUNT_RS - highest RS instruction used */
+		OUT_ACCEL_REG(R300_RS_INST_COUNT, R300_INST_COUNT_RS(1) | R300_TX_OFFSET_RS(6));
+
+		/* Pixel stack frame size. */
+		OUT_ACCEL_REG(R300_US_PIXSIZE, 5);
+
+		/* FP length. */
+		OUT_ACCEL_REG(R500_US_CODE_ADDR, (R500_US_CODE_START_ADDR(0) |
+						  R500_US_CODE_END_ADDR(13)));
+		OUT_ACCEL_REG(R500_US_CODE_RANGE, (R500_US_CODE_RANGE_ADDR(0) |
+						   R500_US_CODE_RANGE_SIZE(13)));
+
+		/* Prepare for FP emission. */
+		OUT_ACCEL_REG(R500_US_CODE_OFFSET, 0);
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_INDEX, R500_US_VECTOR_INST_INDEX(0));
+		FINISH_ACCEL();
+
+		BEGIN_ACCEL(89);
+		/* Pixel shader.
+		 * I've gone ahead and annotated each instruction, since this
+		 * thing is MASSIVE. :3
+		 * Note: In order to avoid buggies with temps and multiple
+		 * inputs, all temps are offset by 2. temp0 -> register2. */
+
+		/* TEX temp2, input1.xxxx, tex1, 1D */
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_INST_TYPE_TEX |
+						       R500_INST_RGB_WMASK_R |
+						       R500_INST_RGB_WMASK_G |
+						       R500_INST_RGB_WMASK_B));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_TEX_ID(1) |
+						       R500_TEX_INST_LD |
+						       R500_TEX_IGNORE_UNCOVERED));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_TEX_SRC_ADDR(1) |
+						       R500_TEX_SRC_S_SWIZ_R |
+						       R500_TEX_SRC_T_SWIZ_R |
+						       R500_TEX_SRC_R_SWIZ_R |
+						       R500_TEX_SRC_Q_SWIZ_R |
+						       R500_TEX_DST_ADDR(2) |
+						       R500_TEX_DST_R_SWIZ_R |
+						       R500_TEX_DST_G_SWIZ_G |
+						       R500_TEX_DST_B_SWIZ_B |
+						       R500_TEX_DST_A_SWIZ_A));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
+
+		/* TEX temp5, input1.yyyy, tex1, 1D */
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_INST_TYPE_TEX |
+						       R500_INST_TEX_SEM_WAIT |
+						       R500_INST_RGB_WMASK_R |
+						       R500_INST_RGB_WMASK_G |
+						       R500_INST_RGB_WMASK_B));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_TEX_ID(1) |
+						       R500_TEX_INST_LD |
+						       R500_TEX_SEM_ACQUIRE |
+						       R500_TEX_IGNORE_UNCOVERED));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_TEX_SRC_ADDR(1) |
+						       R500_TEX_SRC_S_SWIZ_G |
+						       R500_TEX_SRC_T_SWIZ_G |
+						       R500_TEX_SRC_R_SWIZ_G |
+						       R500_TEX_SRC_Q_SWIZ_G |
+						       R500_TEX_DST_ADDR(5) |
+						       R500_TEX_DST_R_SWIZ_R |
+						       R500_TEX_DST_G_SWIZ_G |
+						       R500_TEX_DST_B_SWIZ_B |
+						       R500_TEX_DST_A_SWIZ_A));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
+
+		/* MUL temp4, const0.x0x0, temp2.yyxx */
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_INST_TYPE_ALU |
+						       R500_INST_TEX_SEM_WAIT |
+						       R500_INST_RGB_WMASK_R |
+						       R500_INST_RGB_WMASK_G |
+						       R500_INST_RGB_WMASK_B |
+						       R500_INST_ALPHA_WMASK));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_RGB_ADDR0(0) |
+						       R500_RGB_ADDR0_CONST |
+						       R500_RGB_ADDR1(2)));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALPHA_ADDR0(0) |
+						       R500_ALPHA_ADDR0_CONST |
+						       R500_ALPHA_ADDR1(2)));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALU_RGB_SEL_A_SRC0 |
+						       R500_ALU_RGB_R_SWIZ_A_R |
+						       R500_ALU_RGB_G_SWIZ_A_0 |
+						       R500_ALU_RGB_B_SWIZ_A_R |
+						       R500_ALU_RGB_SEL_B_SRC1 |
+						       R500_ALU_RGB_R_SWIZ_B_G |
+						       R500_ALU_RGB_G_SWIZ_B_G |
+						       R500_ALU_RGB_B_SWIZ_B_R));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALPHA_ADDRD(4) |
+						       R500_ALPHA_OP_MAD |
+						       R500_ALPHA_SEL_A_SRC0 |
+						       R500_ALPHA_SWIZ_A_0 |
+						       R500_ALPHA_SEL_B_SRC1 |
+						       R500_ALPHA_SWIZ_B_R));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALU_RGBA_ADDRD(4) |
+						       R500_ALU_RGBA_OP_MAD |
+						       R500_ALU_RGBA_R_SWIZ_0 |
+						       R500_ALU_RGBA_G_SWIZ_0 |
+						       R500_ALU_RGBA_B_SWIZ_0 |
+						       R500_ALU_RGBA_A_SWIZ_0));
+
+		/* MAD temp3, const0.0y0y, temp5.xxxx, temp4 */
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_INST_TYPE_ALU |
+						       R500_INST_RGB_WMASK_R |
+						       R500_INST_RGB_WMASK_G |
+						       R500_INST_RGB_WMASK_B |
+						       R500_INST_ALPHA_WMASK));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_RGB_ADDR0(0) |
+						       R500_RGB_ADDR0_CONST |
+						       R500_RGB_ADDR1(5) |
+						       R500_RGB_ADDR2(4)));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALPHA_ADDR0(0) |
+						       R500_ALPHA_ADDR0_CONST |
+						       R500_ALPHA_ADDR1(5) |
+						       R500_ALPHA_ADDR2(4)));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALU_RGB_SEL_A_SRC0 |
+						       R500_ALU_RGB_R_SWIZ_A_0 |
+						       R500_ALU_RGB_G_SWIZ_A_G |
+						       R500_ALU_RGB_B_SWIZ_A_0 |
+						       R500_ALU_RGB_SEL_B_SRC1 |
+						       R500_ALU_RGB_R_SWIZ_B_R |
+						       R500_ALU_RGB_G_SWIZ_B_R |
+						       R500_ALU_RGB_B_SWIZ_B_R));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALPHA_ADDRD(3) |
+						       R500_ALPHA_OP_MAD |
+						       R500_ALPHA_SEL_A_SRC0 |
+						       R500_ALPHA_SWIZ_A_G |
+						       R500_ALPHA_SEL_B_SRC1 |
+						       R500_ALPHA_SWIZ_B_R));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALU_RGBA_ADDRD(3) |
+						       R500_ALU_RGBA_OP_MAD |
+						       R500_ALU_RGBA_SEL_C_SRC2 |
+						       R500_ALU_RGBA_R_SWIZ_R |
+						       R500_ALU_RGBA_G_SWIZ_G |
+						       R500_ALU_RGBA_B_SWIZ_B |
+						       R500_ALU_RGBA_A_SWIZ_A));
+
+		/* ADD temp3, temp3, input0.xyxy */
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_INST_TYPE_ALU |
+						       R500_INST_RGB_WMASK_R |
+						       R500_INST_RGB_WMASK_G |
+						       R500_INST_RGB_WMASK_B |
+						       R500_INST_ALPHA_WMASK));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_RGB_ADDR1(3) |
+						       R500_RGB_ADDR2(0)));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALPHA_ADDR1(3) |
+						       R500_ALPHA_ADDR2(0)));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALU_RGB_R_SWIZ_A_1 |
+						       R500_ALU_RGB_G_SWIZ_A_1 |
+						       R500_ALU_RGB_B_SWIZ_A_1 |
+						       R500_ALU_RGB_SEL_B_SRC1 |
+						       R500_ALU_RGB_R_SWIZ_B_R |
+						       R500_ALU_RGB_G_SWIZ_B_G |
+						       R500_ALU_RGB_B_SWIZ_B_B));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALPHA_ADDRD(3) |
+						       R500_ALPHA_OP_MAD |
+						       R500_ALPHA_SWIZ_A_1 |
+						       R500_ALPHA_SEL_B_SRC1 |
+						       R500_ALPHA_SWIZ_B_A));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALU_RGBA_ADDRD(3) |
+						       R500_ALU_RGBA_OP_MAD |
+						       R500_ALU_RGBA_SEL_C_SRC2 |
+						       R500_ALU_RGBA_R_SWIZ_R |
+						       R500_ALU_RGBA_G_SWIZ_G |
+						       R500_ALU_RGBA_B_SWIZ_R |
+						       R500_ALU_RGBA_A_SWIZ_G));
+
+		/* TEX temp1, temp3.zwxy, tex0, 1D */
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_INST_TYPE_TEX |
+						       R500_INST_RGB_WMASK_R |
+						       R500_INST_RGB_WMASK_G |
+						       R500_INST_RGB_WMASK_B |
+						       R500_INST_ALPHA_WMASK));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_TEX_ID(0) |
+						       R500_TEX_INST_LD |
+						       R500_TEX_IGNORE_UNCOVERED));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_TEX_SRC_ADDR(3) |
+						       R500_TEX_SRC_S_SWIZ_B |
+						       R500_TEX_SRC_T_SWIZ_A |
+						       R500_TEX_SRC_R_SWIZ_R |
+						       R500_TEX_SRC_Q_SWIZ_G |
+						       R500_TEX_DST_ADDR(1) |
+						       R500_TEX_DST_R_SWIZ_R |
+						       R500_TEX_DST_G_SWIZ_G |
+						       R500_TEX_DST_B_SWIZ_B |
+						       R500_TEX_DST_A_SWIZ_A));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
+
+		/* TEX temp3, temp3.xyzw, tex0, 1D */
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_INST_TYPE_TEX |
+						       R500_INST_TEX_SEM_WAIT |
+						       R500_INST_RGB_WMASK_R |
+						       R500_INST_RGB_WMASK_G |
+						       R500_INST_RGB_WMASK_B |
+						       R500_INST_ALPHA_WMASK));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_TEX_ID(0) |
+						       R500_TEX_INST_LD |
+						       R500_TEX_SEM_ACQUIRE |
+						       R500_TEX_IGNORE_UNCOVERED));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_TEX_SRC_ADDR(3) |
+						       R500_TEX_SRC_S_SWIZ_R |
+						       R500_TEX_SRC_T_SWIZ_G |
+						       R500_TEX_SRC_R_SWIZ_B |
+						       R500_TEX_SRC_Q_SWIZ_A |
+						       R500_TEX_DST_ADDR(3) |
+						       R500_TEX_DST_R_SWIZ_R |
+						       R500_TEX_DST_G_SWIZ_G |
+						       R500_TEX_DST_B_SWIZ_B |
+						       R500_TEX_DST_A_SWIZ_A));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
+
+		/* MAD temp4, const1.0y0y, temp5.yyyy, temp4 */
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_INST_TYPE_ALU |
+						       R500_INST_RGB_WMASK_R |
+						       R500_INST_RGB_WMASK_G |
+						       R500_INST_RGB_WMASK_B |
+						       R500_INST_ALPHA_WMASK));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_RGB_ADDR0(0) |
+						       R500_RGB_ADDR0_CONST |
+						       R500_RGB_ADDR1(5) |
+						       R500_RGB_ADDR2(4)));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALPHA_ADDR0(0) |
+						       R500_ALPHA_ADDR0_CONST |
+						       R500_ALPHA_ADDR1(5) |
+						       R500_ALPHA_ADDR2(4)));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALU_RGB_SEL_A_SRC0 |
+						       R500_ALU_RGB_R_SWIZ_A_0 |
+						       R500_ALU_RGB_G_SWIZ_A_G |
+						       R500_ALU_RGB_B_SWIZ_A_0 |
+						       R500_ALU_RGB_SEL_B_SRC1 |
+						       R500_ALU_RGB_R_SWIZ_B_G |
+						       R500_ALU_RGB_G_SWIZ_B_G |
+						       R500_ALU_RGB_B_SWIZ_B_G));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALPHA_ADDRD(4) |
+						       R500_ALPHA_OP_MAD |
+						       R500_ALPHA_SEL_A_SRC0 |
+						       R500_ALPHA_SWIZ_A_G |
+						       R500_ALPHA_SEL_B_SRC1 |
+						       R500_ALPHA_SWIZ_B_G));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALU_RGBA_ADDRD(4) |
+						       R500_ALU_RGBA_OP_MAD |
+						       R500_ALU_RGBA_SEL_C_SRC2 |
+						       R500_ALU_RGBA_R_SWIZ_R |
+						       R500_ALU_RGBA_G_SWIZ_G |
+						       R500_ALU_RGBA_B_SWIZ_B |
+						       R500_ALU_RGBA_A_SWIZ_A));
+
+		/* ADD temp0, temp4, input0.xyxy */
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_INST_TYPE_ALU |
+						       R500_INST_RGB_WMASK_R |
+						       R500_INST_RGB_WMASK_G |
+						       R500_INST_RGB_WMASK_B |
+						       R500_INST_ALPHA_WMASK));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_RGB_ADDR1(4) |
+						       R500_RGB_ADDR2(0)));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALPHA_ADDR1(4) |
+						       R500_ALPHA_ADDR2(0)));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALU_RGB_R_SWIZ_A_1 |
+						       R500_ALU_RGB_G_SWIZ_A_1 |
+						       R500_ALU_RGB_B_SWIZ_A_1 |
+						       R500_ALU_RGB_SEL_B_SRC1 |
+						       R500_ALU_RGB_R_SWIZ_B_R |
+						       R500_ALU_RGB_G_SWIZ_B_G |
+						       R500_ALU_RGB_B_SWIZ_B_B));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALPHA_ADDRD(0) |
+						       R500_ALPHA_OP_MAD |
+						       R500_ALPHA_SWIZ_A_1 |
+						       R500_ALPHA_SEL_B_SRC1 |
+						       R500_ALPHA_SWIZ_B_A));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALU_RGBA_ADDRD(0) |
+						       R500_ALU_RGBA_OP_MAD |
+						       R500_ALU_RGBA_SEL_C_SRC2 |
+						       R500_ALU_RGBA_R_SWIZ_R |
+						       R500_ALU_RGBA_G_SWIZ_G |
+						       R500_ALU_RGBA_B_SWIZ_R |
+						       R500_ALU_RGBA_A_SWIZ_G));
+
+		/* TEX temp4, temp0.zwzw, tex0, 1D */
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_INST_TYPE_TEX |
+						       R500_INST_TEX_SEM_WAIT |
+						       R500_INST_RGB_WMASK_R |
+						       R500_INST_RGB_WMASK_G |
+						       R500_INST_RGB_WMASK_B |
+						       R500_INST_ALPHA_WMASK));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_TEX_ID(0) |
+						       R500_TEX_INST_LD |
+						       R500_TEX_IGNORE_UNCOVERED));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_TEX_SRC_ADDR(0) |
+						       R500_TEX_SRC_S_SWIZ_B |
+						       R500_TEX_SRC_T_SWIZ_A |
+						       R500_TEX_SRC_R_SWIZ_B |
+						       R500_TEX_SRC_Q_SWIZ_A |
+						       R500_TEX_DST_ADDR(4) |
+						       R500_TEX_DST_R_SWIZ_R |
+						       R500_TEX_DST_G_SWIZ_G |
+						       R500_TEX_DST_B_SWIZ_B |
+						       R500_TEX_DST_A_SWIZ_A));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
+
+		/* TEX temp0, temp0.xyzw, tex0, 1D */
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_INST_TYPE_TEX |
+						       R500_INST_TEX_SEM_WAIT |
+						       R500_INST_RGB_WMASK_R |
+						       R500_INST_RGB_WMASK_G |
+						       R500_INST_RGB_WMASK_B |
+						   R500_INST_ALPHA_WMASK));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_TEX_ID(0) |
+						       R500_TEX_INST_LD |
+						       R500_TEX_SEM_ACQUIRE |
+						       R500_TEX_IGNORE_UNCOVERED));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_TEX_SRC_ADDR(0) |
+						       R500_TEX_SRC_S_SWIZ_R |
+						       R500_TEX_SRC_T_SWIZ_G |
+						       R500_TEX_SRC_R_SWIZ_B |
+						       R500_TEX_SRC_Q_SWIZ_A |
+						       R500_TEX_DST_ADDR(0) |
+						       R500_TEX_DST_R_SWIZ_R |
+						       R500_TEX_DST_G_SWIZ_G |
+						       R500_TEX_DST_B_SWIZ_B |
+						       R500_TEX_DST_A_SWIZ_A));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
+
+		/* LRP temp3, temp2.zzzz, temp1, temp3 ->
+		 * - PRESUB temps, temp1 - temp3
+		 * - MAD temp2.zzzz, temps, temp3 */
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_INST_TYPE_ALU |
+						       R500_INST_RGB_WMASK_R |
+						       R500_INST_RGB_WMASK_G |
+						       R500_INST_RGB_WMASK_B |
+						       R500_INST_ALPHA_WMASK));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_RGB_ADDR0(3) |
+						       R500_RGB_SRCP_OP_RGB1_MINUS_RGB0 |
+						       R500_RGB_ADDR1(1) |
+						       R500_RGB_ADDR2(2)));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALPHA_ADDR0(3) |
+						       R500_ALPHA_SRCP_OP_A1_MINUS_A0 |
+						       R500_ALPHA_ADDR1(1) |
+						       R500_ALPHA_ADDR2(2)));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALU_RGB_SEL_A_SRC2 |
+						       R500_ALU_RGB_R_SWIZ_A_B |
+						       R500_ALU_RGB_G_SWIZ_A_B |
+						       R500_ALU_RGB_B_SWIZ_A_B |
+						       R500_ALU_RGB_SEL_B_SRCP |
+						       R500_ALU_RGB_R_SWIZ_B_R |
+						       R500_ALU_RGB_G_SWIZ_B_G |
+						       R500_ALU_RGB_B_SWIZ_B_B));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALPHA_ADDRD(3) |
+						       R500_ALPHA_OP_MAD |
+						       R500_ALPHA_SEL_A_SRC2 |
+						       R500_ALPHA_SWIZ_A_B |
+						       R500_ALPHA_SEL_B_SRCP |
+						       R500_ALPHA_SWIZ_B_A));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALU_RGBA_ADDRD(3) |
+						       R500_ALU_RGBA_OP_MAD |
+						       R500_ALU_RGBA_SEL_C_SRC0 |
+						       R500_ALU_RGBA_R_SWIZ_R |
+						       R500_ALU_RGBA_G_SWIZ_G |
+						       R500_ALU_RGBA_B_SWIZ_B |
+						       R500_ALU_RGBA_A_SWIZ_A));
+
+		/* LRP temp0, temp2.zzzz, temp4, temp0 ->
+		 * - PRESUB temps, temp4 - temp1
+		 * - MAD temp2.zzzz, temps, temp0 */
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_INST_TYPE_ALU |
+						       R500_INST_TEX_SEM_WAIT |
+						       R500_INST_RGB_WMASK_R |
+						       R500_INST_RGB_WMASK_G |
+						       R500_INST_RGB_WMASK_B |
+						       R500_INST_ALPHA_WMASK));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_RGB_ADDR0(0) |
+						       R500_RGB_SRCP_OP_RGB1_MINUS_RGB0 |
+						       R500_RGB_ADDR1(4) |
+						       R500_RGB_ADDR2(2)));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALPHA_ADDR0(0) |
+						       R500_ALPHA_SRCP_OP_A1_MINUS_A0 |
+						       R500_ALPHA_ADDR1(4) |
+						       R500_ALPHA_ADDR2(2)));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALU_RGB_SEL_A_SRC2 |
+						       R500_ALU_RGB_R_SWIZ_A_B |
+						       R500_ALU_RGB_G_SWIZ_A_B |
+						       R500_ALU_RGB_B_SWIZ_A_B |
+						       R500_ALU_RGB_SEL_B_SRCP |
+						       R500_ALU_RGB_R_SWIZ_B_R |
+						       R500_ALU_RGB_G_SWIZ_B_G |
+						       R500_ALU_RGB_B_SWIZ_B_B));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALPHA_ADDRD(0) |
+						       R500_ALPHA_OP_MAD |
+						       R500_ALPHA_SEL_A_SRC2 |
+						       R500_ALPHA_SWIZ_A_B |
+						       R500_ALPHA_SEL_B_SRCP |
+						       R500_ALPHA_SWIZ_B_A));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALU_RGBA_ADDRD(0) |
+						       R500_ALU_RGBA_OP_MAD |
+						       R500_ALU_RGBA_SEL_C_SRC0 |
+						       R500_ALU_RGBA_R_SWIZ_R |
+						       R500_ALU_RGBA_G_SWIZ_G |
+						       R500_ALU_RGBA_B_SWIZ_B |
+						       R500_ALU_RGBA_A_SWIZ_A));
+
+		/* LRP output, temp5.zzzz, temp3, temp0 ->
+		 * - PRESUB temps, temp3 - temp0
+		 * - MAD temp5.zzzz, temps, temp0 */
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_INST_TYPE_OUT |
+						       R500_INST_LAST |
+						       R500_INST_TEX_SEM_WAIT |
+						       R500_INST_RGB_WMASK_R |
+						       R500_INST_RGB_WMASK_G |
+						       R500_INST_RGB_WMASK_B |
+						       R500_INST_ALPHA_WMASK |
+						       R500_INST_RGB_OMASK_R |
+						       R500_INST_RGB_OMASK_G |
+						       R500_INST_RGB_OMASK_B |
+						       R500_INST_ALPHA_OMASK));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_RGB_ADDR0(0) |
+						       R500_RGB_SRCP_OP_RGB1_MINUS_RGB0 |
+						       R500_RGB_ADDR1(3) |
+						       R500_RGB_ADDR2(5)));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALPHA_ADDR0(0) |
+						       R500_ALPHA_SRCP_OP_A1_MINUS_A0 |
+						       R500_ALPHA_ADDR1(3) |
+						       R500_ALPHA_ADDR2(5)));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALU_RGB_SEL_A_SRC2 |
+						       R500_ALU_RGB_R_SWIZ_A_B |
+						       R500_ALU_RGB_G_SWIZ_A_B |
+						       R500_ALU_RGB_B_SWIZ_A_B |
+						       R500_ALU_RGB_SEL_B_SRCP |
+						       R500_ALU_RGB_R_SWIZ_B_R |
+						       R500_ALU_RGB_G_SWIZ_B_G |
+						       R500_ALU_RGB_B_SWIZ_B_B));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALPHA_ADDRD(0) |
+						       R500_ALPHA_OP_MAD |
+						       R500_ALPHA_SEL_A_SRC2 |
+						       R500_ALPHA_SWIZ_A_B |
+						       R500_ALPHA_SEL_B_SRCP |
+						       R500_ALPHA_SWIZ_B_A));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALU_RGBA_ADDRD(0) |
+						       R500_ALU_RGBA_OP_MAD |
+						       R500_ALU_RGBA_SEL_C_SRC0 |
+						       R500_ALU_RGBA_R_SWIZ_R |
+						       R500_ALU_RGBA_G_SWIZ_G |
+						       R500_ALU_RGBA_B_SWIZ_B |
+						       R500_ALU_RGBA_A_SWIZ_A));
+
+		/* Shader constants. */
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_INDEX, R500_US_VECTOR_CONST_INDEX(0));
+
+		/* const0 = {1 / texture[0].width, 0, 0, 0} */
+		OUT_ACCEL_REG_F(R500_GA_US_VECTOR_DATA, (1.0/(float)pPriv->w));
+		OUT_ACCEL_REG_F(R500_GA_US_VECTOR_DATA, (1.0/(float)pPriv->h));
+		OUT_ACCEL_REG_F(R500_GA_US_VECTOR_DATA, 0x0);
+		OUT_ACCEL_REG_F(R500_GA_US_VECTOR_DATA, 0x0);
+
+		FINISH_ACCEL();
+
+	    } else {
+		BEGIN_ACCEL(19);
+		/* 2 components: 2 for tex0 */
+		OUT_ACCEL_REG(R300_RS_COUNT,
+			      ((2 << R300_RS_COUNT_IT_COUNT_SHIFT) |
+			       R300_RS_COUNT_HIRES_EN));
+
+		/* R300_INST_COUNT_RS - highest RS instruction used */
+		OUT_ACCEL_REG(R300_RS_INST_COUNT, R300_INST_COUNT_RS(0) | R300_TX_OFFSET_RS(6));
+
+		/* Pixel stack frame size. */
+		OUT_ACCEL_REG(R300_US_PIXSIZE, 0); /* highest temp used */
+
+		/* FP length. */
+		OUT_ACCEL_REG(R500_US_CODE_ADDR, (R500_US_CODE_START_ADDR(0) |
+						  R500_US_CODE_END_ADDR(1)));
+		OUT_ACCEL_REG(R500_US_CODE_RANGE, (R500_US_CODE_RANGE_ADDR(0) |
+						   R500_US_CODE_RANGE_SIZE(1)));
+
+		/* Prepare for FP emission. */
+		OUT_ACCEL_REG(R500_US_CODE_OFFSET, 0);
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_INDEX, R500_US_VECTOR_INST_INDEX(0));
+
+		/* tex inst */
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_INST_TYPE_TEX |
+						       R500_INST_TEX_SEM_WAIT |
+						       R500_INST_RGB_WMASK_R |
+						       R500_INST_RGB_WMASK_G |
+						       R500_INST_RGB_WMASK_B |
+						       R500_INST_ALPHA_WMASK |
+						       R500_INST_RGB_CLAMP |
+						       R500_INST_ALPHA_CLAMP));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_TEX_ID(0) |
+						       R500_TEX_INST_LD |
+						       R500_TEX_SEM_ACQUIRE |
+						       R500_TEX_IGNORE_UNCOVERED));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_TEX_SRC_ADDR(0) |
+						       R500_TEX_SRC_S_SWIZ_R |
+						       R500_TEX_SRC_T_SWIZ_G |
+						       R500_TEX_DST_ADDR(0) |
+						       R500_TEX_DST_R_SWIZ_R |
+						       R500_TEX_DST_G_SWIZ_G |
+						       R500_TEX_DST_B_SWIZ_B |
+						       R500_TEX_DST_A_SWIZ_A));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_DX_ADDR(0) |
+						       R500_DX_S_SWIZ_R |
+						       R500_DX_T_SWIZ_R |
+						       R500_DX_R_SWIZ_R |
+						       R500_DX_Q_SWIZ_R |
+						       R500_DY_ADDR(0) |
+						       R500_DY_S_SWIZ_R |
+						       R500_DY_T_SWIZ_R |
+						       R500_DY_R_SWIZ_R |
+						       R500_DY_Q_SWIZ_R));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, 0x00000000);
+
+		/* ALU inst */
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_INST_TYPE_OUT |
+						       R500_INST_TEX_SEM_WAIT |
+						       R500_INST_LAST |
+						       R500_INST_RGB_OMASK_R |
+						       R500_INST_RGB_OMASK_G |
+						       R500_INST_RGB_OMASK_B |
+						       R500_INST_ALPHA_OMASK |
+						       R500_INST_RGB_CLAMP |
+						       R500_INST_ALPHA_CLAMP));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_RGB_ADDR0(0) |
+						       R500_RGB_ADDR1(0) |
+						       R500_RGB_ADDR1_CONST |
+						       R500_RGB_ADDR2(0) |
+						       R500_RGB_ADDR2_CONST));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALPHA_ADDR0(0) |
+						       R500_ALPHA_ADDR1(0) |
+						       R500_ALPHA_ADDR1_CONST |
+						       R500_ALPHA_ADDR2(0) |
+						       R500_ALPHA_ADDR2_CONST));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALU_RGB_SEL_A_SRC0 |
+						       R500_ALU_RGB_R_SWIZ_A_R |
+						       R500_ALU_RGB_G_SWIZ_A_G |
+						       R500_ALU_RGB_B_SWIZ_A_B |
+						       R500_ALU_RGB_SEL_B_SRC0 |
+						       R500_ALU_RGB_R_SWIZ_B_1 |
+						       R500_ALU_RGB_B_SWIZ_B_1 |
+						       R500_ALU_RGB_G_SWIZ_B_1));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALPHA_OP_MAD |
+						       R500_ALPHA_SWIZ_A_A |
+						       R500_ALPHA_SWIZ_B_1));
+		OUT_ACCEL_REG(R500_GA_US_VECTOR_DATA, (R500_ALU_RGBA_OP_MAD |
+						       R500_ALU_RGBA_R_SWIZ_0 |
+						       R500_ALU_RGBA_G_SWIZ_0 |
+						       R500_ALU_RGBA_B_SWIZ_0 |
+						       R500_ALU_RGBA_A_SWIZ_0));
+		FINISH_ACCEL();
+	    }
 	}
 
-	BEGIN_VIDEO(5);
-	OUT_VIDEO_REG(R300_TX_INVALTAGS, 0);
-	OUT_VIDEO_REG(R300_TX_ENABLE, txenable);
+	BEGIN_ACCEL(6);
+	OUT_ACCEL_REG(R300_TX_INVALTAGS, 0);
+	OUT_ACCEL_REG(R300_TX_ENABLE, txenable);
 
-	OUT_VIDEO_REG(R300_RB3D_COLOROFFSET0, dst_offset);
-	OUT_VIDEO_REG(R300_RB3D_COLORPITCH0, colorpitch);
+	OUT_ACCEL_REG(R300_RB3D_COLOROFFSET0, dst_offset);
+	OUT_ACCEL_REG(R300_RB3D_COLORPITCH0, colorpitch);
 
 	blendcntl = RADEON_SRC_BLEND_GL_ONE | RADEON_DST_BLEND_GL_ZERO;
 	/* no need to enable blending */
-	OUT_VIDEO_REG(R300_RB3D_BLENDCNTL, blendcntl);
-	FINISH_VIDEO();
+	OUT_ACCEL_REG(R300_RB3D_BLENDCNTL, blendcntl);
 
-	BEGIN_VIDEO(1);
-	OUT_VIDEO_REG(R300_VAP_VTX_SIZE, VTX_DWORD_COUNT);
-	FINISH_VIDEO();
+	OUT_ACCEL_REG(R300_VAP_VTX_SIZE, vtx_count);
+	FINISH_ACCEL();
 
     } else {
 
@@ -453,20 +1023,20 @@ FUNC_NAME(RADEONDisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv
 	if (RADEONTilingEnabled(pScrn, pPixmap))
 	    colorpitch |= RADEON_COLOR_TILE_ENABLE;
 
-	BEGIN_VIDEO(5);
+	BEGIN_ACCEL(5);
 
-	OUT_VIDEO_REG(RADEON_PP_CNTL,
-		    RADEON_TEX_0_ENABLE | RADEON_TEX_BLEND_0_ENABLE);
-	OUT_VIDEO_REG(RADEON_RB3D_CNTL,
-		    dst_format | RADEON_ALPHA_BLEND_ENABLE);
-	OUT_VIDEO_REG(RADEON_RB3D_COLOROFFSET, dst_offset);
+	OUT_ACCEL_REG(RADEON_PP_CNTL,
+		      RADEON_TEX_0_ENABLE | RADEON_TEX_BLEND_0_ENABLE);
+	OUT_ACCEL_REG(RADEON_RB3D_CNTL,
+		      dst_format | RADEON_ALPHA_BLEND_ENABLE);
+	OUT_ACCEL_REG(RADEON_RB3D_COLOROFFSET, dst_offset);
 
-	OUT_VIDEO_REG(RADEON_RB3D_COLORPITCH, colorpitch);
+	OUT_ACCEL_REG(RADEON_RB3D_COLORPITCH, colorpitch);
 
-	OUT_VIDEO_REG(RADEON_RB3D_BLENDCNTL,
-		    RADEON_SRC_BLEND_GL_ONE | RADEON_DST_BLEND_GL_ZERO);
+	OUT_ACCEL_REG(RADEON_RB3D_BLENDCNTL,
+		      RADEON_SRC_BLEND_GL_ONE | RADEON_DST_BLEND_GL_ZERO);
 
-	FINISH_VIDEO();
+	FINISH_ACCEL();
 
 
 	if ((info->ChipFamily == CHIP_FAMILY_RV250) ||
@@ -474,77 +1044,82 @@ FUNC_NAME(RADEONDisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv
 	    (info->ChipFamily == CHIP_FAMILY_RS300) ||
 	    (info->ChipFamily == CHIP_FAMILY_R200)) {
 
-	    info->texW[0] = pPriv->w;
-	    info->texH[0] = pPriv->h;
-
-	    BEGIN_VIDEO(12);
-
-	    OUT_VIDEO_REG(R200_SE_VTX_FMT_0, R200_VTX_XY);
-	    OUT_VIDEO_REG(R200_SE_VTX_FMT_1,
-			(2 << R200_VTX_TEX0_COMP_CNT_SHIFT));
-
-	    OUT_VIDEO_REG(R200_PP_TXFILTER_0,
-			R200_MAG_FILTER_LINEAR |
-			R200_MIN_FILTER_LINEAR |
-			R200_YUV_TO_RGB);
-	    OUT_VIDEO_REG(R200_PP_TXFORMAT_0, txformat);
-	    OUT_VIDEO_REG(R200_PP_TXFORMAT_X_0, 0);
-	    OUT_VIDEO_REG(R200_PP_TXSIZE_0,
-			(pPriv->w - 1) |
-			((pPriv->h - 1) << RADEON_TEX_VSIZE_SHIFT));
-	    OUT_VIDEO_REG(R200_PP_TXPITCH_0, pPriv->src_pitch - 32);
-
-	    OUT_VIDEO_REG(R200_PP_TXOFFSET_0, pPriv->src_offset);
-
-	    OUT_VIDEO_REG(R200_PP_TXCBLEND_0,
-			R200_TXC_ARG_A_ZERO |
-			R200_TXC_ARG_B_ZERO |
-			R200_TXC_ARG_C_R0_COLOR |
-			R200_TXC_OP_MADD);
-	    OUT_VIDEO_REG(R200_PP_TXCBLEND2_0,
-			R200_TXC_CLAMP_0_1 | R200_TXC_OUTPUT_REG_R0);
-	    OUT_VIDEO_REG(R200_PP_TXABLEND_0,
-			R200_TXA_ARG_A_ZERO |
-			R200_TXA_ARG_B_ZERO |
-			R200_TXA_ARG_C_R0_ALPHA |
-			R200_TXA_OP_MADD);
-	    OUT_VIDEO_REG(R200_PP_TXABLEND2_0,
-			R200_TXA_CLAMP_0_1 | R200_TXA_OUTPUT_REG_R0);
-	    FINISH_VIDEO();
+	    info->accel_state->texW[0] = pPriv->w;
+	    info->accel_state->texH[0] = pPriv->h;
+
+	    BEGIN_ACCEL(12);
+
+	    OUT_ACCEL_REG(R200_SE_VTX_FMT_0, R200_VTX_XY);
+	    OUT_ACCEL_REG(R200_SE_VTX_FMT_1,
+			  (2 << R200_VTX_TEX0_COMP_CNT_SHIFT));
+
+	    OUT_ACCEL_REG(R200_PP_TXFILTER_0,
+			  R200_MAG_FILTER_LINEAR |
+			  R200_MIN_FILTER_LINEAR |
+			  R200_CLAMP_S_CLAMP_LAST |
+			  R200_CLAMP_T_CLAMP_LAST |
+			  R200_YUV_TO_RGB);
+	    OUT_ACCEL_REG(R200_PP_TXFORMAT_0, txformat);
+	    OUT_ACCEL_REG(R200_PP_TXFORMAT_X_0, 0);
+	    OUT_ACCEL_REG(R200_PP_TXSIZE_0,
+			  (pPriv->w - 1) |
+			  ((pPriv->h - 1) << RADEON_TEX_VSIZE_SHIFT));
+	    OUT_ACCEL_REG(R200_PP_TXPITCH_0, pPriv->src_pitch - 32);
+
+	    OUT_ACCEL_REG(R200_PP_TXOFFSET_0, pPriv->src_offset);
+
+	    OUT_ACCEL_REG(R200_PP_TXCBLEND_0,
+			  R200_TXC_ARG_A_ZERO |
+			  R200_TXC_ARG_B_ZERO |
+			  R200_TXC_ARG_C_R0_COLOR |
+			  R200_TXC_OP_MADD);
+	    OUT_ACCEL_REG(R200_PP_TXCBLEND2_0,
+			  R200_TXC_CLAMP_0_1 | R200_TXC_OUTPUT_REG_R0);
+	    OUT_ACCEL_REG(R200_PP_TXABLEND_0,
+			  R200_TXA_ARG_A_ZERO |
+			  R200_TXA_ARG_B_ZERO |
+			  R200_TXA_ARG_C_R0_ALPHA |
+			  R200_TXA_OP_MADD);
+	    OUT_ACCEL_REG(R200_PP_TXABLEND2_0,
+			  R200_TXA_CLAMP_0_1 | R200_TXA_OUTPUT_REG_R0);
+	    FINISH_ACCEL();
 	} else {
 
-	    info->texW[0] = 1;
-	    info->texH[0] = 1;
-
-	    BEGIN_VIDEO(8);
-
-	    OUT_VIDEO_REG(RADEON_SE_VTX_FMT, RADEON_SE_VTX_FMT_XY |
-			RADEON_SE_VTX_FMT_ST0);
-
-	    OUT_VIDEO_REG(RADEON_PP_TXFILTER_0, RADEON_MAG_FILTER_LINEAR |
-			RADEON_MIN_FILTER_LINEAR |
-			RADEON_YUV_TO_RGB);
-	    OUT_VIDEO_REG(RADEON_PP_TXFORMAT_0, txformat);
-	    OUT_VIDEO_REG(RADEON_PP_TXOFFSET_0, pPriv->src_offset);
-	    OUT_VIDEO_REG(RADEON_PP_TXCBLEND_0,
-			RADEON_COLOR_ARG_A_ZERO |
-			RADEON_COLOR_ARG_B_ZERO |
-			RADEON_COLOR_ARG_C_T0_COLOR |
-			RADEON_BLEND_CTL_ADD |
-			RADEON_CLAMP_TX);
-	    OUT_VIDEO_REG(RADEON_PP_TXABLEND_0,
-			RADEON_ALPHA_ARG_A_ZERO |
-			RADEON_ALPHA_ARG_B_ZERO |
-			RADEON_ALPHA_ARG_C_T0_ALPHA |
-			RADEON_BLEND_CTL_ADD |
-			RADEON_CLAMP_TX);
-
-	    OUT_VIDEO_REG(RADEON_PP_TEX_SIZE_0,
-			(pPriv->w - 1) |
-			((pPriv->h - 1) << RADEON_TEX_VSIZE_SHIFT));
-	    OUT_VIDEO_REG(RADEON_PP_TEX_PITCH_0,
-			pPriv->src_pitch - 32);
-	    FINISH_VIDEO();
+	    info->accel_state->texW[0] = 1;
+	    info->accel_state->texH[0] = 1;
+
+	    BEGIN_ACCEL(8);
+
+	    OUT_ACCEL_REG(RADEON_SE_VTX_FMT, (RADEON_SE_VTX_FMT_XY |
+					      RADEON_SE_VTX_FMT_ST0));
+
+	    OUT_ACCEL_REG(RADEON_PP_TXFILTER_0,
+			  RADEON_MAG_FILTER_LINEAR |
+			  RADEON_MIN_FILTER_LINEAR |
+			  RADEON_CLAMP_S_CLAMP_LAST |
+			  RADEON_CLAMP_T_CLAMP_LAST |
+			  RADEON_YUV_TO_RGB);
+	    OUT_ACCEL_REG(RADEON_PP_TXFORMAT_0, txformat);
+	    OUT_ACCEL_REG(RADEON_PP_TXOFFSET_0, pPriv->src_offset);
+	    OUT_ACCEL_REG(RADEON_PP_TXCBLEND_0,
+			  RADEON_COLOR_ARG_A_ZERO |
+			  RADEON_COLOR_ARG_B_ZERO |
+			  RADEON_COLOR_ARG_C_T0_COLOR |
+			  RADEON_BLEND_CTL_ADD |
+			  RADEON_CLAMP_TX);
+	    OUT_ACCEL_REG(RADEON_PP_TXABLEND_0,
+			  RADEON_ALPHA_ARG_A_ZERO |
+			  RADEON_ALPHA_ARG_B_ZERO |
+			  RADEON_ALPHA_ARG_C_T0_ALPHA |
+			  RADEON_BLEND_CTL_ADD |
+			  RADEON_CLAMP_TX);
+
+	    OUT_ACCEL_REG(RADEON_PP_TEX_SIZE_0,
+			  (pPriv->w - 1) |
+			  ((pPriv->h - 1) << RADEON_TEX_VSIZE_SHIFT));
+	    OUT_ACCEL_REG(RADEON_PP_TEX_PITCH_0,
+			  pPriv->src_pitch - 32);
+	    FINISH_ACCEL();
 	}
     }
 
@@ -582,77 +1157,96 @@ FUNC_NAME(RADEONDisplayTexturedVideo)(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv
 
 #ifdef ACCEL_CP
 	if (info->ChipFamily < CHIP_FAMILY_R200) {
-	    BEGIN_RING(4 * VTX_DWORD_COUNT + 3);
+	    BEGIN_RING(3 * vtx_count + 3);
 	    OUT_RING(CP_PACKET3(RADEON_CP_PACKET3_3D_DRAW_IMMD,
-				4 * VTX_DWORD_COUNT + 1));
+				3 * vtx_count + 1));
 	    OUT_RING(RADEON_CP_VC_FRMT_XY |
 		     RADEON_CP_VC_FRMT_ST0);
-	    OUT_RING(RADEON_CP_VC_CNTL_PRIM_TYPE_TRI_FAN |
+	    OUT_RING(RADEON_CP_VC_CNTL_PRIM_TYPE_RECT_LIST |
 		     RADEON_CP_VC_CNTL_PRIM_WALK_RING |
 		     RADEON_CP_VC_CNTL_MAOS_ENABLE |
 		     RADEON_CP_VC_CNTL_VTX_FMT_RADEON_MODE |
-		     (4 << RADEON_CP_VC_CNTL_NUM_SHIFT));
+		     (3 << RADEON_CP_VC_CNTL_NUM_SHIFT));
 	} else {
 	    if (IS_R300_3D || IS_R500_3D)
-		BEGIN_RING(4 * VTX_DWORD_COUNT + 4);
+		BEGIN_RING(4 * vtx_count + 4);
 	    else
-		BEGIN_RING(4 * VTX_DWORD_COUNT + 2);
+		BEGIN_RING(4 * vtx_count + 2);
 	    OUT_RING(CP_PACKET3(R200_CP_PACKET3_3D_DRAW_IMMD_2,
-				4 * VTX_DWORD_COUNT));
-	    OUT_RING(RADEON_CP_VC_CNTL_PRIM_TYPE_TRI_FAN |
+				4 * vtx_count));
+	    OUT_RING(RADEON_CP_VC_CNTL_PRIM_TYPE_QUAD_LIST |
 		     RADEON_CP_VC_CNTL_PRIM_WALK_RING |
 		     (4 << RADEON_CP_VC_CNTL_NUM_SHIFT));
 	}
 #else /* ACCEL_CP */
 	if (IS_R300_3D || IS_R500_3D)
-	    BEGIN_VIDEO(2 + VTX_DWORD_COUNT * 4);
+	    BEGIN_ACCEL(2 + vtx_count * 4);
+	else if (info->ChipFamily < CHIP_FAMILY_R200)
+	    BEGIN_ACCEL(1 + vtx_count * 3);
 	else
-	    BEGIN_VIDEO(1 + VTX_DWORD_COUNT * 4);
+	    BEGIN_ACCEL(1 + vtx_count * 4);
 
-	if (info->ChipFamily < CHIP_FAMILY_R200) {
-	    OUT_VIDEO_REG(RADEON_SE_VF_CNTL, (RADEON_VF_PRIM_TYPE_TRIANGLE_FAN |
+	if (info->ChipFamily < CHIP_FAMILY_R200)
+	    OUT_ACCEL_REG(RADEON_SE_VF_CNTL, (RADEON_VF_PRIM_TYPE_RECTANGLE_LIST |
 					      RADEON_VF_PRIM_WALK_DATA |
 					      RADEON_VF_RADEON_MODE |
-					      4 << RADEON_VF_NUM_VERTICES_SHIFT));
-	} else {
-	    OUT_VIDEO_REG(RADEON_SE_VF_CNTL, (RADEON_VF_PRIM_TYPE_QUAD_LIST |
+					      (3 << RADEON_VF_NUM_VERTICES_SHIFT)));
+	else
+	    OUT_ACCEL_REG(RADEON_SE_VF_CNTL, (RADEON_VF_PRIM_TYPE_QUAD_LIST |
 					      RADEON_VF_PRIM_WALK_DATA |
-					      4 << RADEON_VF_NUM_VERTICES_SHIFT));
-	}
-#endif
+					      (4 << RADEON_VF_NUM_VERTICES_SHIFT)));
 
-	VTX_OUT((float)dstX,                                      (float)dstY,
-		xFixedToFloat(srcTopLeft.x) / info->texW[0],      xFixedToFloat(srcTopLeft.y) / info->texH[0]);
-	VTX_OUT((float)dstX,                                      (float)(dstY + dsth),
-		xFixedToFloat(srcBottomLeft.x) / info->texW[0],   xFixedToFloat(srcBottomLeft.y) / info->texH[0]);
-	VTX_OUT((float)(dstX + dstw),                                (float)(dstY + dsth),
-		xFixedToFloat(srcBottomRight.x) / info->texW[0],  xFixedToFloat(srcBottomRight.y) / info->texH[0]);
-	VTX_OUT((float)(dstX + dstw),                                (float)dstY,
-		xFixedToFloat(srcTopRight.x) / info->texW[0],     xFixedToFloat(srcTopRight.y) / info->texH[0]);
+#endif
+	if (pPriv->bicubic_enabled) {
+		VTX_OUT_FILTER((float)dstX,                       (float)dstY,
+		xFixedToFloat(srcTopLeft.x) / info->accel_state->texW[0],      xFixedToFloat(srcTopLeft.y) / info->accel_state->texH[0],
+		xFixedToFloat(srcTopLeft.x) + 0.5,                xFixedToFloat(srcTopLeft.y) + 0.5);
+		VTX_OUT_FILTER((float)dstX,                       (float)(dstY + dsth),
+		xFixedToFloat(srcBottomLeft.x) / info->accel_state->texW[0],   xFixedToFloat(srcBottomLeft.y) / info->accel_state->texH[0],
+		xFixedToFloat(srcBottomLeft.x) + 0.5,             xFixedToFloat(srcBottomLeft.y) + 0.5);
+		VTX_OUT_FILTER((float)(dstX + dstw),              (float)(dstY + dsth),
+		xFixedToFloat(srcBottomRight.x) / info->accel_state->texW[0],  xFixedToFloat(srcBottomRight.y) / info->accel_state->texH[0],
+		xFixedToFloat(srcBottomRight.x) + 0.5,            xFixedToFloat(srcBottomRight.y) + 0.5);
+		VTX_OUT_FILTER((float)(dstX + dstw),              (float)dstY,
+		xFixedToFloat(srcTopRight.x) / info->accel_state->texW[0],     xFixedToFloat(srcTopRight.y) / info->accel_state->texH[0],
+		xFixedToFloat(srcTopRight.x) + 0.5,               xFixedToFloat(srcTopRight.y) + 0.5);
+	} else {
+		if (info->ChipFamily >= CHIP_FAMILY_R200) {
+			VTX_OUT((float)dstX,                              (float)dstY,
+			xFixedToFloat(srcTopLeft.x) / info->accel_state->texW[0],      xFixedToFloat(srcTopLeft.y) / info->accel_state->texH[0]);
+		}
+		VTX_OUT((float)dstX,                              (float)(dstY + dsth),
+		xFixedToFloat(srcBottomLeft.x) / info->accel_state->texW[0],   xFixedToFloat(srcBottomLeft.y) / info->accel_state->texH[0]);
+		VTX_OUT((float)(dstX + dstw),                     (float)(dstY + dsth),
+		xFixedToFloat(srcBottomRight.x) / info->accel_state->texW[0],  xFixedToFloat(srcBottomRight.y) / info->accel_state->texH[0]);
+		VTX_OUT((float)(dstX + dstw),                     (float)dstY,
+		xFixedToFloat(srcTopRight.x) / info->accel_state->texW[0],     xFixedToFloat(srcTopRight.y) / info->accel_state->texH[0]);
+	}
 
 	if (IS_R300_3D || IS_R500_3D)
 	    /* flushing is pipelined, free/finish is not */
-	    OUT_VIDEO_REG(R300_RB3D_DSTCACHE_CTLSTAT, R300_DC_FLUSH_3D);
+	    OUT_ACCEL_REG(R300_RB3D_DSTCACHE_CTLSTAT, R300_DC_FLUSH_3D);
 
 #ifdef ACCEL_CP
 	ADVANCE_RING();
 #else
-	FINISH_VIDEO();
+	FINISH_ACCEL();
 #endif /* !ACCEL_CP */
 
 	pBox++;
     }
 
     if (IS_R300_3D || IS_R500_3D) {
-	BEGIN_VIDEO(2);
-	OUT_VIDEO_REG(R300_RB3D_DSTCACHE_CTLSTAT, R300_RB3D_DC_FLUSH_ALL);
+	BEGIN_ACCEL(2);
+	OUT_ACCEL_REG(R300_RB3D_DSTCACHE_CTLSTAT, R300_RB3D_DC_FLUSH_ALL);
     } else
-	BEGIN_VIDEO(1);
-    OUT_VIDEO_REG(RADEON_WAIT_UNTIL, RADEON_WAIT_3D_IDLECLEAN);
-    FINISH_VIDEO();
+	BEGIN_ACCEL(1);
+    OUT_ACCEL_REG(RADEON_WAIT_UNTIL, RADEON_WAIT_3D_IDLECLEAN);
+    FINISH_ACCEL();
 
     DamageDamageRegion(pPriv->pDraw, &pPriv->clip);
 }
 
 #undef VTX_OUT
+#undef VTX_OUT_FILTER
 #undef FUNC_NAME
diff --git a/src/radeon_tv.c b/src/radeon_tv.c
index 90020b3..90d1ac9 100644
--- a/src/radeon_tv.c
+++ b/src/radeon_tv.c
@@ -140,7 +140,7 @@ static const uint16_t vert_timing_PAL[] =
  **********************************************************************/
 static const TVModeConstants availableTVModes[] =
 {
-    {
+    {   /* NTSC timing for 27 Mhz ref clk */
 	800,                /* horResolution */
 	600,                /* verResolution */
 	TV_STD_NTSC,        /* standard */
@@ -155,7 +155,7 @@ static const TVModeConstants availableTVModes[] =
 	4,                  /* crtcPLL_postDiv */
 	1022,               /* pixToTV */
     },
-    {
+    {   /* PAL timing for 27 Mhz ref clk */
 	800,               /* horResolution */
 	600,               /* verResolution */
 	TV_STD_PAL,        /* standard */
@@ -169,7 +169,22 @@ static const TVModeConstants availableTVModes[] =
 	231,               /* crtcPLL_M */
 	4,                 /* crtcPLL_postDiv */
 	759,               /* pixToTV */
-    }
+    },
+    {   /* NTSC timing for 14 Mhz ref clk */
+	800,                /* horResolution */
+	600,                /* verResolution */
+	TV_STD_NTSC,        /* standard */
+	1018,               /* horTotal */
+	727,                /* verTotal */
+	813,                /* horStart */
+	840,                /* horSyncStart */
+	633,                /* verSyncStart */
+	630627,             /* defRestart */
+	347,                /* crtcPLL_N */
+	14,                 /* crtcPLL_M */
+	8,                  /* crtcPLL_postDiv */
+	1022,               /* pixToTV */
+    },
 };
 
 #define N_AVAILABLE_MODES (sizeof(availableModes) / sizeof(availableModes[ 0 ]))
@@ -582,6 +597,8 @@ static Bool RADEONInitTVRestarts(xf86OutputPtr output, RADEONSavePtr save,
 				 DisplayModePtr mode)
 {
     RADEONOutputPrivatePtr radeon_output = output->driver_private;
+    RADEONInfoPtr  info       = RADEONPTR(output->scrn);
+    RADEONPLLPtr pll = &info->pll;
     int restart;
     unsigned hTotal;
     unsigned vTotal;
@@ -597,14 +614,21 @@ static Bool RADEONInitTVRestarts(xf86OutputPtr output, RADEONSavePtr save,
     /* FIXME: need to revisit this when we add more modes */
     if (radeon_output->tvStd == TV_STD_NTSC ||
 	radeon_output->tvStd == TV_STD_NTSC_J ||
-        radeon_output->tvStd == TV_STD_PAL_M)
-	constPtr = &availableTVModes[0];
-    else
-	constPtr = &availableTVModes[1];
+	radeon_output->tvStd == TV_STD_PAL_M) {
+	if (pll->reference_freq == 2700)
+	    constPtr = &availableTVModes[0];
+	else
+	    constPtr = &availableTVModes[2];
+    } else {
+	if (pll->reference_freq == 2700)
+	    constPtr = &availableTVModes[1];
+	else
+	    constPtr = &availableTVModes[1]; /* FIXME */
+    }
 
     hTotal = constPtr->horTotal;
     vTotal = constPtr->verTotal;
-    
+
     if (radeon_output->tvStd == TV_STD_NTSC ||
 	radeon_output->tvStd == TV_STD_NTSC_J ||
         radeon_output->tvStd == TV_STD_PAL_M ||
@@ -696,6 +720,8 @@ void RADEONInitTVRegisters(xf86OutputPtr output, RADEONSavePtr save,
     ScrnInfoPtr pScrn = output->scrn;
     RADEONOutputPrivatePtr radeon_output = output->driver_private;
     RADEONInfoPtr  info = RADEONPTR(pScrn);
+    RADEONPLLPtr pll = &info->pll;
+    unsigned m, n, p;
     unsigned i;
     unsigned long vert_space, flicker_removal;
     uint32_t tmp;
@@ -703,14 +729,20 @@ void RADEONInitTVRegisters(xf86OutputPtr output, RADEONSavePtr save,
     const uint16_t *hor_timing;
     const uint16_t *vert_timing;
 
-
     /* FIXME: need to revisit this when we add more modes */
     if (radeon_output->tvStd == TV_STD_NTSC ||
 	radeon_output->tvStd == TV_STD_NTSC_J ||
-	radeon_output->tvStd == TV_STD_PAL_M)
-	constPtr = &availableTVModes[0];
-    else
-	constPtr = &availableTVModes[1];
+	radeon_output->tvStd == TV_STD_PAL_M) {
+	if (pll->reference_freq == 2700)
+	    constPtr = &availableTVModes[0];
+	else
+	    constPtr = &availableTVModes[2];
+    } else {
+	if (pll->reference_freq == 2700)
+	    constPtr = &availableTVModes[1];
+	else
+	    constPtr = &availableTVModes[1]; /* FIXME */
+    }
 
     save->tv_crc_cntl = 0;
 
@@ -796,7 +828,10 @@ void RADEONInitTVRegisters(xf86OutputPtr output, RADEONSavePtr save,
     save->tv_vscaler_cntl1 = RADEON_Y_W_EN;
     save->tv_vscaler_cntl1 =
 	(save->tv_vscaler_cntl1 & 0xe3ff0000) | (vert_space * (1 << FRAC_BITS) / 10000);
-    save->tv_vscaler_cntl1 |= RADEON_RESTART_FIELD;
+
+    if (pll->reference_freq == 2700)
+	save->tv_vscaler_cntl1 |= RADEON_RESTART_FIELD;
+
     if (constPtr->horResolution == 1024)
 	save->tv_vscaler_cntl1 |= (4 << RADEON_Y_DEL_W_SIG_SHIFT);
     else
@@ -873,18 +908,33 @@ void RADEONInitTVRegisters(xf86OutputPtr output, RADEONSavePtr save,
 #endif
 
     if (radeon_output->tvStd == TV_STD_NTSC ||
-        radeon_output->tvStd == TV_STD_NTSC_J)
-	save->tv_pll_cntl = (NTSC_TV_PLL_M & RADEON_TV_M0LO_MASK) |
-	    (((NTSC_TV_PLL_M >> 8) & RADEON_TV_M0HI_MASK) << RADEON_TV_M0HI_SHIFT) |
-	    ((NTSC_TV_PLL_N & RADEON_TV_N0LO_MASK) << RADEON_TV_N0LO_SHIFT) |
-	    (((NTSC_TV_PLL_N >> 9) & RADEON_TV_N0HI_MASK) << RADEON_TV_N0HI_SHIFT) |
-	    ((NTSC_TV_PLL_P & RADEON_TV_P_MASK) << RADEON_TV_P_SHIFT);
-    else
-	save->tv_pll_cntl = (PAL_TV_PLL_M & RADEON_TV_M0LO_MASK) |
-	    (((PAL_TV_PLL_M >> 8) & RADEON_TV_M0HI_MASK) << RADEON_TV_M0HI_SHIFT) |
-	    ((PAL_TV_PLL_N & RADEON_TV_N0LO_MASK) << RADEON_TV_N0LO_SHIFT) |
-	    (((PAL_TV_PLL_N >> 9) & RADEON_TV_N0HI_MASK) << RADEON_TV_N0HI_SHIFT) |
-	    ((PAL_TV_PLL_P & RADEON_TV_P_MASK) << RADEON_TV_P_SHIFT);
+	radeon_output->tvStd == TV_STD_NTSC_J) {
+	if (pll->reference_freq == 2700) {
+	    m = NTSC_TV_PLL_M_27;
+	    n = NTSC_TV_PLL_N_27;
+	    p = NTSC_TV_PLL_P_27;
+	} else {
+	    m = NTSC_TV_PLL_M_14;
+	    n = NTSC_TV_PLL_N_14;
+	    p = NTSC_TV_PLL_P_14;
+	}
+    } else {
+	if (pll->reference_freq == 2700) {
+	    m = PAL_TV_PLL_M_27;
+	    n = PAL_TV_PLL_N_27;
+	    p = PAL_TV_PLL_P_27;
+	} else {
+	    /* FIXME */
+	    m = PAL_TV_PLL_M_27;
+	    n = PAL_TV_PLL_N_27;
+	    p = PAL_TV_PLL_P_27;
+	}
+    }
+    save->tv_pll_cntl = (m & RADEON_TV_M0LO_MASK) |
+	(((m >> 8) & RADEON_TV_M0HI_MASK) << RADEON_TV_M0HI_SHIFT) |
+	((n & RADEON_TV_N0LO_MASK) << RADEON_TV_N0LO_SHIFT) |
+	(((n >> 9) & RADEON_TV_N0HI_MASK) << RADEON_TV_N0HI_SHIFT) |
+	((p & RADEON_TV_P_MASK) << RADEON_TV_P_SHIFT);
 
     save->tv_pll_cntl1 =  (((4 & RADEON_TVPCP_MASK)<< RADEON_TVPCP_SHIFT) |
 			   ((4 & RADEON_TVPVG_MASK) << RADEON_TVPVG_SHIFT) |
@@ -999,14 +1049,23 @@ void RADEONAdjustCrtcRegistersForTV(ScrnInfoPtr pScrn, RADEONSavePtr save,
 {
     const TVModeConstants *constPtr;
     RADEONOutputPrivatePtr radeon_output = output->driver_private;
+    RADEONInfoPtr  info       = RADEONPTR(pScrn);
+    RADEONPLLPtr pll = &info->pll;
 
     /* FIXME: need to revisit this when we add more modes */
     if (radeon_output->tvStd == TV_STD_NTSC ||
 	radeon_output->tvStd == TV_STD_NTSC_J ||
-        radeon_output->tvStd == TV_STD_PAL_M)
-	constPtr = &availableTVModes[0];
-    else
-	constPtr = &availableTVModes[1];
+	radeon_output->tvStd == TV_STD_PAL_M) {
+	if (pll->reference_freq == 2700)
+	    constPtr = &availableTVModes[0];
+	else
+	    constPtr = &availableTVModes[2];
+    } else {
+	if (pll->reference_freq == 2700)
+	    constPtr = &availableTVModes[1];
+	else
+	    constPtr = &availableTVModes[1]; /* FIXME */
+    }
 
     save->crtc_h_total_disp = (((constPtr->horResolution / 8) - 1) << RADEON_CRTC_H_DISP_SHIFT) |
 	(((constPtr->horTotal / 8) - 1) << RADEON_CRTC_H_TOTAL_SHIFT);
@@ -1030,14 +1089,23 @@ void RADEONAdjustPLLRegistersForTV(ScrnInfoPtr pScrn, RADEONSavePtr save,
     unsigned postDiv;
     const TVModeConstants *constPtr;
     RADEONOutputPrivatePtr radeon_output = output->driver_private;
+    RADEONInfoPtr  info       = RADEONPTR(pScrn);
+    RADEONPLLPtr pll = &info->pll;
 
     /* FIXME: need to revisit this when we add more modes */
     if (radeon_output->tvStd == TV_STD_NTSC ||
 	radeon_output->tvStd == TV_STD_NTSC_J ||
-        radeon_output->tvStd == TV_STD_PAL_M)
-	constPtr = &availableTVModes[0];
-    else
-	constPtr = &availableTVModes[1];
+	radeon_output->tvStd == TV_STD_PAL_M) {
+	if (pll->reference_freq == 2700)
+	    constPtr = &availableTVModes[0];
+	else
+	    constPtr = &availableTVModes[2];
+    } else {
+	if (pll->reference_freq == 2700)
+	    constPtr = &availableTVModes[1];
+	else
+	    constPtr = &availableTVModes[1]; /* FIXME */
+    }
 
     save->htotal_cntl = (constPtr->horTotal & 0x7 /*0xf*/) | RADEON_HTOT_CNTL_VGA_EN;
 
@@ -1083,14 +1151,23 @@ void RADEONAdjustCrtc2RegistersForTV(ScrnInfoPtr pScrn, RADEONSavePtr save,
 {
     const TVModeConstants *constPtr;
     RADEONOutputPrivatePtr radeon_output = output->driver_private;
+    RADEONInfoPtr  info       = RADEONPTR(pScrn);
+    RADEONPLLPtr pll = &info->pll;
 
     /* FIXME: need to revisit this when we add more modes */
     if (radeon_output->tvStd == TV_STD_NTSC ||
 	radeon_output->tvStd == TV_STD_NTSC_J ||
-        radeon_output->tvStd == TV_STD_PAL_M)
-	constPtr = &availableTVModes[0];
-    else
-	constPtr = &availableTVModes[1];
+	radeon_output->tvStd == TV_STD_PAL_M) {
+	if (pll->reference_freq == 2700)
+	    constPtr = &availableTVModes[0];
+	else
+	    constPtr = &availableTVModes[2];
+    } else {
+	if (pll->reference_freq == 2700)
+	    constPtr = &availableTVModes[1];
+	else
+	    constPtr = &availableTVModes[1]; /* FIXME */
+    }
 
     save->crtc2_h_total_disp = (((constPtr->horResolution / 8) - 1) << RADEON_CRTC_H_DISP_SHIFT) |
 	(((constPtr->horTotal / 8) - 1) << RADEON_CRTC_H_TOTAL_SHIFT);
@@ -1114,14 +1191,23 @@ void RADEONAdjustPLL2RegistersForTV(ScrnInfoPtr pScrn, RADEONSavePtr save,
     unsigned postDiv;
     const TVModeConstants *constPtr;
     RADEONOutputPrivatePtr radeon_output = output->driver_private;
+    RADEONInfoPtr  info       = RADEONPTR(pScrn);
+    RADEONPLLPtr pll = &info->pll;
 
     /* FIXME: need to revisit this when we add more modes */
     if (radeon_output->tvStd == TV_STD_NTSC ||
 	radeon_output->tvStd == TV_STD_NTSC_J ||
-        radeon_output->tvStd == TV_STD_PAL_M)
-	constPtr = &availableTVModes[0];
-    else
-	constPtr = &availableTVModes[1];
+	radeon_output->tvStd == TV_STD_PAL_M) {
+	if (pll->reference_freq == 2700)
+	    constPtr = &availableTVModes[0];
+	else
+	    constPtr = &availableTVModes[2];
+    } else {
+	if (pll->reference_freq == 2700)
+	    constPtr = &availableTVModes[1];
+	else
+	    constPtr = &availableTVModes[1]; /* FIXME */
+    }
 
     save->htotal_cntl2 = (constPtr->horTotal & 0x7); /* 0xf */
 
diff --git a/src/radeon_tv.h b/src/radeon_tv.h
index c4b7838..8d77a77 100644
--- a/src/radeon_tv.h
+++ b/src/radeon_tv.h
@@ -27,24 +27,31 @@
 #define MAX_H_SIZE 5 /* Range: [-5..5], negative is smaller, positive is larger */
 
 /* tv standard constants */
-#define NTSC_TV_PLL_M 22
-#define NTSC_TV_PLL_N 175
-#define NTSC_TV_PLL_P 5
 #define NTSC_TV_CLOCK_T 233
 #define NTSC_TV_VFTOTAL 1
 #define NTSC_TV_LINES_PER_FRAME 525
 #define NTSC_TV_ZERO_H_SIZE 479166
 #define NTSC_TV_H_SIZE_UNIT 9478
 
-#define PAL_TV_PLL_M 113
-#define PAL_TV_PLL_N 668
-#define PAL_TV_PLL_P 3
 #define PAL_TV_CLOCK_T 188
 #define PAL_TV_VFTOTAL 3
 #define PAL_TV_LINES_PER_FRAME 625
 #define PAL_TV_ZERO_H_SIZE 473200
 #define PAL_TV_H_SIZE_UNIT 9360
 
+/* tv pll setting for 27 mhz ref clk */
+#define NTSC_TV_PLL_M_27 22
+#define NTSC_TV_PLL_N_27 175
+#define NTSC_TV_PLL_P_27 5
+
+#define PAL_TV_PLL_M_27 113
+#define PAL_TV_PLL_N_27 668
+#define PAL_TV_PLL_P_27 3
+
+/* tv pll setting for 14 mhz ref clk */
+#define NTSC_TV_PLL_M_14 33
+#define NTSC_TV_PLL_N_14 693
+#define NTSC_TV_PLL_P_14 7
 
 #define VERT_LEAD_IN_LINES 2
 #define FRAC_BITS 0xe
diff --git a/src/radeon_version.h b/src/radeon_version.h
index ccc1367..5717ead 100644
--- a/src/radeon_version.h
+++ b/src/radeon_version.h
@@ -39,10 +39,9 @@
 #define R200_DRIVER_NAME     "r200"
 #define R300_DRIVER_NAME     "r300"
 
-#define RADEON_VERSION_MAJOR 4
-#define RADEON_VERSION_MAJOR_TILED 5
-#define RADEON_VERSION_MINOR 3
-#define RADEON_VERSION_PATCH 0
+#define RADEON_VERSION_MAJOR PACKAGE_VERSION_MAJOR
+#define RADEON_VERSION_MINOR PACKAGE_VERSION_MINOR
+#define RADEON_VERSION_PATCH PACKAGE_VERSION_PATCHLEVEL
 
 #ifndef RADEON_VERSION_EXTRA
 #define RADEON_VERSION_EXTRA ""
diff --git a/src/radeon_video.c b/src/radeon_video.c
index ac60166..18299d5 100644
--- a/src/radeon_video.c
+++ b/src/radeon_video.c
@@ -89,10 +89,6 @@ static void RADEON_MSP_SetEncoding(RADEONPortPrivPtr pPriv);
 static void RADEON_TDA9885_SetEncoding(RADEONPortPrivPtr pPriv);
 static void RADEON_FI1236_SetEncoding(RADEONPortPrivPtr pPriv);
 
-
-
-#define ClipValue(v,min,max) ((v) < (min) ? (min) : (v) > (max) ? (max) : (v))
-
 static Atom xvBrightness, xvColorKey, xvSaturation, xvDoubleBuffer;
 static Atom xvRedIntensity, xvGreenIntensity, xvBlueIntensity;
 static Atom xvContrast, xvHue, xvColor, xvAutopaintColorkey, xvSetDefaults;
@@ -106,7 +102,6 @@ static Atom xvEncoding, xvFrequency, xvVolume, xvMute,
 	     
 static Atom xvOvAlpha, xvGrAlpha, xvAlphaMode;
 
-
 #define GET_PORT_PRIVATE(pScrn) \
    (RADEONPortPrivPtr)((RADEONPTR(pScrn))->adaptor->pPortPrivates[0].ptr)
 
@@ -245,19 +240,6 @@ radeon_crtc_clip_video(ScrnInfoPtr pScrn,
 #endif
 }
 
-#ifdef USE_EXA
-static void
-ATIVideoSave(ScreenPtr pScreen, ExaOffscreenArea *area)
-{
-    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
-    RADEONInfoPtr info = RADEONPTR(pScrn);
-    RADEONPortPrivPtr pPriv = info->adaptor->pPortPrivates[0].ptr;
-
-    if (pPriv->video_memory == area)
-        pPriv->video_memory = NULL;
-}
-#endif /* USE_EXA */
-
 void RADEONInitVideo(ScreenPtr pScreen)
 {
     ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
@@ -1632,13 +1614,12 @@ RADEONSetupImageVideo(ScreenPtr pScreen)
 
     pPriv->textured = FALSE;
 
-    if(pPriv->theatre != NULL) 
-    {
+    if(pPriv->theatre != NULL) {
 	/* video decoder is present, extend capabilities */
        adapt->nEncodings = 13;
        adapt->pEncodings = InputVideoEncodings;
        adapt->type |= XvVideoMask;
-       adapt->nAttributes = NUM_DEC_ATTRIBUTES;    
+       adapt->nAttributes = NUM_DEC_ATTRIBUTES;
        adapt->PutVideo = RADEONPutVideo;
     }
 
@@ -1654,8 +1635,19 @@ RADEONStopVideo(ScrnInfoPtr pScrn, pointer data, Bool cleanup)
   unsigned char *RADEONMMIO = info->MMIO;
   RADEONPortPrivPtr pPriv = (RADEONPortPrivPtr)data;
 
-    if (pPriv->textured)
-	return;
+  if (pPriv->textured) {
+      if (cleanup) {
+	  if (pPriv->bicubic_memory != NULL) {
+	      radeon_free_memory(pScrn, pPriv->bicubic_memory);
+	      pPriv->bicubic_memory = NULL;
+	  }
+	  if (pPriv->video_memory != NULL) {
+	      radeon_free_memory(pScrn, pPriv->video_memory);
+	      pPriv->video_memory = NULL;
+	  }
+      }
+      return;
+  }
 
   REGION_EMPTY(pScrn->pScreen, &pPriv->clip);
 
@@ -1675,7 +1667,7 @@ RADEONStopVideo(ScrnInfoPtr pScrn, pointer data, Bool cleanup)
         if(pPriv->i2c != NULL) RADEON_board_setmisc(pPriv);
      }
      if (pPriv->video_memory != NULL) {
-	 RADEONFreeMemory(pScrn, pPriv->video_memory);
+	 radeon_free_memory(pScrn, pPriv->video_memory);
 	 pPriv->video_memory = NULL;
      }
      pPriv->videoStatus = 0;
@@ -1699,9 +1691,6 @@ RADEONSetPortAttribute(ScrnInfoPtr  pScrn,
     Bool		setAlpha = FALSE;
     unsigned char *RADEONMMIO = info->MMIO;
 
-    if (pPriv->textured)
-	return BadMatch;
-
     RADEON_SYNC(info, pScrn);
 
 #define RTFSaturation(a)   (1.0 + ((a)*1.0)/1000.0)
@@ -1928,7 +1917,7 @@ RADEONSetPortAttribute(ScrnInfoPtr  pScrn,
 	if(pPriv->fi1236!=NULL){
 		xf86_fi1236_dump_status(pPriv->fi1236);
 		}
-   } 
+   }
    else if(attribute == xvAdjustment) 
    {
   	pPriv->adjustment=value;
@@ -1973,9 +1962,6 @@ RADEONGetPortAttribute(ScrnInfoPtr  pScrn,
     RADEONInfoPtr	info = RADEONPTR(pScrn);
     RADEONPortPrivPtr	pPriv = (RADEONPortPrivPtr)data;
 
-    if (pPriv->textured)
-	return BadMatch;
-
     if (info->accelOn) RADEON_SYNC(info, pScrn);
 
     if(attribute == xvAutopaintColorkey)
@@ -2433,114 +2419,6 @@ RADEONCopyMungedData(
     }
 }
 
-
-/* Allocates memory, either by resizing the allocation pointed to by mem_struct,
- * or by freeing mem_struct (if non-NULL) and allocating a new space.  The size
- * is measured in bytes, and the offset from the beginning of card space is
- * returned.
- */
-uint32_t
-RADEONAllocateMemory(
-   ScrnInfoPtr pScrn,
-   void **mem_struct,
-   int size
-){
-    ScreenPtr pScreen;
-    RADEONInfoPtr info = RADEONPTR(pScrn);
-    int offset = 0;
-
-    pScreen = screenInfo.screens[pScrn->scrnIndex];
-#ifdef USE_EXA
-    if (info->useEXA) {
-	ExaOffscreenArea *area = *mem_struct;
-
-	if (area != NULL) {
-	    if (area->size >= size)
-		return area->offset;
-
-	    exaOffscreenFree(pScrn->pScreen, area);
-	}
-
-	area = exaOffscreenAlloc(pScrn->pScreen, size, 64, TRUE, ATIVideoSave,
-				 NULL);
-	*mem_struct = area;
-	if (area == NULL)
-	    return 0;
-	offset = area->offset;
-    }
-#endif /* USE_EXA */
-#ifdef USE_XAA
-    if (!info->useEXA) {
-	FBLinearPtr linear = *mem_struct;
-	int cpp = info->CurrentLayout.bitsPerPixel / 8;
-
-	/* XAA allocates in units of pixels at the screen bpp, so adjust size
-	 * appropriately.
-	 */
-	size = (size + cpp - 1) / cpp;
-
-	if (linear) {
-	    if(linear->size >= size)
-		return linear->offset * cpp;
-
-	    if(xf86ResizeOffscreenLinear(linear, size))
-		return linear->offset * cpp;
-
-	    xf86FreeOffscreenLinear(linear);
-	}
-
-	linear = xf86AllocateOffscreenLinear(pScreen, size, 16,
-						NULL, NULL, NULL);
-	*mem_struct = linear;
-
-	if (!linear) {
-	    int max_size;
-
-	    xf86QueryLargestOffscreenLinear(pScreen, &max_size, 16,
-					    PRIORITY_EXTREME);
-
-	    if(max_size < size)
-		return 0;
-
-	    xf86PurgeUnlockedOffscreenAreas(pScreen);
-	    linear = xf86AllocateOffscreenLinear(pScreen, size, 16,
-						     NULL, NULL, NULL);
-	    *mem_struct = linear;
-	    if (!linear)
-		return 0;
-	}
-	offset = linear->offset * cpp;
-    }
-#endif /* USE_XAA */
-
-    return offset;
-}
-
-void
-RADEONFreeMemory(
-   ScrnInfoPtr pScrn,
-   void *mem_struct
-){
-    RADEONInfoPtr info = RADEONPTR(pScrn);
-
-#ifdef USE_EXA
-    if (info->useEXA) {
-	ExaOffscreenArea *area = mem_struct;
-
-	if (area != NULL)
-	    exaOffscreenFree(pScrn->pScreen, area);
-    }
-#endif /* USE_EXA */
-#ifdef USE_XAA
-    if (!info->useEXA) {
-	FBLinearPtr linear = mem_struct;
-
-	if (linear != NULL)
-	    xf86FreeOffscreenLinear(linear);
-    }
-#endif /* USE_XAA */
-}
-
 static void
 RADEONDisplayVideo(
     ScrnInfoPtr pScrn,
@@ -2586,6 +2464,7 @@ RADEONDisplayVideo(
     RADEONOutputPrivatePtr radeon_output;
     xf86OutputPtr output;
     RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
+    int base_offset;
 
     is_rgb=0; is_planar=0;
     switch(id){
@@ -2715,6 +2594,22 @@ RADEONDisplayVideo(
         }
 #endif
 
+    /* Make the overlay base address as close to the buffers as possible to
+     * prevent the buffer offsets from exceeding the hardware limit of 128 MB.
+     * The base address must be aligned to a multiple of 4 MB.
+     */
+    base_offset = ((info->fbLocation +
+		    min(offset1, min(offset2, min(offset3, min(offset4,
+			min(offset5, offset6)))))) & (~0 << 22)) -
+	info->fbLocation;
+
+    offset1 -= base_offset;
+    offset2 -= base_offset;
+    offset3 -= base_offset;
+    offset4 -= base_offset;
+    offset5 -= base_offset;
+    offset6 -= base_offset;
+
     /* keep everything in 16.16 */
 
     if (is_planar) {
@@ -2846,6 +2741,10 @@ RADEONDisplayVideo(
 	src_w >>= 1;
     OUTREG(RADEON_OV0_P2_X_START_END, (src_w + leftuv - 1) | (leftuv << 16));
     OUTREG(RADEON_OV0_P3_X_START_END, (src_w + leftuv - 1) | (leftuv << 16));
+    if (info->ModeReg->ov0_base_addr != (info->fbLocation + base_offset)) {
+	info->ModeReg->ov0_base_addr = info->fbLocation + base_offset;
+	OUTREG(RADEON_OV0_BASE_ADDR, info->ModeReg->ov0_base_addr);
+    }
     OUTREG(RADEON_OV0_VID_BUF0_BASE_ADRS, offset1);
     OUTREG(RADEON_OV0_VID_BUF1_BASE_ADRS, offset2);
     OUTREG(RADEON_OV0_VID_BUF2_BASE_ADRS, offset3);
@@ -3038,9 +2937,9 @@ RADEONPutImage(
    if (idconv == FOURCC_YV12 || id == FOURCC_I420) {
       new_size += (dstPitch >> 1) * ((height + 1) & ~1);
    }
-   pPriv->video_offset = RADEONAllocateMemory(pScrn, &pPriv->video_memory,
-					      (pPriv->doubleBuffer ?
-					       (new_size * 2) : new_size));
+   pPriv->video_offset = radeon_allocate_memory(pScrn, &pPriv->video_memory,
+						(pPriv->doubleBuffer ?
+						 (new_size * 2) : new_size), 64);
    if (pPriv->video_offset == 0)
       return BadAlloc;
 
@@ -3233,7 +3132,7 @@ RADEONVideoTimerCallback(ScrnInfoPtr pScrn, Time now)
 	} else {  /* FREE_TIMER */
 	    if(pPriv->freeTime < now) {
 		if (pPriv->video_memory != NULL) {
-		    RADEONFreeMemory(pScrn, pPriv->video_memory);
+		    radeon_free_memory(pScrn, pPriv->video_memory);
 		    pPriv->video_memory = NULL;
 		}
 		pPriv->videoStatus = 0;
@@ -3268,7 +3167,7 @@ RADEONAllocateSurface(
     pitch = ((w << 1) + 15) & ~15;
     size = pitch * h;
 
-    offset = RADEONAllocateMemory(pScrn, &surface_memory, size);
+    offset = radeon_allocate_memory(pScrn, &surface_memory, size, 64);
     if (offset == 0)
 	return BadAlloc;
 
@@ -3276,18 +3175,18 @@ RADEONAllocateSurface(
     surface->height = h;
 
     if(!(surface->pitches = xalloc(sizeof(int)))) {
-	RADEONFreeMemory(pScrn, surface_memory);
+	radeon_free_memory(pScrn, surface_memory);
 	return BadAlloc;
     }
     if(!(surface->offsets = xalloc(sizeof(int)))) {
 	xfree(surface->pitches);
-	RADEONFreeMemory(pScrn, surface_memory);
+	radeon_free_memory(pScrn, surface_memory);
 	return BadAlloc;
     }
     if(!(pPriv = xalloc(sizeof(OffscreenPrivRec)))) {
 	xfree(surface->pitches);
 	xfree(surface->offsets);
-	RADEONFreeMemory(pScrn, surface_memory);
+	radeon_free_memory(pScrn, surface_memory);
 	return BadAlloc;
     }
 
@@ -3328,7 +3227,8 @@ RADEONFreeSurface(
 
     if(pPriv->isOn)
 	RADEONStopSurface(surface);
-    RADEONFreeMemory(pScrn, pPriv->surface_memory);
+    radeon_free_memory(pScrn, pPriv->surface_memory);
+    pPriv->surface_memory = NULL;
     xfree(surface->pitches);
     xfree(surface->offsets);
     xfree(surface->devPrivate.ptr);
@@ -3602,9 +3502,9 @@ RADEONPutVideo(
    if (pPriv->capture_vbi_data)
       alloc_size += 2 * 2 * vbi_line_width * 21;
 
-   pPriv->video_offset = RADEONAllocateMemory(pScrn, &pPriv->video_memory,
-					      (pPriv->doubleBuffer ?
-					       (new_size * 2) : new_size));
+   pPriv->video_offset = radeon_allocate_memory(pScrn, &pPriv->video_memory,
+						(pPriv->doubleBuffer ?
+						 (new_size * 2) : new_size), 64);
    if (pPriv->video_offset == 0)
       return BadAlloc;
 
diff --git a/src/radeon_video.h b/src/radeon_video.h
index 096de37..11b8029 100644
--- a/src/radeon_video.h
+++ b/src/radeon_video.h
@@ -13,6 +13,10 @@
 
 #include "xf86Crtc.h"
 
+#include "bicubic_table.h"
+
+#define ClipValue(v,min,max) ((v) < (min) ? (min) : (v) > (max) ? (max) : (v))
+
 /* Xvideo port struct */
 typedef struct {
    uint32_t	 transform_index;
@@ -37,7 +41,7 @@ typedef struct {
    uint32_t      radeon_N;
    uint32_t      i2c_status;
    uint32_t      i2c_cntl;
-   
+
    FI1236Ptr     fi1236;
    uint8_t       tuner_type;
    MSP3430Ptr    msp3430;
@@ -46,7 +50,7 @@ typedef struct {
 
    /* VIP bus and devices */
    GENERIC_BUS_Ptr  VIP;
-   TheatrePtr       theatre;   
+   TheatrePtr       theatre;
 
    Bool          video_stream_active;
    int           encoding;
@@ -56,7 +60,7 @@ typedef struct {
    int           sap_channel;
    int           v;
    uint32_t      adjustment; /* general purpose variable */
-   
+
 #define METHOD_BOB      0
 #define METHOD_SINGLE   1
 #define METHOD_WEAVE    2
@@ -82,13 +86,16 @@ typedef struct {
    xf86CrtcPtr   desired_crtc;
 
    int           size;
-#ifdef USE_EXA
-   ExaOffscreenArea *off_screen;
-#endif
 
    void         *video_memory;
    int           video_offset;
 
+   /* bicubic filtering */
+   void         *bicubic_memory;
+   int           bicubic_offset;
+   Bool          bicubic_enabled;
+   uint32_t      bicubic_src_offset;
+
    Atom          device_id, location_id, instance_id;
 
     /* textured video */
@@ -106,18 +113,12 @@ typedef struct {
     int drw_x, drw_y;
 } RADEONPortPrivRec, *RADEONPortPrivPtr;
 
-
 void RADEONInitI2C(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv);
 void RADEONResetI2C(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv);
 
 void RADEONVIP_init(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv);
 void RADEONVIP_reset(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv);
 
-uint32_t
-RADEONAllocateMemory(ScrnInfoPtr pScrn, void **mem_struct, int size);
-void
-RADEONFreeMemory(ScrnInfoPtr pScrn, void *mem_struct);
-
 int  RADEONSetPortAttribute(ScrnInfoPtr, Atom, INT32, pointer);
 int  RADEONGetPortAttribute(ScrnInfoPtr, Atom ,INT32 *, pointer);
 void RADEONStopVideo(ScrnInfoPtr, pointer, Bool);
