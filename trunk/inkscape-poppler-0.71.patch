diff --git a/src/extension/internal/pdfinput/pdf-parser.cpp b/src/extension/internal/pdfinput/pdf-parser.cpp
index bc7ad8a6ee..0d476dc220 100644
--- a/src/extension/internal/pdfinput/pdf-parser.cpp
+++ b/src/extension/internal/pdfinput/pdf-parser.cpp
@@ -267,7 +267,7 @@ public:
     // Manipulate clip path stack
     ClipHistoryEntry *save();
     ClipHistoryEntry *restore();
-    GBool hasSaves() { return saved != nullptr; }
+    bool hasSaves() { return saved != nullptr; }
     void setClip(GfxPath *newClipPath, GfxClipType newClipType = clipNormal);
     GfxPath *getClipPath() { return clipPath; }
     GfxClipType getClipType() { return clipType; }
@@ -295,11 +295,11 @@ PdfParser::PdfParser(XRef *xrefA,
                      _POPPLER_CONST PDFRectangle *cropBox) :
     xref(xrefA),
     builder(builderA),
-    subPage(gFalse),
+    subPage(false),
     printCommands(false),
     res(new GfxResources(xref, resDict, nullptr)), // start the resource stack
-    state(new GfxState(72.0, 72.0, box, rotate, gTrue)),
-    fontChanged(gFalse),
+    state(new GfxState(72.0, 72.0, box, rotate, true)),
+    fontChanged(false),
     clip(clipNone),
     ignoreUndef(0),
     baseMatrix(),
@@ -352,11 +352,11 @@ PdfParser::PdfParser(XRef *xrefA,
 		     _POPPLER_CONST PDFRectangle *box) :
     xref(xrefA),
     builder(builderA),
-    subPage(gTrue),
+    subPage(true),
     printCommands(false),
     res(new GfxResources(xref, resDict, nullptr)), // start the resource stack
-    state(new GfxState(72, 72, box, 0, gFalse)),
-    fontChanged(gFalse),
+    state(new GfxState(72, 72, box, 0, false)),
+    fontChanged(false),
     clip(clipNone),
     ignoreUndef(0),
     baseMatrix(),
@@ -405,7 +405,7 @@ PdfParser::~PdfParser() {
   }
 }
 
-void PdfParser::parse(Object *obj, GBool topLevel) {
+void PdfParser::parse(Object *obj, bool topLevel) {
   Object obj2;
 
   if (obj->isArray()) {
@@ -422,13 +422,13 @@ void PdfParser::parse(Object *obj, GBool topLevel) {
 	error(errInternal, -1, "Weird page contents");
     	return;
   }
-  parser = new Parser(xref, new Lexer(xref, obj), gFalse);
+  parser = new Parser(xref, new Lexer(xref, obj), false);
   go(topLevel);
   delete parser;
   parser = nullptr;
 }
 
-void PdfParser::go(GBool /*topLevel*/)
+void PdfParser::go(bool /*topLevel*/)
 {
   Object obj;
   Object args[maxArgs];
@@ -612,7 +612,7 @@ PdfOperator* PdfParser::findOp(const char *name) {
   return &opTab[a];
 }
 
-GBool PdfParser::checkArg(Object *arg, TchkType type) {
+bool PdfParser::checkArg(Object *arg, TchkType type) {
   switch (type) {
   case tchkBool:   return arg->isBool();
   case tchkInt:    return arg->isInt();
@@ -622,9 +622,9 @@ GBool PdfParser::checkArg(Object *arg, TchkType type) {
   case tchkArray:  return arg->isArray();
   case tchkProps:  return arg->isDict() || arg->isName();
   case tchkSCN:    return arg->isNum() || arg->isName();
-  case tchkNone:   return gFalse;
+  case tchkNone:   return false;
   }
-  return gFalse;
+  return false;
 }
 
 int PdfParser::getPos() {
@@ -679,7 +679,7 @@ void PdfParser::opConcat(Object args[], int /*numArgs*/)
       builder->pushGroup();
       builder->setTransform(a0, a1, a2, a3, a4, a5);
   }
-  fontChanged = gTrue;
+  fontChanged = true;
 }
 
 // TODO not good that numArgs is ignored but args[] is used:
@@ -741,8 +741,8 @@ void PdfParser::opSetExtGState(Object args[], int /*numArgs*/)
   Object obj1, obj2, obj3, obj4, obj5;
   Function *funcs[4] = {nullptr, nullptr, nullptr, nullptr};
   GfxColor backdropColor;
-  GBool haveBackdropColor = gFalse;
-  GBool alpha = gFalse;
+  bool haveBackdropColor = false;
+  bool alpha = false;
 
   _POPPLER_CALL_ARGS(obj1, res->lookupGState, args[0].getName());
   if (obj1.isNull()) {
@@ -779,7 +779,7 @@ void PdfParser::opSetExtGState(Object args[], int /*numArgs*/)
   _POPPLER_FREE(obj2);
 
   // fill/stroke overprint
-  GBool haveFillOP = gFalse;
+  bool haveFillOP = false;
   if ((haveFillOP = _POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "op").isBool())) {
     state->setFillOverprint(obj2.getBool());
   }
@@ -837,9 +837,9 @@ void PdfParser::opSetExtGState(Object args[], int /*numArgs*/)
       builder->clearSoftMask(state);
     } else if (obj2.isDict()) {
       if (_POPPLER_CALL_ARGS_DEREF(obj3, obj2.dictLookup, "S").isName("Alpha")) {
-	alpha = gTrue;
+	alpha = true;
       } else { // "Luminosity"
-	alpha = gFalse;
+	alpha = false;
       }
       _POPPLER_FREE(obj3);
       funcs[0] = nullptr;
@@ -869,8 +869,8 @@ void PdfParser::opSetExtGState(Object args[], int /*numArgs*/)
       if (_POPPLER_CALL_ARGS_DEREF(obj3, obj2.dictLookup, "G").isStream()) {
 	if (_POPPLER_CALL_ARGS_DEREF(obj4, obj3.streamGetDict()->lookup, "Group").isDict()) {
 	  GfxColorSpace *blendingColorSpace = nullptr;
-	  GBool isolated = gFalse;
-	  GBool knockout = gFalse;
+	  bool isolated = false;
+	  bool knockout = false;
 	  if (!_POPPLER_CALL_ARGS_DEREF(obj5, obj4.dictLookup, "CS").isNull()) {
 #if defined(POPPLER_EVEN_NEWER_NEW_COLOR_SPACE_API)
 	    blendingColorSpace = GfxColorSpace::parse(nullptr, &obj5, nullptr, nullptr);
@@ -921,9 +921,9 @@ void PdfParser::opSetExtGState(Object args[], int /*numArgs*/)
   _POPPLER_FREE(obj1);
 }
 
-void PdfParser::doSoftMask(Object *str, GBool alpha,
+void PdfParser::doSoftMask(Object *str, bool alpha,
 		     GfxColorSpace *blendingColorSpace,
-		     GBool isolated, GBool knockout,
+		     bool isolated, bool knockout,
 		     Function *transferFunc, GfxColor *backdropColor) {
   Dict *dict, *resDict;
   double m[6], bbox[4];
@@ -980,7 +980,7 @@ void PdfParser::doSoftMask(Object *str, GBool alpha,
 
   // draw it
   ++formDepth;
-  doForm1(str, resDict, m, bbox, gTrue, gTrue,
+  doForm1(str, resDict, m, bbox, true, true,
 	  blendingColorSpace, isolated, knockout,
 	  alpha, transferFunc, backdropColor);
   --formDepth;
@@ -1436,7 +1436,7 @@ void PdfParser::opFill(Object /*args*/[], int /*numArgs*/)
   if (state->isPath()) {
     if (state->getFillColorSpace()->getMode() == csPattern &&
         !builder->isPatternTypeSupported(state->getFillPattern())) {
-      doPatternFillFallback(gFalse);
+      doPatternFillFallback(false);
     } else {
       builder->addPath(state, true, false);
     }
@@ -1453,7 +1453,7 @@ void PdfParser::opEOFill(Object /*args*/[], int /*numArgs*/)
   if (state->isPath()) {
     if (state->getFillColorSpace()->getMode() == csPattern &&
         !builder->isPatternTypeSupported(state->getFillPattern())) {
-      doPatternFillFallback(gTrue);
+      doPatternFillFallback(true);
     } else {
       builder->addPath(state, true, false, true);
     }
@@ -1468,7 +1468,7 @@ void PdfParser::opFillStroke(Object /*args*/[], int /*numArgs*/)
     return;
   }
   if (state->isPath()) {
-    doFillAndStroke(gFalse);
+    doFillAndStroke(false);
   } else {
     builder->addPath(state, true, true);
   }
@@ -1483,7 +1483,7 @@ void PdfParser::opCloseFillStroke(Object /*args*/[], int /*numArgs*/)
   }
   if (state->isPath()) {
     state->closePath();
-    doFillAndStroke(gFalse);
+    doFillAndStroke(false);
   }
   doEndPath();
 }
@@ -1495,7 +1495,7 @@ void PdfParser::opEOFillStroke(Object /*args*/[], int /*numArgs*/)
     return;
   }
   if (state->isPath()) {
-    doFillAndStroke(gTrue);
+    doFillAndStroke(true);
   }
   doEndPath();
 }
@@ -1508,20 +1508,20 @@ void PdfParser::opCloseEOFillStroke(Object /*args*/[], int /*numArgs*/)
   }
   if (state->isPath()) {
     state->closePath();
-    doFillAndStroke(gTrue);
+    doFillAndStroke(true);
   }
   doEndPath();
 }
 
-void PdfParser::doFillAndStroke(GBool eoFill) {
-    GBool fillOk = gTrue, strokeOk = gTrue;
+void PdfParser::doFillAndStroke(bool eoFill) {
+    bool fillOk = true, strokeOk = true;
     if (state->getFillColorSpace()->getMode() == csPattern &&
         !builder->isPatternTypeSupported(state->getFillPattern())) {
-        fillOk = gFalse;
+        fillOk = false;
     }
     if (state->getStrokeColorSpace()->getMode() == csPattern &&
         !builder->isPatternTypeSupported(state->getStrokePattern())) {
-        strokeOk = gFalse;
+        strokeOk = false;
     }
     if (fillOk && strokeOk) {
         builder->addPath(state, true, true, eoFill);
@@ -1531,7 +1531,7 @@ void PdfParser::doFillAndStroke(GBool eoFill) {
     }
 }
 
-void PdfParser::doPatternFillFallback(GBool eoFill) {
+void PdfParser::doPatternFillFallback(bool eoFill) {
   GfxPattern *pattern;
 
   if (!(pattern = state->getFillPattern())) {
@@ -1541,7 +1541,7 @@ void PdfParser::doPatternFillFallback(GBool eoFill) {
   case 1:
     break;
   case 2:
-    doShadingPatternFillFallback(static_cast<GfxShadingPattern *>(pattern), gFalse, eoFill);
+    doShadingPatternFillFallback(static_cast<GfxShadingPattern *>(pattern), false, eoFill);
     break;
   default:
     error(errUnimplemented, getPos(), "Unimplemented pattern type (%d) in fill",
@@ -1560,7 +1560,7 @@ void PdfParser::doPatternStrokeFallback() {
   case 1:
     break;
   case 2:
-    doShadingPatternFillFallback(static_cast<GfxShadingPattern *>(pattern), gTrue, gFalse);
+    doShadingPatternFillFallback(static_cast<GfxShadingPattern *>(pattern), true, false);
     break;
   default:
     error(errUnimplemented, getPos(), "Unimplemented pattern type ({0:d}) in stroke",
@@ -1570,7 +1570,7 @@ void PdfParser::doPatternStrokeFallback() {
 }
 
 void PdfParser::doShadingPatternFillFallback(GfxShadingPattern *sPat,
-                                             GBool stroke, GBool eoFill) {
+                                             bool stroke, bool eoFill) {
   GfxShading *shading;
   GfxPath *savedPath;
   const double *ctm, *btm, *ptm;
@@ -1684,7 +1684,7 @@ void PdfParser::opShFill(Object args[], int /*numArgs*/)
   double xTemp, yTemp;
   double gradientTransform[6];
   double *matrix = nullptr;
-  GBool savedState = gFalse;
+  bool savedState = false;
 
 #if defined(POPPLER_EVEN_NEWER_COLOR_SPACE_API)
   if (!(shading = res->lookupShading(args[0].getName(), nullptr, nullptr))) {
@@ -1700,13 +1700,13 @@ void PdfParser::opShFill(Object args[], int /*numArgs*/)
   if (shading->getType() != 2 && shading->getType() != 3) {
     savedPath = state->getPath()->copy();
     saveState();
-    savedState = gTrue;
+    savedState = true;
   } else {  // get gradient transform if possible
       // check proper operator sequence
       // first there should be one W(*) and then one 'cm' somewhere before 'sh'
-      GBool seenClip, seenConcat;
+      bool seenClip, seenConcat;
       seenClip = (clipHistory->getClipPath() != nullptr);
-      seenConcat = gFalse;
+      seenConcat = false;
       int i = 1;
       while (i <= maxOperatorHistoryDepth) {
         const char *opName = getPreviousOperator(i);
@@ -1714,7 +1714,7 @@ void PdfParser::opShFill(Object args[], int /*numArgs*/)
           if (seenConcat) {   // more than one 'cm'
             break;
           } else {
-            seenConcat = gTrue;
+            seenConcat = true;
           }
         }
         i++;
@@ -2169,7 +2169,7 @@ void PdfParser::opBeginText(Object /*args*/[], int /*numArgs*/)
   state->setTextMat(1, 0, 0, 1, 0, 0);
   state->textMoveTo(0, 0);
   builder->updateTextPosition(0.0, 0.0);
-  fontChanged = gTrue;
+  fontChanged = true;
   builder->beginTextObject(state);
 }
 
@@ -2197,7 +2197,7 @@ void PdfParser::opSetFont(Object args[], int /*numArgs*/)
     // unsetting the font (drawing no text) is better than using the
     // previous one and drawing random glyphs from it
     state->setFont(nullptr, args[1].getNum());
-    fontChanged = gTrue;
+    fontChanged = true;
     return;
   }
   if (printCommands) {
@@ -2210,7 +2210,7 @@ void PdfParser::opSetFont(Object args[], int /*numArgs*/)
 
   font->incRefCnt();
   state->setFont(font, args[1].getNum());
-  fontChanged = gTrue;
+  fontChanged = true;
 }
 
 // TODO not good that numArgs is ignored but args[] is used:
@@ -2243,7 +2243,7 @@ void PdfParser::opSetHorizScaling(Object args[], int /*numArgs*/)
 {
   state->setHorizScaling(args[0].getNum());
   builder->updateTextMatrix(state);
-  fontChanged = gTrue;
+  fontChanged = true;
 }
 
 //------------------------------------------------------------------------
@@ -2283,7 +2283,7 @@ void PdfParser::opSetTextMatrix(Object args[], int /*numArgs*/)
   state->textMoveTo(0, 0);
   builder->updateTextMatrix(state);
   builder->updateTextPosition(0.0, 0.0);
-  fontChanged = gTrue;
+  fontChanged = true;
 }
 
 void PdfParser::opTextNextLine(Object /*args*/[], int /*numArgs*/)
@@ -2309,7 +2309,7 @@ void PdfParser::opShowText(Object args[], int /*numArgs*/)
   }
   if (fontChanged) {
     builder->updateFont(state);
-    fontChanged = gFalse;
+    fontChanged = false;
   }
   doShowText(args[0].getString());
 }
@@ -2326,7 +2326,7 @@ void PdfParser::opMoveShowText(Object args[], int /*numArgs*/)
   }
   if (fontChanged) {
     builder->updateFont(state);
-    fontChanged = gFalse;
+    fontChanged = false;
   }
   tx = state->getLineX();
   ty = state->getLineY() - state->getLeading();
@@ -2347,7 +2347,7 @@ void PdfParser::opMoveSetShowText(Object args[], int /*numArgs*/)
   }
   if (fontChanged) {
     builder->updateFont(state);
-    fontChanged = gFalse;
+    fontChanged = false;
   }
   state->setWordSpace(args[0].getNum());
   state->setCharSpace(args[1].getNum());
@@ -2371,7 +2371,7 @@ void PdfParser::opShowSpaceText(Object args[], int /*numArgs*/)
   }
   if (fontChanged) {
     builder->updateFont(state);
-    fontChanged = gFalse;
+    fontChanged = false;
   }
   wMode = state->getFont()->getWMode();
   a = args[0].getArray();
@@ -2479,7 +2479,7 @@ void PdfParser::doShowText(GooString *s) {
 	  pushResources(resDict);
 	}
 	if (charProc.isStream()) {
-	  //parse(&charProc, gFalse); // TODO: parse into SVG font
+	  //parse(&charProc, false); // TODO: parse into SVG font
 	} else {
 	  error(errSyntaxError, getPos(), "Missing or bad Type3 CharProc entry");
 	}
@@ -2566,7 +2566,7 @@ void PdfParser::opXObject(Object args[], int /*numArgs*/)
   _POPPLER_CALL_ARGS(obj2, obj1.streamGetDict()->lookup, "Subtype");
   if (obj2.isName(const_cast<char*>("Image"))) {
     _POPPLER_CALL_ARGS(refObj, res->lookupXObjectNF, name);
-    doImage(&refObj, obj1.getStream(), gFalse);
+    doImage(&refObj, obj1.getStream(), false);
     _POPPLER_FREE(refObj);
   } else if (obj2.isName(const_cast<char*>("Form"))) {
     doForm(&obj1);
@@ -2583,19 +2583,19 @@ void PdfParser::opXObject(Object args[], int /*numArgs*/)
   _POPPLER_FREE(obj1);
 }
 
-void PdfParser::doImage(Object * /*ref*/, Stream *str, GBool inlineImg)
+void PdfParser::doImage(Object * /*ref*/, Stream *str, bool inlineImg)
 {
     Dict *dict;
     int width, height;
     int bits;
-    GBool interpolate;
+    bool interpolate;
     StreamColorSpaceMode csMode;
-    GBool mask;
-    GBool invert;
+    bool mask;
+    bool invert;
     Object maskObj, smaskObj;
-    GBool haveColorKeyMask, haveExplicitMask, haveSoftMask;
-    GBool maskInvert;
-    GBool maskInterpolate;
+    bool haveColorKeyMask, haveExplicitMask, haveSoftMask;
+    bool maskInvert;
+    bool maskInterpolate;
     Object obj1, obj2;
     
     // get info from the stream
@@ -2647,9 +2647,9 @@ void PdfParser::doImage(Object * /*ref*/, Stream *str, GBool inlineImg)
     if (obj1.isBool())
       interpolate = obj1.getBool();
     else
-      interpolate = gFalse;
+      interpolate = false;
     _POPPLER_FREE(obj1);
-    maskInterpolate = gFalse;
+    maskInterpolate = false;
 
     // image or mask?
     _POPPLER_CALL_ARGS(obj1, dict->lookup, "ImageMask");
@@ -2657,7 +2657,7 @@ void PdfParser::doImage(Object * /*ref*/, Stream *str, GBool inlineImg)
         _POPPLER_FREE(obj1);
         _POPPLER_CALL_ARGS(obj1, dict->lookup, "IM");
     }
-    mask = gFalse;
+    mask = false;
     if (obj1.isBool()) {
         mask = obj1.getBool();
     }
@@ -2689,7 +2689,7 @@ void PdfParser::doImage(Object * /*ref*/, Stream *str, GBool inlineImg)
         if (bits != 1) {
             goto err1;
         }
-        invert = gFalse;
+        invert = false;
         _POPPLER_CALL_ARGS(obj1, dict->lookup, "Decode");
         if (obj1.isNull()) {
             _POPPLER_FREE(obj1);
@@ -2698,7 +2698,7 @@ void PdfParser::doImage(Object * /*ref*/, Stream *str, GBool inlineImg)
         if (obj1.isArray()) {
             _POPPLER_CALL_ARGS(obj2, obj1.arrayGet, 0);
             if (obj2.isInt() && obj2.getInt() == 1) {
-                invert = gTrue;
+                invert = true;
             }
             _POPPLER_FREE(obj2);
         } else if (!obj1.isNull()) {
@@ -2761,11 +2761,11 @@ void PdfParser::doImage(Object * /*ref*/, Stream *str, GBool inlineImg)
         
         // get the mask
         int maskColors[2*gfxColorMaxComps];
-        haveColorKeyMask = haveExplicitMask = haveSoftMask = gFalse;
+        haveColorKeyMask = haveExplicitMask = haveSoftMask = false;
         Stream *maskStr = nullptr;
         int maskWidth = 0;
         int maskHeight = 0;
-        maskInvert = gFalse;
+        maskInvert = false;
         GfxImageColorMap *maskColorMap = nullptr;
         _POPPLER_CALL_ARGS(maskObj, dict->lookup, "Mask");
         _POPPLER_CALL_ARGS(smaskObj, dict->lookup, "SMask");
@@ -2815,7 +2815,7 @@ void PdfParser::doImage(Object * /*ref*/, Stream *str, GBool inlineImg)
 	    if (obj1.isBool())
 	      maskInterpolate = obj1.getBool();
 	    else
-	      maskInterpolate = gFalse;
+	      maskInterpolate = false;
 	    _POPPLER_FREE(obj1);
             _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "ColorSpace");
             if (obj1.isNull()) {
@@ -2854,7 +2854,7 @@ void PdfParser::doImage(Object * /*ref*/, Stream *str, GBool inlineImg)
                 goto err1;
             }
             //~ handle the Matte entry
-            haveSoftMask = gTrue;
+            haveSoftMask = true;
         } else if (maskObj.isArray()) {
             // color key mask
             int i;
@@ -2863,7 +2863,7 @@ void PdfParser::doImage(Object * /*ref*/, Stream *str, GBool inlineImg)
                 maskColors[i] = obj1.getInt();
                 _POPPLER_FREE(obj1);
             }
-              haveColorKeyMask = gTrue;
+              haveColorKeyMask = true;
         } else if (maskObj.isStream()) {
             // explicit mask
             if (inlineImg) {
@@ -2908,9 +2908,9 @@ void PdfParser::doImage(Object * /*ref*/, Stream *str, GBool inlineImg)
 	    if (obj1.isBool())
 	      maskInterpolate = obj1.getBool();
 	    else
-	      maskInterpolate = gFalse;
+	      maskInterpolate = false;
 	    _POPPLER_FREE(obj1);
-            maskInvert = gFalse;
+            maskInvert = false;
             _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "Decode");
             if (obj1.isNull()) {
                 _POPPLER_FREE(obj1);
@@ -2919,14 +2919,14 @@ void PdfParser::doImage(Object * /*ref*/, Stream *str, GBool inlineImg)
             if (obj1.isArray()) {
                 _POPPLER_CALL_ARGS(obj2, obj1.arrayGet, 0);
                 if (obj2.isInt() && obj2.getInt() == 1) {
-                    maskInvert = gTrue;
+                    maskInvert = true;
                 }
                 _POPPLER_FREE(obj2);
             } else if (!obj1.isNull()) {
                 goto err2;
             }
             _POPPLER_FREE(obj1);
-            haveExplicitMask = gTrue;
+            haveExplicitMask = true;
         }
         
         // draw it
@@ -2957,7 +2957,7 @@ void PdfParser::doImage(Object * /*ref*/, Stream *str, GBool inlineImg)
 
 void PdfParser::doForm(Object *str) {
   Dict *dict;
-  GBool transpGroup, isolated, knockout;
+  bool transpGroup, isolated, knockout;
   GfxColorSpace *blendingColorSpace;
   Object matrixObj, bboxObj;
   double m[6], bbox[4];
@@ -3015,11 +3015,11 @@ void PdfParser::doForm(Object *str) {
   resDict = resObj.isDict() ? resObj.getDict() : (Dict *)nullptr;
 
   // check for a transparency group
-  transpGroup = isolated = knockout = gFalse;
+  transpGroup = isolated = knockout = false;
   blendingColorSpace = nullptr;
   if (_POPPLER_CALL_ARGS_DEREF(obj1, dict->lookup, "Group").isDict()) {
     if (_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "S").isName("Transparency")) {
-      transpGroup = gTrue;
+      transpGroup = true;
       if (!_POPPLER_CALL_ARGS_DEREF(obj3, obj1.dictLookup, "CS").isNull()) {
 #if defined(POPPLER_EVEN_NEWER_NEW_COLOR_SPACE_API)
 	blendingColorSpace = GfxColorSpace::parse(nullptr, &obj3, nullptr, nullptr);
@@ -3046,7 +3046,7 @@ void PdfParser::doForm(Object *str) {
   // draw it
   ++formDepth;
   doForm1(str, resDict, m, bbox,
-	  transpGroup, gFalse, blendingColorSpace, isolated, knockout);
+	  transpGroup, false, blendingColorSpace, isolated, knockout);
   --formDepth;
 
   if (blendingColorSpace) {
@@ -3056,10 +3056,10 @@ void PdfParser::doForm(Object *str) {
 }
 
 void PdfParser::doForm1(Object *str, Dict *resDict, double *matrix, double *bbox,
-		  GBool transpGroup, GBool softMask,
+		  bool transpGroup, bool softMask,
 		  GfxColorSpace *blendingColorSpace,
-		  GBool isolated, GBool knockout,
-		  GBool alpha, Function *transferFunc,
+		  bool isolated, bool knockout,
+		  bool alpha, Function *transferFunc,
 		  GfxColor *backdropColor) {
   Parser *oldParser;
   double oldBaseMatrix[6];
@@ -3120,7 +3120,7 @@ void PdfParser::doForm1(Object *str, Dict *resDict, double *matrix, double *bbox
   }
 
   // draw the form
-  parse(str, gFalse);
+  parse(str, false);
 
   // restore base matrix
   for (i = 0; i < 6; ++i) {
@@ -3160,7 +3160,7 @@ void PdfParser::opBeginImage(Object /*args*/[], int /*numArgs*/)
 
   // display the image
   if (str) {
-    doImage(nullptr, str, gTrue);
+    doImage(nullptr, str, true);
   
     // skip 'EI' tag
     int c1 = str->getUndecodedStream()->getChar();
@@ -3212,10 +3212,10 @@ Stream *PdfParser::buildImageStream() {
 
   // make stream
 #if defined(POPPLER_NEW_OBJECT_API)
-  str = new EmbedStream(parser->getStream(), dict.copy(), gFalse, 0);
+  str = new EmbedStream(parser->getStream(), dict.copy(), false, 0);
   str = str->addFilters(dict.getDict());
 #else
-  str = new EmbedStream(parser->getStream(), &dict, gFalse, 0);
+  str = new EmbedStream(parser->getStream(), &dict, false, 0);
   str = str->addFilters(&dict);
 #endif
 
diff --git a/src/extension/internal/pdfinput/pdf-parser.h b/src/extension/internal/pdfinput/pdf-parser.h
index 2414bd376a..3690fa32ad 100644
--- a/src/extension/internal/pdfinput/pdf-parser.h
+++ b/src/extension/internal/pdfinput/pdf-parser.h
@@ -102,7 +102,7 @@ struct PdfOperator {
 struct OpHistoryEntry {
     const char *name;       // operator's name
     GfxState *state;        // saved state, NULL if none
-    GBool executed;         // whether the operator has been executed
+    bool executed;         // whether the operator has been executed
 
     OpHistoryEntry *next;   // next entry on stack
     unsigned depth;         // total number of entries descending from this
@@ -145,7 +145,7 @@ public:
   virtual ~PdfParser();
 
   // Interpret a stream or array of streams.
-  void parse(Object *obj, GBool topLevel = gTrue);
+  void parse(Object *obj, bool topLevel = true);
 
   // Save graphics state.
   void saveState();
@@ -163,12 +163,12 @@ private:
 
   XRef *xref;			// the xref table for this PDF file
   SvgBuilder *builder;          // SVG generator
-  GBool subPage;		// is this a sub-page object?
-  GBool printCommands;		// print the drawing commands (for debugging)
+  bool subPage;		// is this a sub-page object?
+  bool printCommands;		// print the drawing commands (for debugging)
   GfxResources *res;		// resource stack
 
   GfxState *state;		// current graphics state
-  GBool fontChanged;		// set if font or text matrix has changed
+  bool fontChanged;		// set if font or text matrix has changed
   GfxClipType clip;		// do a clip?
   int ignoreUndef;		// current BX/EX nesting level
   double baseMatrix[6];		// default matrix for most recent
@@ -192,10 +192,10 @@ private:
   OpHistoryEntry *popOperator();
   const char *getPreviousOperator(unsigned int look_back=1);    // returns the nth previous operator's name
 
-  void go(GBool topLevel);
+  void go(bool topLevel);
   void execOp(Object *cmd, Object args[], int numArgs);
   PdfOperator *findOp(const char *name);
-  GBool checkArg(Object *arg, TchkType type);
+  bool checkArg(Object *arg, TchkType type);
   int getPos();
 
   // graphics state operators
@@ -209,9 +209,9 @@ private:
   void opSetMiterLimit(Object args[], int numArgs);
   void opSetLineWidth(Object args[], int numArgs);
   void opSetExtGState(Object args[], int numArgs);
-  void doSoftMask(Object *str, GBool alpha,
+  void doSoftMask(Object *str, bool alpha,
 		  GfxColorSpace *blendingColorSpace,
-		  GBool isolated, GBool knockout,
+		  bool isolated, bool knockout,
 		  Function *transferFunc, GfxColor *backdropColor);
   void opSetRenderingIntent(Object args[], int numArgs);
 
@@ -248,11 +248,11 @@ private:
   void opCloseFillStroke(Object args[], int numArgs);
   void opEOFillStroke(Object args[], int numArgs);
   void opCloseEOFillStroke(Object args[], int numArgs);
-  void doFillAndStroke(GBool eoFill);
-  void doPatternFillFallback(GBool eoFill);
+  void doFillAndStroke(bool eoFill);
+  void doPatternFillFallback(bool eoFill);
   void doPatternStrokeFallback();
   void doShadingPatternFillFallback(GfxShadingPattern *sPat,
-                                    GBool stroke, GBool eoFill);
+                                    bool stroke, bool eoFill);
   void opShFill(Object args[], int numArgs);
   void doFunctionShFill(GfxFunctionShading *shading);
   void doFunctionShFill1(GfxFunctionShading *shading,
@@ -305,13 +305,13 @@ private:
 
   // XObject operators
   void opXObject(Object args[], int numArgs);
-  void doImage(Object *ref, Stream *str, GBool inlineImg);
+  void doImage(Object *ref, Stream *str, bool inlineImg);
   void doForm(Object *str);
   void doForm1(Object *str, Dict *resDict, double *matrix, double *bbox,
-	       GBool transpGroup = gFalse, GBool softMask = gFalse,
+	       bool transpGroup = false, bool softMask = false,
 	       GfxColorSpace *blendingColorSpace = nullptr,
-	       GBool isolated = gFalse, GBool knockout = gFalse,
-	       GBool alpha = gFalse, Function *transferFunc = nullptr,
+	       bool isolated = false, bool knockout = false,
+	       bool alpha = false, Function *transferFunc = nullptr,
 	       GfxColor *backdropColor = nullptr);
 
   // in-line image operators
