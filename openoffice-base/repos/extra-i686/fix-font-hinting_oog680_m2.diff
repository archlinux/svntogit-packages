--- config_office/configure.in
+++ config_office/configure.in
@@ -4689,6 +4689,10 @@
 
    if test "$ENABLE_GTK" = "TRUE" ; then
       PKG_CHECK_MODULES(GTK, gtk+-2.0 >= 2.4 gdk-pixbuf-xlib-2.0 >= 2.2 ,,AC_MSG_ERROR([requirements to build the gtk-plugin not met. Use --disable-gtk or install the missing packages]))
+        PKG_CHECK_MODULES(GDK, gdk-2.0 >= 2.10)
+        if test "x$enable_cairo" == "xno" ; then
+            PKG_CHECK_MODULES( CAIRO, cairo >= 1.4.10 )
+        fi
       BUILD_TYPE="$BUILD_TYPE GTK"
 
       if test "x$enable_systray" = "xyes"; then
--- psprint/inc/psprint/fontmanager.hxx
+++ psprint/inc/psprint/fontmanager.hxx
@@ -49,6 +49,9 @@
 #ifndef _PSPRINT_HELPER_HXX_
 #include <psprint/helper.hxx>
 #endif
+#ifndef _STRING_HXX
+#include <tools/string.hxx>
+#endif
 
 #ifndef _COM_SUN_STAR_LANG_LOCALE_HPP_
 #include <com/sun/star/lang/Locale.hpp>
@@ -152,6 +155,48 @@
 };
 }
 
+namespace fchint
+{
+enum type {
+    Nohint = 0,
+    Slight = 1,
+    Medium = 2,
+    Full = 3
+};
+}
+
+namespace fcsubpixel
+{
+enum type {
+    Unknown = 0,
+    RGB = 1,
+    BGR = 2,
+    VRGB = 3,
+    VBGR = 4,
+    NONE = 5
+};
+}
+
+
+struct FontConfigHints
+{
+    fcstatus::type m_eEmbeddedbitmap;
+    fcstatus::type m_eAntialias;
+    fcstatus::type m_eAutoHint;
+    fcstatus::type m_eHinting;
+    fchint::type m_eHintStyle;
+    fcsubpixel::type m_eSubPixel;
+
+    FontConfigHints() :
+        m_eEmbeddedbitmap( fcstatus::isunset ),
+        m_eAntialias( fcstatus::isunset ),
+        m_eAutoHint( fcstatus::isunset ),
+        m_eHinting( fcstatus::isunset ),
+        m_eHintStyle( fchint::Medium ),
+        m_eSubPixel( fcsubpixel::Unknown )
+        {}
+};
+
 /*
  *  the difference between FastPrintFontInfo and PrintFontInfo
  *  is that the information in FastPrintFontInfo can usually
@@ -177,8 +222,6 @@
     weight::type            			m_eWeight;
     pitch::type             			m_ePitch;
     rtl_TextEncoding        			m_aEncoding;
-    fcstatus::type                      m_eEmbeddedbitmap;
-    fcstatus::type                      m_eAntialias;
 
     FastPrintFontInfo() :
             m_nID( 0 ),
@@ -188,9 +231,7 @@
             m_eWidth( width::Unknown ),
             m_eWeight( weight::Unknown ),
             m_ePitch( pitch::Unknown ),
-            m_aEncoding( RTL_TEXTENCODING_DONTKNOW ),
-            m_eEmbeddedbitmap( fcstatus::isunset ),
-            m_eAntialias( fcstatus::isunset )
+            m_aEncoding( RTL_TEXTENCODING_DONTKNOW )
     {}
 };
 
@@ -200,13 +241,15 @@
     int                     				m_nDescend;
     int                     				m_nLeading;
     int                     				m_nWidth;
+	bool									m_bCJKSupport; // #i73003#
 
     PrintFontInfo() :
             FastPrintFontInfo(),
             m_nAscend( 0 ),
             m_nDescend( 0 ),
             m_nLeading( 0 ),
-            m_nWidth( 0 )
+            m_nWidth( 0 ),
+			m_bCJKSupport( 0 ) // #i73003#
     {}
 };
 
@@ -306,9 +349,7 @@
         int											m_nYMax;
         bool										m_bHaveVerticalSubstitutedGlyphs;
         bool                                        m_bUserOverride;
-
-        fcstatus::type                              m_eEmbeddedbitmap;
-        fcstatus::type                              m_eAntialias;
+		bool										m_bCJKSupport; // #i73003#
 
         std::map< sal_Unicode, sal_Int32 >			m_aEncodingVector;
         std::map< sal_Unicode, rtl::OString >		m_aNonEncoded;
@@ -413,8 +454,11 @@
     std::hash_multimap< sal_Unicode, sal_uInt8 >	m_aUnicodeToAdobecode;
     std::hash_multimap< sal_uInt8, sal_Unicode >	m_aAdobecodeToUnicode;
 
+    std::hash_map< rtl::OString, rtl::OString, rtl::OStringHash > m_aFontconfigNameToLocalized;
+
     mutable FontCache*							m_pFontCache;
     mutable std::vector< fontID >               m_aOverrideFonts;
+    bool m_bFontconfigSuccess;
         
     rtl::OString getAfmFile( PrintFont* pFont ) const;
     rtl::OString getFontFile( PrintFont* pFont ) const;
@@ -737,6 +781,13 @@
     false else
      */
     bool matchFont( FastPrintFontInfo& rInfo, const com::sun::star::lang::Locale& rLocale );
+    FontConfigHints getFontConfigHints(const FastPrintFontInfo& rInfo, int nSize);
+
+    String Substitute(const std::vector<String> &rNames, std::vector<sal_Unicode> &rGlyphs, 
+        const ByteString &rLangAttrib, italic::type eItalic, weight::type eWeight, 
+        width::type eWidth, pitch::type ePitch) const;
+    bool hasFontconfig() const { return m_bFontconfigSuccess; }
+    bool IsSupportCJK( const rtl::OUString& rFontName ); // #i73003#
 };
 
 } // namespace
--- psprint/source/fontmanager/fontcache.cxx
+++ psprint/source/fontmanager/fontcache.cxx
@@ -223,9 +223,9 @@
                 aLine.Append( ';' );
                 aLine.Append( (*it)->m_bUserOverride ? "1" : "0" );
                 aLine.Append( ';' );
-                aLine.Append( ByteString::CreateFromInt32( (*it)->m_eEmbeddedbitmap ) );
+                aLine.Append( ByteString::CreateFromInt32( 0 ) );
                 aLine.Append( ';' );
-                aLine.Append( ByteString::CreateFromInt32( (*it)->m_eAntialias ) );
+                aLine.Append( ByteString::CreateFromInt32( 0 ) );
 
                 switch( (*it)->m_eType )
                 {
@@ -435,9 +435,6 @@
                                     = atoi( pLine + nTokenPos[14] );
                 pFont->m_bUserOverride
                                     = (atoi( pLine + nTokenPos[15] ) != 0);
-                pFont->m_eEmbeddedbitmap
-                                    = (fcstatus::type)atoi(pLine+nTokenPos[16]);
-                pFont->m_eAntialias = (fcstatus::type)atoi(pLine+nTokenPos[17]);
                 int nStyleTokenNr = 18;
                 switch( eType )
                 {
@@ -569,8 +566,6 @@
     pTo->m_nYMax			= pFrom->m_nYMax;
     pTo->m_bHaveVerticalSubstitutedGlyphs = pFrom->m_bHaveVerticalSubstitutedGlyphs;
     pTo->m_bUserOverride    = pFrom->m_bUserOverride;
-    pTo->m_eEmbeddedbitmap  = pFrom->m_eEmbeddedbitmap;
-    pTo->m_eAntialias       = pFrom->m_eAntialias;
 }
 
 /*
@@ -632,9 +627,7 @@
         pRight->m_nXMax				!= pLeft->m_nXMax			||
         pRight->m_nYMax				!= pLeft->m_nYMax			||
         pRight->m_bHaveVerticalSubstitutedGlyphs != pLeft->m_bHaveVerticalSubstitutedGlyphs ||
-        pRight->m_bUserOverride     != pLeft->m_bUserOverride   ||
-        pRight->m_eEmbeddedbitmap   != pLeft->m_eEmbeddedbitmap ||
-        pRight->m_eAntialias        != pLeft->m_eAntialias
+        pRight->m_bUserOverride     != pLeft->m_bUserOverride
         )
         return false;
     std::list< int >::const_iterator lit, rit;
@@ -684,9 +677,9 @@
         FontDirMap::const_iterator entry = dir->second.m_aEntries.find( rFile );
         if( entry != dir->second.m_aEntries.end() )
         {
-            bSuccess = true;
             for( FontCacheEntry::const_iterator font = entry->second.m_aEntry.begin(); font != entry->second.m_aEntry.end(); ++font )
             {
+                bSuccess = true;
                 PrintFontManager::PrintFont* pFont = clonePrintFont( *font );
                 rNewFonts.push_back( pFont );
             }
--- psprint/source/fontmanager/fontconfig.cxx
+++ psprint/source/fontmanager/fontconfig.cxx
@@ -39,6 +39,8 @@
 #ifdef ENABLE_FONTCONFIG
 #include <fontconfig/fontconfig.h>
 // be compatible with fontconfig 2.2.0 release
+#include <cairo-ft.h>
+#include <gdk/gdkscreen.h>
 #ifndef FC_WEIGHT_BOOK
 #define FC_WEIGHT_BOOK 75
 #endif
@@ -47,10 +49,12 @@
 typedef void FcObjectSet;
 typedef void FcPattern;
 typedef void FcFontSet;
+typedef void FcCharSet;
 typedef int FcResult;
 typedef int FcBool;
 typedef int FcMatchKind;
 typedef char FcChar8;
+typedef sal_Int32 FcChar32;
 #endif
 
 #include <cstdio>
@@ -74,6 +78,15 @@
 #ifndef _RTL_USTRBUF_HXX
 #include <rtl/ustrbuf.hxx>
 #endif
+#ifndef _OSL_PROCESS_H_
+#include <osl/process.h>
+#endif
+#ifndef _RTL_LOCALE_HXX_
+#include <rtl/locale.hxx>
+#endif
+#include <utility>
+#include <algorithm>
+
 
 using namespace psp;
 using namespace osl;
@@ -83,6 +96,7 @@
 {
     oslModule		m_pLib;
     FcConfig*		m_pDefConfig;
+    FcFontSet*      m_pOutlineSet;
 
 	FcBool          (*m_pFcInit)();
     FcConfig*		(*m_pFcConfigGetCurrent)();
@@ -91,18 +105,27 @@
     FcPattern*		(*m_pFcPatternCreate)();
     void			(*m_pFcPatternDestroy)(FcPattern*);
     FcFontSet*		(*m_pFcFontList)(FcConfig*,FcPattern*,FcObjectSet*);
+    FcFontSet*      (*m_pFcConfigGetFonts)(FcConfig*,FcSetName);
     FcFontSet*		(*m_pFcFontSetCreate)();
+    FcCharSet*                (*m_pFcCharSetCreate)();
+    FcBool                    (*m_pFcCharSetAddChar)(FcCharSet *, FcChar32);
+    FcBool          (*m_pFcCharSetHasChar)(FcCharSet *, FcChar32);
+    void            (*m_pFcCharSetDestroy)(FcCharSet*);
     void			(*m_pFcFontSetDestroy)(FcFontSet*);
     FcBool			(*m_pFcFontSetAdd)(FcFontSet*,FcPattern*);
+    void            (*m_pFcPatternReference)(FcPattern*);
+    FcResult        (*m_pFcPatternGetCharSet)(const FcPattern*,const char*,int,FcCharSet**);
     FcResult		(*m_pFcPatternGetString)(const FcPattern*,const char*,int,FcChar8**);
     FcResult		(*m_pFcPatternGetInteger)(const FcPattern*,const char*,int,int*);
     FcResult		(*m_pFcPatternGetDouble)(const FcPattern*,const char*,int,double*);
     FcResult		(*m_pFcPatternGetBool)(const FcPattern*,const char*,int,FcBool*);
     void			(*m_pFcDefaultSubstitute)(FcPattern *);
-    FcPattern*		(*m_pFcFontMatch)(FcConfig*,FcPattern*,FcResult*);    
     FcPattern*		(*m_pFcFontSetMatch)(FcConfig*,FcFontSet**, int, FcPattern*,FcResult*);    
     FcBool			(*m_pFcConfigSubstitute)(FcConfig*,FcPattern*,FcMatchKind);
     FcBool			(*m_pFcPatternAddInteger)(FcPattern*,const char*,int);
+    FcBool                    (*m_pFcPatternAddDouble)(FcPattern*,const char*,double);
+    FcBool                    (*m_pFcPatternAddBool)(FcPattern*,const char*,FcBool);
+    FcBool                    (*m_pFcPatternAddCharSet)(FcPattern*,const char*,const FcCharSet*);
     FcBool			(*m_pFcPatternAddString)(FcPattern*,const char*,const FcChar8*);
 
     oslGenericFunction loadSymbol( const char* );
@@ -118,6 +141,7 @@
     { return m_pLib != NULL;}
 
     FcConfig* getDefConfig() { return m_pDefConfig; }
+    FcFontSet* getFontSet() { return m_pOutlineSet; }
 
     FcBool FcInit()
     { return m_pFcInit(); }
@@ -144,17 +168,40 @@
 
     void FcPatternDestroy( FcPattern* pPattern )
     { m_pFcPatternDestroy( pPattern ); }
-    
+
     FcFontSet* FcFontList( FcConfig* pConfig, FcPattern* pPattern, FcObjectSet* pSet )
     { return m_pFcFontList( pConfig, pPattern, pSet ); }
-    
+
+    FcFontSet* FcConfigGetFonts( FcConfig* pConfig, FcSetName eSet)
+    { return m_pFcConfigGetFonts( pConfig, eSet ); }
+
     FcFontSet* FcFontSetCreate()
     { return m_pFcFontSetCreate(); }
+
+    FcCharSet* FcCharSetCreate()
+    { return m_pFcCharSetCreate(); }
+
+    FcBool FcCharSetAddChar(FcCharSet *fcs, FcChar32 ucs4)
+    { return m_pFcCharSetAddChar(fcs, ucs4); }
+
+    FcBool FcCharSetHasChar(FcCharSet *fcs, FcChar32 ucs4)
+    { return m_pFcCharSetHasChar(fcs, ucs4); }
+
+    void FcCharSetDestroy( FcCharSet* pSet )
+    { m_pFcCharSetDestroy( pSet );}
+
     void FcFontSetDestroy( FcFontSet* pSet )
     { m_pFcFontSetDestroy( pSet );}
+
     FcBool FcFontSetAdd( FcFontSet* pSet, FcPattern* pPattern )
     { return m_pFcFontSetAdd( pSet, pPattern ); }
 
+    void FcPatternReference( FcPattern* pPattern )
+    { m_pFcPatternReference( pPattern ); }
+
+    FcResult FcPatternGetCharSet( const FcPattern* pPattern, const char* object, int n, FcCharSet** s )
+    { return m_pFcPatternGetCharSet( pPattern, object, n, s ); }
+
     FcResult FcPatternGetString( const FcPattern* pPattern, const char* object, int n, FcChar8** s )
     { return m_pFcPatternGetString( pPattern, object, n, s ); }
 
@@ -166,18 +213,23 @@
 
     FcResult FcPatternGetBool( const FcPattern* pPattern, const char* object, int n, FcBool* s )
     { return m_pFcPatternGetBool( pPattern, object, n, s ); }
+
     void FcDefaultSubstitute( FcPattern* pPattern )
     { m_pFcDefaultSubstitute( pPattern ); }
-    FcPattern* FcFontMatch( FcConfig* pConfig, FcPattern* pPattern, FcResult* pResult )
-    { return m_pFcFontMatch( pConfig, pPattern, pResult ); }
     FcPattern* FcFontSetMatch( FcConfig* pConfig, FcFontSet **ppFontSet, int nset, FcPattern* pPattern, FcResult* pResult )
     { return m_pFcFontSetMatch ? m_pFcFontSetMatch( pConfig, ppFontSet, nset, pPattern, pResult ) : 0; }
     FcBool FcConfigSubstitute( FcConfig* pConfig, FcPattern* pPattern, FcMatchKind eKind )
     { return m_pFcConfigSubstitute( pConfig, pPattern, eKind ); }
     FcBool FcPatternAddInteger( FcPattern* pPattern, const char* pObject, int nValue )
     { return m_pFcPatternAddInteger( pPattern, pObject, nValue ); }
+    FcBool FcPatternAddDouble( FcPattern* pPattern, const char* pObject, double nValue )
+    { return m_pFcPatternAddDouble( pPattern, pObject, nValue ); }
     FcBool FcPatternAddString( FcPattern* pPattern, const char* pObject, const FcChar8* pString )
     { return m_pFcPatternAddString( pPattern, pObject, pString ); }
+    FcBool FcPatternAddBool( FcPattern* pPattern, const char* pObject, bool nValue )
+    { return m_pFcPatternAddBool( pPattern, pObject, nValue ); }
+    FcBool FcPatternAddCharSet(FcPattern* pPattern,const char* pObject,const FcCharSet*pCharSet)
+    { return m_pFcPatternAddCharSet(pPattern,pObject,pCharSet); }
 };
 
 oslGenericFunction FontCfgWrapper::loadSymbol( const char* pSymbol )
@@ -192,7 +244,8 @@
 
 FontCfgWrapper::FontCfgWrapper()
         : m_pLib( NULL ),
-          m_pDefConfig( NULL )
+          m_pDefConfig( NULL ),
+          m_pOutlineSet( NULL )
 {
 #ifdef ENABLE_FONTCONFIG
     OUString aLib( RTL_CONSTASCII_USTRINGPARAM( "libfontconfig.so.1" ) );
@@ -226,12 +279,26 @@
         loadSymbol( "FcPatternDestroy" );
     m_pFcFontList = (FcFontSet*(*)(FcConfig*,FcPattern*,FcObjectSet*))
         loadSymbol( "FcFontList" );
+    m_pFcConfigGetFonts = (FcFontSet*(*)(FcConfig*,FcSetName))
+        loadSymbol( "FcConfigGetFonts" );
     m_pFcFontSetCreate = (FcFontSet*(*)())
         loadSymbol( "FcFontSetCreate" );
+    m_pFcCharSetCreate = (FcCharSet*(*)())
+        loadSymbol( "FcCharSetCreate" );
+    m_pFcCharSetAddChar = (FcBool(*)(FcCharSet*, FcChar32))
+        loadSymbol( "FcCharSetAddChar" );
+    m_pFcCharSetHasChar = (FcBool(*)(FcCharSet*, FcChar32))
+        loadSymbol( "FcCharSetHasChar" );
+    m_pFcCharSetDestroy = (void(*)(FcCharSet*))
+        loadSymbol( "FcCharSetDestroy" );
     m_pFcFontSetDestroy = (void(*)(FcFontSet*))
         loadSymbol( "FcFontSetDestroy" );
     m_pFcFontSetAdd = (FcBool(*)(FcFontSet*,FcPattern*))
         loadSymbol( "FcFontSetAdd" );
+    m_pFcPatternReference = (void(*)(FcPattern*))
+        loadSymbol( "FcPatternReference" );
+    m_pFcPatternGetCharSet = (FcResult(*)(const FcPattern*,const char*,int,FcCharSet**))
+        loadSymbol( "FcPatternGetCharSet" );
     m_pFcPatternGetString = (FcResult(*)(const FcPattern*,const char*,int,FcChar8**))
         loadSymbol( "FcPatternGetString" );
     m_pFcPatternGetInteger = (FcResult(*)(const FcPattern*,const char*,int,int*))
@@ -242,14 +309,18 @@
         loadSymbol( "FcPatternGetBool" );
     m_pFcDefaultSubstitute = (void(*)(FcPattern *))
         loadSymbol( "FcDefaultSubstitute" );
-    m_pFcFontMatch = (FcPattern*(*)(FcConfig*,FcPattern*,FcResult*))
-        loadSymbol( "FcFontMatch" );
     m_pFcFontSetMatch = (FcPattern*(*)(FcConfig*,FcFontSet**,int,FcPattern*,FcResult*))
         loadSymbol( "FcFontSetMatch" );
     m_pFcConfigSubstitute = (FcBool(*)(FcConfig*,FcPattern*,FcMatchKind))
         loadSymbol( "FcConfigSubstitute" );
     m_pFcPatternAddInteger = (FcBool(*)(FcPattern*,const char*,int))
         loadSymbol( "FcPatternAddInteger" );
+    m_pFcPatternAddDouble = (FcBool(*)(FcPattern*,const char*,double))
+        loadSymbol( "FcPatternAddDouble" );
+    m_pFcPatternAddBool = (FcBool(*)(FcPattern*,const char*,FcBool))
+        loadSymbol( "FcPatternAddBool" );
+    m_pFcPatternAddCharSet = (FcBool(*)(FcPattern*,const char*,const FcCharSet *))
+        loadSymbol( "FcPatternAddCharSet" );
     m_pFcPatternAddString = (FcBool(*)(FcPattern*,const char*,const FcChar8*))
         loadSymbol( "FcPatternAddString" );
 
@@ -261,17 +332,26 @@
             m_pFcPatternCreate				&&
             m_pFcPatternDestroy				&&
             m_pFcFontList					&&
+            m_pFcConfigGetFonts             &&
             m_pFcFontSetCreate				&&
+            m_pFcCharSetCreate				&&
+            m_pFcCharSetAddChar 			&&
+            m_pFcCharSetHasChar             &&
+            m_pFcCharSetDestroy             &&
             m_pFcFontSetDestroy				&&
             m_pFcFontSetAdd					&&
+            m_pFcPatternReference           &&
+			m_pFcPatternGetCharSet			&&
             m_pFcPatternGetString			&&
             m_pFcPatternGetInteger			&&
             m_pFcPatternGetDouble			&&
             m_pFcPatternGetBool				&&
             m_pFcDefaultSubstitute			&&
-            m_pFcFontMatch					&&
             m_pFcConfigSubstitute			&&
             m_pFcPatternAddInteger			&&
+            m_pFcPatternAddDouble                     &&
+            m_pFcPatternAddCharSet			&&
+            m_pFcPatternAddBool 			&&
             m_pFcPatternAddString
             ) )
     {
@@ -289,10 +369,35 @@
         osl_unloadModule( (oslModule)m_pLib );
         m_pLib = NULL;
     }
+
+    m_pOutlineSet = FcFontSetCreate();
+
+    /*
+      add only acceptable outlined fonts to our config, 
+      for future fontconfig use
+    */
+    FcFontSet *pOrig = FcConfigGetFonts(NULL, FcSetSystem);
+
+    if (!pOrig)
+        return;
+
+    for( int i = 0; i < pOrig->nfont; ++i )
+    {
+        FcBool outline = false;
+        FcPattern *pOutlinePattern = pOrig->fonts[i];
+        FcResult eOutRes = 
+			FcPatternGetBool( pOutlinePattern, FC_OUTLINE, 0, &outline );
+        if (eOutRes == FcResultMatch && !outline)
+            continue;
+        FcPatternReference(pOutlinePattern);
+        FcFontSetAdd(m_pOutlineSet, pOutlinePattern);
+    }
 }
 
 FontCfgWrapper::~FontCfgWrapper()
 {
+	if( m_pOutlineSet )
+		FcFontSetDestroy( m_pOutlineSet );
     if( m_pLib )
         osl_unloadModule( (oslModule)m_pLib );
 }
@@ -319,6 +424,94 @@
 #define FC_EMBEDDED_BITMAP "embeddedbitmap"
 #endif
 
+namespace
+{
+    typedef std::pair<FcChar8*, FcChar8*> lang_and_family;
+
+    class localizedsorter
+    {
+            rtl::OLocale maLoc;
+        public:
+            localizedsorter(rtl_Locale* pLoc) : maLoc(pLoc) {}
+            FcChar8* bestname(const std::vector<lang_and_family> &families);
+    };
+
+    FcChar8* localizedsorter::bestname(const std::vector<lang_and_family> &families)
+    {
+        FcChar8* candidate = families.begin()->second;
+        rtl::OString sLangMatch(rtl::OUStringToOString(maLoc.getLanguage().toAsciiLowerCase(), RTL_TEXTENCODING_UTF8));
+        rtl::OString sFullMatch = sLangMatch;
+        sFullMatch += OString('-');
+        sFullMatch += rtl::OUStringToOString(maLoc.getCountry().toAsciiLowerCase(), RTL_TEXTENCODING_UTF8);
+
+        std::vector<lang_and_family>::const_iterator aEnd = families.end();
+        bool alreadyclosematch = false;
+        for (std::vector<lang_and_family>::const_iterator aIter = families.begin(); aIter != aEnd; ++aIter)
+        {
+            const char *pLang = (const char*)aIter->first;
+            //perfect
+            if (strcmp(pLang, sFullMatch.getStr()) == 0)
+            {
+                candidate = aIter->second;
+                break;
+            }
+            else if ((strcmp(pLang, sLangMatch.getStr()) == 0) && (!alreadyclosematch))
+            {
+                candidate = aIter->second;
+                alreadyclosematch = true;
+            }
+        }
+
+        return candidate;
+    }
+
+
+    FcResult lcl_FamilyFromPattern(FontCfgWrapper& rWrapper, FcPattern* pPattern, FcChar8 **family, 
+        std::hash_map< rtl::OString, rtl::OString, rtl::OStringHash > &aFontconfigNameToLocalized)
+    {
+	FcChar8 *origfamily;
+        FcResult eFamilyRes	= rWrapper.FcPatternGetString( pPattern, FC_FAMILY, 0, &origfamily );
+        *family = origfamily;
+
+        if( eFamilyRes == FcResultMatch)
+        {
+            FcChar8* familylang = NULL;
+            if (rWrapper.FcPatternGetString( pPattern, FC_FAMILYLANG, 0, &familylang ) == FcResultMatch)
+            {
+                std::vector< lang_and_family > lang_and_families;
+                lang_and_families.push_back(lang_and_family(familylang, *family));
+                int k = 1;
+                while (1)
+                {
+                    if (rWrapper.FcPatternGetString( pPattern, FC_FAMILYLANG, k, &familylang ) != FcResultMatch)
+                        break;
+                    if (rWrapper.FcPatternGetString( pPattern, FC_FAMILY, k, family ) != FcResultMatch)
+                        break;
+                    lang_and_families.push_back(lang_and_family(familylang, *family));
+                    ++k;
+                }
+
+                //possible to-do, sort by UILocale instead of process locale
+                rtl_Locale* pLoc;
+                osl_getProcessLocale(&pLoc);
+                localizedsorter aSorter(pLoc);
+                *family = aSorter.bestname(lang_and_families);
+
+		std::vector<lang_and_family>::const_iterator aEnd = lang_and_families.end();
+		for (std::vector<lang_and_family>::const_iterator aIter = lang_and_families.begin(); aIter != aEnd; ++aIter)
+		{
+		    const char *candidate = (const char*)(aIter->second);
+		    if (strcmp(candidate, (const char*)(*family)) != 0)
+		        aFontconfigNameToLocalized[OString(candidate)] = OString((const char*)(*family));
+		}
+            }
+        }
+
+        return eFamilyRes;
+    }
+}
+
+
 /*
  * PrintFontManager::initFontconfig
  */
@@ -331,20 +524,7 @@
     if( ! rWrapper.isValid() )
         return false;
 
-    FcConfig* pConfig = rWrapper.getDefConfig();
-    FcObjectSet* pOSet = rWrapper.FcObjectSetBuild( FC_FAMILY,
-                                                    FC_STYLE,
-                                                    FC_SLANT,
-                                                    FC_WEIGHT,
-                                                    FC_SPACING,
-                                                    FC_FILE,
-                                                    FC_OUTLINE,
-                                                    FC_INDEX,
-                                                    FC_EMBEDDED_BITMAP,
-                                                    FC_ANTIALIAS,
-                                                    (void *) NULL );
-    FcPattern* pPattern = rWrapper.FcPatternCreate();
-    FcFontSet* pFSet = rWrapper.FcFontList( pConfig, pPattern, pOSet );
+    FcFontSet* pFSet = rWrapper.getFontSet();
 
     if( pFSet )
     {
@@ -360,18 +540,16 @@
             int weight = 0;
             int spacing = 0;
             int nCollectionEntry = -1;
-            FcBool outline = false, embitmap = true, antialias = true;
+            FcBool outline = false;
             
             FcResult eFileRes	      = rWrapper.FcPatternGetString( pFSet->fonts[i], FC_FILE, 0, &file );
-            FcResult eFamilyRes	      = rWrapper.FcPatternGetString( pFSet->fonts[i], FC_FAMILY, 0, &family );
+            FcResult eFamilyRes       = lcl_FamilyFromPattern(rWrapper, pFSet->fonts[i], &family, m_aFontconfigNameToLocalized );
             FcResult eStyleRes	      = rWrapper.FcPatternGetString( pFSet->fonts[i], FC_STYLE, 0, &style );
             FcResult eSlantRes	      = rWrapper.FcPatternGetInteger( pFSet->fonts[i], FC_SLANT, 0, &slant );
             FcResult eWeightRes	      = rWrapper.FcPatternGetInteger( pFSet->fonts[i], FC_WEIGHT, 0, &weight );
             FcResult eSpacRes	      = rWrapper.FcPatternGetInteger( pFSet->fonts[i], FC_SPACING, 0, &spacing );
             FcResult eOutRes	      = rWrapper.FcPatternGetBool( pFSet->fonts[i], FC_OUTLINE, 0, &outline );
             FcResult eIndexRes        = rWrapper.FcPatternGetInteger( pFSet->fonts[i], FC_INDEX, 0, &nCollectionEntry );
-            FcResult eEmbeddedBitmap  = rWrapper.FcPatternGetBool( pFSet->fonts[i], FC_EMBEDDED_BITMAP, 0, &embitmap );
-            FcResult eAntialias       = rWrapper.FcPatternGetBool( pFSet->fonts[i], FC_ANTIALIAS, 0, &antialias );
             
             if( eFileRes != FcResultMatch || eFamilyRes != FcResultMatch || eOutRes != FcResultMatch )
                 continue;
@@ -389,6 +567,8 @@
                      );
 #endif
 
+            OSL_ASSERT(eOutRes != FcResultMatch || outline);
+
             // only outline fonts are usable to psprint anyway
             if( eOutRes == FcResultMatch && ! outline )
                 continue;
@@ -509,15 +689,6 @@
                 {
                     pUpdate->m_aStyleName = OStringToOUString( OString( (sal_Char*)style ), RTL_TEXTENCODING_UTF8 );
                 }
-                if( eEmbeddedBitmap == FcResultMatch )
-                {
-                  pUpdate->m_eEmbeddedbitmap = embitmap ? fcstatus::istrue : fcstatus::isfalse;
-                }
-                if( eAntialias == FcResultMatch )
-                {
-                  pUpdate->m_eAntialias = antialias ? fcstatus::istrue : fcstatus::isfalse;
-                }
-
                 
                 // update font cache
                 m_pFontCache->updateFontCacheEntry( pUpdate, false );
@@ -542,14 +713,6 @@
         }
     }
     
-    // cleanup
-    if( pPattern )
-        rWrapper.FcPatternDestroy( pPattern );
-    if( pFSet )
-        rWrapper.FcFontSetDestroy( pFSet );
-    if( pOSet )
-        rWrapper.FcObjectSetDestroy( pOSet );
-    
     // how does one get rid of the config ?
 #if OSL_DEBUG_LEVEL > 1
     fprintf( stderr, "inserted %d fonts from fontconfig\n", nFonts );
@@ -563,39 +726,14 @@
     FontCfgWrapper::release();
 }
 
-bool PrintFontManager::matchFont( FastPrintFontInfo& rInfo, const com::sun::star::lang::Locale& rLocale )
+static void addtopattern(FontCfgWrapper& rWrapper, FcPattern *pPattern, 
+	italic::type eItalic, weight::type eWeight, width::type eWidth, pitch::type ePitch)
 {
 #ifdef ENABLE_FONTCONFIG
-    FontCfgWrapper& rWrapper = FontCfgWrapper::get();
-    if( ! rWrapper.isValid() )
-        return false;
-
-    FcConfig* pConfig = rWrapper.getDefConfig();
-    FcPattern* pPattern = rWrapper.FcPatternCreate();
-
-    OString aLangAttrib;
-    // populate pattern with font characteristics
-    if( rLocale.Language.getLength() )
-    {
-        OUStringBuffer aLang(6);
-        aLang.append( rLocale.Language );
-        if( rLocale.Country.getLength() )
-        {
-            aLang.append( sal_Unicode('-') );
-            aLang.append( rLocale.Country );
-        }
-        aLangAttrib = OUStringToOString( aLang.makeStringAndClear(), RTL_TEXTENCODING_UTF8 );
-    }
-    if( aLangAttrib.getLength() )
-        rWrapper.FcPatternAddString( pPattern, FC_LANG, (FcChar8*)aLangAttrib.getStr() );
-
-    OString aFamily = OUStringToOString( rInfo.m_aFamilyName, RTL_TEXTENCODING_UTF8 );
-    if( aFamily.getLength() )
-        rWrapper.FcPatternAddString( pPattern, FC_FAMILY, (FcChar8*)aFamily.getStr() );
-    if( rInfo.m_eItalic != italic::Unknown )
+    if( eItalic != italic::Unknown )
     {
         int nSlant = FC_SLANT_ROMAN;
-        switch( rInfo.m_eItalic )
+        switch( eItalic )
         {
             case italic::Italic:	 	nSlant = FC_SLANT_ITALIC;break;
             case italic::Oblique:	 	nSlant = FC_SLANT_OBLIQUE;break;
@@ -604,10 +742,10 @@
         }
         rWrapper.FcPatternAddInteger( pPattern, FC_SLANT, nSlant );
     }
-    if( rInfo.m_eWeight != weight::Unknown )
+    if( eWeight != weight::Unknown )
     {
         int nWeight = FC_WEIGHT_NORMAL;
-        switch( rInfo.m_eWeight )
+        switch( eWeight )
         {
             case weight::Thin:			nWeight = FC_WEIGHT_THIN;break;
             case weight::UltraLight:	nWeight = FC_WEIGHT_ULTRALIGHT;break;
@@ -624,10 +762,10 @@
         }
         rWrapper.FcPatternAddInteger( pPattern, FC_WEIGHT, nWeight );
     }
-    if( rInfo.m_eWidth != width::Unknown )
+    if( eWidth != width::Unknown )
     {
         int nWidth = FC_WIDTH_NORMAL;
-        switch( rInfo.m_eWidth )
+        switch( eWidth )
         {
             case width::UltraCondensed:	nWidth = FC_WIDTH_ULTRACONDENSED;break;
             case width::ExtraCondensed: nWidth = FC_WIDTH_EXTRACONDENSED;break;
@@ -643,10 +781,10 @@
         }
         rWrapper.FcPatternAddInteger( pPattern, FC_WIDTH, nWidth );
     }
-    if( rInfo.m_ePitch != pitch::Unknown )
+    if( ePitch != pitch::Unknown )
     {
         int nSpacing = FC_PROPORTIONAL;
-        switch( rInfo.m_ePitch )
+        switch( ePitch )
         {
             case pitch::Fixed:			nSpacing = FC_MONO;break;
             case pitch::Variable:		nSpacing = FC_PROPORTIONAL;break;
@@ -654,12 +792,251 @@
                 break;
         }
         rWrapper.FcPatternAddInteger( pPattern, FC_SPACING, nSpacing );
+        if (nSpacing == FC_MONO)
+            rWrapper.FcPatternAddString( pPattern, FC_FAMILY, (FcChar8*)"monospace");
     }
+#endif
+}
+
+String PrintFontManager::Substitute(const std::vector<String> &rNames, std::vector<sal_Unicode> &rGlyphs,
+        const ByteString &rLangAttrib, italic::type eItalic, weight::type eWeight,
+        width::type eWidth, pitch::type ePitch) const
+{
+    String aName;
+#ifdef ENABLE_FONTCONFIG
+    FontCfgWrapper& rWrapper = FontCfgWrapper::get();
+    if( ! rWrapper.isValid() )
+        return aName;
+
+    FcFontSet*  pSet = NULL;
+    FcPattern*  pPattern = rWrapper.FcPatternCreate();
+
+    // Prefer scalable fonts
+    rWrapper.FcPatternAddBool( pPattern, FC_SCALABLE, 1 );
+
+    std::vector<String>::const_iterator aEnd = rNames.end();
+    for (std::vector<String>::const_iterator aIter = rNames.begin(); aIter != aEnd; ++aIter)
+    {
+	    OString maTargetName = OUStringToOString(*aIter, RTL_TEXTENCODING_UTF8);
+        rWrapper.FcPatternAddString(pPattern, FC_FAMILY, (FcChar8*)maTargetName.getStr());
+        break;
+    }
+
+    if( rLangAttrib.Len() )
+        rWrapper.FcPatternAddString(pPattern, FC_LANG, (FcChar8*)rLangAttrib.GetBuffer());
+
+    // Add required Unicode characters, if any
+    if (! rGlyphs.empty() )
+    {
+       FcCharSet *unicodes = rWrapper.FcCharSetCreate();
+	    std::vector<sal_Unicode>::const_iterator aGlyphEnd = rGlyphs.end();
+	    for (std::vector<sal_Unicode>::const_iterator aGlyphIter = rGlyphs.begin(); 
+            aGlyphIter != aGlyphEnd; ++aGlyphIter)
+	    {
+            rWrapper.FcCharSetAddChar( unicodes, (FcChar32)*aGlyphIter );
+	    }
+       rWrapper.FcPatternAddCharSet( pPattern, FC_CHARSET, unicodes);
+       rWrapper.FcCharSetDestroy( unicodes );
+    }
+
+    addtopattern(rWrapper, pPattern, eItalic, eWeight, eWidth, ePitch);
+
+    rWrapper.FcConfigSubstitute( NULL, pPattern, FcMatchPattern );
+    rWrapper.FcDefaultSubstitute( pPattern );
+    FcResult eResult = FcResultNoMatch;
+    FcFontSet *pFontSet = rWrapper.getFontSet();
+    FcPattern* pResult = rWrapper.FcFontSetMatch( NULL, &pFontSet, 1, pPattern, &eResult );
+    rWrapper.FcPatternDestroy( pPattern );
+
+    if( pResult )
+    {
+        pSet = rWrapper.FcFontSetCreate();
+        // info: destroying the pSet destroys pResult implicitly
+        // since pResult was "added" to pSet
+        rWrapper.FcFontSetAdd( pSet, pResult );
+    }
+
+    if( pSet )
+    {
+        if( pSet->nfont > 0 )
+        {
+            //extract the closest match
+            FcChar8* family = NULL;
+            FcResult eFileRes = rWrapper.FcPatternGetString( pSet->fonts[0], FC_FAMILY, 0, &family );
+
+            if( eFileRes == FcResultMatch )
+            {
+                OString sFamily((sal_Char*)family);
+                std::hash_map< rtl::OString, rtl::OString, rtl::OStringHash >::const_iterator aI = m_aFontconfigNameToLocalized.find(sFamily);
+                if (aI != m_aFontconfigNameToLocalized.end())
+                    sFamily = aI->second;
+                aName = String( sFamily.getStr(), RTL_TEXTENCODING_UTF8 );
+            }
+
+            if (!rGlyphs.empty() )
+            {
+		std::vector<sal_Unicode> aGlyphs;
+                FcCharSet *unicodes;
+                if (rWrapper.FcPatternGetCharSet(pSet->fonts[0], FC_CHARSET, 0, &unicodes) == FcResultMatch)
+                {
+                    std::vector<sal_Unicode>::iterator aGlyphEnd = rGlyphs.end();
+                    for (std::vector<sal_Unicode>::iterator aGlyphIter = rGlyphs.begin();
+                        aGlyphIter != aGlyphEnd; ++aGlyphIter)
+                    {
+                            if (rWrapper.FcCharSetHasChar( unicodes, (FcChar32)*aGlyphIter ))
+				aGlyphs.push_back(*aGlyphIter);
+                    }
+                }
+		rGlyphs.swap(aGlyphs);
+            }
+
+        }
+    }
+    rWrapper.FcFontSetDestroy( pSet );
+#endif
+    return aName;
+}
+
+#ifdef ENABLE_FONTCONFIG
+static void lcl_InfoToPattern( const FastPrintFontInfo& rInfo, FontCfgWrapper& rWrapper, FcPattern* pPattern )
+{
+    OString aFamily = OUStringToOString( rInfo.m_aFamilyName, RTL_TEXTENCODING_UTF8 );
+    if( aFamily.getLength() )
+        rWrapper.FcPatternAddString( pPattern, FC_FAMILY, (FcChar8*)aFamily.getStr() );
+
+    addtopattern(rWrapper, pPattern, rInfo.m_eItalic, rInfo.m_eWeight, rInfo.m_eWidth, rInfo.m_ePitch);
+
+}
+#endif
+
+
+FontConfigHints PrintFontManager::getFontConfigHints( const FastPrintFontInfo& rInfo, int nSize)
+{
+    FontConfigHints aHints;
+#ifdef ENABLE_FONTCONFIG
+    FontCfgWrapper& rWrapper = FontCfgWrapper::get();
+    if( ! rWrapper.isValid() )
+        return aHints;
+
+    FcConfig* pConfig = rWrapper.getDefConfig();
+    FcPattern* pPattern = rWrapper.FcPatternCreate();
+
+    lcl_InfoToPattern( rInfo, rWrapper, pPattern );
+    rWrapper.FcPatternAddDouble( pPattern, FC_PIXEL_SIZE, nSize);
+
+    FcBool embitmap = true, antialias = true, autohint = true, hinting = true;
+    int hintstyle = FC_HINT_FULL, rgba = FC_RGBA_UNKNOWN;
+
+    rWrapper.FcConfigSubstitute( pConfig, pPattern, FcMatchPattern );
+    GdkScreen *screen = gdk_screen_get_default();
+    if (screen != NULL) {
+    if (const cairo_font_options_t *pOptions = gdk_screen_get_font_options(screen)) {
+     cairo_ft_font_options_substitute(pOptions, pPattern);
+     }
+    }
+    rWrapper.FcDefaultSubstitute( pPattern );
+    FcResult eEmbeddedBitmap = rWrapper.FcPatternGetBool( pPattern, FC_EMBEDDED_BITMAP, 0, &embitmap );
+    FcResult eAntialias = rWrapper.FcPatternGetBool( pPattern, FC_ANTIALIAS, 0, &antialias );
+    FcResult eAutoHint = rWrapper.FcPatternGetBool( pPattern, FC_AUTOHINT, 0, &autohint );
+    FcResult eSubPixel = rWrapper.FcPatternGetInteger( pPattern, FC_RGBA, 0, &rgba);
+    FcResult eHinting = rWrapper.FcPatternGetBool( pPattern, FC_HINTING, 0, &hinting );
+
+    FcResult eHintStyle = rWrapper.FcPatternGetInteger( pPattern, FC_HINT_STYLE, 0, &hintstyle );
+    rWrapper.FcPatternDestroy(pPattern);
+ 
+    if( eEmbeddedBitmap == FcResultMatch )
+        aHints.m_eEmbeddedbitmap = embitmap ? fcstatus::istrue : fcstatus::isfalse;
+    if( eAntialias == FcResultMatch )
+        aHints.m_eAntialias = antialias ? fcstatus::istrue : fcstatus::isfalse;
+    if( eAutoHint == FcResultMatch )
+        aHints.m_eAutoHint = autohint ? fcstatus::istrue : fcstatus::isfalse;
+    if( eHinting == FcResultMatch )
+        aHints.m_eHinting = hinting ? fcstatus::istrue : fcstatus::isfalse;
+    if (eHintStyle != FcResultMatch)
+        aHints.m_eHintStyle = fchint::Full;
+    else
+    {
+        switch (hintstyle)
+        {
+            case FC_HINT_NONE:
+                aHints.m_eHintStyle = fchint::Nohint;
+                break;
+            case FC_HINT_SLIGHT:
+                aHints.m_eHintStyle = fchint::Slight;
+                break;
+            case FC_HINT_MEDIUM:
+                aHints.m_eHintStyle = fchint::Medium;
+                break;
+            case FC_HINT_FULL:
+            default:
+                aHints.m_eHintStyle = fchint::Full;
+                break;
+        }
+    }
+    if (eSubPixel != FcResultMatch)
+        aHints.m_eSubPixel = fcsubpixel::Unknown;
+    else 
+    {
+        switch (rgba)
+        {
+	    default:
+	    case FC_RGBA_UNKNOWN:
+	        break;
+                aHints.m_eSubPixel = fcsubpixel::Unknown;
+	    case FC_RGBA_RGB:
+                aHints.m_eSubPixel = fcsubpixel::RGB;
+	        break;
+	    case FC_RGBA_BGR:
+                aHints.m_eSubPixel = fcsubpixel::BGR;
+	        break;
+	    case FC_RGBA_VRGB:
+                aHints.m_eSubPixel = fcsubpixel::VRGB;
+	        break;
+	    case FC_RGBA_VBGR:
+                aHints.m_eSubPixel = fcsubpixel::VBGR;
+	        break;
+            case FC_RGBA_NONE:
+                aHints.m_eSubPixel = fcsubpixel::NONE;
+	        break;
+        }
+    }
+#endif
+    return aHints;
+}
+
+bool PrintFontManager::matchFont( FastPrintFontInfo& rInfo, const com::sun::star::lang::Locale& rLocale )
+{
+#ifdef ENABLE_FONTCONFIG
+    FontCfgWrapper& rWrapper = FontCfgWrapper::get();
+    if( ! rWrapper.isValid() )
+        return false;
+
+    FcConfig* pConfig = rWrapper.getDefConfig();
+    FcPattern* pPattern = rWrapper.FcPatternCreate();
+
+    OString aLangAttrib;
+    // populate pattern with font characteristics
+    if( rLocale.Language.getLength() )
+    {
+        OUStringBuffer aLang(6);
+        aLang.append( rLocale.Language );
+        if( rLocale.Country.getLength() )
+        {
+            aLang.append( sal_Unicode('-') );
+            aLang.append( rLocale.Country );
+        }
+        aLangAttrib = OUStringToOString( aLang.makeStringAndClear(), RTL_TEXTENCODING_UTF8 );
+    }
+    if( aLangAttrib.getLength() )
+        rWrapper.FcPatternAddString( pPattern, FC_LANG, (FcChar8*)aLangAttrib.getStr() );
+
+    lcl_InfoToPattern( rInfo, rWrapper, pPattern );
 
     rWrapper.FcConfigSubstitute( pConfig, pPattern, FcMatchPattern );
     rWrapper.FcDefaultSubstitute( pPattern );
     FcResult eResult = FcResultNoMatch;
-    FcPattern* pResult = rWrapper.FcFontMatch( pConfig, pPattern, &eResult );
+    FcFontSet *pFontSet = rWrapper.getFontSet();
+    FcPattern* pResult = rWrapper.FcFontSetMatch( pConfig, &pFontSet, 1, pPattern, &eResult );
     bool bSuccess = false;
     if( pResult )
     {
--- psprint/source/fontmanager/fontmanager.cxx
+++ psprint/source/fontmanager/fontmanager.cxx
@@ -392,8 +392,7 @@
         m_nYMax( 0 ),
         m_bHaveVerticalSubstitutedGlyphs( false ),
         m_bUserOverride( false ),
-        m_eEmbeddedbitmap( fcstatus::isunset ),
-        m_eAntialias( fcstatus::isunset )
+  		m_bCJKSupport( false ) 
 {
 }
 
@@ -1213,7 +1212,8 @@
         m_nNextFontID( 1 ),
         m_pAtoms( new MultiAtomProvider() ),
         m_nNextDirAtom( 1 ),
-        m_pFontCache( NULL )
+        m_pFontCache( NULL ),
+	m_bFontconfigSuccess(false)
 {
     for( unsigned int i = 0; i < sizeof( aAdobeCodes )/sizeof( aAdobeCodes[0] ); i++ )
     {
@@ -2026,6 +2026,9 @@
         // get vertical substitutions flag
         pFont->m_bHaveVerticalSubstitutedGlyphs = DoesVerticalSubstitution( pTTFont, 1 );
 
+		// i#73003#, check for CJK capatibilies for the current font
+		pFont->m_bCJKSupport = (aInfo.ur2 & 0x08000000) >> 27 ;
+
         CloseTTFont( pTTFont );
         bSuccess = true;
     }
@@ -2173,7 +2176,7 @@
 #endif
 
     // first try fontconfig
-    bool bFontconfigSuccess = initFontconfig();
+    m_bFontconfigSuccess = initFontconfig();
 
     // part one - look for downloadable fonts
     rtl_TextEncoding aEncoding = osl_getThreadTextEncoding();
@@ -2195,7 +2198,7 @@
     }
 
     // don't search through many directories fontconfig already told us about
-    if( ! bFontconfigSuccess )
+    if( ! m_bFontconfigSuccess )
     {							
         Display *pDisplay = (Display*)pInitDisplay;
         
@@ -2288,7 +2291,7 @@
             }
         }
 #endif /* SOLARIS */
-    } // ! bFontconfigSuccess
+    } // ! m_bFontconfigSuccess
 
     // fill XLFD aliases from fonts.alias files
     initFontsAlias();
@@ -2760,8 +2763,6 @@
     rInfo.m_eWeight         = pFont->m_eWeight;
     rInfo.m_ePitch          = pFont->m_ePitch;
     rInfo.m_aEncoding       = pFont->m_aEncoding;
-    rInfo.m_eEmbeddedbitmap = pFont->m_eEmbeddedbitmap;
-    rInfo.m_eAntialias      = pFont->m_eAntialias;
     rInfo.m_aAliases.clear();
     for( ::std::list< int >::iterator it = pFont->m_aAliases.begin(); it != pFont->m_aAliases.end(); ++it )
         rInfo.m_aAliases.push_back( m_pAtoms->getString( ATOM_FAMILYNAME, *it ) );
@@ -2788,6 +2789,7 @@
     rInfo.m_nDescend        = pFont->m_nDescend;
     rInfo.m_nLeading        = pFont->m_nLeading;
     rInfo.m_nWidth          = pFont->m_aGlobalMetricX.width < pFont->m_aGlobalMetricY.width ? pFont->m_aGlobalMetricY.width : pFont->m_aGlobalMetricX.width;
+	rInfo.m_bCJKSupport		= pFont->m_bCJKSupport; // #i73003#
 }
 
 // -------------------------------------------------------------------------
@@ -4005,8 +4007,6 @@
         BuiltinFont* pFont = new BuiltinFont();
         pFont->m_nDirectory = 0;
         pFont->m_bUserOverride = false;
-        pFont->m_eEmbeddedbitmap = fcstatus::isunset;
-        pFont->m_eAntialias = fcstatus::isunset;
         pFont->m_pMetrics = new PrintFontMetrics;
         memset( pFont->m_pMetrics->m_aPages, 0xff, sizeof( pFont->m_pMetrics->m_aPages ) );
         pFont->m_pMetrics->m_bKernPairsQueried = true;
@@ -4140,3 +4140,22 @@
     
     return true;
 }
+
+bool PrintFontManager::IsSupportCJK( const rtl::OUString& rFamilyName )
+{
+	bool bRet = true;
+	
+	for( ::std::hash_map< fontID, PrintFont* >::const_iterator it = m_aFonts.begin(); it != m_aFonts.end(); ++it )
+	{
+		fontID nFont = it->first;
+		if( rFamilyName == getFontFamily(nFont) )
+		{
+			PrintFont* pFont = it->second;
+        	// might be a truetype font not yet analyzed
+        	if( pFont->m_eType == fonttype::TrueType )
+				analyzeTrueTypeFile( pFont );
+			return pFont->m_bCJKSupport;
+		}
+	}
+	return bRet;
+}
--- psprint/source/fontmanager/makefile.mk
+++ psprint/source/fontmanager/makefile.mk
@@ -49,6 +49,9 @@
 CDEFS += -DENABLE_FONTCONFIG
 .ENDIF
 
+PKGCONFIG_MODULES=gdk-2.0 freetype2
+.INCLUDE: pkg_config.mk
+
 # --- Files --------------------------------------------------------
 
 .IF "$(GUIBASE)"=="aqua"
--- psprint/util/makefile.mk
+++ psprint/util/makefile.mk
@@ -90,5 +90,10 @@
 
 # --- Targets ------------------------------------------------------------
 
+PKGCONFIG_MODULES=gdk-2.0 freetype2
+.INCLUDE: pkg_config.mk
+SHL1STDLIBS+=$(PKGCONFIG_LIBS)
+
+
 
 .INCLUDE :	target.mk
--- svtools/inc/ctrlbox.hxx
+++ svtools/inc/ctrlbox.hxx
@@ -384,6 +384,7 @@
 	Image			maImageScalableFont;
 	BOOL			mbWYSIWYG;
 	BOOL			mbSymbols;
+	BOOL			mbOnlyListCJKFont; // #i73003#
 
 #ifdef _CTRLBOX_CXX
 	SVT_DLLPRIVATE void			ImplCalcUserItemSize();
--- svtools/source/control/ctrlbox.cxx
+++ svtools/source/control/ctrlbox.cxx
@@ -61,6 +61,8 @@
 
 #include <vcl/i18nhelp.hxx>
 
+#define LB_EAST_NAME 112
+
 #define IMGTEXTSPACE    2
 #define EXTRAFONTSIZE   5
 
@@ -622,6 +624,8 @@
     mpFontList = NULL;
     mbWYSIWYG = FALSE;
     mbSymbols = FALSE;
+	// #i73003#
+	mbOnlyListCJKFont = FALSE;
 }
 
 // -------------------------------------------------------------------
@@ -633,6 +637,13 @@
     mpFontList = NULL;
     mbWYSIWYG = FALSE;
     mbSymbols = FALSE;
+	// #i73003#
+	mbOnlyListCJKFont = FALSE;
+	if( rResId.GetId() == LB_EAST_NAME )
+	{
+		mbOnlyListCJKFont = TRUE;
+	}
+	
 }
 
 // -------------------------------------------------------------------
@@ -696,6 +707,14 @@
     for ( USHORT i = 0; i < nFontCount; i++ )
     {
         const FontInfo& rFontInfo = pList->GetFontName( i );
+		
+		// #i73003#
+		if( mbOnlyListCJKFont && (!rFontInfo.IsSupportCJK()) )
+		{
+			//Only list CJK font
+			continue;
+		}
+		
         ULONG nIndex = InsertEntry( rFontInfo.GetName() );
         if ( nIndex != LISTBOX_ERROR )
         {
--- svx/source/items/textitem.cxx
+++ svx/source/items/textitem.cxx
@@ -3717,7 +3717,7 @@
 {
 	USHORT nLatin, nAsian, nComplex;
 	GetWhichIds( nLatin, nAsian, nComplex );
-
+	
 	SfxPoolItem* pCpy = rItem.Clone();
 	if( SCRIPTTYPE_LATIN & nScriptType )
 	{
@@ -3726,8 +3726,19 @@
 	}
 	if( SCRIPTTYPE_ASIAN & nScriptType )
 	{
-		pCpy->SetWhich( nAsian );
-		GetItemSet().Put( *pCpy );
+		// #i73003#, if the font supports cjk lang, apply it.
+		sal_Bool bCJKFont = sal_True;
+		if ( rItem.ISA(SvxFontItem) )
+		{
+			Font aFont;
+			aFont.SetName(((SvxFontItem&)rItem).GetFamilyName());
+			bCJKFont = aFont.IsSupportCJK();
+		}
+		if( bCJKFont )
+		{
+			pCpy->SetWhich( nAsian );
+			GetItemSet().Put( *pCpy );
+		}
 	}
 	if( SCRIPTTYPE_COMPLEX & nScriptType )
 	{
--- vcl/inc/vcl/font.hxx
+++ vcl/inc/vcl/font.hxx
@@ -156,6 +156,9 @@
 	friend VCL_DLLPUBLIC SvStream&	operator<<( SvStream& rOStm, const Font& );
     
     static Font identifyFont( const void* pBuffer, sal_uInt32 nLen );
+
+	// #i73003#
+	BOOL IsSupportCJK() const;
 };
 
 #endif	// _VCL_FONT_HXX
--- vcl/inc/vcl/impfont.hxx
+++ vcl/inc/vcl/impfont.hxx
@@ -156,6 +156,47 @@
     bool    operator==( const ImplFontMetric& ) const;
 };
 
+// ------------------
+// - ImplFontHints -
+// ------------------
+
+class ImplFontHints
+{
+public:
+    FontEmbeddedBitmap meEmbeddedBitmap; // whether the embedded bitmaps should be used
+    FontAntiAlias      meAntiAlias;      // whether the font should be antialiased
+    FontAutoHint       meAutoHint;       // whether the font should be autohinted
+    FontHinting        meHinting;        // whether the font should be hinted
+    FontHintStyle      meHintStyle;      // type of font hinting to be used
+    FontSubPixel       meSubPixel;       // type of subpixel font hinting to be used
+public:
+    ImplFontHints() :
+        meEmbeddedBitmap(EMBEDDEDBITMAP_DONTKNOW), 
+        meAntiAlias(ANTIALIAS_DONTKNOW), 
+        meAutoHint(AUTOHINT_DONTKNOW), 
+        meHinting(HINTING_DONTKNOW), 
+        meHintStyle(HINT_FULL),
+        meSubPixel(SUBPIXEL_UNKNOWN)
+    {}
+    ImplFontHints(FontEmbeddedBitmap eEmbeddedBitmap, FontAntiAlias eAntiAlias, 
+        FontAutoHint eAutoHint, FontHinting eHinting, FontHintStyle eHintStyle,
+	FontSubPixel eSubPixel) :
+        meEmbeddedBitmap(eEmbeddedBitmap), 
+        meAntiAlias(eAntiAlias), 
+        meAutoHint(eAutoHint), 
+        meHinting(eHinting), 
+        meHintStyle(eHintStyle),
+        meSubPixel(eSubPixel)
+    {}
+    FontAutoHint GetUseAutoHint() const { return meAutoHint; }
+    FontHintStyle GetHintStyle() const { return meHintStyle; }
+    FontSubPixel GetSubPixel() const { return meSubPixel; }
+    bool DontUseEmbeddedBitmaps() const { return meEmbeddedBitmap == EMBEDDEDBITMAP_FALSE; }
+    bool DontUseAntiAlias() const { return meAntiAlias == ANTIALIAS_FALSE; }
+    bool DontUseHinting() const { return (meHinting == HINTING_FALSE) || (GetHintStyle() == HINT_NONE); }
+};
+
+
 // -------------------
 // - ImplFontCharMap -
 // -------------------
--- vcl/inc/vcl/outdev.h
+++ vcl/inc/vcl/outdev.h
@@ -213,7 +213,7 @@
                              const Font& rFont, const Size& rSize, ImplFontSubstEntry* pDevSpecific );
     ImplFontEntry*      GetFallback( ImplDevFontList* pFontList,
                                      const Font& rFont, const Size& rSize,
-                                     int nFallbackLevel );
+                                     int nFallbackLevel, std::vector<sal_Unicode> &rMissingGlyphs );
     void                Release( ImplFontEntry* );
     void                Invalidate();
 };
--- vcl/inc/vcl/outdev.hxx
+++ vcl/inc/vcl/outdev.hxx
@@ -106,6 +106,8 @@
 class FontCharMap;
 class SalLayout;
 class ImplLayoutArgs;
+class ImplFontHints;
+class ImplFontAttributes;
 class VirtualDevice;
 
 namespace basegfx {
@@ -566,6 +568,7 @@
 
     SAL_DLLPRIVATE static FontEmphasisMark ImplGetEmphasisMarkStyle( const Font& rFont );
     SAL_DLLPRIVATE static BOOL ImplIsUnderlineAbove( const Font& );
+    SAL_DLLPRIVATE void ImplGetFontHints( const ImplFontAttributes& rFontAttributes, int nSize, ImplFontHints& rFontHints) const;
 //#endif
 
 protected:
--- vcl/inc/vcl/outfont.hxx
+++ vcl/inc/vcl/outfont.hxx
@@ -118,8 +118,6 @@
     bool               IsDeviceFont() const      { return mbDevice; }
     bool               IsEmbeddable() const      { return mbEmbeddable; }
     bool               IsSubsettable() const     { return mbSubsettable; }
-    FontEmbeddedBitmap UseEmbeddedBitmap() const { return meEmbeddedBitmap; }
-    FontAntiAlias      UseAntiAlias() const      { return meAntiAlias; }
 
 public: // TODO: hide members behind accessor methods
     String             maMapNames;       // List of family name aliass separated with ';'
@@ -128,8 +126,6 @@
     bool               mbDevice;         // true: built in font
     bool               mbSubsettable;    // true: a subset of the font can be created
     bool               mbEmbeddable;     // true: the font can be embedded
-    FontEmbeddedBitmap meEmbeddedBitmap; // whether the embedded bitmaps should be used
-    FontAntiAlias      meAntiAlias;      // whether the font should be antialiased
 };
 
 // ----------------
@@ -231,6 +227,7 @@
     ImplDevFontListData*    FindFontFamily( const String& rFontName ) const;
     ImplDevFontListData*    ImplFindByFont( ImplFontSelectData&, bool bPrinter, ImplFontSubstEntry* pDevSpecificSubst ) const;
     ImplDevFontListData*    ImplFindBySearchName( const String& ) const;
+    ImplDevFontListData*    ImplGetFontconfigSubstitute( ImplFontSelectData &rFontSelData, ImplFontSubstEntry* pDevSpecific ) const;
 
     bool                    HasFallbacks() const;
     void                    SetFallbacks( ImplDevFontListData**, int nCount );
@@ -334,6 +331,10 @@
                         ImplFontEntry( const ImplFontSelectData& );
     virtual             ~ImplFontEntry() {}
 
+    // cache of Unicode characters and replacement font names
+    typedef ::std::hash_map<sal_Unicode,String> UnicodeFallbackList;
+    UnicodeFallbackList maUnicodeFallbackList;
+
 public: // TODO: make data members private
     ImplFontSelectData  maFontSelData;      // FontSelectionData
     ImplFontMetricData  maMetric;           // Font Metric
@@ -344,6 +345,16 @@
     short               mnOwnOrientation;   // text angle if lower layers don't rotate text themselves
     short               mnOrientation;      // text angle in 3600 system
     bool                mbInit;             // true if maMetric member is valid
+
+    void                AddFallbackForUnicode( sal_Unicode ch, String fallback )
+                            { maUnicodeFallbackList[ch] = fallback; }
+    String              GetFallbackForUnicode( sal_Unicode ch )
+                            {
+                                UnicodeFallbackList::const_iterator it = maUnicodeFallbackList.find( ch );
+                                if ( it != maUnicodeFallbackList.end() )
+                                    return (*it).second;
+                                return String();
+                            }
 };
 
 
--- vcl/inc/vcl/salgdi.hxx
+++ vcl/inc/vcl/salgdi.hxx
@@ -238,6 +238,8 @@
     void                   ReleaseFonts() { SetFont( NULL, 0 ); }
     // get the current font's metrics
     virtual void			GetFontMetric( ImplFontMetricData* ) = 0;
+    virtual void 			GetFontHints( const ImplFontAttributes& rFontAttributes, int nSize, ImplFontHints& rFontHints) const = 0;
+
     // get kernign pairs of the current font
     // return only PairCount if (pKernPairs == NULL)
     virtual ULONG			GetKernPairs( ULONG nPairs, ImplKernPairData* pKernPairs ) = 0;
--- vcl/inc/vcl/sallayout.hxx
+++ vcl/inc/vcl/sallayout.hxx
@@ -104,6 +104,7 @@
     bool    GetRun( int* nMinRunPos, int* nEndRunPos, bool* bRTL ) const;
     bool    GetNextPos( int* nCharPos, bool* bRTL );
     bool    PosIsInRun( int nCharPos ) const;
+    bool    PosIsInAnyRun( int nCharPos ) const;
 };
 
 // -----------------
@@ -284,6 +285,8 @@
     ImplFontData*	 GetFallbackFontData( int nFallbackLevel ) const
     { return mpFallbackFonts[ nFallbackLevel ]; }
 
+    void SetInComplete(bool bInComplete = true);
+
 protected:
     virtual         ~MultiSalLayout();
 
@@ -302,6 +305,7 @@
     ImplFontData*	mpFallbackFonts[ MAX_FALLBACK ];
     ImplLayoutRuns  maFallbackRuns[ MAX_FALLBACK ];
     int             mnLevel;
+    bool            mbInComplete;
 };
 
 // --------------------
--- vcl/inc/vcl/vclenum.hxx
+++ vcl/inc/vcl/vclenum.hxx
@@ -289,6 +289,35 @@
 
 #endif
 
+#ifndef ENUM_FONTAUTOHINT_DECLARED
+#define ENUM_FONTAUTOHINT_DECLARED
+
+enum FontAutoHint { AUTOHINT_DONTKNOW, AUTOHINT_FALSE, AUTOHINT_TRUE };
+
+#endif
+
+#ifndef ENUM_FONTHINTING_DECLARED
+#define ENUM_FONTHINTING_DECLARED
+
+enum FontHinting { HINTING_DONTKNOW, HINTING_FALSE, HINTING_TRUE };
+
+#endif
+
+#ifndef ENUM_FONTHINTSTYLE_DECLARED
+#define ENUM_FONTHINTSTYLE_DECLARED
+
+enum FontHintStyle { HINT_NONE, HINT_SLIGHT, HINT_MEDIUM, HINT_FULL };
+
+#endif
+
+#ifndef ENUM_FONTSUBPIXEL_DECLARED
+#define ENUM_FONTSUBPIXEL_DECLARED
+
+enum FontSubPixel { SUBPIXEL_UNKNOWN, SUBPIXEL_RGB, SUBPIXEL_BGR, SUBPIXEL_VRGB, SUBPIXEL_VBGR, SUBPIXEL_NONE};
+
+#endif
+
+
 // ------------------------------------------------------------
 
 #ifndef ENUM_KEYFUNCTYPE_DECLARED
--- vcl/source/gdi/font.cxx
+++ vcl/source/gdi/font.cxx
@@ -61,7 +61,9 @@
 #endif
 
 #include <algorithm>
-
+#ifndef _PSPRINT_FONTMANAGER_HXX_
+#include <psprint/fontmanager.hxx>
+#endif
 // =======================================================================
 
 DBG_NAME( Font )
@@ -1073,6 +1075,17 @@
     return aResult;
 }
 
+// #i73003#
+BOOL Font::IsSupportCJK() const
+{
+	BOOL bRet = TRUE;
+	const String aFamilyName = GetName();
+	#ifdef UNX
+	bRet = ::psp::PrintFontManager::get().IsSupportCJK(aFamilyName);
+	#endif
+	return bRet;
+}
+
 // the inlines from the font.hxx header are now instantiated for pImpl-ification
 // TODO: reformat
 const Color& Font::GetColor() const { return mpImplFont->maColor; }
--- vcl/source/gdi/makefile.mk
+++ vcl/source/gdi/makefile.mk
@@ -50,6 +50,10 @@
 CDEFS+=-D_STD_NO_NAMESPACE -D_VOS_NO_NAMESPACE -D_UNO_NO_NAMESPACE
 .ENDIF
 
+.IF "$(ENABLE_FONTCONFIG)" != ""
+CDEFS += -DENABLE_FONTCONFIG
+.ENDIF
+
 # --- Files --------------------------------------------------------
 
 SLOFILES=	$(SLO)$/salmisc.obj 	\
--- vcl/source/gdi/outdev3.cxx
+++ vcl/source/gdi/outdev3.cxx
@@ -168,6 +168,9 @@
 #include <memory>
 #include <algorithm>
 
+#include <psprint/fontmanager.hxx>
+#include <i18npool/mslangid.hxx>
+
 // =======================================================================
 
 DBG_NAMEEX( OutputDevice )
@@ -2659,6 +2662,126 @@
     }
 }
 
+
+// -----------------------------------------------------------------------
+
+String GetFcSubstitute(const ImplFontSelectData &rFontSelData, std::vector<sal_Unicode> &rGlyphs)
+{
+#ifndef ENABLE_FONTCONFIG
+    String empty;
+    return empty;
+#else
+    std::vector<String> aNames;
+    if( rFontSelData.GetFamilyName().Len() )
+    {
+        sal_uInt16 nIndex = 0;
+	String aTempName;
+        do
+        {
+                aTempName = GetNextFontToken(rFontSelData.GetFamilyName(), nIndex);
+		aNames.push_back(aTempName);
+        }
+        while (nIndex != STRING_NOTFOUND);
+    }
+
+    ByteString aLangAttrib = MsLangId::convertLanguageToIsoByteString( rFontSelData.meLanguage );
+
+    psp::italic::type eItalic = psp::italic::Unknown;
+    if( rFontSelData.GetSlant() != ITALIC_DONTKNOW )
+    {
+        switch( rFontSelData.GetSlant() )
+        {
+            case ITALIC_NORMAL:  eItalic = psp::italic::Italic; break;
+            case ITALIC_OBLIQUE: eItalic = psp::italic::Oblique; break;
+            default:
+                break;
+        }
+    }
+
+    psp::weight::type eWeight = psp::weight::Unknown;
+    if( rFontSelData.GetWeight() != WEIGHT_DONTKNOW )
+    {
+        switch( rFontSelData.GetWeight() )
+        {
+            case WEIGHT_THIN:		eWeight = psp::weight::Thin; break;
+            case WEIGHT_ULTRALIGHT:	eWeight = psp::weight::UltraLight; break;
+            case WEIGHT_LIGHT:		eWeight = psp::weight::Light; break;
+            case WEIGHT_SEMILIGHT:	eWeight = psp::weight::SemiLight; break;
+            case WEIGHT_NORMAL:		eWeight = psp::weight::Normal; break;
+            case WEIGHT_MEDIUM:		eWeight = psp::weight::Medium; break;
+            case WEIGHT_SEMIBOLD:	eWeight = psp::weight::SemiBold; break;
+            case WEIGHT_BOLD:		eWeight = psp::weight::Bold; break;
+            case WEIGHT_ULTRABOLD:	eWeight = psp::weight::UltraBold; break;
+            case WEIGHT_BLACK:		eWeight = psp::weight::Black; break;
+            default:
+                break;
+        }
+    }
+
+    psp::width::type eWidth = psp::width::Unknown;
+    if( rFontSelData.GetWidthType() != WIDTH_DONTKNOW )
+    {
+        switch( rFontSelData.GetWidthType() )
+        {
+            case WIDTH_ULTRA_CONDENSED:	eWidth = psp::width::UltraCondensed; break;
+            case WIDTH_EXTRA_CONDENSED: eWidth = psp::width::ExtraCondensed; break;
+            case WIDTH_CONDENSED:	eWidth = psp::width::Condensed; break;
+            case WIDTH_SEMI_CONDENSED:	eWidth = psp::width::SemiCondensed; break;
+            case WIDTH_NORMAL:		eWidth = psp::width::Normal; break;
+            case WIDTH_SEMI_EXPANDED:	eWidth = psp::width::SemiExpanded; break;
+            case WIDTH_EXPANDED:	eWidth = psp::width::Expanded; break;
+            case WIDTH_EXTRA_EXPANDED:	eWidth = psp::width::ExtraExpanded; break;
+            case WIDTH_ULTRA_EXPANDED:	eWidth = psp::width::UltraExpanded; break;
+            default:
+                break;
+        }
+    }
+
+    psp::pitch::type ePitch = psp::pitch::Unknown;
+    if( rFontSelData.GetPitch() != PITCH_DONTKNOW )
+    {
+        switch(  rFontSelData.GetPitch() )
+        {
+            case PITCH_FIXED:    ePitch=psp::pitch::Fixed; break;
+            case PITCH_VARIABLE: ePitch=psp::pitch::Variable; break;
+            default:
+                break;
+        }
+    }
+
+    const psp::PrintFontManager& rMgr = psp::PrintFontManager::get();
+    return rMgr.Substitute(aNames, rGlyphs, aLangAttrib, eItalic, eWeight, eWidth, ePitch);
+#endif
+}
+
+// -----------------------------------------------------------------------
+
+ImplDevFontListData *ImplDevFontList::ImplGetFontconfigSubstitute( ImplFontSelectData &rFontSelData, ImplFontSubstEntry* pDevSpecific ) const
+{
+    // We dont' actually want to talk to Fontconfig at all for symbol fonts
+    if (rFontSelData.IsSymbolFont())
+        return 0;
+    // StarSymbol is a unicode font, but it still deserves the symbol flag
+    if( 0 == rFontSelData.maSearchName.CompareIgnoreCaseToAscii( "starsymbol", 10)
+        ||  0 == rFontSelData.maSearchName.CompareIgnoreCaseToAscii( "opensymbol", 10) )
+        return 0;
+
+    std::vector<sal_Unicode> aDummy;
+    String aName(GetFcSubstitute(rFontSelData, aDummy));
+    if (!aName.Len())
+        return 0;
+
+    String aUserName(aName);
+    ImplGetEnglishSearchFontName( aName );
+    ImplFontSubstitute( aName, FONT_SUBSTITUTE_ALWAYS, pDevSpecific );
+    ImplDevFontListData *pFontFamily = ImplFindBySearchName( aName );
+    if (pFontFamily)
+        rFontSelData.maTargetName = aUserName;
+
+    return pFontFamily;
+}
+
+
 // -----------------------------------------------------------------------
 
 ImplFontEntry* ImplFontCache::Get( ImplDevFontList* pFontList,
@@ -2897,6 +3020,11 @@
         }
     }
 
+	// #n295561#, #n295568#, use fontconfig to match a font
+	ImplDevFontListData* pFoundFamily = ImplGetFontconfigSubstitute( rFSD, pDevSpecific );
+	if( pFoundFamily )
+		return pFoundFamily;
+		
     // if a target symbol font is not available use a default symbol font
     if( rFSD.IsSymbolFont() )
     {
@@ -3024,115 +3152,119 @@
 // -----------------------------------------------------------------------
 
 ImplFontEntry* ImplFontCache::GetFallback( ImplDevFontList* pFontList,
-    const Font& rOrigFont, const Size& rSize, int nFallbackLevel )
+     const Font& rOrigFont, const Size& rSize, int nFallbackLevel,
+     std::vector<sal_Unicode> &rMissingGlyphs )
 {
-    // make sure the fontlist knows it's fallbacks
-    if( !pFontList->HasFallbacks() )
+    ImplFontEntry*      pFallbackFont = NULL;
+    bool                cached = false;
+    bool                new_entry = false;
+    bool                symbolFont = false;
+    ImplFontEntry*      pOrigFontEntry = Get( pFontList, rOrigFont, rSize, NULL );
+    ImplFontSelectData  aSelData( rOrigFont, rOrigFont.GetName(), rSize );
+    sal_uInt16          nToken = 0;
+    String              aOrigFontName( GetNextFontToken(rOrigFont.GetName(), nToken) );
+
+    
+    const FontNameAttr* fontAttr = FontSubstConfiguration::get()->getSubstInfo( aOrigFontName );
+
+    // We dont' actually want to talk to Fontconfig at all for symbol fonts
+    if ( pFontList && fontAttr && (fontAttr->Type & IMPL_FONT_ATTR_SYMBOL) )
     {
-        // normalized family names of fonts suited for glyph fallback
-        // if a font is available related fonts can be ignored
-        // TODO: implement dynamic lists
-        static const char* aGlyphFallbackList[] = {
-            // empty strings separate the names of unrelated fonts
-            "eudc", "",
-            "arialunicodems", "cyberbit", "code2000", "",
-            "andalesansui", "",
-            "starsymbol", "opensymbol", "",
-            "msmincho", "fzmingti", "fzheiti", "ipamincho", "sazanamimincho", "kochimincho", "",
-            "sunbatang", "sundotum", "baekmukdotum", "gulim", "batang", "dotum", "",
-            "hgmincholightj", "msunglightsc", "msunglighttc", "hymyeongjolightk", "",
-            "tahoma", "timesnewroman", "lucidatypewriter", "lucidasans", "nimbussansl", "",
-            "shree", "mangal", "raavi", "shruti", "tunga", "latha", "",
-            "shayyalmt", "naskmt", "",
-            "david", "nachlieli", "lucidagrande", "",
-            "norasi", "angsanaupc", "",
-            "khmerossystem", "",
-	    "phetsarathot", "",
-            0
-        };
-
-        bool bHasEudc = false;
-        int nMaxLevel = 0;
-        int nBestQuality = 0;
-        ImplDevFontListData** pFallbackList = NULL;
-        for( const char** ppNames = &aGlyphFallbackList[0];; ++ppNames )
+        if ( fontAttr->Substitutions.size() )
         {
-            // advance to next sub-list when end-of-sublist marker
-            if( !**ppNames )    // #i46456# check for empty string, i.e., deref string itself not only ptr to it
+            ::std::vector< String >::const_iterator it = fontAttr->Substitutions.begin();
+            while ( it != fontAttr->Substitutions.end() )
             {
-                if( nBestQuality > 0 )
-                    if( ++nMaxLevel >= MAX_FALLBACK )
-                        break;
-                if( !ppNames[1] )
+                // Since *it is the "search name" like "standardsymbolsl"
+                // we have to find the Family Name (Standard Symbols L) for Fontconfig
+                ImplDevFontListData* pFontFamily = pFontList->FindFontFamily( *it );
+                if (pFontFamily)
+                {
+                    aSelData.maSearchName = pFontFamily->GetFamilyName();
                     break;
-                nBestQuality = 0;
-                continue;
+                }
+                ++it;
             }
+        }
+        symbolFont = true;
+        cached = true;
+    }
 
-            // test if the glyph fallback candidate font is available and scalable
-            String aTokenName( *ppNames, RTL_TEXTENCODING_UTF8 );
-            ImplDevFontListData* pFallbackFont = pFontList->FindFontFamily( aTokenName );
-            if( !pFallbackFont )
-                continue;
-            if( !pFallbackFont->IsScalable() )
-                continue;
+    std::vector<sal_Unicode> aGlyphs(rMissingGlyphs);
 
-            // keep the best font of the glyph fallback sub-list
-            if( nBestQuality < pFallbackFont->GetMinQuality() )
-            {
-                nBestQuality = pFallbackFont->GetMinQuality();
-                // store available glyph fallback fonts
-                if( !pFallbackList )
-                    pFallbackList = new ImplDevFontListData*[ MAX_FALLBACK ];
-                pFallbackList[ nMaxLevel ] = pFallbackFont;
-                if( !bHasEudc && !nMaxLevel )
-                    bHasEudc = (0 == strncmp( *ppNames, "eudc", 5 ));
-            }
-        }
+    // Try cached fallbacks first
+    if ( !symbolFont && !rMissingGlyphs.empty() )
+    {
+        aSelData.maSearchName = pOrigFontEntry->GetFallbackForUnicode( rMissingGlyphs[0] );
+        if ( aSelData.maSearchName.Len() )
+            cached = true;
+    }
 
-        // sort the list of fonts for glyph fallback by quality (highest first)
-        // #i33947# keep the EUDC font at the front of the list
-        // an insertion sort is good enough for this short list
-        const int nSortStart = bHasEudc ? 1 : 0;
-        for( int i = nSortStart+1, j; i < nMaxLevel; ++i )
-        {
-            ImplDevFontListData* pTestFont = pFallbackList[ i ];
-            int nTestQuality = pTestFont->GetMinQuality();
-            for( j = i; --j >= nSortStart; )
-                if( nTestQuality > pFallbackList[j]->GetMinQuality() )
-                    pFallbackList[ j+1 ] = pFallbackList[ j ];
-                else
-                    break;
-            pFallbackList[ j+1 ] = pTestFont;
-        }
+    if ( !cached )
+    {
+        String aName(GetFcSubstitute( aSelData, aGlyphs ));
+        if (aName.Len())
+            aSelData.maSearchName = aName;
+    }
 
-#if defined(HDU_DEBUG)
-        for( int i = 0; i < nMaxLevel; ++i )
+    if (!rMissingGlyphs.empty())
+    {
+        std::vector<sal_Unicode>::const_iterator aEnd = aGlyphs.end();
+        for (std::vector<sal_Unicode>::const_iterator aI = aGlyphs.begin(); aI != aEnd; ++aI)
         {
-            ImplDevFontListData* pFont = pFallbackList[ i ];
-            ByteString aFontName( pFont->GetFamilyName(), RTL_TEXTENCODING_UTF8 );
-            fprintf( stderr, "GlyphFallbackFont[%d] (quality=%05d): \"%s\"\n",
-                i, pFont->GetMinQuality(), aFontName.GetBuffer() );
+            std::vector<sal_Unicode>::iterator aNewEnd = 
+                std::remove(rMissingGlyphs.begin(), rMissingGlyphs.end(), *aI);
+            if (aNewEnd != rMissingGlyphs.end())
+                rMissingGlyphs.erase(aNewEnd);
+            //In this case only the first missing symbol has been taken into account and is
+            //known safe to replace
+            if (cached || symbolFont)
+                break;
         }
-#endif
-
-        pFontList->SetFallbacks( pFallbackList, nMaxLevel );
     }
 
-    Font aFallbackFont = rOrigFont;
-
-    // nFallbackLevel==0 => original font without device specific substitution
-    // nFallbackLevel>=1 => use a font from the glyph fallback font list
-    if( nFallbackLevel>=1 )
+    // Check our font instance cache first, if not found then
+    // add this ImplFontSelectData to the cache along with its ImplFontEntry
+    FontInstanceList::const_iterator it = maFontInstanceList.find( aSelData );
+    if (it != maFontInstanceList.end())
+        pFallbackFont = (*it).second;
+    else
     {
-        ImplDevFontListData* pFallbackData = pFontList->GetFallback( nFallbackLevel-1 );
-        if( !pFallbackData )
-            return NULL;
+        // find the best matching physical font face
+        ImplDevFontListData* pFontFamily = pFontList->FindFontFamily( aSelData.maSearchName );
+        if (pFontFamily)
+        {
+            ImplFontData* pFontData = pFontFamily->FindBestFontFace( aSelData );
 
-        aFallbackFont.SetName( pFallbackData->GetSearchName() );
+            // create a new logical font instance from this physical font face
+            aSelData.mpFontData = pFontData;
+            pFallbackFont = pFontData->CreateFontInstance( aSelData );
+
+            // if we found a different symbol font we need a symbol conversion table
+            if( pFontData->IsSymbolFont() )
+                if( aSelData.maTargetName != aSelData.maSearchName )
+                    pFallbackFont->mpConversion = ImplGetRecodeData( aSelData.maTargetName, aSelData.maSearchName );
+            // add the new entry to the cache
+            maFontInstanceList[ aSelData ] = pFallbackFont;
+            new_entry = true;
+        }
+        else
+        {
+            ByteString l( aSelData.maSearchName, RTL_TEXTENCODING_UTF8 );
+            //fprintf (stderr, "--- Couldn't get FontFamily for '%s'\n", l.GetBuffer());
+        }
     }
 
-    ImplFontEntry* pFallbackFont = Get( pFontList, aFallbackFont, rSize, NULL );
+    // Cache the fallback font for each of the missing Unicode chars
+    if ( !symbolFont && aSelData.maSearchName.Len() )
+    {
+        std::vector<sal_Unicode>::const_iterator aEnd = aGlyphs.end();
+        for (std::vector<sal_Unicode>::const_iterator aI = aGlyphs.begin(); aI != aEnd; ++aI)
+        {
+            if (!pOrigFontEntry->GetFallbackForUnicode(*aI).Len())
+                pOrigFontEntry->AddFallbackForUnicode(*aI, aSelData.maSearchName);
+        }
+    }
 
     if( pFallbackFont && !pFallbackFont->mbInit )
     {
@@ -3142,6 +3274,27 @@
         pFallbackFont->maMetric.maStyleName = String();
     }
 
+    if ( pFallbackFont && !new_entry )
+    {
+        // increase the font instance's reference count
+        if( !pFallbackFont->mnRefCount++ )
+            --mnRef0Count;
+    }
+
+#if 0
+    sal_uInt16 nTok = 0;
+    ByteString n( GetNextFontToken(rOrigFont.GetName(), nTok), RTL_TEXTENCODING_UTF8);
+    ByteString m;
+    if (pFallbackFont)
+    {
+        nTok = 0;
+        ByteString tS( GetNextFontToken(pFallbackFont->maFontSelData.mpFontData->GetFamilyName(), nTok), RTL_TEXTENCODING_UTF8 );
+        m.Assign( tS );
+    }
+    fprintf (stderr, "Glyph fallback '%s'->'%s' %s\n", n.GetBuffer(), pFallbackFont ? m.GetBuffer() : "none",
+                new_entry ? "(new)" : "(cached)");
+#endif
+
     return pFallbackFont;
 }
 
@@ -6101,7 +6254,7 @@
     // do glyph fallback if needed
     // #105768# avoid fallback for very small font sizes
     if( aLayoutArgs.NeedFallback() )
-        if( mpFontEntry && (mpFontEntry->maFontSelData.mnHeight >= 6) )
+        if( mpFontEntry && (mpFontEntry->maFontSelData.mnHeight >= 3) )
             pSalLayout = ImplGlyphFallbackLayout( pSalLayout, aLayoutArgs );
 
     // position, justify, etc. the layout
@@ -6145,6 +6298,12 @@
         rLayoutArgs.ResetPos();
     }
 #endif
+    int nCharPos = -1;
+    bool bRTL = false;
+    std::vector<sal_Unicode> aGlyphs;
+    while (rLayoutArgs.GetNextPos( &nCharPos, &bRTL))
+        aGlyphs.push_back(rLayoutArgs.mpStr[ nCharPos ]);
+    rLayoutArgs.ResetPos();
 
     ImplFontSelectData aFontSelData = mpFontEntry->maFontSelData;
     Size aFontSize( aFontSelData.mnWidth, aFontSelData.mnHeight );
@@ -6161,13 +6320,13 @@
     {
         // find a font family suited for glyph fallback
         ImplFontEntry* pFallbackFont = mpFontCache->GetFallback( mpFontList,
-            maFont, aFontSize, nFallbackLevel-nDevSpecificFallback );
+            maFont, aFontSize, nFallbackLevel-nDevSpecificFallback, aGlyphs );
         if( !pFallbackFont )
             break;
 
         aFontSelData.mpFontEntry = pFallbackFont;
         aFontSelData.mpFontData = pFallbackFont->maFontSelData.mpFontData;
-        if( mpFontEntry )
+        if( mpFontEntry && nFallbackLevel < MAX_FALLBACK-1)
         {
             // ignore fallback font if it is the same as the original font
             if( mpFontEntry->maFontSelData.mpFontData == aFontSelData.mpFontData )
@@ -6195,15 +6354,24 @@
         SalLayout* pFallback = mpGraphics->GetTextLayout( rLayoutArgs, nFallbackLevel );
         if( pFallback )
         {
+            int nTemp = rLayoutArgs.mnFlags;
+
+            if (nFallbackLevel == MAX_FALLBACK-1)
+                rLayoutArgs.mnFlags = rLayoutArgs.mnFlags ^= SAL_LAYOUT_FOR_FALLBACK;
+
             if( pFallback->LayoutText( rLayoutArgs ) )
             {
                 if( !pMultiSalLayout )
                     pMultiSalLayout = new MultiSalLayout( *pSalLayout );
                 pMultiSalLayout->AddFallback( *pFallback,
                     rLayoutArgs.maRuns, aFontSelData.mpFontData );
+                if (nFallbackLevel == MAX_FALLBACK-1)
+                    pMultiSalLayout->SetInComplete();
             }
             else
                 pFallback->Release();
+
+            rLayoutArgs.mnFlags = nTemp;
         }
 
         mpFontCache->Release( pFallbackFont );
@@ -7249,6 +7417,14 @@
 
 // -----------------------------------------------------------------------
 
+void OutputDevice::ImplGetFontHints( const ImplFontAttributes& rFontAttributes, int nSize, ImplFontHints &rHints) const
+{
+    if ( mpGraphics )
+        mpGraphics->GetFontHints( rFontAttributes, nSize, rHints );
+}
+
+// -----------------------------------------------------------------------
+
 FontMetric OutputDevice::GetFontMetric() const
 {
     DBG_TRACE( "OutputDevice::GetFontMetric()" );
--- vcl/source/gdi/sallayout.cxx
+++ vcl/source/gdi/sallayout.cxx
@@ -458,6 +458,27 @@
     return true;
 }
 
+bool ImplLayoutRuns::PosIsInAnyRun( int nCharPos ) const
+{
+    bool bRet = false;
+    int nRunIndex = mnRunIndex;
+
+    ImplLayoutRuns *pThis = const_cast<ImplLayoutRuns*>(this);
+
+    pThis->ResetPos();
+
+    for (int i = 0; i < maRuns.size(); i+=2)
+    {
+        if ((bRet = PosIsInRun( nCharPos )))
+            break;
+        pThis->NextRun();
+    }
+
+    pThis->mnRunIndex = nRunIndex;
+    return bRet;
+}
+
+
 // -----------------------------------------------------------------------
 
 bool ImplLayoutRuns::GetNextPos( int* nCharPos, bool* bRightToLeft )
@@ -1540,13 +1561,20 @@
 
 MultiSalLayout::MultiSalLayout( SalLayout& rBaseLayout )
 :   SalLayout(),
-    mnLevel( 1 )
+    mnLevel( 1 ),
+    mbInComplete( false )
 {
     //maFallbackRuns[0].Clear();
     mpLayouts[ 0 ]  = &rBaseLayout;
     mnUnitsPerPixel = rBaseLayout.GetUnitsPerPixel();
 }
 
+void MultiSalLayout::SetInComplete(bool bInComplete)
+{
+    mbInComplete = bInComplete;
+    maFallbackRuns[mnLevel-1] = ImplLayoutRuns();
+}
+
 // -----------------------------------------------------------------------
 
 MultiSalLayout::~MultiSalLayout()
@@ -1576,7 +1604,8 @@
 {
     if( mnLevel <= 1 )
         return false;
-    maFallbackRuns[ mnLevel-1 ] = rArgs.maRuns;
+    if (!mbInComplete)
+        maFallbackRuns[ mnLevel-1 ] = rArgs.maRuns;
     return true;
 }
 
@@ -1675,7 +1704,12 @@
 
         // remove unused parts of component
         if( n > 0 )
-            mpLayouts[n]->Simplify( false );
+        {
+            if (mbInComplete && (n == mnLevel-1))
+                mpLayouts[n]->Simplify( true );
+            else
+                mpLayouts[n]->Simplify( false );
+        }
 
         // prepare merging components
         nStartNew[ nLevel ] = nStartOld[ nLevel ] = 0;
@@ -1710,7 +1744,7 @@
     {
         // find best fallback level
         for( n = 0; n < nLevel; ++n )
-            if( nValid[n] && !maFallbackRuns[n].PosIsInRun( nActiveCharPos ) )
+            if( nValid[n] && !maFallbackRuns[n].PosIsInAnyRun( nActiveCharPos ) )
                 // fallback level n wins when it requested no further fallback
                 break;
         int nFBLevel = n;
@@ -1732,9 +1766,13 @@
         if( n > 0 )
         {
             // drop the NotDef glyphs in the base layout run if a fallback run exists
-            while( maFallbackRuns[ n-1 ].PosIsInRun( nCharPos[0] ) )
+            while ( 
+                    (maFallbackRuns[ n-1 ].PosIsInRun( nCharPos[0] ) ) &&
+                    (!maFallbackRuns[ n ].PosIsInAnyRun( nCharPos[0] ) )
+                  )
             {
-                mpLayouts[0]->DropGlyph( nStartOld[0] );
+                if (!(mbInComplete && (n == mnLevel-1)))
+                    mpLayouts[0]->DropGlyph( nStartOld[0] );
                 nStartOld[0] = nStartNew[0];
                 nValid[0] = mpLayouts[0]->GetNextGlyphs( 1, &nDummy, aPos,
                     nStartNew[0], &nGlyphAdv[0], &nCharPos[0] );
@@ -1752,6 +1790,7 @@
 
             // proceed to next glyph
             nStartOld[n] = nStartNew[n];
+            int nOrigCharPos = nCharPos[n];
             nValid[n] = mpLayouts[n]->GetNextGlyphs( 1, &nDummy, aPos,
                 nStartNew[n], &nGlyphAdv[n], &nCharPos[n] );
 
@@ -1764,6 +1803,23 @@
                 break;
             }
 
+            //If the next character is one which belongs to the next level, then we
+            //are finished here for now, and we'll pick up after the next level has
+            //been processed
+            if ((n+1 < nLevel) && (abs(nCharPos[n] - nOrigCharPos)))
+            {
+                if (nOrigCharPos < nCharPos[n])
+                {
+                    if (nCharPos[n+1] > nOrigCharPos && (nCharPos[n+1] < nCharPos[n]))
+                        break;
+                }
+                else if (nOrigCharPos > nCharPos[n])
+                {
+                    if (nCharPos[n+1] > nCharPos[n] && (nCharPos[n+1] < nOrigCharPos))
+                        break;
+                }
+            }
+
             // break at end of layout run
             if( n > 0 )
             {
@@ -1839,7 +1895,8 @@
 
 void MultiSalLayout::DrawText( SalGraphics& rGraphics ) const
 {
-    for( int i = mnLevel; --i >= 0; )
+    int nLevel = mbInComplete ? mnLevel-1 : mnLevel;
+    for( int i = nLevel; --i >= 0; )
     {
         SalLayout& rLayout = *mpLayouts[ i ];
         rLayout.DrawBase() = maDrawBase;
--- vcl/source/glyphs/gcach_ftyp.cxx
+++ vcl/source/glyphs/gcach_ftyp.cxx
@@ -44,6 +44,7 @@
 #include <vcl/impfont.hxx>
 #include <vcl/bitmap.hxx>
 #include <vcl/bmpacc.hxx>
+#include <vcl/virdev.hxx>
 
 #include <tools/poly.hxx>
 #include <basegfx/matrix/b2dhommatrix.hxx>
@@ -616,9 +617,6 @@
             aDFA.mbSubsettable= false;
             aDFA.mbEmbeddable = false;
 
-            aDFA.meEmbeddedBitmap = EMBEDDEDBITMAP_DONTKNOW;
-            aDFA.meAntiAlias = ANTIALIAS_DONTKNOW;
-
             FT_Done_Face( aFaceFT );
             AddFontFile( aCFileName, nFaceNum, ++mnNextFontId, aDFA, NULL );
             ++nCount;
@@ -698,6 +696,7 @@
 :   ServerFont( rFSD ),
     mnPrioEmbedded(nDefaultPrioEmbedded),
     mnPrioAntiAlias(nDefaultPrioAntiAlias),
+    mnPrioAutoHint(nDefaultPrioAutoHint),
     mpFontInfo( pFI ),
     maFaceFT( NULL ),
     maSizeFT( NULL ),
@@ -830,44 +829,85 @@
 
     mbArtItalic = (rFSD.meItalic != ITALIC_NONE && pFI->GetFontAttributes().GetSlant() == ITALIC_NONE);
     mbArtBold = (rFSD.meWeight > WEIGHT_MEDIUM && pFI->GetFontAttributes().GetWeight() <= WEIGHT_MEDIUM);
+    mbUseGamma = false;
+    if (mbArtBold)
+    {
+	    //static const int TT_CODEPAGE_RANGE_874  = (1L << 16); // Thai
+	    //static const int TT_CODEPAGE_RANGE_932  = (1L << 17); // JIS/Japan
+	    //static const int TT_CODEPAGE_RANGE_936  = (1L << 18); // Chinese: Simplified
+	    //static const int TT_CODEPAGE_RANGE_949  = (1L << 19); // Korean Wansung
+	    //static const int TT_CODEPAGE_RANGE_950  = (1L << 20); // Chinese: Traditional
+	    //static const int TT_CODEPAGE_RANGE_1361 = (1L << 21); // Korean Johab
+	    static const int TT_CODEPAGE_RANGES1_CJKT = 0x3F0000; // all of the above
+	    const TT_OS2* pOs2 = (const TT_OS2*)FT_Get_Sfnt_Table( maFaceFT, ft_sfnt_os2 );
+	    if ((pOs2) && (pOs2->ulCodePageRange1 & TT_CODEPAGE_RANGES1_CJKT )
+		&& rFSD.mnHeight < 20)
+		mbUseGamma = true;
+    }
+
+    ImplFontHints aHints;
+    VirtualDevice vdev( 1 );
+    vdev.ImplGetFontHints( pFI->GetFontAttributes(), mnWidth, aHints );
+
+    FontAutoHint eHint = aHints.GetUseAutoHint();
+    if (eHint == AUTOHINT_DONTKNOW)
+        eHint = mbUseGamma ? AUTOHINT_TRUE : AUTOHINT_FALSE;
 
-    //static const int TT_CODEPAGE_RANGE_874  = (1L << 16); // Thai
-    //static const int TT_CODEPAGE_RANGE_932  = (1L << 17); // JIS/Japan
-    //static const int TT_CODEPAGE_RANGE_936  = (1L << 18); // Chinese: Simplified
-    //static const int TT_CODEPAGE_RANGE_949  = (1L << 19); // Korean Wansung
-    //static const int TT_CODEPAGE_RANGE_950  = (1L << 20); // Chinese: Traditional
-    //static const int TT_CODEPAGE_RANGE_1361 = (1L << 21); // Korean Johab
-    static const int TT_CODEPAGE_RANGES1_CJKT = 0x3F0000; // all of the above
-    const TT_OS2* pOs2 = (const TT_OS2*)FT_Get_Sfnt_Table( maFaceFT, ft_sfnt_os2 );
-    if ((pOs2) && (pOs2->ulCodePageRange1 & TT_CODEPAGE_RANGES1_CJKT )
-        && rFSD.mnHeight < 20)
-        mbUseGamma = true;
-    else
-        mbUseGamma = false;
-
-    if (mbUseGamma)
+    if (eHint == AUTOHINT_TRUE)
         mnLoadFlags |= FT_LOAD_FORCE_AUTOHINT;
 
     if( (mnSin != 0) && (mnCos != 0) ) // hinting for 0/90/180/270 degrees only
         mnLoadFlags |= FT_LOAD_NO_HINTING;
     mnLoadFlags |= FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH; //#88334#
 
-    if (mpFontInfo->DontUseAntiAlias())
-        mnPrioAntiAlias = 0;
-    if (mpFontInfo->DontUseEmbeddedBitmaps())
-        mnPrioEmbedded = 0;
+    if (aHints.DontUseAntiAlias())
+      mnPrioAntiAlias = 0;
+    if (aHints.DontUseEmbeddedBitmaps())
+      mnPrioEmbedded = 0;
+    if (aHints.DontUseHinting())
+      mnPrioAutoHint = 0;
 
 #if (FTVERSION >= 2005) || defined(TT_CONFIG_OPTION_BYTECODE_INTERPRETER)
-    if( nDefaultPrioAutoHint <= 0 )
+    if( mnPrioAutoHint <= 0 )
 #endif
         mnLoadFlags |= FT_LOAD_NO_HINTING;
 
-#ifdef FT_LOAD_TARGET_LIGHT
+#if defined(FT_LOAD_TARGET_LIGHT) && defined(FT_LOAD_TARGET_NORMAL)
     // enable "light hinting" if available
     if( !(mnLoadFlags & FT_LOAD_NO_HINTING) && (nFTVERSION >= 2103))
-        mnLoadFlags |= FT_LOAD_TARGET_LIGHT;
+    {
+       switch (aHints.GetHintStyle())
+       {
+           default:
+           case HINT_SLIGHT:
+           case HINT_MEDIUM:
+                mnLoadFlags |= FT_LOAD_TARGET_LIGHT;
+                break;
+           case HINT_FULL:
+                mnLoadFlags |= FT_LOAD_TARGET_NORMAL;
+                break;
+           case HINT_NONE:
+                break;
+       }
+    }
 #endif
 
+    switch (aHints.GetSubPixel())
+    {
+        default:
+        case SUBPIXEL_UNKNOWN:
+        case SUBPIXEL_NONE:
+            break;
+        case SUBPIXEL_RGB:
+        case SUBPIXEL_BGR:
+            mnLoadFlags |= FT_LOAD_TARGET_LCD;
+            break;
+        case SUBPIXEL_VRGB:
+        case SUBPIXEL_VBGR:
+            mnLoadFlags |= FT_LOAD_TARGET_LCD_V;
+            break;
+    }
+
     if( ((mnCos != 0) && (mnSin != 0)) || (mnPrioEmbedded <= 0) )
         mnLoadFlags |= FT_LOAD_NO_BITMAP;
 }
@@ -1197,13 +1237,15 @@
         }
     }
 
-#if !defined(TT_CONFIG_OPTION_BYTECODE_INTERPRETER)
+#if 0
     // #95556# autohinting not yet optimized for non-western glyph styles
     if( !(mnLoadFlags & (FT_LOAD_NO_HINTING | FT_LOAD_FORCE_AUTOHINT) )
     &&  ( (aChar >= 0x0600 && aChar < 0x1E00)   // south-east asian + arabic
         ||(aChar >= 0x2900 && aChar < 0xD800)   // CJKV
         ||(aChar >= 0xF800) ) )                 // presentation + symbols
+    {
         nGlyphFlags |= GF_UNHINTED;
+    }
 #endif
 
     if( nGlyphIndex != 0 )
@@ -1334,11 +1376,11 @@
 #if (FTVERSION >= 2002)
     // for 0/90/180/270 degree fonts enable autohinting even if not advisable
     // non-hinted and non-antialiased bitmaps just look too ugly
-    if( (mnCos==0 || mnSin==0) && (nDefaultPrioAutoHint > 0) )
+    if( (mnCos==0 || mnSin==0) && (mnPrioAutoHint > 0) )
         nLoadFlags &= ~FT_LOAD_NO_HINTING;
 #endif
 
-    if( mnPrioEmbedded <= nDefaultPrioAutoHint )
+    if( mnPrioEmbedded <= mnPrioAutoHint )
         nLoadFlags |= FT_LOAD_NO_BITMAP;
 
     FT_Error rc = -1;
@@ -1489,7 +1531,7 @@
     // autohinting in FT<=2.0.4 makes antialiased glyphs look worse
     nLoadFlags |= FT_LOAD_NO_HINTING;
 #else
-    if( (nGlyphFlags & GF_UNHINTED) || (nDefaultPrioAutoHint < mnPrioAntiAlias) )
+    if( (nGlyphFlags & GF_UNHINTED) || (mnPrioAutoHint < mnPrioAntiAlias) )
         nLoadFlags |= FT_LOAD_NO_HINTING;
 #endif
 
--- vcl/source/glyphs/gcach_ftyp.hxx
+++ vcl/source/glyphs/gcach_ftyp.hxx
@@ -93,10 +93,6 @@
     int                   GetFaceNum() const        { return mnFaceNum; }
     int                   GetSynthetic() const      { return mnSynthetic; }
     sal_IntPtr            GetFontId() const         { return mnFontId; }
-    bool                  DontUseAntiAlias() const  
-        { return maDevFontAttributes.UseAntiAlias() == ANTIALIAS_FALSE; }
-    bool                  DontUseEmbeddedBitmaps() const 
-        { return maDevFontAttributes.UseEmbeddedBitmap() == EMBEDDEDBITMAP_FALSE; }
     bool                  IsSymbolFont() const      { return maDevFontAttributes.IsSymbolFont(); }
     const ImplFontAttributes& GetFontAttributes() const { return maDevFontAttributes; }
 
@@ -217,6 +213,7 @@
     int                         mnWidth;
     int                         mnPrioEmbedded;
     int                         mnPrioAntiAlias;
+    int                         mnPrioAutoHint;
     FtFontInfo*                 mpFontInfo;
     FT_Int                      mnLoadFlags;
     double                      mfStretch;
--- vcl/source/glyphs/gcach_layout.cxx
+++ vcl/source/glyphs/gcach_layout.cxx
@@ -404,6 +404,11 @@
 
 // -----------------------------------------------------------------------
 
+static bool lcl_CharIsJoiner(sal_Unicode cChar)
+{
+	return ((cChar == 0x200C) || (cChar == 0x200D));
+}
+
 bool IcuLayoutEngine::operator()( ServerFontLayout& rLayout, ImplLayoutArgs& rArgs )
 {
     LEUnicode* pIcuChars;
@@ -516,7 +521,14 @@
             if( !nGlyphIndex )
             {
                 if( nCharPos >= 0 )
+                {
                     rArgs.NeedFallback( nCharPos, bRightToLeft );
+                    if ( (nCharPos > 0) && lcl_CharIsJoiner(rArgs.mpStr[nCharPos-1]) )
+                        rArgs.NeedFallback( nCharPos-1, bRightToLeft );
+                    else if ( (nCharPos + 1 < nRawRunGlyphCount) && lcl_CharIsJoiner(rArgs.mpStr[nCharPos+1]) )
+                        rArgs.NeedFallback( nCharPos+1, bRightToLeft );
+                }
+
                 if( SAL_LAYOUT_FOR_FALLBACK & rArgs.mnFlags )
                     continue;
             }
--- vcl/source/window/makefile.mk
+++ vcl/source/window/makefile.mk
@@ -46,6 +46,10 @@
 .INCLUDE :	settings.mk
 .INCLUDE :  $(PRJ)$/util$/makefile2.pmk
 
+.IF "$(ENABLE_FONTCONFIG)" != ""
+CDEFS += -DENABLE_FONTCONFIG
+.ENDIF
+
 # --- Files --------------------------------------------------------
 
 SLOFILES= \
--- vcl/source/window/window.cxx
+++ vcl/source/window/window.cxx
@@ -201,6 +201,7 @@
 #endif
 
 #include <vcl/pdfextoutdevdata.hxx>
+#include <psprint/fontmanager.hxx>
 #include "vcl/lazydelete.hxx"
 
 using namespace rtl;
@@ -347,6 +348,12 @@
 
 bool Window::ImplCheckUIFont( const Font& rFont )
 {
+#ifndef WNT
+    const psp::PrintFontManager& rMgr = psp::PrintFontManager::get();
+    if (rMgr.hasFontconfig())
+        return true;
+#endif
+
     String aTestText;
     aTestText.Append( Button::GetStandardText( BUTTON_OK ) );
     aTestText.Append( Button::GetStandardText( BUTTON_CANCEL ) );
--- vcl/unx/headless/svpgdi.hxx
+++ vcl/unx/headless/svpgdi.hxx
@@ -103,6 +103,7 @@
     virtual void			SetTextColor( SalColor nSalColor );
     virtual USHORT         SetFont( ImplFontSelectData*, int nFallbackLevel );
     virtual void			GetFontMetric( ImplFontMetricData* );
+    virtual void 			GetFontHints( const ImplFontAttributes& rFontAttributes, int nSize, ImplFontHints& rFontHints) const {}
     virtual ULONG			GetKernPairs( ULONG nPairs, ImplKernPairData* pKernPairs );
     virtual ImplFontCharMap* GetImplFontCharMap() const;
     virtual void			GetDevFontList( ImplDevFontList* );
--- vcl/unx/headless/svppspgraphics.cxx
+++ vcl/unx/headless/svppspgraphics.cxx
@@ -1175,32 +1175,6 @@
     aDFA.mePitch        = ToFontPitch (rInfo.m_ePitch);
     aDFA.mbSymbolFlag   = (rInfo.m_aEncoding == RTL_TEXTENCODING_SYMBOL);
 
-    switch (rInfo.m_eEmbeddedbitmap)
-    {
-        default:
-            aDFA.meEmbeddedBitmap = EMBEDDEDBITMAP_DONTKNOW;
-            break;
-        case psp::fcstatus::istrue:
-            aDFA.meEmbeddedBitmap = EMBEDDEDBITMAP_TRUE;
-            break;
-        case psp::fcstatus::isfalse:
-            aDFA.meEmbeddedBitmap = EMBEDDEDBITMAP_FALSE;
-            break;
-    }
-
-    switch (rInfo.m_eAntialias)
-    {
-        default:
-            aDFA.meAntiAlias = ANTIALIAS_DONTKNOW;
-            break;
-        case psp::fcstatus::istrue:
-            aDFA.meAntiAlias = ANTIALIAS_TRUE;
-            break;
-        case psp::fcstatus::isfalse:
-            aDFA.meAntiAlias = ANTIALIAS_FALSE;
-            break;
-    }
-
     // special case for the ghostscript fonts
     if( aDFA.maName.CompareIgnoreCaseToAscii( "itc ", 4 ) == COMPARE_EQUAL )
         aDFA.maName = aDFA.maName.Copy( 4 );
--- vcl/unx/headless/svppspgraphics.hxx
+++ vcl/unx/headless/svppspgraphics.hxx
@@ -127,6 +127,7 @@
     virtual void			SetTextColor( SalColor nSalColor );
     virtual USHORT          SetFont( ImplFontSelectData*, int nFallbackLevel );
     virtual void			GetFontMetric( ImplFontMetricData* );
+    virtual void 			GetFontHints( const ImplFontAttributes& rFontAttributes, int nSize, ImplFontHints& rFontHints) const {}
     virtual ULONG			GetKernPairs( ULONG nPairs, ImplKernPairData* pKernPairs );
     virtual ImplFontCharMap* GetImplFontCharMap() const;
     virtual void			GetDevFontList( ImplDevFontList* );
--- vcl/unx/inc/pspgraphics.h
+++ vcl/unx/inc/pspgraphics.h
@@ -129,6 +129,7 @@
     virtual void			SetTextColor( SalColor nSalColor );
     virtual USHORT          SetFont( ImplFontSelectData*, int nFallbackLevel );
     virtual void			GetFontMetric( ImplFontMetricData* );
+    virtual void                        GetFontHints( const ImplFontAttributes& rFontAttributes, int nSize, ImplFontHints& rFontHints) const;
     virtual ULONG			GetKernPairs( ULONG nPairs, ImplKernPairData* pKernPairs );
     virtual ImplFontCharMap* GetImplFontCharMap() const;
     virtual void			GetDevFontList( ImplDevFontList* );
--- vcl/unx/inc/salgdi.h
+++ vcl/unx/inc/salgdi.h
@@ -248,6 +248,7 @@
     virtual void			SetTextColor( SalColor nSalColor );
     virtual USHORT         SetFont( ImplFontSelectData*, int nFallbackLevel );
     virtual void			GetFontMetric( ImplFontMetricData* );
+    virtual void                        GetFontHints( const ImplFontAttributes& rFontAttributes, int nSize, ImplFontHints& rFontHints) const;
     virtual ULONG			GetKernPairs( ULONG nPairs, ImplKernPairData* pKernPairs );
     virtual ImplFontCharMap* GetImplFontCharMap() const;
     virtual void			GetDevFontList( ImplDevFontList* );
--- vcl/unx/source/gdi/pspgraphics.cxx
+++ vcl/unx/source/gdi/pspgraphics.cxx
@@ -852,6 +852,10 @@
     }
 }
 
+void PspGraphics::GetFontHints( const ImplFontAttributes& rFontAttributes, int nSize, ImplFontHints& rFontHints) const
+{
+}
+
 void PspGraphics::GetFontMetric( ImplFontMetricData *pMetric )
 {
     const psp::PrintFontManager& rMgr = psp::PrintFontManager::get();
@@ -1264,32 +1268,6 @@
     aDFA.mePitch        = ToFontPitch (rInfo.m_ePitch);
     aDFA.mbSymbolFlag   = (rInfo.m_aEncoding == RTL_TEXTENCODING_SYMBOL);
 
-    switch (rInfo.m_eEmbeddedbitmap)
-    {
-        default:
-            aDFA.meEmbeddedBitmap = EMBEDDEDBITMAP_DONTKNOW;
-            break;
-        case psp::fcstatus::istrue:
-            aDFA.meEmbeddedBitmap = EMBEDDEDBITMAP_TRUE;
-            break;
-        case psp::fcstatus::isfalse:
-            aDFA.meEmbeddedBitmap = EMBEDDEDBITMAP_FALSE;
-            break;
-    }
-
-    switch (rInfo.m_eAntialias)
-    {
-        default:
-            aDFA.meAntiAlias = ANTIALIAS_DONTKNOW;
-            break;
-        case psp::fcstatus::istrue:
-            aDFA.meAntiAlias = ANTIALIAS_TRUE;
-            break;
-        case psp::fcstatus::isfalse:
-            aDFA.meAntiAlias = ANTIALIAS_FALSE;
-            break;
-    }
-
     // special case for the ghostscript fonts
     if( aDFA.maName.CompareIgnoreCaseToAscii( "itc ", 4 ) == COMPARE_EQUAL )
         aDFA.maName = aDFA.maName.Copy( 4 );
--- vcl/unx/source/gdi/salgdi3.cxx
+++ vcl/unx/source/gdi/salgdi3.cxx
@@ -1325,6 +1325,197 @@
 
 // ----------------------------------------------------------------------------
 
+void X11SalGraphics::GetFontHints( const ImplFontAttributes& rFontAttributes, int nSize, ImplFontHints& rFontHints) const
+{
+    psp::FastPrintFontInfo aInfo;
+    // set family name
+    aInfo.m_aFamilyName = rFontAttributes.GetFamilyName();
+    // set italic
+    switch( rFontAttributes.GetSlant() )
+    {
+        case ITALIC_NONE:
+            aInfo.m_eItalic = psp::italic::Upright;
+            break;
+        case ITALIC_NORMAL:
+            aInfo.m_eItalic = psp::italic::Italic;
+            break;
+        case ITALIC_OBLIQUE:
+            aInfo.m_eItalic = psp::italic::Oblique;
+            break;
+        default:
+            aInfo.m_eItalic = psp::italic::Unknown;
+            break;
+
+    }
+    // set weight
+    switch( rFontAttributes.GetWeight() )
+    {
+        case WEIGHT_THIN:
+            aInfo.m_eWeight = psp::weight::Thin;
+            break;
+        case WEIGHT_ULTRALIGHT:
+            aInfo.m_eWeight = psp::weight::UltraLight;
+            break;
+        case WEIGHT_LIGHT:
+            aInfo.m_eWeight = psp::weight::Light;
+            break;
+        case WEIGHT_SEMILIGHT:
+            aInfo.m_eWeight = psp::weight::SemiLight;
+            break;
+        case WEIGHT_NORMAL:
+            aInfo.m_eWeight = psp::weight::Normal;
+            break;
+        case WEIGHT_MEDIUM:
+            aInfo.m_eWeight = psp::weight::Medium;
+            break;
+        case WEIGHT_SEMIBOLD:
+            aInfo.m_eWeight = psp::weight::SemiBold;
+            break;
+        case WEIGHT_BOLD:
+            aInfo.m_eWeight = psp::weight::Bold;
+            break;
+        case WEIGHT_ULTRABOLD:
+            aInfo.m_eWeight = psp::weight::UltraBold;
+            break;
+        case WEIGHT_BLACK:
+            aInfo.m_eWeight = psp::weight::Black;
+            break;
+        default:
+            aInfo.m_eWeight = psp::weight::Unknown;
+            break;
+    }
+    // set width
+    switch( rFontAttributes.GetWidthType() )
+    {
+        case WIDTH_ULTRA_CONDENSED:
+            aInfo.m_eWidth = psp::width::UltraCondensed;
+            break;
+        case WIDTH_EXTRA_CONDENSED:
+            aInfo.m_eWidth = psp::width::ExtraCondensed;
+            break;
+        case WIDTH_CONDENSED:
+            aInfo.m_eWidth = psp::width::Condensed;
+            break;
+        case WIDTH_SEMI_CONDENSED:
+            aInfo.m_eWidth = psp::width::SemiCondensed;
+            break;
+        case WIDTH_NORMAL:
+            aInfo.m_eWidth = psp::width::Normal;
+            break;
+        case WIDTH_SEMI_EXPANDED:
+            aInfo.m_eWidth = psp::width::SemiExpanded;
+            break;
+        case WIDTH_EXPANDED:
+            aInfo.m_eWidth = psp::width::Expanded;
+            break;
+        case WIDTH_EXTRA_EXPANDED:
+            aInfo.m_eWidth = psp::width::ExtraExpanded;
+            break;
+        case WIDTH_ULTRA_EXPANDED:
+            aInfo.m_eWidth = psp::width::UltraExpanded;
+            break;
+        default:
+            aInfo.m_eWidth = psp::width::Unknown;
+            break;
+    }
+
+    psp::FontConfigHints aHints(psp::PrintFontManager::get().getFontConfigHints(aInfo, nSize));
+
+    switch (aHints.m_eEmbeddedbitmap)
+    {
+        default: 
+            rFontHints.meEmbeddedBitmap = EMBEDDEDBITMAP_DONTKNOW;
+            break;
+        case psp::fcstatus::istrue: 
+            rFontHints.meEmbeddedBitmap = EMBEDDEDBITMAP_TRUE;
+            break;
+        case psp::fcstatus::isfalse: 
+            rFontHints.meEmbeddedBitmap = EMBEDDEDBITMAP_FALSE;
+            break;
+    }
+
+    switch (aHints.m_eAntialias)
+    {
+        default: 
+            rFontHints.meAntiAlias = ANTIALIAS_DONTKNOW;
+            break;
+        case psp::fcstatus::istrue: 
+            rFontHints.meAntiAlias = ANTIALIAS_TRUE;
+            break;
+        case psp::fcstatus::isfalse: 
+            rFontHints.meAntiAlias = ANTIALIAS_FALSE;
+            break;
+    }
+
+    switch (aHints.m_eAutoHint)
+    {
+        default: 
+            rFontHints.meAutoHint = AUTOHINT_DONTKNOW;
+            break;
+        case psp::fcstatus::istrue: 
+            rFontHints.meAutoHint = AUTOHINT_TRUE;
+            break;
+        case psp::fcstatus::isfalse: 
+            rFontHints.meAutoHint = AUTOHINT_FALSE;
+            break;
+    }
+
+    switch (aHints.m_eHinting)
+    {
+        default: 
+            rFontHints.meHinting = HINTING_DONTKNOW;
+            break;
+        case psp::fcstatus::istrue: 
+            rFontHints.meHinting = HINTING_TRUE;
+            break;
+        case psp::fcstatus::isfalse: 
+            rFontHints.meHinting = HINTING_FALSE;
+            break;
+    }
+
+    switch (aHints.m_eHintStyle)
+    {
+        case psp::fchint::Nohint: 
+            rFontHints.meHintStyle = HINT_NONE;
+            break;
+        case psp::fchint::Slight: 
+            rFontHints.meHintStyle = HINT_SLIGHT;
+            break;
+        case psp::fchint::Medium: 
+            rFontHints.meHintStyle = HINT_MEDIUM;
+            break;
+        default: 
+        case psp::fchint::Full: 
+            rFontHints.meHintStyle = HINT_FULL;
+            break;
+    }
+
+    switch (aHints.m_eSubPixel)
+    {
+        default:
+        case psp::fcsubpixel::Unknown:
+            rFontHints.meSubPixel = SUBPIXEL_UNKNOWN;
+            break;
+        case psp::fcsubpixel::RGB:
+            rFontHints.meSubPixel = SUBPIXEL_RGB;
+            break;
+        case psp::fcsubpixel::BGR:
+            rFontHints.meSubPixel = SUBPIXEL_BGR;
+            break;
+        case psp::fcsubpixel::VRGB:
+            rFontHints.meSubPixel = SUBPIXEL_VRGB;
+            break;
+        case psp::fcsubpixel::VBGR:
+            rFontHints.meSubPixel = SUBPIXEL_VBGR;
+            break;
+        case psp::fcsubpixel::NONE:
+            rFontHints.meSubPixel = SUBPIXEL_NONE;
+            break;
+    }
+}
+
+// ----------------------------------------------------------------------------
+
 void
 X11SalGraphics::GetFontMetric( ImplFontMetricData *pMetric )
 {
--- vcl/unx/source/gdi/xlfd_extd.cxx
+++ vcl/unx/source/gdi/xlfd_extd.cxx
@@ -122,9 +122,6 @@
     mbSubsettable  = false;
     mbEmbeddable   = false;
 
-    meEmbeddedBitmap = EMBEDDEDBITMAP_DONTKNOW;
-    meAntiAlias = ANTIALIAS_DONTKNOW;
-
     mnQuality      = -1;
 }
 
--- vcl/util/makefile.mk
+++ vcl/util/makefile.mk
@@ -182,6 +182,7 @@
             $(BASEGFXLIB)		\
             $(ICUUCLIB)			\
             $(ICULELIB)			\
+            -lpsp$(VERSION)$(DLLPOSTFIX)	\
 			$(JVMACCESSLIB)
 SHL1USE_EXPORTS=ordinal
 
--- vcl/win/inc/salgdi.h
+++ vcl/win/inc/salgdi.h
@@ -288,6 +288,7 @@
     virtual USHORT         SetFont( ImplFontSelectData*, int nFallbackLevel );
     // get the current font's etrics
     virtual void			GetFontMetric( ImplFontMetricData* );
+    virtual void                        GetFontHints( const ImplFontAttributes& rFontAttributes, int nHints, ImplFontHints& rFontHints);
     // get kernign pairs of the current font
     // return only PairCount if (pKernPairs == NULL)
     virtual ULONG			GetKernPairs( ULONG nPairs, ImplKernPairData* pKernPairs );
--- vcl/win/source/gdi/salgdi3.cxx
+++ vcl/win/source/gdi/salgdi3.cxx
@@ -1430,6 +1430,12 @@
 
 // -----------------------------------------------------------------------
 
+void WinSalGraphics::GetFontHints( const ImplFontAttributes& rFontAttributes, int nSize, ImplFontHints& rFontHints)
+{
+}
+
+// -----------------------------------------------------------------------
+
 void WinSalGraphics::GetFontMetric( ImplFontMetricData* pMetric )
 {
     if ( aSalShlData.mbWNT )
